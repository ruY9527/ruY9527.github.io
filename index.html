<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"ruy9527.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.13.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script><meta name="description" content="知识笔记"><meta property="og:type" content="website"><meta property="og:title" content="YangBao"><meta property="og:url" content="https://ruy9527.github.io/index.html"><meta property="og:site_name" content="YangBao"><meta property="og:description" content="知识笔记"><meta property="og:locale" content="en_US"><meta property="article:author" content="YangBao"><meta property="article:tag" content="知识笔记"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://ruy9527.github.io/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>YangBao</title><script async defer data-website-id="" src=""></script><script defer data-domain="" src=""></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="YangBao" type="application/atom+xml">
</head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">YangBao</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li></ul></nav></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="YangBao" src="/images/touxiang.jpg"><p class="site-author-name" itemprop="name">YangBao</p><div class="site-description" itemprop="description">知识笔记</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">23</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><a href="https://github.com/ruY9527" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ruY9527" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:1411091515@qq.com" title="E-Mail → mailto:1411091515@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/12/30/data_article/flink%E6%9C%AC%E5%9C%B0%E7%BC%96%E8%AF%91/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/12/30/data_article/flink%E6%9C%AC%E5%9C%B0%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">flink本地编译</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-12-30 20:41:44" itemprop="dateCreated datePublished" datetime="2021-12-30T20:41:44+08:00">2021-12-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>0</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>1 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/11/20/data_article/%E6%95%B0%E6%8D%AE%E7%BB%8F%E5%8E%86-%E4%BA%8C/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/20/data_article/%E6%95%B0%E6%8D%AE%E7%BB%8F%E5%8E%86-%E4%BA%8C/" class="post-title-link" itemprop="url">数据经历(二)</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-20 11:39:41" itemprop="dateCreated datePublished" datetime="2021-11-20T11:39:41+08:00">2021-11-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%88%90%E9%95%BF/" itemprop="url" rel="index"><span itemprop="name">数据成长</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>1.6k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>1 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="数据开发流程"><a href="#数据开发流程" class="headerlink" title="数据开发流程"></a>数据开发流程</h2><p>​ 其实数据开发中遇见的问题和我们应用层面的问题存在部分的相似之处，但是在进行数据问题排错的时候，又存在些许的不相似。总体上的感觉,得去做过和排查过,自身才能对问题理解到比较清晰。</p><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>​ 任务调度,这个是有时序的,也是存在先后顺序的。 一般最晚的时间点就是我们拉取最晚那批数据的时间了。</p><p>​ 理想情况下(基于离线数仓): 比较理想的情况下,就是我们最好每一层的处理时间预算都是停留在一个小时左右,但是具体的时间量等情况，得看数据量和具体的业务需要了.</p><p>​ 0点1点: 执行ods的数据,具体的调度周期就跟你业务上的数据变化或者数仓中的数据需要,来进行调度周期是天&#x2F;周&#x2F;月等情况的调度处理.</p><p>​ 1点到2点: 执行dim或者dwd的数据,这个组织维度的数据,看是否有变化的调整(一般公司的人员组织或者集团下的预取,城市,项目之类的会存在有变化的调整).</p><p>​ 2点到3点: dws 层的数据处理,一般dws的数据可以是由dim和dwd进行轻度汇总获取出来的. 其实到了这层的话,需要的指标对应的最小维度基本已经可以看到数据了。只是这个维度的数据,是最小的时间维度和组织维度汇聚出来的。</p><p>​ 3点到4点: adm层的数据汇总,也就是我们的数仓最终给输出出来的大宽表数据.</p><p>​ 有了大宽表后,看下数据还需不需要同步到mmp这类的数据库中,来进行一个高效率的查询(比如clickhouse,drios等).</p><h2 id="表的设计"><a href="#表的设计" class="headerlink" title="表的设计"></a>表的设计</h2><p>​ 表的设计也是很关键的,目前虽然我们的数据设计来源于业务需求&#x2F;报表需求&#x2F;商业报表需求等场景,但是更好的联系起实际的设计也很重要的。</p><p>​ 举个例子: 我们的组织维度, 存在 组织1 , 组织2 ， 组织3 (这三者的关系就是我们平常看到的树的概念,1是2的上级,2是3的上级),同时还存在时间维度的(月,季度,年). 此时,梳理完指标的计算口径,我们发现,1的数据由2汇聚,2的数据由3进行汇聚, 年由月汇聚,季度也是月汇聚出来的, 于是我们设计dws或者adm最后汇总的表样时候,可以冗余 组织2和组织1对应到组织3,时间维度冗余最小的月份，于是在组织这个维度就可以清晰的看到，根据组织1和组织2进行sum和group的时候,就获取初对应组织的值了(冗余组织的关系,聚合的时候就可以减少去需要上下级之间的关系了).</p><p>​ 前置条件: 数据汇聚的计算口径得清晰和明白,方案并不能适应所有的场景. 比如这里的组织得明确最多多少层,一般一个集团或者一个公司,不会出现很多级得概念.</p><h2 id="数据重复"><a href="#数据重复" class="headerlink" title="数据重复"></a>数据重复</h2><p>​ 数据重复这个问题也是很常见的话,比如你拉取过来的组织怎么重复了呀? 我这个指标的字段怎么在帆软报表上也是重复的了啊? 比如有时候我们为了去冗余一些多余的字段进来的时候,并没有很明白该字段对应的场景或者说是业务变化的场景,导致重复的问题</p><p>​ 举个例子: 更新时间字段, 我们聚合sum数据的时候,可能会考虑到冗余该字段进来,于是并没有考虑到时间变化可能会有不同的日期的时候的场景,group就会出现多条数据的情况</p><p>​</p><p>​ 任务重跑导致的数据重复问题:</p><p>​ 一般hive中,我们都会对表进行分区之类的操作. 我们在插入数据之前,会覆盖数据的. 什么意思呢? 就是insert overwrite 会在插入之前,删除对应分区的数据,再进行数据的插入. 但是有时候写漏掉了或者job跑的时候出现同时多跑的情况,就有可能出现数据重复的问题</p><h2 id="实时数据接入"><a href="#实时数据接入" class="headerlink" title="实时数据接入"></a>实时数据接入</h2><p>​ flink cdc : 待使用</p><p>​ canal: 正常情况下,我们会使用canal+kafka来进行与程序的结构,意思就是canal假装成mysql的重节点,获取mysql的binlog变化的数据,然后再对其进行解析,写入到kafka中. 数据到了kafka,后面的程序要怎么消费就怎么消费.</p><p>​ 后面待更新</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​ 不论去做什么陌生的领域也好,我们一定要有自己的理解和分析技巧. 要有自己的韧性和耐心,去面对在你不知道的领域上的问题和难点.</p><p>​ 保持冷静的思维,是面对未知的场景和难题.</p><p>​ 保持好奇和坚持的心态和行为,去持续学习和成长.</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/11/12/data_article/%E6%95%B0%E6%8D%AE%E7%BB%8F%E5%8E%86-%E4%B8%80/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/12/data_article/%E6%95%B0%E6%8D%AE%E7%BB%8F%E5%8E%86-%E4%B8%80/" class="post-title-link" itemprop="url">数据经历(一)</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-12 13:12:18" itemprop="dateCreated datePublished" datetime="2021-11-12T13:12:18+08:00">2021-11-12</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%88%90%E9%95%BF/" itemprop="url" rel="index"><span itemprop="name">数据成长</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>1.6k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>1 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​ 在公司的数据平台上,进行一些简单的指标开发也有一段时间了,对于是否有预期的成长的还是取决于个人的欲望以及行动,不排除我是行动的巨婴.</p><p>​ 也简单的记录下自己这段时间的一些总结语录以及如果我下次还在数据方面的项目上怎么处理?</p><h2 id="需求和调研"><a href="#需求和调研" class="headerlink" title="需求和调研"></a>需求和调研</h2><p>​ 由于目前的项目都是在乙方的场景,所以需要去与甲方进行沟通了解他们的需求以及系统,并且同时还要去推动相关需求指标的进度。这里涉及到的东西其实很多。</p><p>​ 需求以及调研: 这个阶段一定要好好梳理该对行业或者同样类似的系统,进行梳理，最好是能明白业务场景。 就举个例子: 财务系统,这是目前大公司都会具备的吧,那换个角度去思考的话,如果我只晓得了财务系统的话，那我是不是在梳理相关场景或者相关指标的情况下，是不是就轻松很多了呢？ 然后在整理需求和调研阶段的话，对应的坑以及客户的业务痛点就会很清晰和明白了。</p><p>​ 也就是说句直白的话: 对应业务场景和需求痛点,不论是不是站在产品的角度或者开发的角度视角，一定要对其进行吃透，而不能模糊二口，特别是在调研阶段，如果你存在很多业务场景不是很清晰的情况,就会非常容易出现你在梳理需求的时候,吃不透业务痛点,对应客户需要的真是东西很难把握，甚至说，你可能就把握不住。</p><h2 id="指标梳理"><a href="#指标梳理" class="headerlink" title="指标梳理"></a>指标梳理</h2><p>​ 指标梳理这步很关键的,根据你目前的需求等场景进行指标的梳理,梳理出来的结果就是你想要的或者业务方想要的.</p><p>​ 指标梳理这个步骤中,我们一定要吃透或者理解透目前业务方或者需要梳理的指标的系统里面的一定业务场景,这会关系到你接下来的取数以及数据要怎么聚合的操作和设计这块.</p><p>​ 维度梳理: 最基本的维度梳理,也就是业务场景下,需要梳理的维度是有那些场景的. 比如:时间维度,汇总维度,组织维度等.</p><p>​ 每种不同的维度,都会对你的sql产生很大的影响,比如你的组织维度是一层一层的,那你在组织维度进行汇总的时候,你是不是还要考虑到时间的维度? 月到季度?月到年等这种时间维度的概念汇总.</p><p>​ 基于上面,业务需求+指标的梳理,这些都昨完了的话,那其实业务调研和指标梳理要做的事情,就已经做完了，于是就可以放开了的去设计接入数据源的时间维度，sql进行汇总的逻辑操作.</p><p>​ 其实,你的指标梳理到好的话,你开发后的工作会舒服很多</p><p>​ 指标文档: 这里的调研,对应要输出出来的,你每个指标对应的时间维度或者是其他的维度,同时也要一并输出出来的是:业务口径和计算口径</p><h2 id="数据核算-amp-数据字典输出"><a href="#数据核算-amp-数据字典输出" class="headerlink" title="数据核算 &amp; 数据字典输出"></a>数据核算 &amp; 数据字典输出</h2><p>​ 再根据需求或者业务方提供了相应的指标之后,那么我们紧接着要去做的事情就是,通过数据源去查看,去查看数据之类的东西是否符合预期。 比如财务指标: 不同的记账科目编码,那你就要去梳理下是否有科目编码这个字典表。</p><p>​ 然后你在核算数据的同时，还要去输出一个比较关键的文档.</p><p>​ 数据字段文档: 这个数据字段文档的话,其实就是已经设计到数仓方面的数据。</p><p>​ ods &#x2F; dwd &#x2F; dws &#x2F; dim &#x2F; adm</p><p>​ 设计到这五层的数仓建模的字典表的输出,每一层的表怎么接入,全量还是增量? 触发时间是什么时候(也就是调度周期)？如果是增量的话,依赖的增量字段是什么？还是利用类似flink cdc这类的框架来进行实时数据的接入?</p><p>​ 这个文档输出后,还要与客户进行确认.</p><h2 id="开发注意点"><a href="#开发注意点" class="headerlink" title="开发注意点"></a>开发注意点</h2><p>​ 全量: 如果数据是全量每天或者每月拉入进来的话,要涉及考虑的问题是数据量的大小(避免数据量太大影响到可能在凌晨运行的job).</p><p>​ 伪增量: 是否有可信的更新字段,来进行伪增量的获取. 比如更新时间, 我每天或者多久的时间范围内,我就去更新时间是在这个范围的数据.</p><p>​ 实时增量: 类似flick cdc 或者 cancl去监听mysql的binlog这样的功能来实现实时增量的功能.</p><h2 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h2><p>​ 这个地方其实对应的就是无规矩不方圆, 也就是开发之前要定义好规矩,这样不仅仅对程序很有益,对后面来的同事或者随时看你程序的涉及等方案的时候,也是一目了然的.</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/11/04/mybatis/mybatis%E4%B8%8Espringboot%E6%95%B4%E5%90%88%E9%98%85%E8%AF%BB/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/04/mybatis/mybatis%E4%B8%8Espringboot%E6%95%B4%E5%90%88%E9%98%85%E8%AF%BB/" class="post-title-link" itemprop="url">mybatis与springboot整合阅读</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-04 00:29:43" itemprop="dateCreated datePublished" datetime="2021-11-04T00:29:43+08:00">2021-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">java框架</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java%E6%A1%86%E6%9E%B6/mybatis/" itemprop="url" rel="index"><span itemprop="name">mybatis</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>15k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>14 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>MyBatis 与 SpringBoot 整合操作. 在这次整合的过程中,再次明白自己毫无疑问的是一个比较手残的同学了.</p><p>这里我们是基于 sql 语句写在 xml 里面进行整合的操作.</p><h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><p>这里说下创建一个 入门 项目的大致流程.</p><p>先创建一个 SpringBoot 项目 , 引入依赖 : <a target="_blank" rel="noopener" href="https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/pom.xml">https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/pom.xml</a></p><p>创建 MyBatis 的配置文件信息 : <a target="_blank" rel="noopener" href="https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/resources/mybatis-config.xml">https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/resources/mybatis-config.xml</a></p><p>创建查询的 sql 语句，也就是我们的 mapper 文件 : <a target="_blank" rel="noopener" href="https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-boot-hello/src/main/resources/mapper">https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-boot-hello/src/main/resources/mapper</a></p><p>application.properties : <a target="_blank" rel="noopener" href="https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/resources/application.properties">https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/resources/application.properties</a></p><p>扫描 mapper 接口 : @MapperScan(basePackages &#x3D; {“com.iyang.mybatis.springboot.hello.mapper”}) <a target="_blank" rel="noopener" href="https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/java/com/iyang/mybatis/springboot/hello/MybatisSpringBootHelloApplication.java">https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/java/com/iyang/mybatis/springboot/hello/MybatisSpringBootHelloApplication.java</a></p><p>这里是没有引入 web 依赖的 , 直接启动 main 方法 , 然后就可以看到我们查询出来的结果了.</p><p>如果你熟悉 SpringBoot 源码的话，就会晓得有一个自动装配的操作.</p><p>如果不熟悉的话，那么就只能通过 @MapperScan(basePackages &#x3D; {“com.iyang.mybatis.springboot.hello.mapper”}) 去看 , 这样有些是依赖自动装配（spring.factories） 中的配置加载的, 所以这里建议在看之前，如果是有一点 SpringBoot 扩展的知识了解是很好的。如果没有怎么办呢？没有就来看我接下来的内容。</p><p>其实这个地方你仔细想下，在 MyBatis 与 Spring 整合的时候，通过 xml 的方式给 MyBatis 的bean 已经 mybatis-spring 中自己写的扫描类，最后将扫描出来的 bd 在还没初始化之前，将bd 的beanClass 替换为我们的代理类.</p><p>那么，SpringBoot 与 MyBatis 整合的时候，最后要做的事情是不是也是将 MyBatis 的信息注入到 SpringBoot 来呢？只不过，SpringBoot 就不像 Spring 一样了，还将 bean 的信息配置到 xml 文件中.</p><p>于是，接下来跟我的阅读&amp;分析来一步一步的往下看.</p><h4 id="方法分析"><a href="#方法分析" class="headerlink" title="方法分析"></a>方法分析</h4><p><strong>关注点一</strong> : 这里我们点入到 org.mybatis.spring.annotation.MapperScan 注解里面来，可以看到有一个 @Import(MapperScannerRegistrar.class) , 于是我们顺手跟进来 : org.mybatis.spring.annotation.MapperScannerRegistrar , 从名字上来，这个类就做了一个扫描mapper并且将mapper注入到Spring容器中来的事情.</p><p><strong>关注点二</strong> : 我们从引入进来的依赖来看, mybatis-spring-boot-starter-2.1.2.jar 跟进到 这个包来，可以看到这个包也是引入一些进来. mybatis&#x2F;mybatis-spring&#x2F;spring-boot-starter-jdbc 这三个依赖我们应该不是很陌生的，mybatis-spring-boot-autoconfigure主要来看这个。 spring.factories 的作用大家可以去了解下，SpringBoot很多 EnableAutoConfiguration 的配置都是放入在这个里面的，在启动的时候，会去一层一层的去读取 spring.factories 文件的内容。 这里我们主要来看 : org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration 这个类皆可.</p><p>MyBatis 在 properties 中的配置文件读取 : org.mybatis.spring.boot.autoconfigure.MybatisProperties</p><p>可以看到该类上是有: @ConfigurationProperties(prefix &#x3D; MybatisProperties.MYBATIS_PREFIX)</p><p>于是我们一下子就多了二个关注点, 这里我们可以采用之前的 笨方法， 当你对整合流程执行不是很熟悉的话，可以在这二个关注点的重写方法上都打算断点，看下其执行顺序是怎么执行的. 弄清楚了执行流程,就可以跟着流程来一步一步的分析. 从我们打上 debug 开始，往下的执行流程就是一步一步来的，那么就跟着我们debug 的方法来一步一步的分析.</p><p>org.mybatis.spring.annotation.MapperScannerRegistrar#registerBeanDefinitions() —&gt; org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#MybatisAutoConfiguration —&gt; org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#afterPropertiesSet —-&gt; org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionFactory —&gt; org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionTemplate() —-&gt;</p><p><strong>org.mybatis.spring.annotation.MapperScannerRegistrar#registerBeanDefinitions() 方法</strong> :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &#123;@inheritDoc&#125;</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">/***</span><br><span class="line">*  这里是获取出了注解里面属性的值. </span><br><span class="line">*/   </span><br><span class="line">  AnnotationAttributes mapperScanAttrs = </span><br><span class="line">  AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line"></span><br><span class="line">// 能获取到有注解,不是null,就会走到下面的代码中来.    </span><br><span class="line">  if (mapperScanAttrs != null) &#123;</span><br><span class="line">    registerBeanDefinitions(importingClassMetadata, mapperScanAttrs, registry,</span><br><span class="line">        generateBaseBeanName(importingClassMetadata, 0));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* </span><br><span class="line">*/</span><br><span class="line">  void registerBeanDefinitions(AnnotationMetadata annoMeta, AnnotationAttributes annoAttrs,</span><br><span class="line">      BeanDefinitionRegistry registry, String beanName) &#123;</span><br><span class="line"></span><br><span class="line">// 利用 BeanDefinitionBuilder 构造者,传入了一个 MapperScannerConfigurer.class</span><br><span class="line">// 这里的 builder里面是有一个 bd 的,里面的beanClass就是 MapperScannerConfigurer      </span><br><span class="line">    BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);</span><br><span class="line">    builder.addPropertyValue(&quot;processPropertyPlaceHolders&quot;, true);</span><br><span class="line"></span><br><span class="line">// 这里获取 @MapperScan 注解的属性, 如果属性是有值的话,就会设置到 builder 中来. </span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(&quot;annotationClass&quot;);</span><br><span class="line">    if (!Annotation.class.equals(annotationClass)) &#123;</span><br><span class="line">      builder.addPropertyValue(&quot;annotationClass&quot;, annotationClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; markerInterface = annoAttrs.getClass(&quot;markerInterface&quot;);</span><br><span class="line">    if (!Class.class.equals(markerInterface)) &#123;</span><br><span class="line">      builder.addPropertyValue(&quot;markerInterface&quot;, markerInterface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass(&quot;nameGenerator&quot;);</span><br><span class="line">    if (!BeanNameGenerator.class.equals(generatorClass)) &#123;</span><br><span class="line">      builder.addPropertyValue(&quot;nameGenerator&quot;, BeanUtils.instantiateClass(generatorClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass(&quot;factoryBean&quot;);</span><br><span class="line">    if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123;</span><br><span class="line">      builder.addPropertyValue(&quot;mapperFactoryBeanClass&quot;, mapperFactoryBeanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String sqlSessionTemplateRef = annoAttrs.getString(&quot;sqlSessionTemplateRef&quot;);</span><br><span class="line">    if (StringUtils.hasText(sqlSessionTemplateRef)) &#123;</span><br><span class="line">      builder.addPropertyValue(&quot;sqlSessionTemplateBeanName&quot;, annoAttrs.getString(&quot;sqlSessionTemplateRef&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String sqlSessionFactoryRef = annoAttrs.getString(&quot;sqlSessionFactoryRef&quot;);</span><br><span class="line">    if (StringUtils.hasText(sqlSessionFactoryRef)) &#123;</span><br><span class="line">      builder.addPropertyValue(&quot;sqlSessionFactoryBeanName&quot;, annoAttrs.getString(&quot;sqlSessionFactoryRef&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 下面是根据 value/basePackages/basePackageClasses 来获取包的信息,</span><br><span class="line">// 这里也就说, 我们可以跟着这三个属性来配置包信息.      </span><br><span class="line">    List&lt;String&gt; basePackages = new ArrayList&lt;&gt;();</span><br><span class="line">    basePackages.addAll(</span><br><span class="line">        Arrays.stream(annoAttrs.getStringArray(&quot;value&quot;)).filter(StringUtils::hasText).collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">    basePackages.addAll(Arrays.stream(annoAttrs.getStringArray(&quot;basePackages&quot;)).filter(StringUtils::hasText)</span><br><span class="line">        .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">    basePackages.addAll(Arrays.stream(annoAttrs.getClassArray(&quot;basePackageClasses&quot;)).map(ClassUtils::getPackageName)</span><br><span class="line">        .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">// 如果没有获取到包的信息,那就根据注解所在的路径来获取默认的路径.      </span><br><span class="line">    if (basePackages.isEmpty()) &#123;</span><br><span class="line">      basePackages.add(getDefaultBasePackage(annoMeta));</span><br><span class="line">    &#125;</span><br><span class="line">// 如果有lazyInitialization属性的值,就设置到 builder 中来. </span><br><span class="line">    String lazyInitialization = annoAttrs.getString(&quot;lazyInitialization&quot;);</span><br><span class="line">    if (StringUtils.hasText(lazyInitialization)) &#123;</span><br><span class="line">      builder.addPropertyValue(&quot;lazyInitialization&quot;, lazyInitialization);</span><br><span class="line">    &#125;</span><br><span class="line">// 添加包的属性</span><br><span class="line">    builder.addPropertyValue(&quot;basePackage&quot;, StringUtils.collectionToCommaDelimitedString(basePackages));</span><br><span class="line"></span><br><span class="line">//  getBeanDefinition() 在返回 bd 之前，会走一个 validate 方法.</span><br><span class="line">// org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition</span><br><span class="line">// 走这个方法来将 bd 给注入到 Spring 容器中来.</span><br><span class="line">// 这里注入进去的 beanName 的值是 :  com.iyang.mybatis.springboot.hello.MybatisSpringBootHelloApplication#MapperScannerRegistrar#0</span><br><span class="line">// 注入进去的 bd 的 beanClass : class org.mybatis.spring.mapper.MapperScannerConfigurer </span><br><span class="line">    registry.registerBeanDefinition(beanName, builder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>这里可以总结下 registerBeanDefinitions 方法，该方法就是将 @MapperScan 的注解属性的值给到 : BeanDefinitionBuilder builder, 该builder 里面有bd,bd的beanClass是MapperScannerConfigurer，最后将MapperScannerConfigurer注入到 Spring 容器中来.</strong></p><hr><p><strong>MyBatisAutoConfiguration() 有参构造函数</strong></p><p>这里我们在 MybatisAutoConfiguration 构造函数上打上断点, 可以根据 断点来分析，走完👆面的方法，然后我们点击走到下一个断点来，就会走到 这个 有参构造函数.</p><p>如果好奇的话，可以跟踪debug 的堆栈信息，是怎么走到这步来的. 走到这个方法来 : finishBeanFactoryInitialization(beanFactory) 这是最初的入口.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public MybatisAutoConfiguration(MybatisProperties properties, ObjectProvider&lt;Interceptor[]&gt; interceptorsProvider,</span><br><span class="line">    ObjectProvider&lt;TypeHandler[]&gt; typeHandlersProvider, ObjectProvider&lt;LanguageDriver[]&gt; languageDriversProvider,</span><br><span class="line">    ResourceLoader resourceLoader, ObjectProvider&lt;DatabaseIdProvider&gt; databaseIdProvider,</span><br><span class="line">    ObjectProvider&lt;List&lt;ConfigurationCustomizer&gt;&gt; configurationCustomizersProvider) &#123;</span><br><span class="line">// 这里都是赋值    </span><br><span class="line">  this.properties = properties;</span><br><span class="line">  this.interceptors = interceptorsProvider.getIfAvailable();</span><br><span class="line">  this.typeHandlers = typeHandlersProvider.getIfAvailable();</span><br><span class="line">  this.languageDrivers = languageDriversProvider.getIfAvailable();</span><br><span class="line">  this.resourceLoader = resourceLoader;</span><br><span class="line">  this.databaseIdProvider = databaseIdProvider.getIfAvailable();</span><br><span class="line">  this.configurationCustomizers = configurationCustomizersProvider.getIfAvailable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#afterPropertiesSet()方法</strong></p><p>这里可以看到是对配置文件是否存在进行检验.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void afterPropertiesSet() &#123;</span><br><span class="line">  checkConfigFileExists();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检验配置文件是否存在</span><br><span class="line">  private void checkConfigFileExists() &#123;</span><br><span class="line">    if (this.properties.isCheckConfigLocation() &amp;&amp; StringUtils.hasText(this.properties.getConfigLocation())) &#123;</span><br><span class="line">      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());</span><br><span class="line">      Assert.state(resource.exists(),</span><br><span class="line">          &quot;Cannot find config location: &quot; + resource + &quot; (please add config file or check your Mybatis configuration)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionFactory 方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">// 这里说下 @ConditionalOnMissingBean 的作用,当bean不存在的时候，则实例化这个bean.</span><br><span class="line">// 这里会传入 dataSource 进来.</span><br><span class="line">@Bean</span><br><span class="line">@ConditionalOnMissingBean</span><br><span class="line">public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception &#123;</span><br><span class="line">// 创建 sqlSessionBean 对象.    </span><br><span class="line">  SqlSessionFactoryBean factory = new SqlSessionFactoryBean();</span><br><span class="line">// 设置 dataSource &amp; SpringBootVFS.class      </span><br><span class="line">  factory.setDataSource(dataSource);</span><br><span class="line">  factory.setVfs(SpringBootVFS.class);</span><br><span class="line">// 获取到 MyBatis 的配置文件属性,如果有的话,就会设置到 configLocation属性来.    </span><br><span class="line">  if (StringUtils.hasText(this.properties.getConfigLocation())) &#123;</span><br><span class="line">    factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">// 这里从 properties 中获取 configuration,没有值就会是null.    </span><br><span class="line">  applyConfiguration(factory);</span><br><span class="line">  if (this.properties.getConfigurationProperties() != null) &#123;</span><br><span class="line">    factory.setConfigurationProperties(this.properties.getConfigurationProperties());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 如果有插件,就会设置插件.    </span><br><span class="line">  if (!ObjectUtils.isEmpty(this.interceptors)) &#123;</span><br><span class="line">    factory.setPlugins(this.interceptors);</span><br><span class="line">  &#125;</span><br><span class="line">  if (this.databaseIdProvider != null) &#123;</span><br><span class="line">    factory.setDatabaseIdProvider(this.databaseIdProvider);</span><br><span class="line">  &#125;</span><br><span class="line">// 包的名别设置    </span><br><span class="line">  if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) &#123;</span><br><span class="line">    factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());</span><br><span class="line">  &#125;</span><br><span class="line">  if (this.properties.getTypeAliasesSuperType() != null) &#123;</span><br><span class="line">    factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());</span><br><span class="line">  &#125;</span><br><span class="line">  if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) &#123;</span><br><span class="line">    factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());</span><br><span class="line">  &#125;</span><br><span class="line">  if (!ObjectUtils.isEmpty(this.typeHandlers)) &#123;</span><br><span class="line">    factory.setTypeHandlers(this.typeHandlers);</span><br><span class="line">  &#125;</span><br><span class="line">  if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) &#123;</span><br><span class="line">    factory.setMapperLocations(this.properties.resolveMapperLocations());</span><br><span class="line">  &#125;</span><br><span class="line">// 这里都是配置属性的设置.    </span><br><span class="line"></span><br><span class="line">// 获取 propert 字段属性的名字.    </span><br><span class="line">  Set&lt;String&gt; factoryPropertyNames = Stream</span><br><span class="line">      .of(new BeanWrapperImpl(SqlSessionFactoryBean.class).getPropertyDescriptors()).map(PropertyDescriptor::getName)</span><br><span class="line">      .collect(Collectors.toSet());</span><br><span class="line">  Class&lt;? extends LanguageDriver&gt; defaultLanguageDriver = this.properties.getDefaultScriptingLanguageDriver();</span><br><span class="line">  if (factoryPropertyNames.contains(&quot;scriptingLanguageDrivers&quot;) &amp;&amp; !ObjectUtils.isEmpty(this.languageDrivers)) &#123;</span><br><span class="line">    // Need to mybatis-spring 2.0.2+</span><br><span class="line">    factory.setScriptingLanguageDrivers(this.languageDrivers);</span><br><span class="line">    if (defaultLanguageDriver == null &amp;&amp; this.languageDrivers.length == 1) &#123;</span><br><span class="line">      defaultLanguageDriver = this.languageDrivers[0].getClass();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">// 设置默认的脚本语言解析器. 这里没有,设置的是默认的null.    </span><br><span class="line">  if (factoryPropertyNames.contains(&quot;defaultScriptingLanguageDriver&quot;)) &#123;</span><br><span class="line">    // Need to mybatis-spring 2.0.2+</span><br><span class="line">    factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);</span><br><span class="line">  &#125;</span><br><span class="line">// org.mybatis.spring.SqlSessionFactoryBean#getObject,这里走到了 SqlSessionBean.</span><br><span class="line">// 这个SqlSessionFactoryBean是在有之前 mybatis和Spring 整合分析有提过到的,可以参考getObject方法: https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello    </span><br><span class="line">// 这里会走 org.mybatis.spring.SqlSessionFactoryBean#getObject 的 afterPropertiesSet 方法来创建一个 SqlSessionFactory , 这里返回的 SqlSessionFactory 就注入到 Spring 容器中来.    </span><br><span class="line">  return factory.getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以这个方法 ： 先是new了一个SqlSessionFactoryBean对象，如果你仔细看的话，你会发现这个对象在之前 mybatis-spring 整合的时候，我们通过 xml 配置文件配置进来的，并且同时通过标签给赋值了datasource等信息， 而这里是通过代码，if等判断，来对 SqlSessionFactoryBean 的属性进行set值的. 最后也是创建出一个 SqlSessionFactory 给注入到 Spring 容器中来.</strong></p><hr><p><strong>org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionTemplate 方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@ConditionalOnMissingBean</span><br><span class="line">public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) &#123;</span><br><span class="line">// 这里根据 executorType 是否有值来判断要走的构造函数方法.    </span><br><span class="line">  ExecutorType executorType = this.properties.getExecutorType();</span><br><span class="line">  if (executorType != null) &#123;</span><br><span class="line">    return new SqlSessionTemplate(sqlSessionFactory, executorType);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">// 这里默认的获取是 SIMPLE 这个 ExecutorType.      </span><br><span class="line">    return new SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// org.mybatis.spring.SqlSessionTemplate#SqlSessionTemplate(org.apache.ibatis.session.SqlSessionFactory, org.apache.ibatis.session.ExecutorType, org.springframework.dao.support.PersistenceExceptionTranslator),最后可以跟进到这个方法中来.</span><br><span class="line"></span><br><span class="line">  public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,</span><br><span class="line">      PersistenceExceptionTranslator exceptionTranslator) &#123;</span><br><span class="line">// 对sqlSessionFactory 和 executorType 进行校验</span><br><span class="line">    notNull(sqlSessionFactory, &quot;Property &#x27;sqlSessionFactory&#x27; is required&quot;);</span><br><span class="line">    notNull(executorType, &quot;Property &#x27;executorType&#x27; is required&quot;);</span><br><span class="line"></span><br><span class="line">    this.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    this.executorType = executorType;</span><br><span class="line">    this.exceptionTranslator = exceptionTranslator;</span><br><span class="line">// 这里通过 JDK 的代码来生成了一个 sqlSessionProxy 代理的对象.      </span><br><span class="line">    this.sqlSessionProxy = (SqlSession) newProxyInstance(SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">        new Class[] &#123; SqlSession.class &#125;, new SqlSessionInterceptor());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>该方法是将 SqlSessionTemplate 给注入到 Spring 容器中啦.</p><h4 id="疑惑点"><a href="#疑惑点" class="headerlink" title="疑惑点"></a>疑惑点</h4><p>大家有没有疑惑我们定义的 mapper 接口 好像从这个流程分析下来，并没有提到 ，那么是在上面时候被注入到 Spring 容器中来的呢？</p><p>registerBeanDefinitions() 这个方法 , 注入了MapperScannerConfigurer 到 Spring 容器中来了，可以回顾下之前 mybatis 整合 Spring 的时候，我们是通过 xml 配置了这个对象注入到 spring 容器中来的。 那么注入进来的,回调到 org.mybatis.spring.mapper.MapperScannerConfigurer#postProcessBeanDefinitionRegistry 这个方法的时候，就会将扫描并且将我们的mapper接口文件，给注入到 Spring 容器中来的. 然后扫描的包，是根据@MapperScan 解析注解的时候，是有对扫描的包进行解析的.</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>其实 SpringBoot 整合 MyBatis , 我们从二个切入点来分析是怎么整合进来的.<br>​ 一是 @MapperScan 注解中的 @Import(MapperScannerRegistrar.class) 将 MapperScannerRegistrar 给导入到 Spring 容器中来, 然后MapperSacnnerRegistrar 来讲 org.mybatis.spring.mapper.MapperScannerConfigurer 给注入到 Spring中来，替换了我们之前用 Spring 整合 Mybatis 的时候，通过xml配置文件整合进来.</p><p>二是利用 SpringBoot 提供的 spring-boot-autoconfigure + spring.factories() 来 配置自动注入, 这里注入了 MybatisAutoConfiguration 配置类. 然后注入进来的 MyBatis 配置类做了什么事情呢？ 可以看到这个类中是有做: 注入了 SqlSessionFactory. SqlSessionFactory 又是怎么注入进来的呢？ 可以看到 org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionFactory 方法是有先创建一个 org.mybatis.spring.SqlSessionFactoryBean 的， 看到 SqlSessionFactoryBean 这个对象，我们就不难想起 Spring + Mybatis 里面的 beans.xml 是将该对象注入到 Spring 容器中来. 这里是直接new的，然后将一些配置属性并满足条件,给set到 SqlSessionFactoryBean 中来，最后调用 org.mybatis.spring.SqlSessionFactoryBean#getObject 方法来获取 SqlSessionFactory.</p><p>spring.factories 文件内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\</span><br><span class="line">org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</span><br></pre></td></tr></table></figure><p>最后从写的案例里面看, MyBatis 整合 SpringBoot 其实都是在 mybatis —&gt; MyBatis + Spring 等一步一步推导上来的，所以这里不难理解，好的技术都是在有需要和时间的沉淀下一步一步成长起来的.</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/11/04/mybatis/mybatis%E4%B8%8Espring%E6%95%B4%E5%90%88%E9%98%85%E8%AF%BB/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/04/mybatis/mybatis%E4%B8%8Espring%E6%95%B4%E5%90%88%E9%98%85%E8%AF%BB/" class="post-title-link" itemprop="url">mybatis与spring整合阅读</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-04 00:29:31" itemprop="dateCreated datePublished" datetime="2021-11-04T00:29:31+08:00">2021-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">java框架</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java%E6%A1%86%E6%9E%B6/mybatis/" itemprop="url" rel="index"><span itemprop="name">mybatis</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>16k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>14 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h4 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h4><p>MyBatis 与 Spring 整合操作. 在我们入门学习 SSM 等东西的时候，就发现了任何东西，最后都是逃不过与Spring整合起来的道路. 然后这里看完 MyBatis 整合完 Spring 之后，那么之后一些其他的第三方，比如axon&#x2F;redis&#x2F;apollo&#x2F;shiro 等这些东西，如果要整合 Spring 的时候，是不是也是相似的整合方式呢？</p><p>这个需要我们看完 MyBatis 与 Spring 之后，探究其整合的操作.</p><h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><p>分几个步骤，操作一把即可,带你回到哪个 SM 时代，不过这回是没有了 tomcat 的.</p><p>先放上一个完成的整合地址 : <a target="_blank" rel="noopener" href="https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello">https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello</a> 如果不要看下面流程的,一步跳过即可.</p><ol><li>先创建一个 maven 项目，引入依赖. 依赖参考地址 : <a target="_blank" rel="noopener" href="https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/pom.xml">https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/pom.xml</a></li><li>db配置 : <a target="_blank" rel="noopener" href="https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/src/main/resources/db.properties">https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/src/main/resources/db.properties</a></li><li>MyBatis配置: <a target="_blank" rel="noopener" href="https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src/main/resources/mybatis">https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src/main/resources/mybatis</a></li><li>Spring 配置: <a target="_blank" rel="noopener" href="https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/src/main/resources/spring-beans.xml">https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/src/main/resources/spring-beans.xml</a></li><li>最后,来份我们熟悉的 <a target="_blank" rel="noopener" href="https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src/main/resources/sql">https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src/main/resources/sql</a> mapper.xml 文件.</li><li>不忘记再来一份代码 : <a target="_blank" rel="noopener" href="https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src">https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src</a> 这些直接跑测试类即可.</li></ol><p>跟着这上面的几个步骤，就可以搭建完一个项目. 然后喊上我们的 永哥， 打上传说中的 debug , 疯狂的调试看每步干了什么事.</p><p>这个的时候，可以跑下测试类，是ok的.</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>这里我们首先想到的是我们引入的依赖,是不是有个 mybatis-spring 的依赖. 从这个依赖，可以很明显的看出来，就是通过这个依赖，将 MyBatis 和 Spring 整合起来的。</p><p>然后再想想，我们除了这个依赖的话，还再哪里有使用到一些 Spring 和 MyBatis 的东西呢？ 然后看到 spring-beans.xml 这个xml配置, 可以看到 org.mybatis.spring.SqlSessionFactoryBean 给注入到 bean 里面来了.org.mybatis.spring.mapper.MapperScannerConfigurer也是给注入到 bean 里面来了. 并且二者都有通过来进行属性设置值操作.</p><p>那么,我们就基于这二个类的源码开始阅读.</p><p><strong>SqlSessionFactoryBean (org.mybatis.spring.SqlSessionFactoryBean)</strong></p><p>这里 SqlSessionFactoryBean 是实现了很多接口,这些接口都是Spring的.</p><p>FactoryBean 工厂bean,点进去可以看到,其有方法getObject()&#x2F;getObjectType等方法获取bean的,然后加上泛型,也就是这里获取的 getObject就是泛型.</p><p>InitializingBean: afterPropertiesSet 初始化 bean 的时候，会调用该方法.</p><p>ApplicationEvent: Spring的事件传播机制，就是使用的这种方式.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/**  可以看到这个类实现了 Spring 这个多接口,那么就有个问题,实现了这么多接口的方法,到底是哪个方法先执行的呢？ 如果你对Spring源码很熟悉的话,是有可能清楚的,但是还是会有点绕的. </span><br><span class="line">这里我们给 getObject/afterPropertiesSet/onApplicationEvent这三个方法打上断点来进行debug,</span><br><span class="line">debug每走的一步,就是执行的先后顺序。如果不是特别熟悉源码的执行顺序,这种笨方法其实也是可以的.</span><br><span class="line">*</span><br><span class="line">* 所以这里debug的执行顺序是 : afterPropertiesSet --&gt; getObject  ---&gt; onApplicationEvent</span><br><span class="line">* 于是我们就跟着这个顺序来阅读.</span><br><span class="line">* 注意在调用这些方法之前,&lt;property&gt;标签的值都是已经赋值进来了的,是通过反射走的set 方法进来的.</span><br><span class="line">*/</span><br><span class="line">public class SqlSessionFactoryBean</span><br><span class="line">    implements FactoryBean&lt;SqlSessionFactory&gt;, InitializingBean, ApplicationListener&lt;ApplicationEvent&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 实现FactoryBean 方法,这里是实现了该接口的三个方法. 其实这里的 isSingle是可以不用实现的</span><br><span class="line">// 因为接口是用 default 来修饰的.</span><br><span class="line">  /**</span><br><span class="line">   * 该方法是判断并且再次确认 SqlSessionFactory是不是有了. 如果没有的话,就会调用afterProperties来初始化.</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public SqlSessionFactory getObject() throws Exception &#123;</span><br><span class="line">    if (this.sqlSessionFactory == null) &#123;</span><br><span class="line">      afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this.sqlSessionFactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Class&lt;? extends SqlSessionFactory&gt; getObjectType() &#123;</span><br><span class="line">    return this.sqlSessionFactory == null ? SqlSessionFactory.class : this.sqlSessionFactory.getClass();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public boolean isSingleton() &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// InitializingBean 实现的方法</span><br><span class="line">  @Override</span><br><span class="line">  public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">// 先对 dataSource/sqlSessionFactoryBuilder进行非null的判断.</span><br><span class="line">    notNull(dataSource, &quot;Property &#x27;dataSource&#x27; is required&quot;);</span><br><span class="line">    notNull(sqlSessionFactoryBuilder, &quot;Property &#x27;sqlSessionFactoryBuilder&#x27; is required&quot;);</span><br><span class="line">    state((configuration == null &amp;&amp; configLocation == null) || !(configuration != null &amp;&amp; configLocation != null),</span><br><span class="line">        &quot;Property &#x27;configuration&#x27; and &#x27;configLocation&#x27; can not specified with together&quot;);</span><br><span class="line">// 这里构建出 一个 sqlSessionFactory工厂来,想想我们最初再看单个MyBatis项目的时候,是不是也有一个获取SqlSessionFactroy的方法,然后从sqlSessionFactory会话中获取出SqlSession来.</span><br><span class="line">    this.sqlSessionFactory = buildSqlSessionFactory();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// ApplicationListener实现方法</span><br><span class="line">  /**</span><br><span class="line">   * failFast 时ture 并且传过来的 event是 ContextRefreshedEvent的话,就会进来.</span><br><span class="line">   *  这里目前都是调用get方法,没有很仔细看出其作用.</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public void onApplicationEvent(ApplicationEvent event) &#123;</span><br><span class="line">    if (failFast &amp;&amp; event instanceof ContextRefreshedEvent) &#123;</span><br><span class="line">      // fail-fast -&gt; check all statements are completed</span><br><span class="line">      this.sqlSessionFactory.getConfiguration().getMappedStatementNames();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>org.mybatis.spring.SqlSessionFactoryBean#buildSqlSessionFactory</strong></p><p>该方法需要单独拿出来说下,因为内容还是比较多的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Build a &#123;@code SqlSessionFactory&#125; instance.</span><br><span class="line"> *</span><br><span class="line"> * The default implementation uses the standard MyBatis &#123;@code XMLConfigBuilder&#125; API to build a</span><br><span class="line"> * &#123;@code SqlSessionFactory&#125; instance based on a Reader. Since 1.3.0, it can be specified a &#123;@link Configuration&#125;</span><br><span class="line"> * instance directly(without config file).</span><br><span class="line"> *</span><br><span class="line"> * @return SqlSessionFactory</span><br><span class="line"> * @throws Exception</span><br><span class="line"> *           if configuration is failed</span><br><span class="line"> */</span><br><span class="line">protected SqlSessionFactory buildSqlSessionFactory() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">  final Configuration targetConfiguration;</span><br><span class="line"></span><br><span class="line">  XMLConfigBuilder xmlConfigBuilder = null;</span><br><span class="line">    </span><br><span class="line"> // 这里分为configuration/ configLocation / 非前二者(可以理解为默认的).</span><br><span class="line"> // 三种处理方式.   </span><br><span class="line">  if (this.configuration != null) &#123;</span><br><span class="line">    targetConfiguration = this.configuration;</span><br><span class="line">    if (targetConfiguration.getVariables() == null) &#123;</span><br><span class="line">      targetConfiguration.setVariables(this.configurationProperties);</span><br><span class="line">    &#125; else if (this.configurationProperties != null) &#123;</span><br><span class="line">      targetConfiguration.getVariables().putAll(this.configurationProperties);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (this.configLocation != null) &#123;</span><br><span class="line">// 这里就是我们配置的情况 </span><br><span class="line">// org.apache.ibatis.builder.xml.XMLConfigBuilder#XMLConfigBuilder(java.io.InputStream, java.lang.String, java.util.Properties),可以看到这个熟悉的操作,也就是我们单个解析 MyBatis的时候有进行分析过的.      </span><br><span class="line">    xmlConfigBuilder = new XMLConfigBuilder(this.configLocation.getInputStream(), null, this.configurationProperties);</span><br><span class="line">// 获取出 configuration 配置信息.      </span><br><span class="line">    targetConfiguration = xmlConfigBuilder.getConfiguration();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    LOGGER.debug(</span><br><span class="line">        () -&gt; &quot;Property &#x27;configuration&#x27; or &#x27;configLocation&#x27; not specified, using default MyBatis Configuration&quot;);</span><br><span class="line">    targetConfiguration = new Configuration();</span><br><span class="line">    Optional.ofNullable(this.configurationProperties).ifPresent(targetConfiguration::setVariables);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 这里采用 Optional,如果objectFactory不是null的话,就会调用targetConfiguration的 setObjectFactory方法.下面这二个是同理.</span><br><span class="line">  Optional.ofNullable(this.objectFactory).ifPresent(targetConfiguration::setObjectFactory);</span><br><span class="line">  Optional.ofNullable(this.objectWrapperFactory).ifPresent(targetConfiguration::setObjectWrapperFactory);</span><br><span class="line">  Optional.ofNullable(this.vfs).ifPresent(targetConfiguration::setVfsImpl);</span><br><span class="line"></span><br><span class="line">// 这里如果有配置typeAliasesPackage这个参数的话,就会对该包下进行扫描,进行一系列的过滤,</span><br><span class="line">// 如果都满足条件的话,targetConfiguration.getTypeAliasRegistry()::registerAlias就会注册到这里. </span><br><span class="line">  if (hasLength(this.typeAliasesPackage)) &#123;</span><br><span class="line">    scanClasses(this.typeAliasesPackage, this.typeAliasesSuperType).stream()</span><br><span class="line">        .filter(clazz -&gt; !clazz.isAnonymousClass()).filter(clazz -&gt; !clazz.isInterface())</span><br><span class="line">        .filter(clazz -&gt; !clazz.isMemberClass()).forEach(targetConfiguration.getTypeAliasRegistry()::registerAlias);</span><br><span class="line">  &#125;</span><br><span class="line">// 是否有typeAliases这个参数,如果有的话,也是可以看到是注册到上面哪一步的里面来.</span><br><span class="line">  if (!isEmpty(this.typeAliases)) &#123;</span><br><span class="line">    Stream.of(this.typeAliases).forEach(typeAlias -&gt; &#123;</span><br><span class="line">      targetConfiguration.getTypeAliasRegistry().registerAlias(typeAlias);</span><br><span class="line">      LOGGER.debug(() -&gt; &quot;Registered type alias: &#x27;&quot; + typeAlias + &quot;&#x27;&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//判断是否有插件,如果有插件的话,也会添加到configuration中来.    </span><br><span class="line">  if (!isEmpty(this.plugins)) &#123;</span><br><span class="line">    Stream.of(this.plugins).forEach(plugin -&gt; &#123;</span><br><span class="line">      targetConfiguration.addInterceptor(plugin);</span><br><span class="line">      LOGGER.debug(() -&gt; &quot;Registered plugin: &#x27;&quot; + plugin + &quot;&#x27;&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (hasLength(this.typeHandlersPackage)) &#123;</span><br><span class="line">    scanClasses(this.typeHandlersPackage, TypeHandler.class).stream().filter(clazz -&gt; !clazz.isAnonymousClass())</span><br><span class="line">        .filter(clazz -&gt; !clazz.isInterface()).filter(clazz -&gt; !Modifier.isAbstract(clazz.getModifiers()))</span><br><span class="line">        .forEach(targetConfiguration.getTypeHandlerRegistry()::register);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (!isEmpty(this.typeHandlers)) &#123;</span><br><span class="line">    Stream.of(this.typeHandlers).forEach(typeHandler -&gt; &#123;</span><br><span class="line">      targetConfiguration.getTypeHandlerRegistry().register(typeHandler);</span><br><span class="line">      LOGGER.debug(() -&gt; &quot;Registered type handler: &#x27;&quot; + typeHandler + &quot;&#x27;&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  targetConfiguration.setDefaultEnumTypeHandler(defaultEnumTypeHandler);</span><br><span class="line"></span><br><span class="line">  if (!isEmpty(this.scriptingLanguageDrivers)) &#123;</span><br><span class="line">    Stream.of(this.scriptingLanguageDrivers).forEach(languageDriver -&gt; &#123;</span><br><span class="line">      targetConfiguration.getLanguageRegistry().register(languageDriver);</span><br><span class="line">      LOGGER.debug(() -&gt; &quot;Registered scripting language driver: &#x27;&quot; + languageDriver + &quot;&#x27;&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  Optional.ofNullable(this.defaultScriptingLanguageDriver)</span><br><span class="line">      .ifPresent(targetConfiguration::setDefaultScriptingLanguage);</span><br><span class="line"></span><br><span class="line">  if (this.databaseIdProvider != null) &#123;// fix #64 set databaseId before parse mapper xmls</span><br><span class="line">    try &#123;</span><br><span class="line">      targetConfiguration.setDatabaseId(this.databaseIdProvider.getDatabaseId(this.dataSource));</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">      throw new NestedIOException(&quot;Failed getting a databaseId&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Optional.ofNullable(this.cache).ifPresent(targetConfiguration::addCache);</span><br><span class="line">// 这这之前,都是对一些配置信息的读取,如果有的话,就会进行相应的赋值之类的操作.</span><br><span class="line">    </span><br><span class="line">  if (xmlConfigBuilder != null) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">// 最后这里的 parse 解析方法,是和单个 Mybatis的解读是一样的.        </span><br><span class="line">      xmlConfigBuilder.parse();</span><br><span class="line">      LOGGER.debug(() -&gt; &quot;Parsed configuration file: &#x27;&quot; + this.configLocation + &quot;&#x27;&quot;);</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">      throw new NestedIOException(&quot;Failed to parse config resource: &quot; + this.configLocation, ex);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//这里可以看事务工厂,是使用了mybatis-spring包下的.</span><br><span class="line">  targetConfiguration.setEnvironment(new Environment(this.environment,</span><br><span class="line">      this.transactionFactory == null ? new SpringManagedTransactionFactory() : this.transactionFactory,</span><br><span class="line">      this.dataSource));</span><br><span class="line"></span><br><span class="line">// 这里是处理 mapper.xml 文件的配置,如果在这里是有配置的话,那么也是会被解析到的.    </span><br><span class="line">  if (this.mapperLocations != null) &#123;</span><br><span class="line">    if (this.mapperLocations.length == 0) &#123;</span><br><span class="line">      LOGGER.warn(() -&gt; &quot;Property &#x27;mapperLocations&#x27; was specified but matching resources are not found.&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      for (Resource mapperLocation : this.mapperLocations) &#123;</span><br><span class="line">        if (mapperLocation == null) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">          XMLMapperBuilder xmlMapperBuilder = new XMLMapperBuilder(mapperLocation.getInputStream(),</span><br><span class="line">              targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());</span><br><span class="line">          xmlMapperBuilder.parse();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">          throw new NestedIOException(&quot;Failed to parse mapping resource: &#x27;&quot; + mapperLocation + &quot;&#x27;&quot;, e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">          ErrorContext.instance().reset();</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.debug(() -&gt; &quot;Parsed mapper file: &#x27;&quot; + mapperLocation + &quot;&#x27;&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    LOGGER.debug(() -&gt; &quot;Property &#x27;mapperLocations&#x27; was not specified.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">//org.apache.ibatis.session.defaults.DefaultSqlSessionFactory,最后到这里也是new了一个mybatis包下的默认SqlSessionFactory类.</span><br><span class="line">  return this.sqlSessionFactoryBuilder.build(targetConfiguration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到该方法给人感觉, 先是判断一些配置信息是不是有值，如果是有值的话，就会进行相应的处理。最后调用我们在看单个 mybatis 的 parse 解析方法,最后new了一个默认的sqlSessionFactory工厂类出来.</p><p><strong>MapperScannerConfigurer(org.mybatis.spring.mapper.MapperScannerConfigurer)</strong></p><p>接着看,spring-beans.xml 里面的第二个配置.</p><p>可以看到该类，也是实现了 spring 的很多接口.</p><p>BeanDefinitionRegistryPostProcessor : 注册BeanDefinition到Spring容器中来.</p><p>ApplicationContextAware : 获取 ApplicationContext</p><p>BeanNameAware : 设置 beanName名字.</p><p>这里也可以按照上面的笨方法，一次对重写的方法打上断点. 然后开启我们的debug来看看方法的执行顺序.</p><p>其执行顺序 : setBeanName —&gt; setApplicationContext —&gt; afterPropertiesSet —&gt; postProcessBeanDefinitionRegistry , 跟着这四个方法执行的顺序来看.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class MapperScannerConfigurer</span><br><span class="line">    implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware &#123; &#125;</span><br></pre></td></tr></table></figure><p>赋值给 beanName 值. org.mybatis.spring.mapper.MapperScannerConfigurer#0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setBeanName(String name) &#123;</span><br><span class="line">  this.beanName = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 然后这里是给到 ApplicationContext. 这也就说这个类现在有了 ApplicationContext,可以根据context提供的api来进行相应的操作.</span><br><span class="line">  @Override</span><br><span class="line">  public void setApplicationContext(ApplicationContext applicationContext) &#123;</span><br><span class="line">    this.applicationContext = applicationContext;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 检验配置包的值不能为null.</span><br><span class="line">  @Override</span><br><span class="line">  public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">    notNull(this.basePackage, &quot;Property &#x27;basePackage&#x27; is required&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   * 可以感受到这个方法, 在拿到了BeanDefinitionRegistry的情况下,往里面注册bd.</span><br><span class="line">   * @since 1.0.2</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    if (this.processPropertyPlaceHolders) &#123;</span><br><span class="line">      processPropertyPlaceHolders();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 这段是创建了一个 ClassPathMapperScanner 对象,然后往里面set属性.      </span><br><span class="line">    ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);</span><br><span class="line">    scanner.setAddToConfig(this.addToConfig);</span><br><span class="line">    scanner.setAnnotationClass(this.annotationClass);</span><br><span class="line">    scanner.setMarkerInterface(this.markerInterface);</span><br><span class="line">    scanner.setSqlSessionFactory(this.sqlSessionFactory);</span><br><span class="line">    scanner.setSqlSessionTemplate(this.sqlSessionTemplate);</span><br><span class="line">    scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName);</span><br><span class="line">    scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName);</span><br><span class="line">    scanner.setResourceLoader(this.applicationContext);</span><br><span class="line">    scanner.setBeanNameGenerator(this.nameGenerator);</span><br><span class="line">    scanner.setMapperFactoryBeanClass(this.mapperFactoryBeanClass);</span><br><span class="line">      </span><br><span class="line">    if (StringUtils.hasText(lazyInitialization)) &#123;</span><br><span class="line">      scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));</span><br><span class="line">    &#125;</span><br><span class="line">    if (StringUtils.hasText(defaultScope)) &#123;</span><br><span class="line">      scanner.setDefaultScope(defaultScope);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">// 对register里的信息进行过滤      </span><br><span class="line">    scanner.registerFilters();</span><br><span class="line">// org.springframework.context.annotation.ClassPathBeanDefinitionScanner#scan</span><br><span class="line">// 这里主要看扫描的方法. 根据,来切割我们写的 basePackage 信息.扫描类的信息,最后还是借用了 org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan 来进行扫描的. //  doScan(basePackages) 是对 xml 进行扫描的.</span><br><span class="line">// AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); 是对注解进行扫描的.</span><br><span class="line">// 最后返回注册到 Spring 容器中的 bean 个数</span><br><span class="line">// 所以如果我们配置了下面的标签,那么在这里都会被扫描到并且注册到Spring容器中.</span><br><span class="line">//     &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">//        &lt;property name=&quot;basePackage&quot; value=&quot;com.iyang.sm.mapper&quot; &gt;&lt;/property&gt;</span><br><span class="line">//    &lt;/bean&gt;</span><br><span class="line">// 这里需要注意的是:  org.mybatis.spring.mapper.ClassPathMapperScanner#processBeanDefinitions</span><br><span class="line">//   definition.setBeanClass(this.mapperFactoryBeanClass);  这里的这行代码,是给bd的beanClass给换成了 MapperFactoryBean.class , </span><br><span class="line">//  definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName);     // 这句代码,将 beanClassName 给到 db之后, 然后就才用 beanClassName来new一个 MapperFactoryBean 对象来, 所以这里并不是使用无参构造函数.</span><br><span class="line">// 也许会问,怎么证实没有走无参数构造函数呢 ? 而是去走的 set 方法呢 ? </span><br><span class="line">// 再不能动源码的情况下, 面对这种情况情况最好的办法就是, 在无参构造函数上打上断点.</span><br><span class="line">// 如果没走到断点上,那就说明不是走的无参构造函数来初始化的.      </span><br><span class="line">    scanner.scan(</span><br><span class="line">        StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>所以到这里, 可以看到 MyBatis 与 Spring 整合的过程就已经完成了.</p><p>我们这里是主要对 SqlSessionFactoryBean 和 MapperScannerConfigurer 来进行分析的, 可以很明显的感觉到,我们是配置好这二个bean后,就可以使用了. 着重看第二个, org.mybatis.spring.mapper.MapperScannerConfigurer 这个bean,就是做了如何将 MyBatis 的 mapper接口文件给加载到 Spring 中来的. <strong>那么这里我在想, 如果有天我自己开发出一个好用的框架来,要与 Spring 进行整合的话,是不是也这样整合就可以了？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置sqlSessionFactory，SqlSessionFactoryBean是用来产生sqlSessionFactory的 --&gt;</span><br><span class="line">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;!-- 加载mybatis的全局配置文件，放在classpath下的mybatis文件夹中了 --&gt;</span><br><span class="line">    &lt;property name=&quot;configLocation&quot; value=&quot;mybatis/SqlMapConfig.xml&quot; /&gt;</span><br><span class="line">    &lt;!-- 加载数据源，使用上面配置好的数据源 --&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--  配置扫描 MyBatis 接口的包 --&gt;</span><br><span class="line">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;basePackage&quot; value=&quot;com.iyang.sm.mapper&quot; &gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>可以看到 MyBatis 与 Spring 整合后, 对于解析 MyBatis 的 mapper 配置文件等，都是走的之前单个 mybatis 的逻辑, 是没有什么变化的. 主要的是将 , SqlSessionFactory 和 Mapper.class(接口类) 给注入到 Spring 容器中.然后接口的话, 是怎么使用的代理类来进行实例化完后, 将对象给注入到 Spring 容器中的呢 ？ 这里看 org.mybatis.spring.mapper.MapperScannerConfigurer 做的事情就明白了.</p><p>不过在看 mybatis 与 Spring 整合的时候, 还是建议要有对 BeanDefinitionRegistryPostProcessor &#x2F; InitializingBean &#x2F; ApplicationContextAware &#x2F; BeanNameAware 有一定的了接. 就是有了了解后, 你就会很明显的感受到， mybatis 为什么是实现这个接口，实现这个接口并且重写这个方法，在后面是什么时候被调用的. 意思也就是，你至少得明白点 Spring 对外提供的一些扩展点，才能很好的理解这些东西.</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/11/04/mybatis/mybatis%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E9%98%85%E8%AF%BB/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/04/mybatis/mybatis%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E9%98%85%E8%AF%BB/" class="post-title-link" itemprop="url">mybatis工作流程阅读</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-04 00:29:16" itemprop="dateCreated datePublished" datetime="2021-11-04T00:29:16+08:00">2021-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">java框架</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java%E6%A1%86%E6%9E%B6/mybatis/" itemprop="url" rel="index"><span itemprop="name">mybatis</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>18k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>17 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h4 id="MyBatis-的工程流程分析"><a href="#MyBatis-的工程流程分析" class="headerlink" title="MyBatis 的工程流程分析"></a>MyBatis 的工程流程分析</h4><p>MyBatis 是我们在学习Java框架，也就是学习完JavaWeb的知识后,要学习到的一个ORM的框架. 我也是学习&amp;使用过后，再次对源码进行阅读的. 所以这篇文章记录 MyBatis 的一个 work flow.</p><p>先放上项目地址 : <a target="_blank" rel="noopener" href="https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-work-flow">https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-work-flow</a></p><p>有兴趣的同学,可以clone下来看看.</p><h4 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h4><p>先放上案列的代码, 然后我们可以挨个的分析.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class InitHelloMyBatis &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        // 读取配置文件.</span><br><span class="line">        InputStream mybatisInputStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">        // 传入读取配置文件的流,使用SqlSessionFactoryBuilder来</span><br><span class="line">        // 构建 SqlSessionFactory.</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mybatisInputStream);</span><br><span class="line">        // 从 SqlSessionFactory 中获取SqlSession会话.</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        // 从会话中获取 Mapper.</span><br><span class="line">        BlogMapper blogMapper = session.getMapper(BlogMapper.class);</span><br><span class="line">        </span><br><span class="line">        // 调用查询方法.</span><br><span class="line">        TbBlog tbBlog = blogMapper.selectBlog(1);</span><br><span class="line">        System.out.println(tbBlog);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里说下大致流程 :</p><ul><li>使用 Resources 来读取 mybatis-config.xml配置文件, 如果该文件不存在或者读取出来 InputStream 是 null 的话,程序就会抛出 IOException 的错误来.</li><li>读取配置没有问题,来到 new SqlSessionFactoryBuilder().build(io) 来构建出一个 SqlSessionFactory 来, 这里构建出来的 SqlSessionFactory 肯定是有已经讲配置文件给全部加载进去了的.</li><li>SqlSessionFactory.openSession() 从 SqlSessionFactory 中获取一次会话, 然后可以从会话中获取出接口(BlogMapper)来,这里是不是有点好奇,明明这就是一个接口,也没有实现类,怎么就可以get出一个接口对象来?获取出接口来,然后就可以调用接口中的方法, 根据id查询出数据来.</li></ul><p>可以看到,根据从官网写的一个列子,从表面来看,代码量并不是很多. 所以接下来点去源码,去跟进源码中的每个方法,到底做了些什么事情.</p><p><strong>读取配置文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream mybatisInputStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br></pre></td></tr></table></figure><p>org.apache.ibatis.io.Resources (Class).</p><p>可以看到MyBatis源码还写了一个 ClassLoader的包装类，通过ClassLoaderWrapper包装类来讲配置文件转化为InputSream.</p><p>如果返回的InputStream是null，就会抛出IOException来.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns a resource on the classpath as a Stream object</span><br><span class="line"> *</span><br><span class="line"> * @param loader   The classloader used to fetch the resource</span><br><span class="line"> * @param resource The resource to find</span><br><span class="line"> * @return The resource</span><br><span class="line"> * @throws java.io.IOException If the resource cannot be found or read</span><br><span class="line"> */</span><br><span class="line">private static ClassLoaderWrapper classLoaderWrapper = new ClassLoaderWrapper();</span><br><span class="line"></span><br><span class="line">public static InputStream getResourceAsStream(ClassLoader loader, String resource) throws IOException &#123;</span><br><span class="line">  // 利用 ClasssLoaderWrapper.  </span><br><span class="line">  InputStream in = classLoaderWrapper.getResourceAsStream(resource, loader);</span><br><span class="line">  if (in == null) &#123;</span><br><span class="line">    throw new IOException(&quot;Could not find resource &quot; + resource);</span><br><span class="line">  &#125;</span><br><span class="line">  return in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我们接着看 ClassLoaderWrapper 是怎么 读取配置文件 &amp; 转化为 InputStream 流的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 这里返回的是 ClassLoader的数组,如果对ClassLoader不是很了解的话,可以先去百度了解下.</span><br><span class="line">ClassLoader[] getClassLoaders(ClassLoader classLoader) &#123;</span><br><span class="line">  return new ClassLoader[]&#123;</span><br><span class="line">      // 传递进来的 </span><br><span class="line">      classLoader,</span><br><span class="line">      // 默认的 ClassLoader</span><br><span class="line">      defaultClassLoader,</span><br><span class="line">      // 根据当前线程获取出来的</span><br><span class="line">      Thread.currentThread().getContextClassLoader(),</span><br><span class="line">      // 根据当前 Class 获取出来的.</span><br><span class="line">      getClass().getClassLoader(),</span><br><span class="line">      // 系统的ClassLoader.</span><br><span class="line">      systemClassLoader&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 获取到了 classLoader的数组,然后对其进行迭代.</span><br><span class="line">// 也就是使用 ClassLoader的  getResourceAsStream 方法,来讲 mybatis-config.xml</span><br><span class="line">// 配置文件转化为 InputStream.</span><br><span class="line">// 最后如果获取到InputStream都是null的话,那么返回的也就是null了.</span><br><span class="line">// 根据上面的说法,返回的如果是null的话,就会出 IOException来.</span><br><span class="line">InputStream getResourceAsStream(String resource, ClassLoader[] classLoader) &#123;</span><br><span class="line">    for (ClassLoader cl : classLoader) &#123;</span><br><span class="line">      if (null != cl) &#123;</span><br><span class="line"></span><br><span class="line">        // try to find the resource as passed</span><br><span class="line">        InputStream returnValue = cl.getResourceAsStream(resource);</span><br><span class="line"></span><br><span class="line">        // now, some class loaders want this leading &quot;/&quot;, so we&#x27;ll add it and try again if we didn&#x27;t find the resource</span><br><span class="line">        if (null == returnValue) &#123;</span><br><span class="line">          returnValue = cl.getResourceAsStream(&quot;/&quot; + resource);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (null != returnValue) &#123;</span><br><span class="line">          return returnValue;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>至此,MyBatis读取 mybatis-config.xml 配置文件也就是解析完毕,可以看到采用了自己写的 ClassLoaderWrapper来操作的, 传递一种 ClassLoader进来,其默认的&amp;系统&amp;线程的,加一起也是有四种. 最后挨个进来迭代，满足条件的会读取文件转化为InputStream,如果都是null的话,也会返回null.</strong></p><hr><p><strong>获取SqlSessionFactory &amp; 解析配置文件</strong></p><p>new SqlSessionFactoryBuilder() 也是new了一个 SqlSessionFactoryBuild,个人理解 SqlSessionFactoryBuilder 就是专程用来构建出 SqlSessionFactory 来的,毕竟其后面有一个 build 方法.</p><p>Problem ? 这里有个问题,为什么不将 SqlSessionFactoryBuilder 的build 方法,修改为静态的 ? 如果修改为静态的话，那就不用new了,就可以直接 SqlSessionFactoryBuilder.build(mybatisInputStream);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory = new                     SqlSessionFactoryBuilder().build(mybatisInputStream);</span><br></pre></td></tr></table></figure><p><strong>SqlSessionFactory</strong></p><p>接着我们来到 SqlSessionFactory 的 build 方法.</p><p>这里在 finnaly 中, 可以看到 ErrorContext 利用了 ThreadLocal , 刚好这周出了 ThreadLocal 的视频.</p><p>视频地址 : <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ga4y1W72w">https://www.bilibili.com/video/BV1Ga4y1W72w</a></p><p>有兴趣&amp;乐于学习&amp;分享的,可以共同进步.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    // 利用传入进来的参数,new出来了一个 XMLConfigBuilder.</span><br><span class="line">    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">    return build(parser.parse());</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    // 这里对 ThreadLocal 中进行 remove() 操作   </span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">    try &#123;</span><br><span class="line">      // 关闭流.  </span><br><span class="line">      inputStream.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      // Intentionally ignore. Prefer previous error.</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new XmlConfigBuilder() 方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">public XMLConfigBuilder(InputStream inputStream, String environment, Properties props) &#123;</span><br><span class="line">  // 先new一个XMLMapperEntityResolver,再new一个XPathParser,然后就走到下面的构造函数.</span><br><span class="line">  this(new XPathParser(inputStream, true, props, new XMLMapperEntityResolver()), environment, props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 最后还是走到这个构造方法中来.</span><br><span class="line">private XMLConfigBuilder(XPathParser parser, String environment, Properties props) &#123;</span><br><span class="line">  super(new Configuration());</span><br><span class="line">  ErrorContext.instance().resource(&quot;SQL Mapper Configuration&quot;);</span><br><span class="line">  this.configuration.setVariables(props);</span><br><span class="line">  this.parsed = false;</span><br><span class="line">  this.environment = environment;</span><br><span class="line">  this.parser = parser;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------</span><br><span class="line">// new XPathParser代码:</span><br><span class="line">    </span><br><span class="line">  public XPathParser(InputStream inputStream, boolean validation, Properties variables, EntityResolver entityResolver) &#123;</span><br><span class="line">    // 普通的构造方法.</span><br><span class="line">    // 对 XPathParser的validation/entityResolver/variables/xpath</span><br><span class="line">    // 的属性进行赋值操作.</span><br><span class="line">    commonConstructor(validation, variables, entityResolver);</span><br><span class="line">    this.document = createDocument(new InputSource(inputStream));</span><br><span class="line">  &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// createDocument 方法</span><br><span class="line">  private Document createDocument(InputSource inputSource) &#123;</span><br><span class="line">    // important: this must only be called AFTER common constructor</span><br><span class="line">    try &#123;</span><br><span class="line">      // 这里通过debug看,返回的对象是DocumentBuilderFactoryImpl</span><br><span class="line">      // 也就是其实现类.  </span><br><span class="line">      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">     // 对 factory 的 features(HashMap) 添加值,   </span><br><span class="line">      factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);</span><br><span class="line">     // 对 factory 的 validating 进行赋值  </span><br><span class="line">      factory.setValidating(validation);</span><br><span class="line">	 // 这下面都是对 factory的属性进行赋值操作.	</span><br><span class="line">      factory.setNamespaceAware(false);</span><br><span class="line">      factory.setIgnoringComments(true);</span><br><span class="line">      factory.setIgnoringElementContentWhitespace(false);</span><br><span class="line">      factory.setCoalescing(false);</span><br><span class="line">      factory.setExpandEntityReferences(true);</span><br><span class="line">		</span><br><span class="line">      // 可以看到 return new DocumentBuilderImpl</span><br><span class="line">      // 最后返回的也是其实现类. </span><br><span class="line">      DocumentBuilder builder = factory.newDocumentBuilder();</span><br><span class="line">      builder.setEntityResolver(entityResolver);</span><br><span class="line">      // 设置错误的handler,可以看到ErrorHandler是接口,这里是匿名实现的</span><br><span class="line">      // 也就是直接new了接口,然后重写其方法.  </span><br><span class="line">      builder.setErrorHandler(new ErrorHandler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void error(SAXParseException exception) throws SAXException &#123;</span><br><span class="line">          throw exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void fatalError(SAXParseException exception) throws SAXException &#123;</span><br><span class="line">          throw exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void warning(SAXParseException exception) throws SAXException &#123;</span><br><span class="line">          // NOP</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      //   DocumentBuilderImpl 的 parse 解析方法</span><br><span class="line">      return builder.parse(inputSource);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BuilderException(&quot;Error creating document instance.  Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">-------------</span><br><span class="line">//   builder.parse(inputSource)</span><br><span class="line"></span><br><span class="line">    public Document parse(InputSource is) throws SAXException, IOException &#123;</span><br><span class="line">        if (is == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN,</span><br><span class="line">                &quot;jaxp-null-input-source&quot;, null));</span><br><span class="line">        &#125;</span><br><span class="line">    // fSchemaValidator 是 null ,跳过.</span><br><span class="line">        if (fSchemaValidator != null) &#123;</span><br><span class="line">            if (fSchemaValidationManager != null) &#123;</span><br><span class="line">                fSchemaValidationManager.reset();</span><br><span class="line">                fUnparsedEntityHandler.reset();</span><br><span class="line">            &#125;</span><br><span class="line">            resetSchemaValidator();</span><br><span class="line">        &#125;</span><br><span class="line">  // 使用 xml 的相关类对 is 进行解析  </span><br><span class="line">        domParser.parse(is);</span><br><span class="line"> //  ?   </span><br><span class="line">        Document doc = domParser.getDocument();</span><br><span class="line"> // ? 这些解析 Document 的地方.....   </span><br><span class="line">        domParser.dropDocumentReferences();</span><br><span class="line">        return doc;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------</span><br><span class="line">// 最后看到 this 构造函数.</span><br><span class="line"></span><br><span class="line">  private XMLConfigBuilder(XPathParser parser, String environment, Properties props) &#123;</span><br><span class="line">    /** new Configuration() 中,TypeAliasRegistry typeAliasRegistry中的 typeAliases,</span><br><span class="line">    *   在初始化这个对象的时候,就默认设置了一些别名配置.</span><br><span class="line">    *   初始化的时候,还有对 LanguageDriverRegistry 的 LANGUAGE_DRIVER_MAP 赋值.</span><br><span class="line">    *  父类 :  BaseBuilder抽象类.</span><br><span class="line">    *  然后调用super方法,将configuration赋值父类的configuration</span><br><span class="line">    *  同时将 configuration的typeAliasRegistry和typeHandlerRegistry也赋值</span><br><span class="line">    *  给当前的这个对象.</span><br><span class="line">    *   </span><br><span class="line">    */</span><br><span class="line">    super(new Configuration());</span><br><span class="line">    // instance() 方法是往 ThreadLocal里面去set了一个ErrorContext</span><br><span class="line">    // 最后会在finnaly中进行remove掉.</span><br><span class="line">    ErrorContext.instance().resource(&quot;SQL Mapper Configuration&quot;);</span><br><span class="line">    // 将 props 赋值到 configuration 的 variable 参数.</span><br><span class="line">    this.configuration.setVariables(props);</span><br><span class="line">    // 表示还没有被解析</span><br><span class="line">    this.parsed = false;</span><br><span class="line">    this.environment = environment;</span><br><span class="line">    this.parser = parser;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>到这里,就可以看到 this构造方法以及其之前还有new对象的方法,都已经走完了. 这上面的方法,基本都是再为后面的解析xml文件做准备, 并且还有一些初始化数据的赋值操作.</p><p><strong>Note</strong> : 注意这里的 BaseBuilder是抽象类,其实现类是有好几个的. 这种写法,其实是将子类的一些common的方法,写入到 BaseBuilder父类中,然后不同的方法,需要子类自己去重写这个方法实现自己的业务逻辑. 当然一些参数也是可以放在抽象类中.</p><p><strong>build(parser.parse())</strong> : 解析代码.</p><p>parser.parse() 方法 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public Configuration parse() &#123;</span><br><span class="line">  // 用 parsed 来控制是否解析过,如果已经解析过了,那就抛出异常.  </span><br><span class="line">  if (parsed) &#123;</span><br><span class="line">    throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  parsed = true;</span><br><span class="line">  //   </span><br><span class="line">  parseConfiguration(parser.evalNode(&quot;/configuration&quot;));</span><br><span class="line">  return configuration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line">// parseConfiguration</span><br><span class="line">// 这里 debug 可以看到 root 是 configuration 的配置文件信息.   </span><br><span class="line">// 这里可以初步看到实对 我们的配置文件mybatis-config.xml进行解析,并且加载到 configuration中.</span><br><span class="line">// 后面我们跟着官网文档一步一步的阅读,会有专门对解析配置的源码进行分析.    </span><br><span class="line">  private void parseConfiguration(XNode root) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      //issue #117 read properties first</span><br><span class="line">      //   </span><br><span class="line">      propertiesElement(root.evalNode(&quot;properties&quot;));</span><br><span class="line">      Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));</span><br><span class="line">      loadCustomVfs(settings);</span><br><span class="line">      loadCustomLogImpl(settings);</span><br><span class="line">      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));</span><br><span class="line">      pluginElement(root.evalNode(&quot;plugins&quot;));</span><br><span class="line">      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));</span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));</span><br><span class="line">      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));</span><br><span class="line">      settingsElement(settings);</span><br><span class="line">      // read it after objectFactory and objectWrapperFactory issue #631</span><br><span class="line">      environmentsElement(root.evalNode(&quot;environments&quot;));</span><br><span class="line">      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));</span><br><span class="line">      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));</span><br><span class="line">      mapperElement(root.evalNode(&quot;mappers&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>build(parser.parse()) 方法</strong></p><p>这里是对 parser.parse() 调用玩返回的 Configuration 传入到新创建的 DefaultSqlSessionFactory 对象中.</p><p>也就是说,我们拿到的 SqlSessionFactory 是 DefaultSqlSessionFactory.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(Configuration config) &#123;</span><br><span class="line">  return new DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取 SqlSession</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">// org.apache.ibatis.session.defaults.DefaultSqlSessionFactory#openSessionFromDataSource</span><br><span class="line">// 看到这个方法,直接跟进到这个方法来.</span><br><span class="line"></span><br><span class="line">  private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123;</span><br><span class="line">    Transaction tx = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        </span><br><span class="line">// 从 configuration中获取出environment来,这里的 getEnvironment对应的是</span><br><span class="line">// 标签的 &lt;environment&gt;  里面的内容</span><br><span class="line">// org.apache.ibatis.mapping.Environment</span><br><span class="line">// 可以看到这个对象,id对应mybatis-config.xml中的environment id</span><br><span class="line">// datasource 对应  environment &gt; dataSource 字段.</span><br><span class="line">      final Environment environment = configuration.getEnvironment();</span><br><span class="line">// 根据    environment 来获取 TransactionFactory,也就是MyBatis的事务工厂.</span><br><span class="line">// debug 是可以看到  environment 中是有一个JdbcTransactionFactory的,</span><br><span class="line">// 如果没用的话,就会自己new一个 ManagedTransactionFactory 来.        </span><br><span class="line">      final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line"></span><br><span class="line">// 在 JdbcTransactionFactory 中new出了一个 JdbcTransaction</span><br><span class="line">// 也就是new了一个JDBC事务.</span><br><span class="line">// org.apache.ibatis.transaction.jdbc.JdbcTransaction,</span><br><span class="line">// 可以看到 JdbcTransaction 中有commit / rollback的方法,</span><br><span class="line">// 也就是说这个地方就是对事务进行操作的地方        </span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">// 这里是获取是执行器,</span><br><span class="line">// 具体代码: org.apache.ibatis.session.Configuration#newExecutor(org.apache.ibatis.transaction.Transaction, org.apache.ibatis.session.ExecutorType)</span><br><span class="line">// 这里有 SIMPLE, REUSE, BATCH ,CachingExecutor 还可以在 plugin 中自己定义.</span><br><span class="line">//executor = (Executor) interceptorChain.pluginAll(executor); 从这行代码可以看到,</span><br><span class="line">// 其实还是可以自己扩展的.        </span><br><span class="line">//org.apache.ibatis.plugin.InterceptorChain        </span><br><span class="line">      final Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">// 最后 new 出了一个默认的 SqlSession 会话.</span><br><span class="line">// 该会话中存有 configuration / executor 等核心东西.        </span><br><span class="line">      return new DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); // may have fetched a connection so lets call close()</span><br><span class="line">      throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">// 最后还是不忘记对使用过的ThreadLocal 进行remove 操作.        </span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>至此, 可以看到 MyBatis 从SqlSessionFactory中获取出来SqlSession会话, 也可以理解为几个步骤.</p><p>首先获取事务工厂, 然后再从事务工厂中获取一个事务来, JdbcTransaction 有兴趣的同学可以看下这个类,里面也是封装了写 commit &#x2F; rollback等方法. 再接着获取出 执行器(Executor),这里从代码哪里看,执行器还是有几种类型的,也执行自定义. 最后new了一个 DefaultSqlSession 回去.</p><p><strong>session.getMapper(BlogMapper.class);</strong></p><p>接着看,上一步返回的session,是怎么获取到我们写的Mapper接口文件(Mapper这种文件,在解析配置文件的时候,其实就已经解析到MyBatis的configuration里面去了).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line"> // knownMappers  中 key 是我们定义接口的Class,value是MapperProxyFactory,</span><br><span class="line">// MapperProxyFactory中的mapperInterface中存放了我们的接口class    </span><br><span class="line">  final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    </span><br><span class="line">// 如果获取出来的是null,那么MyBatis就认为你传入进来的接口是不存在的,就会抛出异常来.    </span><br><span class="line">  if (mapperProxyFactory == null) &#123;</span><br><span class="line">    throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">// 满足条件的话,调用newInstance方法,从方法名字上看,是创建一个instance的实例.      </span><br><span class="line">    return mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">// mapperProxyFactory.newInstance(sqlSession) 代码</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  public T newInstance(SqlSession sqlSession) &#123;</span><br><span class="line">    // new 了一个 MapperProxy对象.</span><br><span class="line">    final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    return newInstance(mapperProxy);</span><br><span class="line">  &#125;    </span><br><span class="line"></span><br><span class="line">// 最后可以看到使用 Proxy.newProxyInstance方法来创建的一个对象.</span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123;</span><br><span class="line">    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line">// 如果你是debug模式的话,那么你可以看到BlogMapper的对象地址池在 debug 中显示的值.</span><br><span class="line">// org.apache.ibatis.binding.MapperProxy@ef9296d    </span><br><span class="line">BlogMapper blogMapper = session.getMapper(BlogMapper.class);</span><br></pre></td></tr></table></figure><p>从SqlSession 中获取 BlogMapper我们写的mapper流程, 先从 knownMappers 中根据key获取出来之前加载配置已经加载完毕的信息,如果没用的话,就会抛出没有的异常. 最后使用 Proxy.newProxyIntsance来生成的一个类似接口实现类的代码,不同的是, 在 new MapperProxy 的时候,就已经将接下来需要的信息全部传入进去.</p><p><strong>blogMapper.selectBlog(1) 方法</strong></p><p>竟然 BlogMapper是通过Proxy.newInstance获取出来的,那它是怎么查询的数据库? 又是怎么将字段给映射到 Object一一对应的呢 ?</p><p>debug会走到 MapperProxy的invoke方法来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    if (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      return method.invoke(this, args);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return cachedInvoker(method).invoke(proxy, method, args, sqlSession);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (Throwable t) &#123;</span><br><span class="line">    throw ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line">// 通过 invoke 方法, 走 mapperMethod的execute方法,来到了这里.</span><br><span class="line">// switch 有 INSERT/UPDATE/DELETE/SELECT/FLUSH,如果这几种没有匹配到的话,就会抛出异常来.    </span><br><span class="line">  public Object execute(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">    Object result;</span><br><span class="line">    switch (command.getType()) &#123;</span><br><span class="line">            </span><br><span class="line">// 不难看到 INSERT/UPDATE/DELETE都是先调用 convertArgsToSqlCommandParam 方法,</span><br><span class="line">// 也就是先将参数转化为sql,然后将执行的结果 赋值 给 result 参数.            </span><br><span class="line">      case INSERT: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case UPDATE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case DELETE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">// 如果是 select 语句,可以根据返回值来分类,如果是void&amp;&amp;method.hasResultHandler,就会返回null</span><br><span class="line">// 多个 / Map类型  /    Cursor 类型   /  最后查询一个        </span><br><span class="line">      case SELECT:</span><br><span class="line">        if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result = null;</span><br><span class="line">        &#125; else if (method.returnsMany()) &#123;</span><br><span class="line">          result = executeForMany(sqlSession, args);</span><br><span class="line">        &#125; else if (method.returnsMap()) &#123;</span><br><span class="line">          result = executeForMap(sqlSession, args);</span><br><span class="line">        &#125; else if (method.returnsCursor()) &#123;</span><br><span class="line">          result = executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">          if (method.returnsOptional()</span><br><span class="line">              &amp;&amp; (result == null || !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">            result = Optional.ofNullable(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line"> // 刷新会话.           </span><br><span class="line">      case FLUSH:</span><br><span class="line">        result = sqlSession.flushStatements();</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">// 如果result 是 null, 方法返回的修饰符是private并且 返回值不是void的话,就会抛出异常.    </span><br><span class="line">    if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      throw new BindingException(&quot;Mapper method &#x27;&quot; + command.getName()</span><br><span class="line">          + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里可以看到,先是对 INSERT &#x2F; UPDATE &#x2F; DELETE &#x2F; SELECT 进行分类处理, 然后对再分别根据不同的类型进行处理. 都是先有转化为sql,然后将执行结果赋值给result.</p><p>至于里面详细的查询执行sql,还有动态sql,每次会话缓存等,后面看到详细的情况再一一说明. 这里只是对MyBatis的基本工作进行了一个梳理. 然后后面再根据基础梳理,再来挨个击碎他们.</p><p>至此, MyBatis的入门分析流程是结束的. 理解起来,应该还不是那么难.</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>根据 com.iyang.mybatis.InitHelloMyBatis , 也就是入门的demo来梳理下流程.</p><ol><li>读取配置文件,也就是将配置文件读取,转化为inptStream流.</li><li>利用 SqlSessionFactoryBuilder 来 解析流, 起内部又利用 BaseBuilder(其又很多实现类,这里用的XMLConfigBuilder)也解析xml配置文件. Configuration configuration 该类中是保存着xml配置文件的很多信息. 然后 DefaultSqlSessionFactory 中有configuration字段,也就是属性.</li><li>然后从 DefaultSqlSessionFactory 中获取 SqlSession来, 并且也会是否开启事务(参考:org.apache.ibatis.transaction.jdbc.JdbcTransaction)类,然后获取 Executor,Executor也是有几种种类的,也可以自己自定义,最后返回一个 DefaultSqlSession 来.</li><li>然后从 SqlSession 中获取我们的接口Mapper, 最后也是利用 Proxy.newProxyInstance 来生成的接口,也就是代理(这里打印出地址池或者debug看地址池,就会很明显的看到是代理对象).</li><li>最后走查询的方法, 也就是走到了 MapperProxy 来. 可以看到MapperProxy里面是有sqlSession的,而SqlSession是有 Executor&#x2F;configuration&#x2F;autoCommit等信息的, 有了sqlSession,就剩下执行sql和映射sql查询出来的结果来了(这里是 mapperMethod.execute(sqlSession, args) —&gt; org.apache.ibatis.binding.MapperMethod#execute 走到这里来了,这里之后就会分类进行处理,然后映射sql语句).</li><li>至此,一个 MyBatis 的 HelloWorld分析流程是完毕的.</li></ol></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/11/04/mybatis/mybatis%E4%B8%ADmapper%E6%96%87%E4%BB%B6%E9%98%85%E8%AF%BB/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/04/mybatis/mybatis%E4%B8%ADmapper%E6%96%87%E4%BB%B6%E9%98%85%E8%AF%BB/" class="post-title-link" itemprop="url">mybatis中mapper文件阅读</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-04 00:28:59" itemprop="dateCreated datePublished" datetime="2021-11-04T00:28:59+08:00">2021-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">java框架</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java%E6%A1%86%E6%9E%B6/mybatis/" itemprop="url" rel="index"><span itemprop="name">mybatis</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>15k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>13 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h4 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h4><p>MyBatis是如何对 Mapper 文件中的sql进行处理呢？ 虽然上篇解析 mybatis-config.xml 是有进行说明的, 但是应该拿出来单独仔细解析下. 因为这个里面涉及到动态sql, 加上mapper文件自身也有很多标签内容,然后MyBatis是怎么读取出这些内容的呢？读取出来后,又是做了怎么样的处理, 然后达到了sql那种执行效果的呢？</p><p>意思也就是,Mapper + 动态sql , 内容还是有点多的, 并且也很重要, 是非常有必要拿出来单独的仔细讲解下的.</p><h4 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h4><p>在之前对标签的进行解析的时候,是有对 标签进行一个初步的解析. 然后里面其实是很多内容还没填补很详细,所以特意记录下对 详细操作的. 那么，下文就开始操作吧.</p><p><strong>org.apache.ibatis.builder.xml.XMLMapperBuilder#parse</strong></p><p>主要来看这段解析的代码 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public void parse() &#123;</span><br><span class="line">    </span><br><span class="line">// 利用 org.apache.ibatis.session.Configuration 的 loadedResources</span><br><span class="line">// 来判断是不是已经加载过了的.    </span><br><span class="line">  if (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    configurationElement(parser.evalNode(&quot;/mapper&quot;));</span><br><span class="line">// 这里添加到 loadedResources 中来,也就是用来控制是不是已经解析过了的.      </span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    bindMapperForNamespace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 这三个方法给我一种好像解析那种没有还没解析完的 ? 这个地方有待完善.    </span><br><span class="line">  parsePendingResultMaps();</span><br><span class="line">  parsePendingCacheRefs();</span><br><span class="line">  parsePendingStatements();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// configurationElement 方法,</span><br><span class="line">// 可以看到这个方法中,很多标签(namespace/parameterMa/resultMap/sql)</span><br><span class="line">// 还有下面的select/insert/update/delete</span><br><span class="line">// 这些熟悉的标签</span><br><span class="line">  private void configurationElement(XNode context) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      String namespace = context.getStringAttribute(&quot;namespace&quot;);</span><br><span class="line">      if (namespace == null || namespace.equals(&quot;&quot;)) &#123;</span><br><span class="line">        throw new BuilderException(&quot;Mapper&#x27;s namespace cannot be empty&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">// 将 namespace 赋值进去,也就是当前正在解析的 namespace.        </span><br><span class="line">      builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">        </span><br><span class="line">// 这里是对缓存标签进行解析.        </span><br><span class="line">      cacheRefElement(context.evalNode(&quot;cache-ref&quot;));</span><br><span class="line">      cacheElement(context.evalNode(&quot;cache&quot;));</span><br><span class="line"> </span><br><span class="line">// 解析 parameterMap标签        </span><br><span class="line">      parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;));</span><br><span class="line">        </span><br><span class="line">//         </span><br><span class="line">      resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;));</span><br><span class="line">      sqlElement(context.evalNodes(&quot;/mapper/sql&quot;));</span><br><span class="line">      buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BuilderException(&quot;Error parsing Mapper XML. The XML location is &#x27;&quot; + resource + &quot;&#x27;. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>resultMapElements 方法 :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">// 这里的 list 是 xml 文件中的所有 &lt;resultMap&gt; 标签文件.</span><br><span class="line">private void resultMapElements(List&lt;XNode&gt; list) &#123;</span><br><span class="line">  for (XNode resultMapNode : list) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">//  有点好奇,该方法返回的 ResultMap 这边好像并没有参数,有点尴尬.</span><br><span class="line">//  不过是已经存储在 org.apache.ibatis.session.Configuration#resultMaps 中.       </span><br><span class="line">      resultMapElement(resultMapNode);</span><br><span class="line">    &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">      // ignore, it will be retried</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line">// 最后跟进到这个方法中来.</span><br><span class="line">  private ResultMap resultMapElement(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings, Class&lt;?&gt; enclosingType) &#123;</span><br><span class="line">    ErrorContext.instance().activity(&quot;processing &quot; + resultMapNode.getValueBasedIdentifier());</span><br><span class="line"> </span><br><span class="line">// 获取出 type , 这里我们获取出来的 type 是 TbBlog.    </span><br><span class="line">    String type = resultMapNode.getStringAttribute(&quot;type&quot;,</span><br><span class="line">        resultMapNode.getStringAttribute(&quot;ofType&quot;,</span><br><span class="line">            resultMapNode.getStringAttribute(&quot;resultType&quot;,</span><br><span class="line">                resultMapNode.getStringAttribute(&quot;javaType&quot;))));</span><br><span class="line">// 先判断 org.apache.ibatis.type.TypeAliasRegistry#typeAliases 中有没有,</span><br><span class="line">// 如果没有的话,就会自己new一个出来.    </span><br><span class="line">    Class&lt;?&gt; typeClass = resolveClass(type);</span><br><span class="line">    if (typeClass == null) &#123;</span><br><span class="line">// TODO,如果没有话?        </span><br><span class="line">      typeClass = inheritEnclosingType(resultMapNode, enclosingType);</span><br><span class="line">    &#125;</span><br><span class="line">    Discriminator discriminator = null;</span><br><span class="line">    List&lt;ResultMapping&gt; resultMappings = new ArrayList&lt;&gt;(additionalResultMappings);</span><br><span class="line">    </span><br><span class="line"> // 获取该 &lt;resultMap&gt; 下的子标签</span><br><span class="line">// 那么这里也就是获取 &lt;id&gt; 和 &lt;result&gt; 这二个.    </span><br><span class="line">    List&lt;XNode&gt; resultChildren = resultMapNode.getChildren();</span><br><span class="line">    for (XNode resultChild : resultChildren) &#123;</span><br><span class="line">// 分为 constructor / discriminator / 其他 这三类情况        </span><br><span class="line">      if (&quot;constructor&quot;.equals(resultChild.getName())) &#123;</span><br><span class="line">        processConstructorElement(resultChild, typeClass, resultMappings);</span><br><span class="line">      &#125; else if (&quot;discriminator&quot;.equals(resultChild.getName())) &#123;</span><br><span class="line">        discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line"> // 非前二者情况.         </span><br><span class="line">        List&lt;ResultFlag&gt; flags = new ArrayList&lt;&gt;();</span><br><span class="line">        if (&quot;id&quot;.equals(resultChild.getName())) &#123;</span><br><span class="line">         // 如果标签是id的话,就会给flags添加ResultFlag.ID.</span><br><span class="line">          flags.add(ResultFlag.ID);</span><br><span class="line">        &#125;</span><br><span class="line">  //  将返回回来的 ResultMapping 添加进来.       </span><br><span class="line">        resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">// 这里获取的是 &lt;resultMap&gt; 标签的 id 字段.    </span><br><span class="line">    String id = resultMapNode.getStringAttribute(&quot;id&quot;,</span><br><span class="line">            resultMapNode.getValueBasedIdentifier());</span><br><span class="line">// 这里还可以使用 extends 属性, 不是看到这里, 都好奇还有这种标签.    </span><br><span class="line">    String extend = resultMapNode.getStringAttribute(&quot;extends&quot;);</span><br><span class="line">    Boolean autoMapping = resultMapNode.getBooleanAttribute(&quot;autoMapping&quot;);</span><br><span class="line">// 这里 new 了一个 ResultMapResolver 对象.   </span><br><span class="line">    ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);</span><br><span class="line">    try &#123;</span><br><span class="line">// 这里最后就是 new 了一个 ResultMap 对象, 该对象的 id 是 namespace + 方法ID 拼接.</span><br><span class="line">// 然后将该对象给添加到  org.apache.ibatis.session.Configuration#resultMaps 中来,</span><br><span class="line">// key 就是其id, 最后就是根据 local / global 来分别进行二种情况检查.        </span><br><span class="line">      return resultMapResolver.resolve();</span><br><span class="line">    &#125; catch (IncompleteElementException  e) &#123;</span><br><span class="line">      configuration.addIncompleteResultMap(resultMapResolver);</span><br><span class="line">      throw e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//  buildResultMappingFromContext 方法</span><br><span class="line">// 该方法是对 resultMap 中的字段进行解析.</span><br><span class="line">  private ResultMapping buildResultMappingFromContext(XNode context, Class&lt;?&gt; resultType, List&lt;ResultFlag&gt; flags) &#123;</span><br><span class="line">    String property;</span><br><span class="line">    if (flags.contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">      property = context.getStringAttribute(&quot;name&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      property = context.getStringAttribute(&quot;property&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    String column = context.getStringAttribute(&quot;column&quot;);</span><br><span class="line">    String javaType = context.getStringAttribute(&quot;javaType&quot;);</span><br><span class="line">    String jdbcType = context.getStringAttribute(&quot;jdbcType&quot;);</span><br><span class="line">    String nestedSelect = context.getStringAttribute(&quot;select&quot;);</span><br><span class="line">    String nestedResultMap = context.getStringAttribute(&quot;resultMap&quot;, () -&gt;</span><br><span class="line">      processNestedResultMappings(context, Collections.emptyList(), resultType));</span><br><span class="line">    String notNullColumn = context.getStringAttribute(&quot;notNullColumn&quot;);</span><br><span class="line">    String columnPrefix = context.getStringAttribute(&quot;columnPrefix&quot;);</span><br><span class="line">    String typeHandler = context.getStringAttribute(&quot;typeHandler&quot;);</span><br><span class="line">    String resultSet = context.getStringAttribute(&quot;resultSet&quot;);</span><br><span class="line">    String foreignColumn = context.getStringAttribute(&quot;foreignColumn&quot;);</span><br><span class="line">    boolean lazy = &quot;lazy&quot;.equals(context.getStringAttribute(&quot;fetchType&quot;, configuration.isLazyLoadingEnabled() ? &quot;lazy&quot; : &quot;eager&quot;));</span><br><span class="line">      </span><br><span class="line">// 获取 javaType , typeHandler , jdbcType 等对象.      </span><br><span class="line">    Class&lt;?&gt; javaTypeClass = resolveClass(javaType);</span><br><span class="line">    Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerClass = resolveClass(typeHandler);</span><br><span class="line">    JdbcType jdbcTypeEnum = resolveJdbcType(jdbcType);</span><br><span class="line">// org.apache.ibatis.builder.MapperBuilderAssistant#buildResultMapping(java.lang.Class&lt;?&gt;, java.lang.String, java.lang.String, java.lang.Class&lt;?&gt;, org.apache.ibatis.type.JdbcType, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.Class&lt;? extends org.apache.ibatis.type.TypeHandler&lt;?&gt;&gt;, java.util.List&lt;org.apache.ibatis.mapping.ResultFlag&gt;, java.lang.String, java.lang.String, boolean)</span><br><span class="line">// 可以看到这里传递进来的参数还是很多的.</span><br><span class="line">// 最后返回 ResultMapping 对象,也就是说这么多参数&amp;buildResultMapping方法中的参数,</span><br><span class="line">//都设置到该对象中来了.     </span><br><span class="line">    return builderAssistant.buildResultMapping(resultType, property, column, javaTypeClass, jdbcTypeEnum, nestedSelect, nestedResultMap, notNullColumn, columnPrefix, typeHandlerClass, flags, resultSet, foreignColumn, lazy);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>SqlElement 方法</strong></p><p>该方法可以很明显的感受到是对 标签进行解析的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void sqlElement(List&lt;XNode&gt; list) &#123;</span><br><span class="line"> // configuration 获取出来 dataBaseId是null,跳过此方法  </span><br><span class="line">  if (configuration.getDatabaseId() != null) &#123;</span><br><span class="line">    sqlElement(list, configuration.getDatabaseId());</span><br><span class="line">  &#125;</span><br><span class="line">//    </span><br><span class="line">  sqlElement(list, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 有点好奇写代码风格:  sqlElement(list,configuration.getDatabaseId());</span><br><span class="line">------------------------</span><br><span class="line"></span><br><span class="line">//  sqlElement 方法</span><br><span class="line">  private void sqlElement(List&lt;XNode&gt; list, String requiredDatabaseId) &#123;</span><br><span class="line">    for (XNode context : list) &#123;</span><br><span class="line">        </span><br><span class="line"> // 获取 databaseId 和 id 这二个属性的值.       </span><br><span class="line">      String databaseId = context.getStringAttribute(&quot;databaseId&quot;);</span><br><span class="line">      String id = context.getStringAttribute(&quot;id&quot;);</span><br><span class="line"> //  org.apache.ibatis.builder.MapperBuilderAssistant#applyCurrentNamespace   </span><br><span class="line"> // 该方法最后返回的id的值是: namespace + id       </span><br><span class="line">      id = builderAssistant.applyCurrentNamespace(id, false);</span><br><span class="line">//sqlFragments 不包含该id就返回true,也就说该Map是确定是否已经解析过了的.         </span><br><span class="line">      if (databaseIdMatchesCurrent(id, databaseId, requiredDatabaseId)) &#123;</span><br><span class="line">// 添加到 org.apache.ibatis.builder.xml.XMLMapperBuilder#sqlFragments 中来.          </span><br><span class="line">        sqlFragments.put(id, context);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后 解析后的值,是使用 namespace + id 存放在 org.apache.ibatis.builder.xml.XMLMapperBuilder#sqlFragments 的属性中的.</p><p><strong>buildStatementFromContext() 方法 :</strong></p><p>这里是对 select &#x2F; insert &#x2F; update &#x2F; delete 标签进行解析.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 可以看到 databaseId 的获取与 sql 标签是一样的操作</span><br><span class="line">private void buildStatementFromContext(List&lt;XNode&gt; list) &#123;</span><br><span class="line">  if (configuration.getDatabaseId() != null) &#123;</span><br><span class="line">    buildStatementFromContext(list, configuration.getDatabaseId());</span><br><span class="line">  &#125;</span><br><span class="line">  buildStatementFromContext(list, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 所以我们可以跟进到这个方法来.</span><br><span class="line">  private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId) &#123;</span><br><span class="line">    for (XNode context : list) &#123;</span><br><span class="line">// 先 new 了一个 XMLStatementBuilder 对象, 紧接着就调用该对象的 解析 方法.        </span><br><span class="line">      final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);</span><br><span class="line">      try &#123;</span><br><span class="line">        statementParser.parseStatementNode();</span><br><span class="line">      &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">        configuration.addIncompleteStatement(statementParser);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 解析方法</span><br><span class="line">  public void parseStatementNode() &#123;</span><br><span class="line">    String id = context.getStringAttribute(&quot;id&quot;);</span><br><span class="line">    String databaseId = context.getStringAttribute(&quot;databaseId&quot;);</span><br><span class="line">// 用 namespace + id 组合为 id</span><br><span class="line">// org.apache.ibatis.session.Configuration#mappedStatements</span><br><span class="line">// 接着就是判断在 mappedStatements 中是不是有该id,如果不存在就返回ture,</span><br><span class="line">// 存在就返回false,这里也就会直接return出去,也就是不会往后面执行了.      </span><br><span class="line">    if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">// 获取标签名字,  select / insert/ update /delete.</span><br><span class="line">    String nodeName = context.getNode().getNodeName();</span><br><span class="line">// 转化为大写的 SELECT      </span><br><span class="line">    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">    boolean isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">// 是否刷新 cache,也就是select是不刷新的,那么其他的就应该是要刷新的.      </span><br><span class="line">    boolean flushCache = context.getBooleanAttribute(&quot;flushCache&quot;, !isSelect);</span><br><span class="line">// 使用使用 cache,这里应该是一级缓存，默认开启的.      </span><br><span class="line">    boolean useCache = context.getBooleanAttribute(&quot;useCache&quot;, isSelect);</span><br><span class="line">// 结果排序, 如果没有配置的话,默认就是false.      </span><br><span class="line">    boolean resultOrdered = context.getBooleanAttribute(&quot;resultOrdered&quot;, false);</span><br><span class="line"></span><br><span class="line">    // Include Fragments before parsing</span><br><span class="line">// 创建了一个 XMLIncludeTransformer 对象,该对象应该是进行转化的.      </span><br><span class="line">    XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line"> //  TODO ? 该方法有待更新     </span><br><span class="line">    includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">//获取 parameterType 属性,如果有的话,也会获取出该属性对应的 Class.    </span><br><span class="line">    String parameterType = context.getStringAttribute(&quot;parameterType&quot;);</span><br><span class="line">    Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line"></span><br><span class="line">// lang : null,这里是没有设置的.      </span><br><span class="line">    String lang = context.getStringAttribute(&quot;lang&quot;);</span><br><span class="line">    LanguageDriver langDriver = getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">    // Parse selectKey after includes and remove them.</span><br><span class="line">// 这里对是否有 selectKey 进行处理.我们这里目前没有使用 selectKey</span><br><span class="line">    processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"></span><br><span class="line">    // Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed)</span><br><span class="line">    KeyGenerator keyGenerator;</span><br><span class="line"> // selectBlog!selectKey     </span><br><span class="line">    String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">// 这里拼接上 namespace :  com.iyang.mybatis.mapper.BlogMapper.selectBlog!selectKey      </span><br><span class="line">    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, true);</span><br><span class="line"></span><br><span class="line">// 这里是判断是否有 主键自动生成. 这里是查询语句,应该是没有的. </span><br><span class="line">    if (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">      keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      keyGenerator = context.getBooleanAttribute(&quot;useGeneratedKeys&quot;,</span><br><span class="line">          configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">          ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 创建一个 XMLScriptBuilder 对象,使用该对象的parseScriptNode方法来解析</span><br><span class="line">// org.apache.ibatis.scripting.xmltags.XMLScriptBuilder#parseScriptNode</span><br><span class="line">// 获取出sql, 有个 isDynamic 参数,来判断是不是动态sql语句.</span><br><span class="line">// 这里不是动态sql,最后new了一个RawSqlSource.</span><br><span class="line">// org.apache.ibatis.builder.SqlSourceBuilder#parse,我们的#&#123;id&#125; 替换成 ? 就是在</span><br><span class="line">// 这里进行替换的.</span><br><span class="line">// 如果是动态 sql 的话,就会创建出 DynamicSqlSource 该对象来.</span><br><span class="line">// 可以看到 SqlSource 下面是有 四个实现类的.</span><br><span class="line">// 这里返回的 SqlSource里面有sql语句的,和返回类型的.      </span><br><span class="line">    SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line"> </span><br><span class="line">// 获取属性.      </span><br><span class="line">    StatementType statementType = StatementType.valueOf(context.getStringAttribute(&quot;statementType&quot;, StatementType.PREPARED.toString()));</span><br><span class="line">    Integer fetchSize = context.getIntAttribute(&quot;fetchSize&quot;);</span><br><span class="line">    Integer timeout = context.getIntAttribute(&quot;timeout&quot;);</span><br><span class="line">    String parameterMap = context.getStringAttribute(&quot;parameterMap&quot;);</span><br><span class="line">// 获取返回类型. 获取出来的 resultTypeClass 是 class com.iyang.mybatis.pojo.TbBlog      </span><br><span class="line">    String resultType = context.getStringAttribute(&quot;resultType&quot;);</span><br><span class="line">    Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">    String resultMap = context.getStringAttribute(&quot;resultMap&quot;);      </span><br><span class="line">    String resultSetType = context.getStringAttribute(&quot;resultSetType&quot;);</span><br><span class="line">    ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);</span><br><span class="line">    if (resultSetTypeEnum == null) &#123;</span><br><span class="line">      resultSetTypeEnum = configuration.getDefaultResultSetType();</span><br><span class="line">    &#125;</span><br><span class="line">// 获取属性的值      </span><br><span class="line">    String keyProperty = context.getStringAttribute(&quot;keyProperty&quot;);</span><br><span class="line">    String keyColumn = context.getStringAttribute(&quot;keyColumn&quot;);</span><br><span class="line">    String resultSets = context.getStringAttribute(&quot;resultSets&quot;);</span><br><span class="line"></span><br><span class="line">// 创建一个 MappedStatement.Builder 对象出来.</span><br><span class="line">// 再通过 builder 构建出一个 MappedStatement 对象来.</span><br><span class="line">// 最后放入到 org.apache.ibatis.session.Configuration#mappedStatements 中来.      </span><br><span class="line">    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">        resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void processSelectKeyNodes(String id, Class&lt;?&gt; parameterTypeClass, LanguageDriver langDriver) &#123;</span><br><span class="line">    List&lt;XNode&gt; selectKeyNodes = context.evalNodes(&quot;selectKey&quot;);</span><br><span class="line">    if (configuration.getDatabaseId() != null) &#123;</span><br><span class="line">      parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, configuration.getDatabaseId());</span><br><span class="line">    &#125;</span><br><span class="line">    parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, null);</span><br><span class="line">    removeSelectKeyNodes(selectKeyNodes);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总结下 MyBatis 解析 Mapper的xml 文件流程。 可以感受到,对于Mybatis处理Mapper,对其字段属性都是挨个解析的,还是下了很大的功夫.</p><p>先是有一个集合来控制是否已经解析过了,算是一种是否解析的开关配置. 可以看到其先后的解析顺序,</p><p>namespace –&gt; cache-ref –&gt; cache —&gt; mapper&#x2F;parameterMap —&gt; mapper&#x2F;resultMap —&gt; mapper&#x2F;sql —&gt; select&#x2F;insert&#x2F;update&#x2F;detele.</p><p>当解析这些标签的时候, 又会对标签里面的属性进行解析. 这里,主要看下我们平常使用到最多的标签, MyBatis 对这些标签解析了后,其后有是怎么利用的呢？可以看到目前MyBatis是存放在一些configuration等类信息里面,那么等到真正去查询sql语句的时候, MyBatis 又是怎么用上的呢？ 这里目前只讲了如何解析.</p><p>解析完了，没异常，那就是解析都ok了，剩下的就是看当 MyBatis 去查询的时候, 是怎么利用上这些资源的呢？所以看接下来的更新.</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/11/04/mybatis/mybatis%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E9%98%85%E8%AF%BB/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/04/mybatis/mybatis%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E9%98%85%E8%AF%BB/" class="post-title-link" itemprop="url">mybatis本地缓存阅读</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-04 00:28:33" itemprop="dateCreated datePublished" datetime="2021-11-04T00:28:33+08:00">2021-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">java框架</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java%E6%A1%86%E6%9E%B6/mybatis/" itemprop="url" rel="index"><span itemprop="name">mybatis</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>12k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>11 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h4 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h4><h4 id="缓存这个知识点在许多地方都有的，利用到好的话，对系统的很多地方查询是有很大的提升的-可以看到-MyBatis-也是有-cache-的，那MyBatis-是怎么利用这个缓存的呢？-在-INSERT-x2F-UPDATE-x2F-DELETE-x2F-SELECT中-是不是只有SELECT的时候用到了缓存，如果是-INSERT-x2F-UPDATE-x2F-DELETE-是否会对缓存有影响？"><a href="#缓存这个知识点在许多地方都有的，利用到好的话，对系统的很多地方查询是有很大的提升的-可以看到-MyBatis-也是有-cache-的，那MyBatis-是怎么利用这个缓存的呢？-在-INSERT-x2F-UPDATE-x2F-DELETE-x2F-SELECT中-是不是只有SELECT的时候用到了缓存，如果是-INSERT-x2F-UPDATE-x2F-DELETE-是否会对缓存有影响？" class="headerlink" title="缓存这个知识点在许多地方都有的，利用到好的话，对系统的很多地方查询是有很大的提升的. 可以看到,MyBatis 也是有 cache 的，那MyBatis 是怎么利用这个缓存的呢？ 在 INSERT&#x2F;UPDATE&#x2F;DELETE&#x2F;SELECT中,是不是只有SELECT的时候用到了缓存，如果是 INSERT&#x2F;UPDATE&#x2F;DELETE 是否会对缓存有影响？"></a>缓存这个知识点在许多地方都有的，利用到好的话，对系统的很多地方查询是有很大的提升的. 可以看到,MyBatis 也是有 cache 的，那MyBatis 是怎么利用这个缓存的呢？ 在 INSERT&#x2F;UPDATE&#x2F;DELETE&#x2F;SELECT中,是不是只有SELECT的时候用到了缓存，如果是 INSERT&#x2F;UPDATE&#x2F;DELETE 是否会对缓存有影响？</h4><p>可以看结果来分析，然后跟进源码来仔细分析.</p><p>MyBatis 是分为 一级缓存 和 二级缓存的. 那么，我们就先从一级缓存开始.</p><h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><p>案例代码 :</p><p>这里我们是打印的查询sql的语句，再第二次再查询的时候，是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">InputStream mybatisInputStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line"></span><br><span class="line">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mybatisInputStream);</span><br><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">BlogMapper blogMapper = session.getMapper(BlogMapper.class);</span><br><span class="line">TbBlog tbBlog = blogMapper.selectBlog(1);</span><br><span class="line">System.out.println(blogMapper.selectBlog(1));</span><br><span class="line">System.out.println(tbBlog);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 结果可以看到,第二次并没有再打印出 sql 语句来.</span><br><span class="line">==&gt;  Preparing: select * from tb_blog where id = ? </span><br><span class="line">==&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;==    Columns: id, name</span><br><span class="line">&lt;==        Row: 1, 6565</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">TbBlog&#123;id=1, name=&#x27;6565&#x27;&#125;</span><br><span class="line">TbBlog&#123;id=1, name=&#x27;6565&#x27;&#125;</span><br></pre></td></tr></table></figure><p>案例二 : 我们再第二次查询之前 加入 一个add 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">InputStream mybatisInputStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line"></span><br><span class="line">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mybatisInputStream);</span><br><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">BlogMapper blogMapper = session.getMapper(BlogMapper.class);</span><br><span class="line">TbBlog tbBlog = blogMapper.selectBlog(1);</span><br><span class="line"></span><br><span class="line">System.out.println(blogMapper.addBlog(&quot;GavinYang&quot;));</span><br><span class="line">System.out.println(blogMapper.selectBlog(1));</span><br><span class="line">System.out.println(tbBlog);</span><br><span class="line"></span><br><span class="line">// 看结果,可以看到当中间穿插一个 insert 的sql语句,那么在第二次查询的时候,就会执行sql语句.</span><br><span class="line">// 那么也就说，这个时候缓存是失效了.</span><br><span class="line">==&gt;  Preparing: select * from tb_blog where id = ? </span><br><span class="line">==&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;==    Columns: id, name</span><br><span class="line">&lt;==        Row: 1, 6565</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">==&gt;  Preparing: insert into tb_blog (name) values(?) </span><br><span class="line">==&gt; Parameters: GavinYang(String)</span><br><span class="line">&lt;==    Updates: 1</span><br><span class="line">1</span><br><span class="line">==&gt;  Preparing: select * from tb_blog where id = ? </span><br><span class="line">==&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;==    Columns: id, name</span><br><span class="line">&lt;==        Row: 1, 6565</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">TbBlog&#123;id=1, name=&#x27;6565&#x27;&#125;</span><br><span class="line">TbBlog&#123;id=1, name=&#x27;6565&#x27;&#125;</span><br></pre></td></tr></table></figure><p>案例三 : 使用二个 SqlSession 案例</p><p>可以很明显的看到 , 在第二次的时候还出现了脏数据.</p><p>这里也可以看到一级缓存是只在 SqlSession 中存在的,也就是数据库会话内部共享的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">InputStream mybatisInputStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mybatisInputStream);</span><br><span class="line"></span><br><span class="line">SqlSession openSession1 = sqlSessionFactory.openSession();</span><br><span class="line">SqlSession openSession2 = sqlSessionFactory.openSession();</span><br><span class="line">BlogMapper blogMapper1 = openSession1.getMapper(BlogMapper.class);</span><br><span class="line">BlogMapper blogMapper2 = openSession2.getMapper(BlogMapper.class);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;blogMapper1 读取数据 &quot; + blogMapper1.selectBlog(1));</span><br><span class="line">System.out.println(&quot;blogMapper2 读取数据&quot; + blogMapper2.selectBlog(1));</span><br><span class="line"></span><br><span class="line">System.out.println(blogMapper1.updateHashCode(&quot;PeterWong&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;blogMapper1 读取数据 &quot; + blogMapper1.selectBlog(1));</span><br><span class="line">System.out.println(&quot;blogMapper2 读取数据&quot; + blogMapper2.selectBlog(1));</span><br><span class="line"></span><br><span class="line">// 然后我们可以看到 log 打印出来的内容</span><br><span class="line">==&gt;  Preparing: select * from tb_blog where id = ? </span><br><span class="line">==&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;==    Columns: id, name</span><br><span class="line">&lt;==        Row: 1, 6565</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">blogMapper1 读取数据 TbBlog&#123;id=1, name=&#x27;6565&#x27;&#125;</span><br><span class="line">Created connection 433287555.</span><br><span class="line">Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@19d37183]</span><br><span class="line">==&gt;  Preparing: select * from tb_blog where id = ? </span><br><span class="line">==&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;==    Columns: id, name</span><br><span class="line">&lt;==        Row: 1, 6565</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">blogMapper2 读取数据TbBlog&#123;id=1, name=&#x27;6565&#x27;&#125;</span><br><span class="line">==&gt;  Preparing: update tb_blog set name = ? where id = 1; </span><br><span class="line">==&gt; Parameters: PeterWong(String)</span><br><span class="line">&lt;==    Updates: 1</span><br><span class="line">1</span><br><span class="line">==&gt;  Preparing: select * from tb_blog where id = ? </span><br><span class="line">==&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;==    Columns: id, name</span><br><span class="line">&lt;==        Row: 1, PeterWong</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">blogMapper1 读取数据 TbBlog&#123;id=1, name=&#x27;PeterWong&#x27;&#125;</span><br><span class="line">blogMapper2 读取数据TbBlog&#123;id=1, name=&#x27;6565&#x27;&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们说了三面的这三种情况, 具体的执行流程可以我们可以现在 案例一里面对第二次 query 进行 debug 分析操作. 当我们debug到 org.apache.ibatis.executor.BaseExecutor#query(org.apache.ibatis.mapping.MappedStatement, java.lang.Object, org.apache.ibatis.session.RowBounds, org.apache.ibatis.session.ResultHandler, org.apache.ibatis.cache.CacheKey, org.apache.ibatis.mapping.BoundSql) 的时候，可以看到 org.apache.ibatis.executor.BaseExecutor#localCache 只有一个 缓存的值的 ， 根据 getObject 方法可以跟进到 org.apache.ibatis.cache.impl.PerpetualCache#cache 中来,</p><p>传入进来的 key 值是 : -1896651191:1062027004:com.iyang.mybatis.mapper.BlogMapper.selectBlog:0:2147483647:select * from tb_blog where id &#x3D; ?:1:development 然后从 cache 中获取出值来, 所以这里就没有走 query 的查询语句.</p><p>这是命中缓存的情况.</p><p>下面我们来看下, 在第二次 query 之前如果执行了一个 add 方法，为什么就命中不了了呢？</p><p>这里可以大致猜测下，在执行完 add 方法后，是不是给 cache 给清除掉了，然后再去查询的时候，就查询不到了.</p><p>于是我们在 add 方法上进行 debug 查看下 :</p><p>最后我们 debug 跟进到这里 : org.apache.ibatis.executor.BaseExecutor#clearLocalCache 就可以发现</p><p>这里是有二个 clear 方法，也就是清除方法.</p><p>localCache.clear() —-&gt; org.apache.ibatis.cache.impl.PerpetualCache#clear 对应的就是这里的清楚方法，直接调用 HashMap 的clear 方法进行清除.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localCache.clear();</span><br><span class="line">localOutputParameterCache.clear();</span><br></pre></td></tr></table></figure><p>所以这里可以看出在第二次调用 query 之前，如果是有 insert&#x2F;update&#x2F;delete 等方法的话，就会去重置这二个地方的缓存的.</p><p>MyBatis 的一级缓存的是跟随 SqlSession 的，这里是可以根据简单的案例效果看出来的.</p><p>一级缓存只是使用了一个 HashMap , 最后清除缓存的时候，也是调用 HashMap 的clear 方法</p><p>最后从案例三可以看出来，当多个 SqlSession 的时候，由于各自有存有各自的缓存，所以是很容易引起脏数据的, 将缓存级别设置为 Statement.</p><h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><p>可以看到一级缓存的话，是局限于 SqlSession . 如果要多个 sqlSession 之间共享缓存的话，就需要开启二级缓存. 开启的话,我们在 MyBatis 配置文件中加上:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 开启二级缓存 --&gt;</span><br><span class="line">    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure><p><strong>案例一 : 是否提交事务</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    InputStream mybatisInputStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mybatisInputStream);</span><br><span class="line">    SqlSession sqlSession1 = sqlSessionFactory.openSession(true);</span><br><span class="line">    SqlSession sqlSession2 = sqlSessionFactory.openSession(true);</span><br><span class="line"></span><br><span class="line">    BlogMapper blogMapper1 = sqlSession1.getMapper(BlogMapper.class);</span><br><span class="line">    BlogMapper blogMapper2 = sqlSession2.getMapper(BlogMapper.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;blogMapper1 获取数据&quot; + blogMapper1.selectBlog(1));</span><br><span class="line">    </span><br><span class="line">    // sqlSession1.commit();</span><br><span class="line">    </span><br><span class="line">    System.out.println(&quot;blogMapper2 获取数据&quot; + blogMapper2.selectBlog(1));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//   ----------------   true结果   -----------------------</span><br><span class="line"></span><br><span class="line">Created connection 492079624.</span><br><span class="line">==&gt;  Preparing: select * from tb_blog where id = ? </span><br><span class="line">==&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;==    Columns: id, name</span><br><span class="line">&lt;==        Row: 1, 6565</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">blogMapper1 获取数据TbBlog&#123;id=1, name=&#x27;6565&#x27;&#125;</span><br><span class="line">Opening JDBC Connection</span><br><span class="line">    </span><br><span class="line">Created connection 433287555.</span><br><span class="line">==&gt;  Preparing: select * from tb_blog where id = ? </span><br><span class="line">==&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;==    Columns: id, name</span><br><span class="line">&lt;==        Row: 1, 6565</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">blogMapper2 获取数据TbBlog&#123;id=1, name=&#x27;6565&#x27;&#125;    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">// ------------   加上commit()方法结果   ---------------</span><br><span class="line"></span><br><span class="line">Created connection 630074945.</span><br><span class="line">==&gt;  Preparing: select * from tb_blog where id = ? </span><br><span class="line">==&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;==    Columns: id, name</span><br><span class="line">&lt;==        Row: 1, 6565</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">blogMapper1 获取数据TbBlog&#123;id=1, name=&#x27;6565&#x27;&#125;</span><br><span class="line">Cache Hit Ratio [com.iyang.mybatis.mapper.BlogMapper]: 0.5</span><br><span class="line">blogMapper2 获取数据TbBlog&#123;id=1, name=&#x27;6565&#x27;&#125;</span><br></pre></td></tr></table></figure><p>从这里看, 是否提交事务可以看出来，是会影响二级缓存的.</p><p><strong>案例二 : 中间穿插更新语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)  throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    InputStream mybatisInputStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mybatisInputStream);</span><br><span class="line">    SqlSession sqlSession1 = sqlSessionFactory.openSession(false);</span><br><span class="line">    SqlSession sqlSession2 = sqlSessionFactory.openSession(false);</span><br><span class="line">    SqlSession sqlSession3 = sqlSessionFactory.openSession(false);</span><br><span class="line"></span><br><span class="line">    BlogMapper blogMapper1 = sqlSession1.getMapper(BlogMapper.class);</span><br><span class="line">    BlogMapper blogMapper2 = sqlSession2.getMapper(BlogMapper.class);</span><br><span class="line">    BlogMapper blogMapper3 = sqlSession3.getMapper(BlogMapper.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot; blogMapper1 查询出来的数据 : &quot; + blogMapper1.selectBlog(1));</span><br><span class="line">    sqlSession1.commit();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot; blogMapper2 查询出来的结果 : &quot; + blogMapper2.selectBlog(1));</span><br><span class="line"></span><br><span class="line">    System.out.println(blogMapper3.updateHashCode(&quot;GavinYang&quot;));</span><br><span class="line">    sqlSession3.commit();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot; blogMapper2 查询出来的结果 : &quot; + blogMapper2.selectBlog(1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  ------------------  打印结果 ------</span><br><span class="line"></span><br><span class="line">Created connection 630074945.</span><br><span class="line">Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@258e2e41]</span><br><span class="line">==&gt;  Preparing: select * from tb_blog where id = ? </span><br><span class="line">==&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;==    Columns: id, name</span><br><span class="line">&lt;==        Row: 1, 6565</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line"> blogMapper1 查询出来的数据 : TbBlog&#123;id=1, name=&#x27;6565&#x27;&#125;</span><br><span class="line">Cache Hit Ratio [com.iyang.mybatis.mapper.BlogMapper]: 0.5</span><br><span class="line"> blogMapper2 查询出来的结果 : TbBlog&#123;id=1, name=&#x27;6565&#x27;&#125;</span><br><span class="line"></span><br><span class="line">Created connection 603443293.</span><br><span class="line">Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@23f7d05d]</span><br><span class="line">==&gt;  Preparing: update tb_blog set name = ? where id = 1; </span><br><span class="line">==&gt; Parameters: GavinYang(String)</span><br><span class="line">&lt;==    Updates: 1</span><br><span class="line">1</span><br><span class="line">Committing JDBC Connection [com.mysql.jdbc.JDBC4Connection@23f7d05d]</span><br><span class="line">Cache Hit Ratio [com.iyang.mybatis.mapper.BlogMapper]: 0.3333333333333333</span><br><span class="line">Opening JDBC Connection</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">Created connection 707976812.</span><br><span class="line">Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@2a32de6c]</span><br><span class="line">==&gt;  Preparing: select * from tb_blog where id = ? </span><br><span class="line">==&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;==    Columns: id, name</span><br><span class="line">&lt;==        Row: 1, GavinYang</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line"> blogMapper2 查询出来的结果 : TbBlog&#123;id=1, name=&#x27;GavinYang&#x27;&#125;</span><br></pre></td></tr></table></figure><p>这里是可以看到在更新之后并且 commit 了事务之后，后面紧跟的 sql 是去查询 数据库了的. 所以这里是可以看出来，update等操作是会去 清空对应的缓存的。</p><p>这里我们根据 案例一 的情况来分析，在开启了 二级缓存 的时候，是从哪里获取出来的数据的呢？</p><p>debug 跟进来 : org.apache.ibatis.executor.CachingExecutor#query(org.apache.ibatis.mapping.MappedStatement, java.lang.Object, org.apache.ibatis.session.RowBounds, org.apache.ibatis.session.ResultHandler, org.apache.ibatis.cache.CacheKey, org.apache.ibatis.mapping.BoundSql)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span><br><span class="line">    throws SQLException &#123;</span><br><span class="line">  Cache cache = ms.getCache();</span><br><span class="line">  if (cache != null) &#123;</span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    if (ms.isUseCache() &amp;&amp; resultHandler == null) &#123;</span><br><span class="line">      ensureNoOutParams(ms, boundSql);</span><br><span class="line">      @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">// debug 到这里，可以看到,就已经返回了我们需要的数据.        </span><br><span class="line">      List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">      if (list == null) &#123;</span><br><span class="line">        list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        tcm.putObject(cache, key, list); // issue #578 and #116</span><br><span class="line">      &#125;</span><br><span class="line">      return list;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>org.apache.ibatis.executor.CachingExecutor#tcm 调用这个对象的 getObject 方法获取到了我们需要的值, 跟进来又从 org.apache.ibatis.cache.decorators.TransactionalCache 的 getObject 获取出我们的值, 最后从 org.apache.ibatis.cache.decorators.TransactionalCache#delegate 获取出值, 返回回来的.</p><p>org.apache.ibatis.cache.decorators.TransactionalCache#getObject</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object getObject(Object key) &#123;</span><br><span class="line">  // issue #116</span><br><span class="line">// 从缓存中获取出值.    </span><br><span class="line">  Object object = delegate.getObject(key);</span><br><span class="line">  if (object == null) &#123;</span><br><span class="line">// 如果获取出来是null,也就是缓存中没有的话,org.apache.ibatis.cache.decorators.TransactionalCache#entriesMissedInCache 就添加到这个集合中来.      </span><br><span class="line">    entriesMissedInCache.add(key);</span><br><span class="line">  &#125;</span><br><span class="line">  // issue #146</span><br><span class="line">// commit 后需要 clear 的话，就会返回 null.</span><br><span class="line">// 这里想下这个变量会不会和我门案例二中的 update 操作有关系呢？</span><br><span class="line">// 这里再 update后再 debug 发现,  delegate 中获取出来的是 null ,也就是确实是获取不到缓存了</span><br><span class="line">// 和这个参数没关系.    </span><br><span class="line">  if (clearOnCommit) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return object;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyBatis 二级缓存不适应于配置文件中存在多表查询的情况. 一般我们是单表的 cache, 由于 mybatis 的二级缓存是基于 namespace 的, 多表查询语句所在的 namespace 无法感应到其他的 namespace 中的语句对多表中设计修改，就会引发脏数据. 这个时候，可以采用 cache-ref 来做处理，但是这样的话,缓存的颗粒度就变粗了.</p><p>执行流程 : 如果开启了二级缓存的话， MyBatis 会先走二级缓存，如果二级缓存没有的话，就会去一级缓存看看，如果都没有的话，就去查询数据库.</p><p>二级缓存 : 用 org.apache.ibatis.executor.CachingExecutor 装饰了 org.apache.ibatis.executor.BaseExecutor 的子类, 委托具体职责给 delegate 之前，实现了二级缓存的查询和写入功能.</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后看 一级缓存和二级缓存，都是利用的 HashMap 这种来做到本地缓存， 只是二级缓存的作用范围比起一级缓存的话，是要大的，并且也利用了一些 装饰者 等设计模式来设计二级缓存的.</p><p>如果是部署的分布式项目的话，那么还是 得切换到 redis 这种缓存来了， 本地利用 HashMap 这种缓存满足不了的.</p><p>文献参考地址 : <a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/01/19/mybatis-cache.html">https://tech.meituan.com/2018/01/19/mybatis-cache.html</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/11/04/mybatis/mybatis%E4%B8%ADconfig-xml%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/04/mybatis/mybatis%E4%B8%ADconfig-xml%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/" class="post-title-link" itemprop="url">mybatis中config-xml代码阅读</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-04 00:28:20" itemprop="dateCreated datePublished" datetime="2021-11-04T00:28:20+08:00">2021-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">java框架</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java%E6%A1%86%E6%9E%B6/mybatis/" itemprop="url" rel="index"><span itemprop="name">mybatis</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>19k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>17 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h4 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h4><p>对于配置文件的解析, 还是相对比较好理解的, 就是读取配置文件, 然后在代码需要的地方给使用到.</p><p>这里,可以扩展下, Spring &#x2F; SpringBoot 等是怎么读取配置文件呢 ? 并且配置文件还是有 xml &#x2F; properties&#x2F;yaml 等格式的 ， 其读取代码是怎么写的 ? 然后基于 阿波罗(携程开源) 的配置中心 , 其实现配置又是怎么实现的呢 ? 然后这里，看了 Mybatis 读取配置文件, 后续再出 Spring 配置文件的时候，如果二者读取配置进行对比, 你个人更倾向使用代码呢 ?</p><p>所以,这里就开启读取 Mybatis 是如何解析配置文件的操作.</p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>这里的配置文件解读,是根据 MyBatis官网来一步一步的解析阅读. 如果有官网没有涉及到的,发现了也会在后续加上去的. 解析多行代码, 才能理解 何为优秀.</p><p><strong>标签一 : properties</strong></p><p>org.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfiguration —&gt; propertiesElement(root.evalNode(“properties”)) 方法中来.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 这里传入进来的 XNode 的值,就是我们写的 properties 标签.</span><br><span class="line">// 可以看到 XNode的属性,name标签的名字,attributes就是key/value属性</span><br><span class="line">// 比如这里: key 就是 resource , value 就是 ./db.properties.</span><br><span class="line">private void propertiesElement(XNode context) throws Exception &#123;</span><br><span class="line">  if (context != null) &#123;</span><br><span class="line">// 这里调用的node.getChildNodes(),如果有点话,会遍历挨个解析,最后封装成为key/value结构.      </span><br><span class="line">    Properties defaults = context.getChildrenAsProperties();</span><br><span class="line">// 获取 resource / url 二者的值.      </span><br><span class="line">    String resource = context.getStringAttribute(&quot;resource&quot;);</span><br><span class="line">    String url = context.getStringAttribute(&quot;url&quot;);</span><br><span class="line">// 如果二者都是null,就会抛出异常来.      </span><br><span class="line">    if (resource != null &amp;&amp; url != null) &#123;</span><br><span class="line">      throw new BuilderException(&quot;The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line"> // 这里先处理resource,再处理url,也就是有可能url会覆盖掉resource的内容.</span><br><span class="line"> // 二者读取的方式不一样,前者是根据 resource开始读,url是根据绝对路径开始读.</span><br><span class="line"> // 最后 defaults 里面放入的全部是 key/value 对应的键值对</span><br><span class="line"> // 也就是db.properties中的 key / value 相对应i起来.     </span><br><span class="line">    if (resource != null) &#123;</span><br><span class="line">      defaults.putAll(Resources.getResourceAsProperties(resource));</span><br><span class="line">    &#125; else if (url != null) &#123;</span><br><span class="line">      defaults.putAll(Resources.getUrlAsProperties(url));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">// 这里看的是 xml 里面是不是直接有 porperties 配置.     </span><br><span class="line">// 如果有的话,就会putAll进去.      </span><br><span class="line">    Properties vars = configuration.getVariables();</span><br><span class="line">    if (vars != null) &#123;</span><br><span class="line">      defaults.putAll(vars);</span><br><span class="line">    &#125;</span><br><span class="line">// 最后吧 defaults,也就是properties给放入到 BaseBuilder 和 Confifuration中去.      </span><br><span class="line">    parser.setVariables(defaults);</span><br><span class="line">    configuration.setVariables(defaults);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line">//  如何让 Properties vars = configuration.getVariables(); 有值呢 ?</span><br><span class="line">//  如果只是单个的 MyBatis 项目的话, 就自己手动new一个properties对象</span><br><span class="line">//  然后key输入自己要覆盖掉的key就可以了</span><br><span class="line">        Properties dbConfigProperties = new Properties();</span><br><span class="line">        dbConfigProperties.setProperty(&quot;jdbc.password&quot;,&quot;GavinYang&quot;);</span><br><span class="line"></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mybatisInputStream,dbConfigProperties);</span><br></pre></td></tr></table></figure><p><strong>标签二 : settings</strong></p><p>这是 MyBatis对 settings 的操作.</p><p>具体的 settings 中每项配置参考官网链接 : <a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/configuration.html#properties">https://mybatis.org/mybatis-3/configuration.html#properties</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 解析 setting ---&gt; 转化为 key /value</span><br><span class="line">Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));</span><br><span class="line">// </span><br><span class="line">loadCustomVfs(settings);</span><br><span class="line">loadCustomLogImpl(settings);</span><br></pre></td></tr></table></figure><p>settingsAsProperties 方法</p><p>可以看到, 该方法就是进行加载,转化为key&#x2F;value键值对类型, 然后对其key检验是否在</p><p>Configuration 中都有 set 方法.</p><p>Notes : 为了验证下, 我们加上一个没有的标签, 可以看到下面的异常. 所以我们看到这种异常的时候，是可以去检查下是不是名字什么有问题.</p><h3 id="Cause-org-apache-ibatis-builder-BuilderException-Error-parsing-SQL-Mapper-Configuration-Cause-org-apache-ibatis-builder-BuilderException-The-setting-nnnnn-is-not-known-Make-sure-you-spelled-it-correctly-case-sensitive"><a href="#Cause-org-apache-ibatis-builder-BuilderException-Error-parsing-SQL-Mapper-Configuration-Cause-org-apache-ibatis-builder-BuilderException-The-setting-nnnnn-is-not-known-Make-sure-you-spelled-it-correctly-case-sensitive" class="headerlink" title="Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: org.apache.ibatis.builder.BuilderException: The setting nnnnn is not known. Make sure you spelled it correctly (case sensitive)."></a>Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: org.apache.ibatis.builder.BuilderException: The setting nnnnn is not known. Make sure you spelled it correctly (case sensitive).</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private Properties settingsAsProperties(XNode context) &#123;</span><br><span class="line">  if (context == null) &#123;</span><br><span class="line">    return new Properties();</span><br><span class="line">  &#125;</span><br><span class="line"> // 对 settings 下的 setting 进行解析 并且 转化为 key / value 操作.   </span><br><span class="line">  Properties props = context.getChildrenAsProperties();</span><br><span class="line">  // Check that all settings are known to the configuration class</span><br><span class="line"> // 对 Configuration 进行校验, 确认上面的 props 中的key 在 Configuration</span><br><span class="line">// 中是都有set 方法的,目测是后面反射需要使用到.    </span><br><span class="line">  MetaClass metaConfig = MetaClass.forClass(Configuration.class, localReflectorFactory);</span><br><span class="line">  for (Object key : props.keySet()) &#123;</span><br><span class="line">    if (!metaConfig.hasSetter(String.valueOf(key))) &#123;</span><br><span class="line">      throw new BuilderException(&quot;The setting &quot; + key + &quot; is not known.  Make sure you spelled it correctly (case sensitive).&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return props;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadCustomVfs(settings) 方法</p><p>该方法,主要就是读取 vfsImpl 对用的value,切割下,然后用 classForName 来获取 class,</p><p>最后赋值到 configuration 中去. 这里算是对 vfs 的一种自定义的扩展,虽然目前还不太清楚vfs具体作用.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void loadCustomVfs(Properties props) throws ClassNotFoundException &#123;</span><br><span class="line">  // 获取 vfsImpl 的 value.  </span><br><span class="line">  String value = props.getProperty(&quot;vfsImpl&quot;);</span><br><span class="line">  if (value != null) &#123;</span><br><span class="line">   // 根据 , 进行切割.   </span><br><span class="line">    String[] clazzes = value.split(&quot;,&quot;);</span><br><span class="line">    for (String clazz : clazzes) &#123;</span><br><span class="line">      if (!clazz.isEmpty()) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        // 反射,获取出 Class , 最后赋值到 configuration 中去.  </span><br><span class="line">        Class&lt;? extends VFS&gt; vfsImpl = (Class&lt;? extends VFS&gt;)Resources.classForName(clazz);</span><br><span class="line">        configuration.setVfsImpl(vfsImpl);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadCustomLogImpl(settings) 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private void loadCustomLogImpl(Properties props) &#123;</span><br><span class="line">  Class&lt;? extends Log&gt; logImpl = resolveClass(props.getProperty(&quot;logImpl&quot;));</span><br><span class="line">  // 将 log set 到 configuration 中去.  </span><br><span class="line">  configuration.setLogImpl(logImpl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------</span><br><span class="line">// resolve 最后如果不是 null 的话,</span><br><span class="line">org.apache.ibatis.type.TypeAliasRegistry#resolveAlias</span><br><span class="line"></span><br><span class="line"> // 就会走到这里,这里可以看先是在 typeAliases(HashMap) 中判断下,如果存在就直接获取</span><br><span class="line">// 如果不存在就用 Resources.ClassForName来操作</span><br><span class="line">// 这里的 HashMap就类似于,记录之前是否已经加载了或者预热.</span><br><span class="line">// 如果是用来做cache的话, 那就应该最后会在 return 之前继续把值给放入进去.    </span><br><span class="line">  public &lt;T&gt; Class&lt;T&gt; resolveAlias(String string) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      if (string == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      // issue #748</span><br><span class="line">      String key = string.toLowerCase(Locale.ENGLISH);</span><br><span class="line">      Class&lt;T&gt; value;</span><br><span class="line">      if (typeAliases.containsKey(key)) &#123;</span><br><span class="line">        value = (Class&lt;T&gt;) typeAliases.get(key);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        value = (Class&lt;T&gt;) Resources.classForName(string);</span><br><span class="line">      &#125;</span><br><span class="line">      return value;</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">      throw new TypeException(&quot;Could not resolve type alias &#x27;&quot; + string + &quot;&#x27;.  Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">// 如果我们在配置文件中没有定义的话,这里默认是null,也就是说不会set进去.    </span><br><span class="line">  public void setLogImpl(Class&lt;? extends Log&gt; logImpl) &#123;</span><br><span class="line">    if (logImpl != null) &#123;</span><br><span class="line">      this.logImpl = logImpl;</span><br><span class="line">      LogFactory.useCustomLogging(this.logImpl);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>标签三 :</strong></p><p>关于别名的配置.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));</span><br><span class="line">private void typeAliasesElement(XNode parent) &#123;</span><br><span class="line">  if (parent != null) &#123;</span><br><span class="line">   // 对 typeAliases 下的子标签进行迭代.</span><br><span class="line">   // 分为是 package 和非 package   </span><br><span class="line">    for (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      if (&quot;package&quot;.equals(child.getName())) &#123;</span><br><span class="line">       // 获取你输入的包   </span><br><span class="line">        String typeAliasPackage = child.getStringAttribute(&quot;name&quot;);</span><br><span class="line">        configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line"> // &lt;typeAlias type=&quot;com.iyang.mybatis.pojo.TbBlog&quot; alias=&quot;TbBlog&quot; /&gt;</span><br><span class="line"> // 这里就是对这种进行解析的         </span><br><span class="line">        String alias = child.getStringAttribute(&quot;alias&quot;);</span><br><span class="line">        String type = child.getStringAttribute(&quot;type&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">          Class&lt;?&gt; clazz = Resources.classForName(type);</span><br><span class="line">   // 如果没写别名,就只传入 clazz.         </span><br><span class="line">          if (alias == null) &#123;</span><br><span class="line">            typeAliasRegistry.registerAlias(clazz);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">   // 写了别名,就别名和clazz一起传入进来.           </span><br><span class="line">            typeAliasRegistry.registerAlias(alias, clazz);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">          throw new BuilderException(&quot;Error registering typeAlias for &#x27;&quot; + alias + &quot;&#x27;. Cause: &quot; + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">// 这里可以看到是根据 packageName 来 register进来的.    </span><br><span class="line">  public void registerAliases(String packageName, Class&lt;?&gt; superType) &#123;</span><br><span class="line">    // new 一个解析器工具类</span><br><span class="line">    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;&gt;();</span><br><span class="line">    // 获取包的path,然后获取该包下的文件,如果文件是.class结尾的话</span><br><span class="line">    // 最后在 ResolverUtil 中matchess是有该包下的全名称.</span><br><span class="line">    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);</span><br><span class="line">    // 这里返回的是上一步说的 matches</span><br><span class="line">    Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; typeSet = resolverUtil.getClasses();</span><br><span class="line">    for (Class&lt;?&gt; type : typeSet) &#123;</span><br><span class="line">      // Ignore inner classes and interfaces (including package-info.java)</span><br><span class="line">      // Skip also inner classes. See issue #6</span><br><span class="line">      // 如果不是接口,不是内部类等条件的话,就走  registerAlias 方法</span><br><span class="line">      if (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp; !type.isMemberClass()) &#123;</span><br><span class="line"> // 先获取类名字,判断该类上有没有 @Alias 注解,如果有注解的话,就用注解的值作为缩写的.</span><br><span class="line"> // 最后判断是不是null,是null就会抛出异常来.最后将上面获取出来的缩写名字,转化为大写.</span><br><span class="line"> // 如果此时 typeAliases 是已经有了该值的话,就会抛出异常来.否则就放入到typeAliases来</span><br><span class="line"> // private final Map&lt;String, Class&lt;?&gt;&gt; typeAliases = new HashMap&lt;&gt;();</span><br><span class="line"> // 可以看到 typeAliases 是一个HashMap,并且其存储的Key/Value还是蛮明显的.         </span><br><span class="line">        registerAlias(type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>标签四</strong></p><p>扩展的 demo 可以参考 MyBatis官网 : <a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/configuration.html">https://mybatis.org/mybatis-3/configuration.html</a></p><p>然后看 MyBatis 是如何将插件给利用上的呢 ?</p><p>首先在 mybatis-config.xml 中配置好我们自己定义的 plugin</p><p>这里以我配置了二个插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;plugin interceptor=&quot;com.iyang.mybatis.plugins.ExamplePlugin&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;GavinYang&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;age&quot; value=&quot;22&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;hobby&quot; value=&quot;lwf&quot;/&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line">    &lt;plugin interceptor=&quot;com.iyang.mybatis.plugins.QuerySqlPlugin&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;GavinYang&quot;/&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; 处理 plugin 的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void pluginElement(XNode parent) throws Exception &#123;</span><br><span class="line">  // 这里传入进来的就是 &lt;plugins&gt;整个标签内容.  </span><br><span class="line">  if (parent != null) &#123;</span><br><span class="line">   // 获取 &lt;plugins&gt; 下的 &lt;plugin&gt; 集合,进行迭代处理.   </span><br><span class="line">    for (XNode child : parent.getChildren()) &#123;</span><br><span class="line">     // 获取插件的 全限定名字.   </span><br><span class="line">      String interceptor = child.getStringAttribute(&quot;interceptor&quot;);</span><br><span class="line">     // 获取我们定义在 plugin 下的 properties.   </span><br><span class="line">      Properties properties = child.getChildrenAsProperties();</span><br><span class="line">// resolveClass是最后注册到typeAliasRegistry来.    </span><br><span class="line">// 实例化,这里就可以看到我们在定义的Plugin中,无参构造函数打印出来的内容了.        </span><br><span class="line">      Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).getDeclaredConstructor().newInstance();</span><br><span class="line">// 将 properties 赋值给  interceptorInstance</span><br><span class="line">// 也就是放入到 interceptorInstance 来.        </span><br><span class="line">      interceptorInstance.setProperties(properties);</span><br><span class="line">// org.apache.ibatis.plugin.InterceptorChain</span><br><span class="line">// 这是是将interceptorInstance添加到InterceptorChain的interceptors中来.        </span><br><span class="line">      configuration.addInterceptor(interceptorInstance);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 MyBatis在加载plugin的时候,是利用了反射来new出一个对象来,并且注册到 typeAliasRegistry 中来. 这里主要是解析 plugin 的配置, 后面在执行sql的时候,都是如何使用到这些 plugin 的呢 ? 肯定是有一个从InterceptorChain中获取interceptors来,然后进行处理.</p><p><strong>标签五 : &lt; objectFactory &gt;</strong></p><p>objectFactory 的处理方式是和 标签四相似的,只是最后在使用场景是有点不同的.</p><p>代码上的操作也是类似的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void objectFactoryElement(XNode context) throws Exception &#123;</span><br><span class="line">  if (context != null) &#123;</span><br><span class="line">    String type = context.getStringAttribute(&quot;type&quot;);</span><br><span class="line">    Properties properties = context.getChildrenAsProperties();</span><br><span class="line">    ObjectFactory factory = (ObjectFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">    factory.setProperties(properties);</span><br><span class="line">    configuration.setObjectFactory(factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>标签五 :</strong></p><p>该标签在 MyBatis 官网是没有demo, 我是根据代码来顺藤摸瓜写的一个.</p><p>参考 : org.apache.ibatis.reflection.wrapper.DefaultObjectWrapperFactory 这个源码,来模仿写的一个.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));</span><br><span class="line">private void objectWrapperFactoryElement(XNode context) throws Exception &#123;</span><br><span class="line">  if (context != null) &#123;</span><br><span class="line">   // 获取 配置文件中的type值   </span><br><span class="line">    String type = context.getStringAttribute(&quot;type&quot;);</span><br><span class="line"> // 先注册到  typeAliasRegistry 来,然后实例化这个类.</span><br><span class="line"> // 我们在自己定义的类中,写一个无参构造函数,就可以看到我们打印的内容了.     </span><br><span class="line">    ObjectWrapperFactory factory = (ObjectWrapperFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">// 最后赋值到 confifuration 中来.      </span><br><span class="line">    configuration.setObjectWrapperFactory(factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>标签六 : &lt; reflectorFactory &gt;</strong></p><p>处理方式和上面类似.</p><p>这里我们自己写一个 com.iyang.mybatis.factory.GavinReflectorFactory 来继承DefaultReflectorFactory,在无参数构造函数中打印下内容, 然后debug跟进.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void reflectorFactoryElement(XNode context) throws Exception &#123;</span><br><span class="line">  if (context != null) &#123;</span><br><span class="line">    String type = context.getStringAttribute(&quot;type&quot;);</span><br><span class="line">    ReflectorFactory factory = (ReflectorFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">    configuration.setReflectorFactory(factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>标签七 :</strong></p><p>environments 标签都是放入一些 db 的配置信息等.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">    &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">        &lt;!-- 事务 --&gt;</span><br><span class="line">        &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;!-- DB 连接配置 --&gt;</span><br><span class="line">        &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;</span><br><span class="line">            &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">            &lt;property name=&quot;username&quot; value = &quot;$&#123;jdbc.username&#125;&quot; /&gt;</span><br><span class="line">            &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line">        &lt;/dataSource&gt;</span><br><span class="line">    &lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br><span class="line">private void environmentsElement(XNode context) throws Exception &#123;</span><br><span class="line">  if (context != null) &#123;</span><br><span class="line">    if (environment == null) &#123;</span><br><span class="line">// 获取 default 对应字段的值         </span><br><span class="line">      environment = context.getStringAttribute(&quot;default&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">// 这里的 getChildren 获取的是 &lt;environments&gt; --&gt; &lt;environment&gt;下的子标签      </span><br><span class="line">    for (XNode child : context.getChildren()) &#123;</span><br><span class="line">      String id = child.getStringAttribute(&quot;id&quot;);</span><br><span class="line">// 确保 id 和  上一步的environment 的值是相同的,就会返回true.      </span><br><span class="line">      if (isSpecifiedEnvironment(id)) &#123;</span><br><span class="line">/**</span><br><span class="line">*  获取出 transactionManager 对应的标签.</span><br><span class="line">*  然后根据 JBDC(配置文件中的值),然后从 typeAliasRegistry中获取出来，</span><br><span class="line">*  调用反射来 实例化 这个对象. </span><br><span class="line">*  最后还是可以配置 properties,会被set到txFactory中去的.</span><br><span class="line">*  但是 JdbcTransactionFactory 好像没有重写 setProperties 方法.</span><br><span class="line">*/          </span><br><span class="line">        TransactionFactory txFactory = transactionManagerElement(child.evalNode(&quot;transactionManager&quot;));</span><br><span class="line">// 先获取  dataSource 字段</span><br><span class="line">/**</span><br><span class="line">*  先获取type的值,然后再获取 properties的标签字段值.</span><br><span class="line">*  根据我们的配置 : org.apache.ibatis.datasource.pooled.PooledDataSourceFactory,应该会获取出这个对象.该对象其内部是有一个,org.apache.ibatis.datasource.pooled.PooledDataSource的,里面有部分默认值的.</span><br><span class="line">*最后将  properties 调用 org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory#setProperties方法,</span><br><span class="line">最后是将 properties 里面的key/value 都设置到 MetaObject metaDataSource = SystemMetaObject.forObject(dataSource);来了.</span><br><span class="line">*/</span><br><span class="line">        DataSourceFactory dsFactory = dataSourceElement(child.evalNode(&quot;dataSource&quot;));</span><br><span class="line">// 从  PooledDataSourceFactory 中获取 datasource 属性.         </span><br><span class="line">        DataSource dataSource = dsFactory.getDataSource();</span><br><span class="line">// 这里采用链式编程,也就是将id/txFactory/dataSource 都给set到 Environment.Builder来了.         </span><br><span class="line">        Environment.Builder environmentBuilder = new Environment.Builder(id)</span><br><span class="line">            .transactionFactory(txFactory)</span><br><span class="line">            .dataSource(dataSource);</span><br><span class="line">  //    environmentBuilder.build() 也就是new 了一个 Environment </span><br><span class="line">  // 最后 赋值到 configuration 中来了.        </span><br><span class="line">        configuration.setEnvironment(environmentBuilder.build());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析 environments ,利用 typeAliasRegistry 中已经注册好了的信息,然后根据名字缩写(比如JDBC)这种,来获取class对象, 用 反射来 new 一波对象出来,真是美滋滋. 接着就是解析 事务&#x2F;JDBC连接配置信息等, 最后将信息保存到 DataSource 中来. 反手再来一波 链式编程 来new对象出来, 最后就是一个 Environment 对象出来,给set 到 configuration 中来.</p><p><strong>标签八</strong></p><p>到这里,可以看到对xml的解析操作. 先解析 标签 的值出来,然后根据值进行分类处理或者根据自己的需求来进行处理.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void typeHandlerElement(XNode parent) &#123;</span><br><span class="line">  if (parent != null) &#123;</span><br><span class="line">    for (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      // 如果子标签是 package   </span><br><span class="line">      if (&quot;package&quot;.equals(child.getName())) &#123;</span><br><span class="line">       // 获取出 name 对应的值.   </span><br><span class="line">        String typeHandlerPackage = child.getStringAttribute(&quot;name&quot;);</span><br><span class="line">      // 注册到   typeHandlerRegistry 中来.  </span><br><span class="line">        typeHandlerRegistry.register(typeHandlerPackage);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line"> // 这里获取出三种值来,   javaType/jdbcType/  handler    </span><br><span class="line">        String javaTypeName = child.getStringAttribute(&quot;javaType&quot;);</span><br><span class="line">        String jdbcTypeName = child.getStringAttribute(&quot;jdbcType&quot;);</span><br><span class="line">        String handlerTypeName = child.getStringAttribute(&quot;handler&quot;);</span><br><span class="line">        Class&lt;?&gt; javaTypeClass = resolveClass(javaTypeName);</span><br><span class="line">        JdbcType jdbcType = resolveJdbcType(jdbcTypeName);</span><br><span class="line">        Class&lt;?&gt; typeHandlerClass = resolveClass(handlerTypeName);</span><br><span class="line">  // 分为  javaTypeClass 是不是 null 的情况       </span><br><span class="line">        if (javaTypeClass != null) &#123;</span><br><span class="line">         // 基于 javaTypeClass 是不是 null的情况,再判断 jdbcType 是不是null  </span><br><span class="line">          if (jdbcType == null) &#123;</span><br><span class="line">            typeHandlerRegistry.register(javaTypeClass, typeHandlerClass);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">// 这是根据   handlerTypeName 注册到 typeHandlerRegistry 中来.           </span><br><span class="line">          typeHandlerRegistry.register(typeHandlerClass);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>标签九 :</strong></p><p>该标签是对我们对应的对象,其sql语句存放的地址. 也就是里面放入的是于mapper接口对应的方法,查询的sql语句.</p><p>接下来看下 MyBatis 是对 mappers 标签的内容进行了说明解析和处理.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">      </span><br><span class="line"> <span class="comment">// getChildren 获取的是 mappers 下的 mapper 标签</span></span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line"><span class="comment">// 如果配置的是 package.        </span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapperPackage</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        configuration.addMappers(mapperPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 获取出    resource/url/class 这三类的值.       </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapperClass</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line"> <span class="comment">// 对 resource 处理         </span></span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="literal">null</span> &amp;&amp; url == <span class="literal">null</span> &amp;&amp; mapperClass == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 将 resource 赋值给 ErrorContext 中  </span></span><br><span class="line">          ErrorContext.instance().resource(resource);</span><br><span class="line">     <span class="comment">// 读取文件.       </span></span><br><span class="line">          <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="comment">// 使用 XMLMapperBuilder 来对解析xml内容.            </span></span><br><span class="line">          <span class="type">XMLMapperBuilder</span> <span class="variable">mapperParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line"><span class="comment">// url 处理            </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="literal">null</span> &amp;&amp; url != <span class="literal">null</span> &amp;&amp; mapperClass == <span class="literal">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(url);</span><br><span class="line">          <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getUrlAsStream(url);</span><br><span class="line">          <span class="type">XMLMapperBuilder</span> <span class="variable">mapperParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line"><span class="comment">// mapperClass 处理            </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="literal">null</span> &amp;&amp; url == <span class="literal">null</span> &amp;&amp; mapperClass != <span class="literal">null</span>) &#123;</span><br><span class="line">          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">          configuration.addMapper(mapperInterface);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------</span><br><span class="line"><span class="comment">// 这里我们跟进 mapperParser.parse() 方法来</span></span><br><span class="line"><span class="comment">// org.apache.ibatis.builder.xml.XMLMapperBuilder</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 判断 configuration 的 loadedResources 是否含有该值,如果不含有的话,就会去解析.  </span></span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line"><span class="comment">// 对mapper 标签进行解析        </span></span><br><span class="line">      configurationElement(parser.evalNode(<span class="string">&quot;/mapper&quot;</span>));</span><br><span class="line">      configuration.addLoadedResource(resource);</span><br><span class="line">      bindMapperForNamespace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parsePendingResultMaps();</span><br><span class="line">    parsePendingCacheRefs();</span><br><span class="line">    parsePendingStatements();</span><br><span class="line">  &#125;    </span><br><span class="line"></span><br><span class="line">-----------------------------------</span><br><span class="line"><span class="comment">//   configurationElement 方法</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">configurationElement</span><span class="params">(XNode context)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// 获取 namespace       </span></span><br><span class="line">      <span class="type">String</span> <span class="variable">namespace</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;namespace&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (namespace == <span class="literal">null</span> || namespace.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Mapper&#x27;s namespace cannot be empty&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//  MapperBuilderAssistant 将 namespace 绑定到该类的参数中来.        </span></span><br><span class="line">      builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 这里的 cache-ref / cache 都是暂时没有配置的.     </span></span><br><span class="line">      cacheRefElement(context.evalNode(<span class="string">&quot;cache-ref&quot;</span>));</span><br><span class="line">      cacheElement(context.evalNode(<span class="string">&quot;cache&quot;</span>));</span><br><span class="line">        </span><br><span class="line"> <span class="comment">//  /mapper/parameterMap 也是暂时没有配置的  </span></span><br><span class="line">      parameterMapElement(context.evalNodes(<span class="string">&quot;/mapper/parameterMap&quot;</span>));</span><br><span class="line">        </span><br><span class="line"><span class="comment">// resultMap 是对对象字段的映射</span></span><br><span class="line"><span class="comment">// mapper/sql 是对一些公用的sql进行抽取</span></span><br><span class="line"><span class="comment">// 二者暂时都没有配置        </span></span><br><span class="line">      resultMapElements(context.evalNodes(<span class="string">&quot;/mapper/resultMap&quot;</span>));</span><br><span class="line">      sqlElement(context.evalNodes(<span class="string">&quot;/mapper/sql&quot;</span>));</span><br><span class="line"><span class="comment">// 获取 select / insert / update / delete 等 标签.        </span></span><br><span class="line">      buildStatementFromContext(context.evalNodes(<span class="string">&quot;select|insert|update|delete&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error parsing Mapper XML. The XML location is &#x27;&quot;</span> + resource + <span class="string">&quot;&#x27;. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 往下跟方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode context : list) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">XMLStatementBuilder</span> <span class="variable">statementParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLStatementBuilder</span>(configuration, builderAssistant, context, requiredDatabaseId);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        statementParser.parseStatementNode();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">        configuration.addIncompleteStatement(statementParser);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/11/04/spring/SpringBoot%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%8E%A5%E5%8F%A3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/04/spring/SpringBoot%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">SpringBoot动态添加接口</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-04 00:17:24" itemprop="dateCreated datePublished" datetime="2021-11-04T00:17:24+08:00">2021-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/springBoot/" itemprop="url" rel="index"><span itemprop="name">springBoot</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>6.4k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>6 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近看了公司的产品,有一个这样的动态,就是根据input输入的内容,进行动态接口的添加.</p><p>比如 我在没有添加之前,访问 <a target="_blank" rel="noopener" href="http://localhost:8080/test">http://localhost:8080/test</a> 该地址是404, 于是通过input的输入创建,就相当于动态添加了一个接口,于是就可以访问了.</p><p>实现的方式有很多种, 具体的想要的效果肯定是需要根据自己的业务角度来.</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>这里是说下个人的实现思路 :</p><ul><li>方案一 : 先定义好类,然后使用反射根据定义的类,创建好一个对象出来,然后将这个对象给注入到Spring容器中来,这里不仅仅是注入进来这么简单,还是需要经过 MVC(也就是Controller等注解的匹配操作)来实现</li><li>方案二 : 基于请求404的拦截来现实. 比如你新添加的接口访问肯定是404,于是我们可以定义一个拦截,然后获取出请求的路径,根据提前定好的一些设置,进行逻辑的处理.</li></ul><p>这里肯定还会有很多好的实现思路,并且基于每个框架都是不一样的,这里更多的是基于 SpringBoot框架来实现这个思路的.</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="基于反射创建bean注入代码实现"><a href="#基于反射创建bean注入代码实现" class="headerlink" title="基于反射创建bean注入代码实现"></a>基于反射创建bean注入代码实现</h3><p>定义一个类的模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">templateValue</span> <span class="operator">=</span> <span class="string">&quot;import org.springframework.web.bind.annotation.GetMapping;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;import org.springframework.web.bind.annotation.RequestMapping;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;import org.springframework.web.bind.annotation.RestController;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;@RestController\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;@RequestMapping(\&quot;/test\&quot;)\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;public class TestController &#123;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;    @GetMapping(\&quot;/test\&quot;)\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;    public String test()&#123;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;        return \&quot;测试Test接口\&quot;;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;&#125;&quot;</span>;</span><br></pre></td></tr></table></figure><p>提供一个接口来反射创建对象并且注入到spring容器中来:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/create&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createTemplate</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, <span class="type">byte</span>[]&gt; bytecode = DynamicLoader.compile(<span class="string">&quot;TestController.java&quot;</span>, templateValue);</span><br><span class="line">        <span class="type">MemoryClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MemoryClassLoader</span>(bytecode);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;TestController&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注入 bean 容器的代码 : 容器中是存在这个 bean 对象的,但是Controller却没有访问到.</span></span><br><span class="line">        <span class="type">BeanDefinitionBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(object.getClass());</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> springUtils.getContext();</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> (DefaultListableBeanFactory) context.getBeanFactory();</span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;testController&quot;</span>,builder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">        <span class="type">RequestMappingHandlerMapping</span> <span class="variable">mappingHandlerMapping</span> <span class="operator">=</span> context.getBean(RequestMappingHandlerMapping.class);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">oj</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;testController&quot;</span>);</span><br><span class="line">        Map&lt;Method, RequestMappingInfo&gt; methods = MethodIntrospector.selectMethods(oj.getClass(),(MethodIntrospector.MetadataLookup&lt;RequestMappingInfo&gt;) method -&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="type">RequestMapping</span> <span class="variable">requestMapping</span> <span class="operator">=</span> AnnotatedElementUtils.findMergedAnnotation(method, RequestMapping.class);</span><br><span class="line">                RequestMappingInfo.<span class="type">Builder</span> <span class="variable">mappping</span> <span class="operator">=</span> RequestMappingInfo.paths(requestMapping.path())</span><br><span class="line">                                  .methods(requestMapping.method())</span><br><span class="line">                                  .params(requestMapping.params())</span><br><span class="line">                                  .headers(requestMapping.headers())</span><br><span class="line">                                  .consumes(requestMapping.consumes())</span><br><span class="line">                                  .produces(requestMapping.produces())</span><br><span class="line">                                  .mappingName(requestMapping.name());</span><br><span class="line">                <span class="keyword">return</span> mappping.build();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">rmhmMethod</span> <span class="operator">=</span> mappingHandlerMapping.getClass()</span><br><span class="line">                            .getDeclaredMethod(<span class="string">&quot;registerHandlerMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Method.class, Object.class&#125;);</span><br><span class="line"></span><br><span class="line">        rmhmMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        methods.forEach((method,mapping) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                rmhmMethod.invoke(mappingHandlerMapping,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;oj,method,mapping&#125; );</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Spring工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringUtils</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        context = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (ConfigurableApplicationContext)context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此,就可以动态的创建出一个接口来了。</p><p>当然了,这里的代码都是写固定在代码里面的,可以提供 template 或者 通过页面定义给添加进来, 然后调用 反射&#x2F;注入到Spring容器中等操作即可.</p><h3 id="基于-404-拦截请求"><a href="#基于-404-拦截请求" class="headerlink" title="基于 404 拦截请求"></a>基于 404 拦截请求</h3><p>这是 SpringBoot 本来就有的 404 拦截实现, 如果不做什么处理的话,那么进入到这里来的url地址就会是&#x2F;error,是无法满足实现的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelfErrorController</span> <span class="keyword">implements</span> <span class="title class_">ErrorController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">ERROR_PATH</span> <span class="operator">=</span> <span class="string">&quot;/error&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Supports the HTML Error View</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = ERROR_PATH)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">errorHtml</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">statusCode</span> <span class="operator">=</span> (Integer) request.getAttribute(<span class="string">&quot;javax.servlet.error.status_code&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        log.info(<span class="string">&quot;在SelfErrorController中请求的路径 : &#123;&#125; &quot;</span> ,requestURI);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到路径后就可以执行相应的代码逻辑.</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">realUrlName</span> <span class="operator">=</span> request.getAttribute(<span class="string">&quot;realName&quot;</span>).toString();</span><br><span class="line">        log.info(<span class="string">&quot;在SelfErrorController中真实存在的请求路径是 : --&gt; &#123;&#125; &quot;</span> , realUrlName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(statusCode == <span class="number">401</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="string">&quot;&#123; \&quot;code\&quot;: \&quot;401\&quot;&#125;&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(statusCode == <span class="number">404</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#123; \&quot;code\&quot;: \&quot;404\&quot;&#125;&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(statusCode == <span class="number">403</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#123; \&quot;code\&quot;: \&quot;403\&quot;&#125;&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#123; \&quot;code\&quot;: \&quot;500\&quot;&#125;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getErrorPath</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为上面无法满足的前提下,所以我们可以使用拦截来配置原来的路径.</p><p>配置类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppConfigurer</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">SelfInterceptor</span>()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义拦截器:</p><p>这里可以看到将原有的路径给set字段realName了.</p><p>所以在上面的error接口,我们调用这个realName字段就可以获取到了原有的路径.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelfInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                             Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 前置拦截器</span></span><br><span class="line">        log.info(<span class="string">&quot;前置拦截器调用 : com.iyang.hello.boot.config.SelfInterceptor.preHandle 中来.&quot;</span> );</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        log.info(<span class="string">&quot;在preHandle方法中捕捉到的请求路径 : ---&gt; &#123;&#125; &quot;</span> , requestURI);</span><br><span class="line">        <span class="comment">// handler 是 ResourceHttpRequestHandler</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                           Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        request.setAttribute(<span class="string">&quot;realName&quot;</span>,requestURI);</span><br><span class="line">        <span class="keyword">if</span>(response.getStatus() == <span class="number">404</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;状态是404正常操作&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;请求的url路径是 ---&gt; &#123;&#125; &quot;</span> , requestURI);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该技能看到比较有意思,具体的实现和设计思路其实是有很多种的,具体得看项目的业务是不是需要使用.</p><p>并且实现的思路并不是只有这一种,肯定是还有很多种的.</p><p>适合自己的业务是最好的.</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a></nav></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">YangBao</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>Symbols count total: </span><span title="Symbols count total">307k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>Reading time total &asymp;</span> <span title="Reading time total">4:39</span></span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a></div></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script></body></html>