[{"title":"mybatisä¸springbootæ•´åˆé˜…è¯»","url":"/2021/11/04/mybatis/mybatisä¸springbootæ•´åˆé˜…è¯»/","content":"\n#### å‰æ\n\n MyBatis ä¸ SpringBoot æ•´åˆæ“ä½œ. åœ¨è¿™æ¬¡æ•´åˆçš„è¿‡ç¨‹ä¸­,å†æ¬¡æ˜ç™½è‡ªå·±æ¯«æ— ç–‘é—®çš„æ˜¯ä¸€ä¸ªæ¯”è¾ƒæ‰‹æ®‹çš„åŒå­¦äº†.\n\n è¿™é‡Œæˆ‘ä»¬æ˜¯åŸºäº sql è¯­å¥å†™åœ¨ xml é‡Œé¢è¿›è¡Œæ•´åˆçš„æ“ä½œ.\n\n#### å…¥é—¨\n\n è¿™é‡Œè¯´ä¸‹åˆ›å»ºä¸€ä¸ª å…¥é—¨ é¡¹ç›®çš„å¤§è‡´æµç¨‹.\n\n å…ˆåˆ›å»ºä¸€ä¸ª SpringBoot é¡¹ç›® , å¼•å…¥ä¾èµ– : https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/pom.xml\n\n åˆ›å»º MyBatis çš„é…ç½®æ–‡ä»¶ä¿¡æ¯ : https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/resources/mybatis-config.xml\n\n åˆ›å»ºæŸ¥è¯¢çš„ sql è¯­å¥ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬çš„ mapper æ–‡ä»¶ : https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-boot-hello/src/main/resources/mapper\n\n application.properties : https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/resources/application.properties\n\n æ‰«æ mapper æ¥å£ : @MapperScan(basePackages = {â€œcom.iyang.mybatis.springboot.hello.mapperâ€}) https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/java/com/iyang/mybatis/springboot/hello/MybatisSpringBootHelloApplication.java\n\nè¿™é‡Œæ˜¯æ²¡æœ‰å¼•å…¥ web ä¾èµ–çš„ , ç›´æ¥å¯åŠ¨ main æ–¹æ³• , ç„¶åå°±å¯ä»¥çœ‹åˆ°æˆ‘ä»¬æŸ¥è¯¢å‡ºæ¥çš„ç»“æœäº†.\n\nå¦‚æœä½ ç†Ÿæ‚‰ SpringBoot æºç çš„è¯ï¼Œå°±ä¼šæ™“å¾—æœ‰ä¸€ä¸ªè‡ªåŠ¨è£…é…çš„æ“ä½œ.\n\nå¦‚æœä¸ç†Ÿæ‚‰çš„è¯ï¼Œé‚£ä¹ˆå°±åªèƒ½é€šè¿‡ @MapperScan(basePackages = {â€œcom.iyang.mybatis.springboot.hello.mapperâ€}) å»çœ‹ , è¿™æ ·æœ‰äº›æ˜¯ä¾èµ–è‡ªåŠ¨è£…é…ï¼ˆspring.factoriesï¼‰ ä¸­çš„é…ç½®åŠ è½½çš„, æ‰€ä»¥è¿™é‡Œå»ºè®®åœ¨çœ‹ä¹‹å‰ï¼Œå¦‚æœæ˜¯æœ‰ä¸€ç‚¹ SpringBoot æ‰©å±•çš„çŸ¥è¯†äº†è§£æ˜¯å¾ˆå¥½çš„ã€‚å¦‚æœæ²¡æœ‰æ€ä¹ˆåŠå‘¢ï¼Ÿæ²¡æœ‰å°±æ¥çœ‹æˆ‘æ¥ä¸‹æ¥çš„å†…å®¹ã€‚\n\nå…¶å®è¿™ä¸ªåœ°æ–¹ä½ ä»”ç»†æƒ³ä¸‹ï¼Œåœ¨ MyBatis ä¸ Spring æ•´åˆçš„æ—¶å€™ï¼Œé€šè¿‡ xml çš„æ–¹å¼ç»™ MyBatis çš„bean å·²ç» mybatis-spring ä¸­è‡ªå·±å†™çš„æ‰«æç±»ï¼Œæœ€åå°†æ‰«æå‡ºæ¥çš„ bd åœ¨è¿˜æ²¡åˆå§‹åŒ–ä¹‹å‰ï¼Œå°†bd çš„beanClass æ›¿æ¢ä¸ºæˆ‘ä»¬çš„ä»£ç†ç±».\n\né‚£ä¹ˆï¼ŒSpringBoot ä¸ MyBatis æ•´åˆçš„æ—¶å€™ï¼Œæœ€åè¦åšçš„äº‹æƒ…æ˜¯ä¸æ˜¯ä¹Ÿæ˜¯å°† MyBatis çš„ä¿¡æ¯æ³¨å…¥åˆ° SpringBoot æ¥å‘¢ï¼Ÿåªä¸è¿‡ï¼ŒSpringBoot å°±ä¸åƒ Spring ä¸€æ ·äº†ï¼Œè¿˜å°† bean çš„ä¿¡æ¯é…ç½®åˆ° xml æ–‡ä»¶ä¸­.\n\näºæ˜¯ï¼Œæ¥ä¸‹æ¥è·Ÿæˆ‘çš„é˜…è¯»&åˆ†ææ¥ä¸€æ­¥ä¸€æ­¥çš„å¾€ä¸‹çœ‹.\n\n#### æ–¹æ³•åˆ†æ\n\n **å…³æ³¨ç‚¹ä¸€** : è¿™é‡Œæˆ‘ä»¬ç‚¹å…¥åˆ° org.mybatis.spring.annotation.MapperScan æ³¨è§£é‡Œé¢æ¥ï¼Œå¯ä»¥çœ‹åˆ°æœ‰ä¸€ä¸ª @Import(MapperScannerRegistrar.class) , äºæ˜¯æˆ‘ä»¬é¡ºæ‰‹è·Ÿè¿›æ¥ : org.mybatis.spring.annotation.MapperScannerRegistrar , ä»åå­—ä¸Šæ¥ï¼Œè¿™ä¸ªç±»å°±åšäº†ä¸€ä¸ªæ‰«æmapperå¹¶ä¸”å°†mapperæ³¨å…¥åˆ°Springå®¹å™¨ä¸­æ¥çš„äº‹æƒ….\n\n **å…³æ³¨ç‚¹äºŒ** : æˆ‘ä»¬ä»å¼•å…¥è¿›æ¥çš„ä¾èµ–æ¥çœ‹, mybatis-spring-boot-starter-2.1.2.jar è·Ÿè¿›åˆ° è¿™ä¸ªåŒ…æ¥ï¼Œå¯ä»¥çœ‹åˆ°è¿™ä¸ªåŒ…ä¹Ÿæ˜¯å¼•å…¥ä¸€äº›è¿›æ¥. mybatis/mybatis-spring/spring-boot-starter-jdbc è¿™ä¸‰ä¸ªä¾èµ–æˆ‘ä»¬åº”è¯¥ä¸æ˜¯å¾ˆé™Œç”Ÿçš„ï¼Œmybatis-spring-boot-autoconfigureä¸»è¦æ¥çœ‹è¿™ä¸ªã€‚ spring.factories çš„ä½œç”¨å¤§å®¶å¯ä»¥å»äº†è§£ä¸‹ï¼ŒSpringBootå¾ˆå¤š EnableAutoConfiguration çš„é…ç½®éƒ½æ˜¯æ”¾å…¥åœ¨è¿™ä¸ªé‡Œé¢çš„ï¼Œåœ¨å¯åŠ¨çš„æ—¶å€™ï¼Œä¼šå»ä¸€å±‚ä¸€å±‚çš„å»è¯»å– spring.factories æ–‡ä»¶çš„å†…å®¹ã€‚ è¿™é‡Œæˆ‘ä»¬ä¸»è¦æ¥çœ‹ : org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration è¿™ä¸ªç±»çš†å¯.\n\n MyBatis åœ¨ properties ä¸­çš„é…ç½®æ–‡ä»¶è¯»å– : org.mybatis.spring.boot.autoconfigure.MybatisProperties\n\nå¯ä»¥çœ‹åˆ°è¯¥ç±»ä¸Šæ˜¯æœ‰: @ConfigurationProperties(prefix = MybatisProperties.MYBATIS_PREFIX)\n\näºæ˜¯æˆ‘ä»¬ä¸€ä¸‹å­å°±å¤šäº†äºŒä¸ªå…³æ³¨ç‚¹, è¿™é‡Œæˆ‘ä»¬å¯ä»¥é‡‡ç”¨ä¹‹å‰çš„ ç¬¨æ–¹æ³•ï¼Œ å½“ä½ å¯¹æ•´åˆæµç¨‹æ‰§è¡Œä¸æ˜¯å¾ˆç†Ÿæ‚‰çš„è¯ï¼Œå¯ä»¥åœ¨è¿™äºŒä¸ªå…³æ³¨ç‚¹çš„é‡å†™æ–¹æ³•ä¸Šéƒ½æ‰“ç®—æ–­ç‚¹ï¼Œçœ‹ä¸‹å…¶æ‰§è¡Œé¡ºåºæ˜¯æ€ä¹ˆæ‰§è¡Œçš„. å¼„æ¸…æ¥šäº†æ‰§è¡Œæµç¨‹,å°±å¯ä»¥è·Ÿç€æµç¨‹æ¥ä¸€æ­¥ä¸€æ­¥çš„åˆ†æ. ä»æˆ‘ä»¬æ‰“ä¸Š debug å¼€å§‹ï¼Œå¾€ä¸‹çš„æ‰§è¡Œæµç¨‹å°±æ˜¯ä¸€æ­¥ä¸€æ­¥æ¥çš„ï¼Œé‚£ä¹ˆå°±è·Ÿç€æˆ‘ä»¬debug çš„æ–¹æ³•æ¥ä¸€æ­¥ä¸€æ­¥çš„åˆ†æ.\n\norg.mybatis.spring.annotation.MapperScannerRegistrar#registerBeanDefinitions() â€”> org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#MybatisAutoConfiguration â€”> org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#afterPropertiesSet â€”-> org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionFactory â€”> org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionTemplate() â€”->\n\n**org.mybatis.spring.annotation.MapperScannerRegistrar#registerBeanDefinitions() æ–¹æ³•** :\n\n```\n/**\n * {@inheritDoc}\n */\n@Override\npublic void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n/***\n*  è¿™é‡Œæ˜¯è·å–å‡ºäº†æ³¨è§£é‡Œé¢å±æ€§çš„å€¼. \n*/   \n  AnnotationAttributes mapperScanAttrs = \n  AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));\n\n// èƒ½è·å–åˆ°æœ‰æ³¨è§£,ä¸æ˜¯null,å°±ä¼šèµ°åˆ°ä¸‹é¢çš„ä»£ç ä¸­æ¥.    \n  if (mapperScanAttrs != null) {\n    registerBeanDefinitions(importingClassMetadata, mapperScanAttrs, registry,\n        generateBaseBeanName(importingClassMetadata, 0));\n  }\n}\n\n/**\n* \n*/\n  void registerBeanDefinitions(AnnotationMetadata annoMeta, AnnotationAttributes annoAttrs,\n      BeanDefinitionRegistry registry, String beanName) {\n\n// åˆ©ç”¨ BeanDefinitionBuilder æ„é€ è€…,ä¼ å…¥äº†ä¸€ä¸ª MapperScannerConfigurer.class\n// è¿™é‡Œçš„ builderé‡Œé¢æ˜¯æœ‰ä¸€ä¸ª bd çš„,é‡Œé¢çš„beanClasså°±æ˜¯ MapperScannerConfigurer      \n    BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);\n    builder.addPropertyValue(\"processPropertyPlaceHolders\", true);\n\n// è¿™é‡Œè·å– @MapperScan æ³¨è§£çš„å±æ€§, å¦‚æœå±æ€§æ˜¯æœ‰å€¼çš„è¯,å°±ä¼šè®¾ç½®åˆ° builder ä¸­æ¥. \n    Class<? extends Annotation> annotationClass = annoAttrs.getClass(\"annotationClass\");\n    if (!Annotation.class.equals(annotationClass)) {\n      builder.addPropertyValue(\"annotationClass\", annotationClass);\n    }\n\n    Class<?> markerInterface = annoAttrs.getClass(\"markerInterface\");\n    if (!Class.class.equals(markerInterface)) {\n      builder.addPropertyValue(\"markerInterface\", markerInterface);\n    }\n\n    Class<? extends BeanNameGenerator> generatorClass = annoAttrs.getClass(\"nameGenerator\");\n    if (!BeanNameGenerator.class.equals(generatorClass)) {\n      builder.addPropertyValue(\"nameGenerator\", BeanUtils.instantiateClass(generatorClass));\n    }\n\n    Class<? extends MapperFactoryBean> mapperFactoryBeanClass = annoAttrs.getClass(\"factoryBean\");\n    if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) {\n      builder.addPropertyValue(\"mapperFactoryBeanClass\", mapperFactoryBeanClass);\n    }\n\n    String sqlSessionTemplateRef = annoAttrs.getString(\"sqlSessionTemplateRef\");\n    if (StringUtils.hasText(sqlSessionTemplateRef)) {\n      builder.addPropertyValue(\"sqlSessionTemplateBeanName\", annoAttrs.getString(\"sqlSessionTemplateRef\"));\n    }\n\n    String sqlSessionFactoryRef = annoAttrs.getString(\"sqlSessionFactoryRef\");\n    if (StringUtils.hasText(sqlSessionFactoryRef)) {\n      builder.addPropertyValue(\"sqlSessionFactoryBeanName\", annoAttrs.getString(\"sqlSessionFactoryRef\"));\n    }\n\n\n// ä¸‹é¢æ˜¯æ ¹æ® value/basePackages/basePackageClasses æ¥è·å–åŒ…çš„ä¿¡æ¯,\n// è¿™é‡Œä¹Ÿå°±è¯´, æˆ‘ä»¬å¯ä»¥è·Ÿç€è¿™ä¸‰ä¸ªå±æ€§æ¥é…ç½®åŒ…ä¿¡æ¯.      \n    List<String> basePackages = new ArrayList<>();\n    basePackages.addAll(\n        Arrays.stream(annoAttrs.getStringArray(\"value\")).filter(StringUtils::hasText).collect(Collectors.toList()));\n\n    basePackages.addAll(Arrays.stream(annoAttrs.getStringArray(\"basePackages\")).filter(StringUtils::hasText)\n        .collect(Collectors.toList()));\n\n    basePackages.addAll(Arrays.stream(annoAttrs.getClassArray(\"basePackageClasses\")).map(ClassUtils::getPackageName)\n        .collect(Collectors.toList()));\n\n// å¦‚æœæ²¡æœ‰è·å–åˆ°åŒ…çš„ä¿¡æ¯,é‚£å°±æ ¹æ®æ³¨è§£æ‰€åœ¨çš„è·¯å¾„æ¥è·å–é»˜è®¤çš„è·¯å¾„.      \n    if (basePackages.isEmpty()) {\n      basePackages.add(getDefaultBasePackage(annoMeta));\n    }\n// å¦‚æœæœ‰lazyInitializationå±æ€§çš„å€¼,å°±è®¾ç½®åˆ° builder ä¸­æ¥. \n    String lazyInitialization = annoAttrs.getString(\"lazyInitialization\");\n    if (StringUtils.hasText(lazyInitialization)) {\n      builder.addPropertyValue(\"lazyInitialization\", lazyInitialization);\n    }\n// æ·»åŠ åŒ…çš„å±æ€§\n    builder.addPropertyValue(\"basePackage\", StringUtils.collectionToCommaDelimitedString(basePackages));\n\n//  getBeanDefinition() åœ¨è¿”å› bd ä¹‹å‰ï¼Œä¼šèµ°ä¸€ä¸ª validate æ–¹æ³•.\n// org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition\n// èµ°è¿™ä¸ªæ–¹æ³•æ¥å°† bd ç»™æ³¨å…¥åˆ° Spring å®¹å™¨ä¸­æ¥.\n// è¿™é‡Œæ³¨å…¥è¿›å»çš„ beanName çš„å€¼æ˜¯ :  com.iyang.mybatis.springboot.hello.MybatisSpringBootHelloApplication#MapperScannerRegistrar#0\n// æ³¨å…¥è¿›å»çš„ bd çš„ beanClass : class org.mybatis.spring.mapper.MapperScannerConfigurer \n    registry.registerBeanDefinition(beanName, builder.getBeanDefinition());\n\n  }\n```\n\n**è¿™é‡Œå¯ä»¥æ€»ç»“ä¸‹ registerBeanDefinitions æ–¹æ³•ï¼Œè¯¥æ–¹æ³•å°±æ˜¯å°† @MapperScan çš„æ³¨è§£å±æ€§çš„å€¼ç»™åˆ° : BeanDefinitionBuilder builder, è¯¥builder é‡Œé¢æœ‰bd,bdçš„beanClassæ˜¯MapperScannerConfigurerï¼Œæœ€åå°†MapperScannerConfigureræ³¨å…¥åˆ° Spring å®¹å™¨ä¸­æ¥.**\n\n------\n\n**MyBatisAutoConfiguration() æœ‰å‚æ„é€ å‡½æ•°**\n\nè¿™é‡Œæˆ‘ä»¬åœ¨ MybatisAutoConfiguration æ„é€ å‡½æ•°ä¸Šæ‰“ä¸Šæ–­ç‚¹, å¯ä»¥æ ¹æ® æ–­ç‚¹æ¥åˆ†æï¼Œèµ°å®ŒğŸ‘†é¢çš„æ–¹æ³•ï¼Œç„¶åæˆ‘ä»¬ç‚¹å‡»èµ°åˆ°ä¸‹ä¸€ä¸ªæ–­ç‚¹æ¥ï¼Œå°±ä¼šèµ°åˆ° è¿™ä¸ª æœ‰å‚æ„é€ å‡½æ•°.\n\nå¦‚æœå¥½å¥‡çš„è¯ï¼Œå¯ä»¥è·Ÿè¸ªdebug çš„å †æ ˆä¿¡æ¯ï¼Œæ˜¯æ€ä¹ˆèµ°åˆ°è¿™æ­¥æ¥çš„. èµ°åˆ°è¿™ä¸ªæ–¹æ³•æ¥ : finishBeanFactoryInitialization(beanFactory) è¿™æ˜¯æœ€åˆçš„å…¥å£.\n\n```\npublic MybatisAutoConfiguration(MybatisProperties properties, ObjectProvider<Interceptor[]> interceptorsProvider,\n    ObjectProvider<TypeHandler[]> typeHandlersProvider, ObjectProvider<LanguageDriver[]> languageDriversProvider,\n    ResourceLoader resourceLoader, ObjectProvider<DatabaseIdProvider> databaseIdProvider,\n    ObjectProvider<List<ConfigurationCustomizer>> configurationCustomizersProvider) {\n// è¿™é‡Œéƒ½æ˜¯èµ‹å€¼    \n  this.properties = properties;\n  this.interceptors = interceptorsProvider.getIfAvailable();\n  this.typeHandlers = typeHandlersProvider.getIfAvailable();\n  this.languageDrivers = languageDriversProvider.getIfAvailable();\n  this.resourceLoader = resourceLoader;\n  this.databaseIdProvider = databaseIdProvider.getIfAvailable();\n  this.configurationCustomizers = configurationCustomizersProvider.getIfAvailable();\n}\n```\n\n**org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#afterPropertiesSet()æ–¹æ³•**\n\nè¿™é‡Œå¯ä»¥çœ‹åˆ°æ˜¯å¯¹é…ç½®æ–‡ä»¶æ˜¯å¦å­˜åœ¨è¿›è¡Œæ£€éªŒ.\n\n```\n@Override\npublic void afterPropertiesSet() {\n  checkConfigFileExists();\n}\n\n// æ£€éªŒé…ç½®æ–‡ä»¶æ˜¯å¦å­˜åœ¨\n  private void checkConfigFileExists() {\n    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {\n      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());\n      Assert.state(resource.exists(),\n          \"Cannot find config location: \" + resource + \" (please add config file or check your Mybatis configuration)\");\n    }\n  }\n```\n\n**org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionFactory æ–¹æ³•**\n\n```\n// è¿™é‡Œè¯´ä¸‹ @ConditionalOnMissingBean çš„ä½œç”¨,å½“beanä¸å­˜åœ¨çš„æ—¶å€™ï¼Œåˆ™å®ä¾‹åŒ–è¿™ä¸ªbean.\n// è¿™é‡Œä¼šä¼ å…¥ dataSource è¿›æ¥.\n@Bean\n@ConditionalOnMissingBean\npublic SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {\n// åˆ›å»º sqlSessionBean å¯¹è±¡.    \n  SqlSessionFactoryBean factory = new SqlSessionFactoryBean();\n// è®¾ç½® dataSource & SpringBootVFS.class      \n  factory.setDataSource(dataSource);\n  factory.setVfs(SpringBootVFS.class);\n// è·å–åˆ° MyBatis çš„é…ç½®æ–‡ä»¶å±æ€§,å¦‚æœæœ‰çš„è¯,å°±ä¼šè®¾ç½®åˆ° configLocationå±æ€§æ¥.    \n  if (StringUtils.hasText(this.properties.getConfigLocation())) {\n    factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));\n  }\n    \n// è¿™é‡Œä» properties ä¸­è·å– configuration,æ²¡æœ‰å€¼å°±ä¼šæ˜¯null.    \n  applyConfiguration(factory);\n  if (this.properties.getConfigurationProperties() != null) {\n    factory.setConfigurationProperties(this.properties.getConfigurationProperties());\n  }\n\n// å¦‚æœæœ‰æ’ä»¶,å°±ä¼šè®¾ç½®æ’ä»¶.    \n  if (!ObjectUtils.isEmpty(this.interceptors)) {\n    factory.setPlugins(this.interceptors);\n  }\n  if (this.databaseIdProvider != null) {\n    factory.setDatabaseIdProvider(this.databaseIdProvider);\n  }\n// åŒ…çš„ååˆ«è®¾ç½®    \n  if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {\n    factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());\n  }\n  if (this.properties.getTypeAliasesSuperType() != null) {\n    factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());\n  }\n  if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {\n    factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());\n  }\n  if (!ObjectUtils.isEmpty(this.typeHandlers)) {\n    factory.setTypeHandlers(this.typeHandlers);\n  }\n  if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {\n    factory.setMapperLocations(this.properties.resolveMapperLocations());\n  }\n// è¿™é‡Œéƒ½æ˜¯é…ç½®å±æ€§çš„è®¾ç½®.    \n\n// è·å– propert å­—æ®µå±æ€§çš„åå­—.    \n  Set<String> factoryPropertyNames = Stream\n      .of(new BeanWrapperImpl(SqlSessionFactoryBean.class).getPropertyDescriptors()).map(PropertyDescriptor::getName)\n      .collect(Collectors.toSet());\n  Class<? extends LanguageDriver> defaultLanguageDriver = this.properties.getDefaultScriptingLanguageDriver();\n  if (factoryPropertyNames.contains(\"scriptingLanguageDrivers\") && !ObjectUtils.isEmpty(this.languageDrivers)) {\n    // Need to mybatis-spring 2.0.2+\n    factory.setScriptingLanguageDrivers(this.languageDrivers);\n    if (defaultLanguageDriver == null && this.languageDrivers.length == 1) {\n      defaultLanguageDriver = this.languageDrivers[0].getClass();\n    }\n  }\n// è®¾ç½®é»˜è®¤çš„è„šæœ¬è¯­è¨€è§£æå™¨. è¿™é‡Œæ²¡æœ‰,è®¾ç½®çš„æ˜¯é»˜è®¤çš„null.    \n  if (factoryPropertyNames.contains(\"defaultScriptingLanguageDriver\")) {\n    // Need to mybatis-spring 2.0.2+\n    factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);\n  }\n// org.mybatis.spring.SqlSessionFactoryBean#getObject,è¿™é‡Œèµ°åˆ°äº† SqlSessionBean.\n// è¿™ä¸ªSqlSessionFactoryBeanæ˜¯åœ¨æœ‰ä¹‹å‰ mybatiså’ŒSpring æ•´åˆåˆ†ææœ‰æè¿‡åˆ°çš„,å¯ä»¥å‚è€ƒgetObjectæ–¹æ³•: https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello    \n// è¿™é‡Œä¼šèµ° org.mybatis.spring.SqlSessionFactoryBean#getObject çš„ afterPropertiesSet æ–¹æ³•æ¥åˆ›å»ºä¸€ä¸ª SqlSessionFactory , è¿™é‡Œè¿”å›çš„ SqlSessionFactory å°±æ³¨å…¥åˆ° Spring å®¹å™¨ä¸­æ¥.    \n  return factory.getObject();\n}\n```\n\n**æ‰€ä»¥è¿™ä¸ªæ–¹æ³• ï¼š å…ˆæ˜¯newäº†ä¸€ä¸ªSqlSessionFactoryBeanå¯¹è±¡ï¼Œå¦‚æœä½ ä»”ç»†çœ‹çš„è¯ï¼Œä½ ä¼šå‘ç°è¿™ä¸ªå¯¹è±¡åœ¨ä¹‹å‰ mybatis-spring æ•´åˆçš„æ—¶å€™ï¼Œæˆ‘ä»¬é€šè¿‡ xml é…ç½®æ–‡ä»¶é…ç½®è¿›æ¥çš„ï¼Œå¹¶ä¸”åŒæ—¶é€šè¿‡æ ‡ç­¾ç»™èµ‹å€¼äº†datasourceç­‰ä¿¡æ¯ï¼Œ è€Œè¿™é‡Œæ˜¯é€šè¿‡ä»£ç ï¼Œifç­‰åˆ¤æ–­ï¼Œæ¥å¯¹ SqlSessionFactoryBean çš„å±æ€§è¿›è¡Œsetå€¼çš„. æœ€åä¹Ÿæ˜¯åˆ›å»ºå‡ºä¸€ä¸ª SqlSessionFactory ç»™æ³¨å…¥åˆ° Spring å®¹å™¨ä¸­æ¥.**\n\n------\n\n**org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionTemplate æ–¹æ³•**\n\n```\n@Bean\n@ConditionalOnMissingBean\npublic SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {\n// è¿™é‡Œæ ¹æ® executorType æ˜¯å¦æœ‰å€¼æ¥åˆ¤æ–­è¦èµ°çš„æ„é€ å‡½æ•°æ–¹æ³•.    \n  ExecutorType executorType = this.properties.getExecutorType();\n  if (executorType != null) {\n    return new SqlSessionTemplate(sqlSessionFactory, executorType);\n  } else {\n// è¿™é‡Œé»˜è®¤çš„è·å–æ˜¯ SIMPLE è¿™ä¸ª ExecutorType.      \n    return new SqlSessionTemplate(sqlSessionFactory);\n  }\n}\n\n// org.mybatis.spring.SqlSessionTemplate#SqlSessionTemplate(org.apache.ibatis.session.SqlSessionFactory, org.apache.ibatis.session.ExecutorType, org.springframework.dao.support.PersistenceExceptionTranslator),æœ€åå¯ä»¥è·Ÿè¿›åˆ°è¿™ä¸ªæ–¹æ³•ä¸­æ¥.\n\n  public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,\n      PersistenceExceptionTranslator exceptionTranslator) {\n// å¯¹sqlSessionFactory å’Œ executorType è¿›è¡Œæ ¡éªŒ\n    notNull(sqlSessionFactory, \"Property 'sqlSessionFactory' is required\");\n    notNull(executorType, \"Property 'executorType' is required\");\n\n    this.sqlSessionFactory = sqlSessionFactory;\n    this.executorType = executorType;\n    this.exceptionTranslator = exceptionTranslator;\n// è¿™é‡Œé€šè¿‡ JDK çš„ä»£ç æ¥ç”Ÿæˆäº†ä¸€ä¸ª sqlSessionProxy ä»£ç†çš„å¯¹è±¡.      \n    this.sqlSessionProxy = (SqlSession) newProxyInstance(SqlSessionFactory.class.getClassLoader(),\n        new Class[] { SqlSession.class }, new SqlSessionInterceptor());\n  }\n```\n\nè¯¥æ–¹æ³•æ˜¯å°† SqlSessionTemplate ç»™æ³¨å…¥åˆ° Spring å®¹å™¨ä¸­å•¦.\n\n#### ç–‘æƒ‘ç‚¹\n\n å¤§å®¶æœ‰æ²¡æœ‰ç–‘æƒ‘æˆ‘ä»¬å®šä¹‰çš„ mapper æ¥å£ å¥½åƒä»è¿™ä¸ªæµç¨‹åˆ†æä¸‹æ¥ï¼Œå¹¶æ²¡æœ‰æåˆ° ï¼Œé‚£ä¹ˆæ˜¯åœ¨ä¸Šé¢æ—¶å€™è¢«æ³¨å…¥åˆ° Spring å®¹å™¨ä¸­æ¥çš„å‘¢ï¼Ÿ\n\n registerBeanDefinitions() è¿™ä¸ªæ–¹æ³• , æ³¨å…¥äº†MapperScannerConfigurer åˆ° Spring å®¹å™¨ä¸­æ¥äº†ï¼Œå¯ä»¥å›é¡¾ä¸‹ä¹‹å‰ mybatis æ•´åˆ Spring çš„æ—¶å€™ï¼Œæˆ‘ä»¬æ˜¯é€šè¿‡ xml é…ç½®äº†è¿™ä¸ªå¯¹è±¡æ³¨å…¥åˆ° spring å®¹å™¨ä¸­æ¥çš„ã€‚ é‚£ä¹ˆæ³¨å…¥è¿›æ¥çš„,å›è°ƒåˆ° org.mybatis.spring.mapper.MapperScannerConfigurer#postProcessBeanDefinitionRegistry è¿™ä¸ªæ–¹æ³•çš„æ—¶å€™ï¼Œå°±ä¼šå°†æ‰«æå¹¶ä¸”å°†æˆ‘ä»¬çš„mapperæ¥å£æ–‡ä»¶ï¼Œç»™æ³¨å…¥åˆ° Spring å®¹å™¨ä¸­æ¥çš„. ç„¶åæ‰«æçš„åŒ…ï¼Œæ˜¯æ ¹æ®@MapperScan è§£ææ³¨è§£çš„æ—¶å€™ï¼Œæ˜¯æœ‰å¯¹æ‰«æçš„åŒ…è¿›è¡Œè§£æçš„.\n\n#### æ€»ç»“\n\n å…¶å® SpringBoot æ•´åˆ MyBatis , æˆ‘ä»¬ä»äºŒä¸ªåˆ‡å…¥ç‚¹æ¥åˆ†ææ˜¯æ€ä¹ˆæ•´åˆè¿›æ¥çš„.\nâ€‹ ä¸€æ˜¯ @MapperScan æ³¨è§£ä¸­çš„ @Import(MapperScannerRegistrar.class) å°† MapperScannerRegistrar ç»™å¯¼å…¥åˆ° Spring å®¹å™¨ä¸­æ¥, ç„¶åMapperSacnnerRegistrar æ¥è®² org.mybatis.spring.mapper.MapperScannerConfigurer ç»™æ³¨å…¥åˆ° Springä¸­æ¥ï¼Œæ›¿æ¢äº†æˆ‘ä»¬ä¹‹å‰ç”¨ Spring æ•´åˆ Mybatis çš„æ—¶å€™ï¼Œé€šè¿‡xmlé…ç½®æ–‡ä»¶æ•´åˆè¿›æ¥.\n\n äºŒæ˜¯åˆ©ç”¨ SpringBoot æä¾›çš„ spring-boot-autoconfigure + spring.factories() æ¥ é…ç½®è‡ªåŠ¨æ³¨å…¥, è¿™é‡Œæ³¨å…¥äº† MybatisAutoConfiguration é…ç½®ç±». ç„¶åæ³¨å…¥è¿›æ¥çš„ MyBatis é…ç½®ç±»åšäº†ä»€ä¹ˆäº‹æƒ…å‘¢ï¼Ÿ å¯ä»¥çœ‹åˆ°è¿™ä¸ªç±»ä¸­æ˜¯æœ‰åš: æ³¨å…¥äº† SqlSessionFactory. SqlSessionFactory åˆæ˜¯æ€ä¹ˆæ³¨å…¥è¿›æ¥çš„å‘¢ï¼Ÿ å¯ä»¥çœ‹åˆ° org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionFactory æ–¹æ³•æ˜¯æœ‰å…ˆåˆ›å»ºä¸€ä¸ª org.mybatis.spring.SqlSessionFactoryBean çš„ï¼Œ çœ‹åˆ° SqlSessionFactoryBean è¿™ä¸ªå¯¹è±¡ï¼Œæˆ‘ä»¬å°±ä¸éš¾æƒ³èµ· Spring + Mybatis é‡Œé¢çš„ beans.xml æ˜¯å°†è¯¥å¯¹è±¡æ³¨å…¥åˆ° Spring å®¹å™¨ä¸­æ¥. è¿™é‡Œæ˜¯ç›´æ¥newçš„ï¼Œç„¶åå°†ä¸€äº›é…ç½®å±æ€§å¹¶æ»¡è¶³æ¡ä»¶,ç»™setåˆ° SqlSessionFactoryBean ä¸­æ¥ï¼Œæœ€åè°ƒç”¨ org.mybatis.spring.SqlSessionFactoryBean#getObject æ–¹æ³•æ¥è·å– SqlSessionFactory.\n\nspring.factories æ–‡ä»¶å†…å®¹\n\n```\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\\\norg.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration\n```\n\næœ€åä»å†™çš„æ¡ˆä¾‹é‡Œé¢çœ‹, MyBatis æ•´åˆ SpringBoot å…¶å®éƒ½æ˜¯åœ¨ mybatis â€”> MyBatis + Spring ç­‰ä¸€æ­¥ä¸€æ­¥æ¨å¯¼ä¸Šæ¥çš„ï¼Œæ‰€ä»¥è¿™é‡Œä¸éš¾ç†è§£ï¼Œå¥½çš„æŠ€æœ¯éƒ½æ˜¯åœ¨æœ‰éœ€è¦å’Œæ—¶é—´çš„æ²‰æ·€ä¸‹ä¸€æ­¥ä¸€æ­¥æˆé•¿èµ·æ¥çš„.\n","tags":["javaæ¡†æ¶","mybatis"],"categories":["javaæ¡†æ¶","mybatis"]},{"title":"mybatisä¸springæ•´åˆé˜…è¯»","url":"/2021/11/04/mybatis/mybatisä¸springæ•´åˆé˜…è¯»/","content":"\n\n\n#### é¢˜è®°\n\n MyBatis ä¸ Spring æ•´åˆæ“ä½œ. åœ¨æˆ‘ä»¬å…¥é—¨å­¦ä¹  SSM ç­‰ä¸œè¥¿çš„æ—¶å€™ï¼Œå°±å‘ç°äº†ä»»ä½•ä¸œè¥¿ï¼Œæœ€åéƒ½æ˜¯é€ƒä¸è¿‡ä¸Springæ•´åˆèµ·æ¥çš„é“è·¯. ç„¶åè¿™é‡Œçœ‹å®Œ MyBatis æ•´åˆå®Œ Spring ä¹‹åï¼Œé‚£ä¹ˆä¹‹åä¸€äº›å…¶ä»–çš„ç¬¬ä¸‰æ–¹ï¼Œæ¯”å¦‚axon/redis/apollo/shiro ç­‰è¿™äº›ä¸œè¥¿ï¼Œå¦‚æœè¦æ•´åˆ Spring çš„æ—¶å€™ï¼Œæ˜¯ä¸æ˜¯ä¹Ÿæ˜¯ç›¸ä¼¼çš„æ•´åˆæ–¹å¼å‘¢ï¼Ÿ\n\n è¿™ä¸ªéœ€è¦æˆ‘ä»¬çœ‹å®Œ MyBatis ä¸ Spring ä¹‹åï¼Œæ¢ç©¶å…¶æ•´åˆçš„æ“ä½œ.\n\n#### å…¥é—¨\n\n åˆ†å‡ ä¸ªæ­¥éª¤ï¼Œæ“ä½œä¸€æŠŠå³å¯,å¸¦ä½ å›åˆ°å“ªä¸ª SM æ—¶ä»£ï¼Œä¸è¿‡è¿™å›æ˜¯æ²¡æœ‰äº† tomcat çš„.\n\n å…ˆæ”¾ä¸Šä¸€ä¸ªå®Œæˆçš„æ•´åˆåœ°å€ : https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello å¦‚æœä¸è¦çœ‹ä¸‹é¢æµç¨‹çš„,ä¸€æ­¥è·³è¿‡å³å¯.\n\n1. å…ˆåˆ›å»ºä¸€ä¸ª maven é¡¹ç›®ï¼Œå¼•å…¥ä¾èµ–. ä¾èµ–å‚è€ƒåœ°å€ : https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/pom.xml\n2. dbé…ç½® : https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/src/main/resources/db.properties\n3. MyBatisé…ç½®: https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src/main/resources/mybatis\n4. Spring é…ç½®: https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/src/main/resources/spring-beans.xml\n5. æœ€å,æ¥ä»½æˆ‘ä»¬ç†Ÿæ‚‰çš„ https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src/main/resources/sql mapper.xml æ–‡ä»¶.\n6. ä¸å¿˜è®°å†æ¥ä¸€ä»½ä»£ç  : https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src è¿™äº›ç›´æ¥è·‘æµ‹è¯•ç±»å³å¯.\n\nè·Ÿç€è¿™ä¸Šé¢çš„å‡ ä¸ªæ­¥éª¤ï¼Œå°±å¯ä»¥æ­å»ºå®Œä¸€ä¸ªé¡¹ç›®. ç„¶åå–Šä¸Šæˆ‘ä»¬çš„ æ°¸å“¥ï¼Œ æ‰“ä¸Šä¼ è¯´ä¸­çš„ debug , ç–¯ç‹‚çš„è°ƒè¯•çœ‹æ¯æ­¥å¹²äº†ä»€ä¹ˆäº‹.\n\nè¿™ä¸ªçš„æ—¶å€™ï¼Œå¯ä»¥è·‘ä¸‹æµ‹è¯•ç±»ï¼Œæ˜¯okçš„.\n\n#### åˆ†æ\n\n è¿™é‡Œæˆ‘ä»¬é¦–å…ˆæƒ³åˆ°çš„æ˜¯æˆ‘ä»¬å¼•å…¥çš„ä¾èµ–,æ˜¯ä¸æ˜¯æœ‰ä¸ª mybatis-spring çš„ä¾èµ–. ä»è¿™ä¸ªä¾èµ–ï¼Œå¯ä»¥å¾ˆæ˜æ˜¾çš„çœ‹å‡ºæ¥ï¼Œå°±æ˜¯é€šè¿‡è¿™ä¸ªä¾èµ–ï¼Œå°† MyBatis å’Œ Spring æ•´åˆèµ·æ¥çš„ã€‚\n\n ç„¶åå†æƒ³æƒ³ï¼Œæˆ‘ä»¬é™¤äº†è¿™ä¸ªä¾èµ–çš„è¯ï¼Œè¿˜å†å“ªé‡Œæœ‰ä½¿ç”¨åˆ°ä¸€äº› Spring å’Œ MyBatis çš„ä¸œè¥¿å‘¢ï¼Ÿ ç„¶åçœ‹åˆ° spring-beans.xml è¿™ä¸ªxmlé…ç½®, å¯ä»¥çœ‹åˆ° org.mybatis.spring.SqlSessionFactoryBean ç»™æ³¨å…¥åˆ° bean é‡Œé¢æ¥äº†.org.mybatis.spring.mapper.MapperScannerConfigurerä¹Ÿæ˜¯ç»™æ³¨å…¥åˆ° bean é‡Œé¢æ¥äº†. å¹¶ä¸”äºŒè€…éƒ½æœ‰é€šè¿‡æ¥è¿›è¡Œå±æ€§è®¾ç½®å€¼æ“ä½œ.\n\n é‚£ä¹ˆ,æˆ‘ä»¬å°±åŸºäºè¿™äºŒä¸ªç±»çš„æºç å¼€å§‹é˜…è¯».\n\n **SqlSessionFactoryBean (org.mybatis.spring.SqlSessionFactoryBean)**\n\nè¿™é‡Œ SqlSessionFactoryBean æ˜¯å®ç°äº†å¾ˆå¤šæ¥å£,è¿™äº›æ¥å£éƒ½æ˜¯Springçš„.\n\nFactoryBean å·¥å‚bean,ç‚¹è¿›å»å¯ä»¥çœ‹åˆ°,å…¶æœ‰æ–¹æ³•getObject()/getObjectTypeç­‰æ–¹æ³•è·å–beançš„,ç„¶ååŠ ä¸Šæ³›å‹,ä¹Ÿå°±æ˜¯è¿™é‡Œè·å–çš„ getObjectå°±æ˜¯æ³›å‹.\n\nInitializingBean: afterPropertiesSet åˆå§‹åŒ– bean çš„æ—¶å€™ï¼Œä¼šè°ƒç”¨è¯¥æ–¹æ³•.\n\nApplicationEvent: Springçš„äº‹ä»¶ä¼ æ’­æœºåˆ¶ï¼Œå°±æ˜¯ä½¿ç”¨çš„è¿™ç§æ–¹å¼.\n\n```\n/**  å¯ä»¥çœ‹åˆ°è¿™ä¸ªç±»å®ç°äº† Spring è¿™ä¸ªå¤šæ¥å£,é‚£ä¹ˆå°±æœ‰ä¸ªé—®é¢˜,å®ç°äº†è¿™ä¹ˆå¤šæ¥å£çš„æ–¹æ³•,åˆ°åº•æ˜¯å“ªä¸ªæ–¹æ³•å…ˆæ‰§è¡Œçš„å‘¢ï¼Ÿ å¦‚æœä½ å¯¹Springæºç å¾ˆç†Ÿæ‚‰çš„è¯,æ˜¯æœ‰å¯èƒ½æ¸…æ¥šçš„,ä½†æ˜¯è¿˜æ˜¯ä¼šæœ‰ç‚¹ç»•çš„. \nè¿™é‡Œæˆ‘ä»¬ç»™ getObject/afterPropertiesSet/onApplicationEventè¿™ä¸‰ä¸ªæ–¹æ³•æ‰“ä¸Šæ–­ç‚¹æ¥è¿›è¡Œdebug,\ndebugæ¯èµ°çš„ä¸€æ­¥,å°±æ˜¯æ‰§è¡Œçš„å…ˆåé¡ºåºã€‚å¦‚æœä¸æ˜¯ç‰¹åˆ«ç†Ÿæ‚‰æºç çš„æ‰§è¡Œé¡ºåº,è¿™ç§ç¬¨æ–¹æ³•å…¶å®ä¹Ÿæ˜¯å¯ä»¥çš„.\n*\n* æ‰€ä»¥è¿™é‡Œdebugçš„æ‰§è¡Œé¡ºåºæ˜¯ : afterPropertiesSet --> getObject  ---> onApplicationEvent\n* äºæ˜¯æˆ‘ä»¬å°±è·Ÿç€è¿™ä¸ªé¡ºåºæ¥é˜…è¯».\n* æ³¨æ„åœ¨è°ƒç”¨è¿™äº›æ–¹æ³•ä¹‹å‰,<property>æ ‡ç­¾çš„å€¼éƒ½æ˜¯å·²ç»èµ‹å€¼è¿›æ¥äº†çš„,æ˜¯é€šè¿‡åå°„èµ°çš„set æ–¹æ³•è¿›æ¥çš„.\n*/\npublic class SqlSessionFactoryBean\n    implements FactoryBean<SqlSessionFactory>, InitializingBean, ApplicationListener<ApplicationEvent> {}\n\n// å®ç°FactoryBean æ–¹æ³•,è¿™é‡Œæ˜¯å®ç°äº†è¯¥æ¥å£çš„ä¸‰ä¸ªæ–¹æ³•. å…¶å®è¿™é‡Œçš„ isSingleæ˜¯å¯ä»¥ä¸ç”¨å®ç°çš„\n// å› ä¸ºæ¥å£æ˜¯ç”¨ default æ¥ä¿®é¥°çš„.\n  /**\n   * è¯¥æ–¹æ³•æ˜¯åˆ¤æ–­å¹¶ä¸”å†æ¬¡ç¡®è®¤ SqlSessionFactoryæ˜¯ä¸æ˜¯æœ‰äº†. å¦‚æœæ²¡æœ‰çš„è¯,å°±ä¼šè°ƒç”¨afterPropertiesæ¥åˆå§‹åŒ–.\n   * {@inheritDoc}\n   */\n  @Override\n  public SqlSessionFactory getObject() throws Exception {\n    if (this.sqlSessionFactory == null) {\n      afterPropertiesSet();\n    }\n\n    return this.sqlSessionFactory;\n  }\n\n  @Override\n  public Class<? extends SqlSessionFactory> getObjectType() {\n    return this.sqlSessionFactory == null ? SqlSessionFactory.class : this.sqlSessionFactory.getClass();\n  }\n\n  @Override\n  public boolean isSingleton() {\n    return true;\n  }\n\n\n// InitializingBean å®ç°çš„æ–¹æ³•\n  @Override\n  public void afterPropertiesSet() throws Exception {\n// å…ˆå¯¹ dataSource/sqlSessionFactoryBuilderè¿›è¡Œénullçš„åˆ¤æ–­.\n    notNull(dataSource, \"Property 'dataSource' is required\");\n    notNull(sqlSessionFactoryBuilder, \"Property 'sqlSessionFactoryBuilder' is required\");\n    state((configuration == null && configLocation == null) || !(configuration != null && configLocation != null),\n        \"Property 'configuration' and 'configLocation' can not specified with together\");\n// è¿™é‡Œæ„å»ºå‡º ä¸€ä¸ª sqlSessionFactoryå·¥å‚æ¥,æƒ³æƒ³æˆ‘ä»¬æœ€åˆå†çœ‹å•ä¸ªMyBatisé¡¹ç›®çš„æ—¶å€™,æ˜¯ä¸æ˜¯ä¹Ÿæœ‰ä¸€ä¸ªè·å–SqlSessionFactroyçš„æ–¹æ³•,ç„¶åä»sqlSessionFactoryä¼šè¯ä¸­è·å–å‡ºSqlSessionæ¥.\n    this.sqlSessionFactory = buildSqlSessionFactory();\n  }\n\n// ApplicationListenerå®ç°æ–¹æ³•\n  /**\n   * failFast æ—¶ture å¹¶ä¸”ä¼ è¿‡æ¥çš„ eventæ˜¯ ContextRefreshedEventçš„è¯,å°±ä¼šè¿›æ¥.\n   *  è¿™é‡Œç›®å‰éƒ½æ˜¯è°ƒç”¨getæ–¹æ³•,æ²¡æœ‰å¾ˆä»”ç»†çœ‹å‡ºå…¶ä½œç”¨.\n   * {@inheritDoc}\n   */\n  @Override\n  public void onApplicationEvent(ApplicationEvent event) {\n    if (failFast && event instanceof ContextRefreshedEvent) {\n      // fail-fast -> check all statements are completed\n      this.sqlSessionFactory.getConfiguration().getMappedStatementNames();\n    }\n  }\n```\n\n**org.mybatis.spring.SqlSessionFactoryBean#buildSqlSessionFactory**\n\nè¯¥æ–¹æ³•éœ€è¦å•ç‹¬æ‹¿å‡ºæ¥è¯´ä¸‹,å› ä¸ºå†…å®¹è¿˜æ˜¯æ¯”è¾ƒå¤šçš„.\n\n```\n/**\n * Build a {@code SqlSessionFactory} instance.\n *\n * The default implementation uses the standard MyBatis {@code XMLConfigBuilder} API to build a\n * {@code SqlSessionFactory} instance based on a Reader. Since 1.3.0, it can be specified a {@link Configuration}\n * instance directly(without config file).\n *\n * @return SqlSessionFactory\n * @throws Exception\n *           if configuration is failed\n */\nprotected SqlSessionFactory buildSqlSessionFactory() throws Exception {\n\n  final Configuration targetConfiguration;\n\n  XMLConfigBuilder xmlConfigBuilder = null;\n    \n // è¿™é‡Œåˆ†ä¸ºconfiguration/ configLocation / éå‰äºŒè€…(å¯ä»¥ç†è§£ä¸ºé»˜è®¤çš„).\n // ä¸‰ç§å¤„ç†æ–¹å¼.   \n  if (this.configuration != null) {\n    targetConfiguration = this.configuration;\n    if (targetConfiguration.getVariables() == null) {\n      targetConfiguration.setVariables(this.configurationProperties);\n    } else if (this.configurationProperties != null) {\n      targetConfiguration.getVariables().putAll(this.configurationProperties);\n    }\n  } else if (this.configLocation != null) {\n// è¿™é‡Œå°±æ˜¯æˆ‘ä»¬é…ç½®çš„æƒ…å†µ \n// org.apache.ibatis.builder.xml.XMLConfigBuilder#XMLConfigBuilder(java.io.InputStream, java.lang.String, java.util.Properties),å¯ä»¥çœ‹åˆ°è¿™ä¸ªç†Ÿæ‚‰çš„æ“ä½œ,ä¹Ÿå°±æ˜¯æˆ‘ä»¬å•ä¸ªè§£æ MyBatisçš„æ—¶å€™æœ‰è¿›è¡Œåˆ†æè¿‡çš„.      \n    xmlConfigBuilder = new XMLConfigBuilder(this.configLocation.getInputStream(), null, this.configurationProperties);\n// è·å–å‡º configuration é…ç½®ä¿¡æ¯.      \n    targetConfiguration = xmlConfigBuilder.getConfiguration();\n  } else {\n    LOGGER.debug(\n        () -> \"Property 'configuration' or 'configLocation' not specified, using default MyBatis Configuration\");\n    targetConfiguration = new Configuration();\n    Optional.ofNullable(this.configurationProperties).ifPresent(targetConfiguration::setVariables);\n  }\n\n\n// è¿™é‡Œé‡‡ç”¨ Optional,å¦‚æœobjectFactoryä¸æ˜¯nullçš„è¯,å°±ä¼šè°ƒç”¨targetConfigurationçš„ setObjectFactoryæ–¹æ³•.ä¸‹é¢è¿™äºŒä¸ªæ˜¯åŒç†.\n  Optional.ofNullable(this.objectFactory).ifPresent(targetConfiguration::setObjectFactory);\n  Optional.ofNullable(this.objectWrapperFactory).ifPresent(targetConfiguration::setObjectWrapperFactory);\n  Optional.ofNullable(this.vfs).ifPresent(targetConfiguration::setVfsImpl);\n\n// è¿™é‡Œå¦‚æœæœ‰é…ç½®typeAliasesPackageè¿™ä¸ªå‚æ•°çš„è¯,å°±ä¼šå¯¹è¯¥åŒ…ä¸‹è¿›è¡Œæ‰«æ,è¿›è¡Œä¸€ç³»åˆ—çš„è¿‡æ»¤,\n// å¦‚æœéƒ½æ»¡è¶³æ¡ä»¶çš„è¯,targetConfiguration.getTypeAliasRegistry()::registerAliaså°±ä¼šæ³¨å†Œåˆ°è¿™é‡Œ. \n  if (hasLength(this.typeAliasesPackage)) {\n    scanClasses(this.typeAliasesPackage, this.typeAliasesSuperType).stream()\n        .filter(clazz -> !clazz.isAnonymousClass()).filter(clazz -> !clazz.isInterface())\n        .filter(clazz -> !clazz.isMemberClass()).forEach(targetConfiguration.getTypeAliasRegistry()::registerAlias);\n  }\n// æ˜¯å¦æœ‰typeAliasesè¿™ä¸ªå‚æ•°,å¦‚æœæœ‰çš„è¯,ä¹Ÿæ˜¯å¯ä»¥çœ‹åˆ°æ˜¯æ³¨å†Œåˆ°ä¸Šé¢å“ªä¸€æ­¥çš„é‡Œé¢æ¥.\n  if (!isEmpty(this.typeAliases)) {\n    Stream.of(this.typeAliases).forEach(typeAlias -> {\n      targetConfiguration.getTypeAliasRegistry().registerAlias(typeAlias);\n      LOGGER.debug(() -> \"Registered type alias: '\" + typeAlias + \"'\");\n    });\n  }\n\n//åˆ¤æ–­æ˜¯å¦æœ‰æ’ä»¶,å¦‚æœæœ‰æ’ä»¶çš„è¯,ä¹Ÿä¼šæ·»åŠ åˆ°configurationä¸­æ¥.    \n  if (!isEmpty(this.plugins)) {\n    Stream.of(this.plugins).forEach(plugin -> {\n      targetConfiguration.addInterceptor(plugin);\n      LOGGER.debug(() -> \"Registered plugin: '\" + plugin + \"'\");\n    });\n  }\n\n  if (hasLength(this.typeHandlersPackage)) {\n    scanClasses(this.typeHandlersPackage, TypeHandler.class).stream().filter(clazz -> !clazz.isAnonymousClass())\n        .filter(clazz -> !clazz.isInterface()).filter(clazz -> !Modifier.isAbstract(clazz.getModifiers()))\n        .forEach(targetConfiguration.getTypeHandlerRegistry()::register);\n  }\n\n  if (!isEmpty(this.typeHandlers)) {\n    Stream.of(this.typeHandlers).forEach(typeHandler -> {\n      targetConfiguration.getTypeHandlerRegistry().register(typeHandler);\n      LOGGER.debug(() -> \"Registered type handler: '\" + typeHandler + \"'\");\n    });\n  }\n\n  targetConfiguration.setDefaultEnumTypeHandler(defaultEnumTypeHandler);\n\n  if (!isEmpty(this.scriptingLanguageDrivers)) {\n    Stream.of(this.scriptingLanguageDrivers).forEach(languageDriver -> {\n      targetConfiguration.getLanguageRegistry().register(languageDriver);\n      LOGGER.debug(() -> \"Registered scripting language driver: '\" + languageDriver + \"'\");\n    });\n  }\n  Optional.ofNullable(this.defaultScriptingLanguageDriver)\n      .ifPresent(targetConfiguration::setDefaultScriptingLanguage);\n\n  if (this.databaseIdProvider != null) {// fix #64 set databaseId before parse mapper xmls\n    try {\n      targetConfiguration.setDatabaseId(this.databaseIdProvider.getDatabaseId(this.dataSource));\n    } catch (SQLException e) {\n      throw new NestedIOException(\"Failed getting a databaseId\", e);\n    }\n  }\n\n  Optional.ofNullable(this.cache).ifPresent(targetConfiguration::addCache);\n// è¿™è¿™ä¹‹å‰,éƒ½æ˜¯å¯¹ä¸€äº›é…ç½®ä¿¡æ¯çš„è¯»å–,å¦‚æœæœ‰çš„è¯,å°±ä¼šè¿›è¡Œç›¸åº”çš„èµ‹å€¼ä¹‹ç±»çš„æ“ä½œ.\n    \n  if (xmlConfigBuilder != null) {\n    try {\n// æœ€åè¿™é‡Œçš„ parse è§£ææ–¹æ³•,æ˜¯å’Œå•ä¸ª Mybatisçš„è§£è¯»æ˜¯ä¸€æ ·çš„.        \n      xmlConfigBuilder.parse();\n      LOGGER.debug(() -> \"Parsed configuration file: '\" + this.configLocation + \"'\");\n    } catch (Exception ex) {\n      throw new NestedIOException(\"Failed to parse config resource: \" + this.configLocation, ex);\n    } finally {\n      ErrorContext.instance().reset();\n    }\n  }\n\n//è¿™é‡Œå¯ä»¥çœ‹äº‹åŠ¡å·¥å‚,æ˜¯ä½¿ç”¨äº†mybatis-springåŒ…ä¸‹çš„.\n  targetConfiguration.setEnvironment(new Environment(this.environment,\n      this.transactionFactory == null ? new SpringManagedTransactionFactory() : this.transactionFactory,\n      this.dataSource));\n\n// è¿™é‡Œæ˜¯å¤„ç† mapper.xml æ–‡ä»¶çš„é…ç½®,å¦‚æœåœ¨è¿™é‡Œæ˜¯æœ‰é…ç½®çš„è¯,é‚£ä¹ˆä¹Ÿæ˜¯ä¼šè¢«è§£æåˆ°çš„.    \n  if (this.mapperLocations != null) {\n    if (this.mapperLocations.length == 0) {\n      LOGGER.warn(() -> \"Property 'mapperLocations' was specified but matching resources are not found.\");\n    } else {\n      for (Resource mapperLocation : this.mapperLocations) {\n        if (mapperLocation == null) {\n          continue;\n        }\n        try {\n          XMLMapperBuilder xmlMapperBuilder = new XMLMapperBuilder(mapperLocation.getInputStream(),\n              targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());\n          xmlMapperBuilder.parse();\n        } catch (Exception e) {\n          throw new NestedIOException(\"Failed to parse mapping resource: '\" + mapperLocation + \"'\", e);\n        } finally {\n          ErrorContext.instance().reset();\n        }\n        LOGGER.debug(() -> \"Parsed mapper file: '\" + mapperLocation + \"'\");\n      }\n    }\n  } else {\n    LOGGER.debug(() -> \"Property 'mapperLocations' was not specified.\");\n  }\n//org.apache.ibatis.session.defaults.DefaultSqlSessionFactory,æœ€ååˆ°è¿™é‡Œä¹Ÿæ˜¯newäº†ä¸€ä¸ªmybatisåŒ…ä¸‹çš„é»˜è®¤SqlSessionFactoryç±».\n  return this.sqlSessionFactoryBuilder.build(targetConfiguration);\n}\n```\n\nå¯ä»¥çœ‹åˆ°è¯¥æ–¹æ³•ç»™äººæ„Ÿè§‰, å…ˆæ˜¯åˆ¤æ–­ä¸€äº›é…ç½®ä¿¡æ¯æ˜¯ä¸æ˜¯æœ‰å€¼ï¼Œå¦‚æœæ˜¯æœ‰å€¼çš„è¯ï¼Œå°±ä¼šè¿›è¡Œç›¸åº”çš„å¤„ç†ã€‚æœ€åè°ƒç”¨æˆ‘ä»¬åœ¨çœ‹å•ä¸ª mybatis çš„ parse è§£ææ–¹æ³•,æœ€ånewäº†ä¸€ä¸ªé»˜è®¤çš„sqlSessionFactoryå·¥å‚ç±»å‡ºæ¥.\n\n**MapperScannerConfigurer(org.mybatis.spring.mapper.MapperScannerConfigurer)**\n\næ¥ç€çœ‹,spring-beans.xml é‡Œé¢çš„ç¬¬äºŒä¸ªé…ç½®.\n\nå¯ä»¥çœ‹åˆ°è¯¥ç±»ï¼Œä¹Ÿæ˜¯å®ç°äº† spring çš„å¾ˆå¤šæ¥å£.\n\nBeanDefinitionRegistryPostProcessor : æ³¨å†ŒBeanDefinitionåˆ°Springå®¹å™¨ä¸­æ¥.\n\nApplicationContextAware : è·å– ApplicationContext\n\nBeanNameAware : è®¾ç½® beanNameåå­—.\n\nè¿™é‡Œä¹Ÿå¯ä»¥æŒ‰ç…§ä¸Šé¢çš„ç¬¨æ–¹æ³•ï¼Œä¸€æ¬¡å¯¹é‡å†™çš„æ–¹æ³•æ‰“ä¸Šæ–­ç‚¹. ç„¶åå¼€å¯æˆ‘ä»¬çš„debugæ¥çœ‹çœ‹æ–¹æ³•çš„æ‰§è¡Œé¡ºåº.\n\nå…¶æ‰§è¡Œé¡ºåº : setBeanName â€”> setApplicationContext â€”> afterPropertiesSet â€”> postProcessBeanDefinitionRegistry , è·Ÿç€è¿™å››ä¸ªæ–¹æ³•æ‰§è¡Œçš„é¡ºåºæ¥çœ‹.\n\n```\npublic class MapperScannerConfigurer\n    implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware { }\n```\n\nèµ‹å€¼ç»™ beanName å€¼. org.mybatis.spring.mapper.MapperScannerConfigurer#0\n\n```\n@Override\npublic void setBeanName(String name) {\n  this.beanName = name;\n}\n\n\n// ç„¶åè¿™é‡Œæ˜¯ç»™åˆ° ApplicationContext. è¿™ä¹Ÿå°±è¯´è¿™ä¸ªç±»ç°åœ¨æœ‰äº† ApplicationContext,å¯ä»¥æ ¹æ®contextæä¾›çš„apiæ¥è¿›è¡Œç›¸åº”çš„æ“ä½œ.\n  @Override\n  public void setApplicationContext(ApplicationContext applicationContext) {\n    this.applicationContext = applicationContext;\n  }\n\n// æ£€éªŒé…ç½®åŒ…çš„å€¼ä¸èƒ½ä¸ºnull.\n  @Override\n  public void afterPropertiesSet() throws Exception {\n    notNull(this.basePackage, \"Property 'basePackage' is required\");\n  }\n\n\n\n  /**\n   * {@inheritDoc}\n   * å¯ä»¥æ„Ÿå—åˆ°è¿™ä¸ªæ–¹æ³•, åœ¨æ‹¿åˆ°äº†BeanDefinitionRegistryçš„æƒ…å†µä¸‹,å¾€é‡Œé¢æ³¨å†Œbd.\n   * @since 1.0.2\n   */\n  @Override\n  public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {\n    if (this.processPropertyPlaceHolders) {\n      processPropertyPlaceHolders();\n    }\n\n// è¿™æ®µæ˜¯åˆ›å»ºäº†ä¸€ä¸ª ClassPathMapperScanner å¯¹è±¡,ç„¶åå¾€é‡Œé¢setå±æ€§.      \n    ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);\n    scanner.setAddToConfig(this.addToConfig);\n    scanner.setAnnotationClass(this.annotationClass);\n    scanner.setMarkerInterface(this.markerInterface);\n    scanner.setSqlSessionFactory(this.sqlSessionFactory);\n    scanner.setSqlSessionTemplate(this.sqlSessionTemplate);\n    scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName);\n    scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName);\n    scanner.setResourceLoader(this.applicationContext);\n    scanner.setBeanNameGenerator(this.nameGenerator);\n    scanner.setMapperFactoryBeanClass(this.mapperFactoryBeanClass);\n      \n    if (StringUtils.hasText(lazyInitialization)) {\n      scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));\n    }\n    if (StringUtils.hasText(defaultScope)) {\n      scanner.setDefaultScope(defaultScope);\n    }\n      \n// å¯¹registeré‡Œçš„ä¿¡æ¯è¿›è¡Œè¿‡æ»¤      \n    scanner.registerFilters();\n// org.springframework.context.annotation.ClassPathBeanDefinitionScanner#scan\n// è¿™é‡Œä¸»è¦çœ‹æ‰«æçš„æ–¹æ³•. æ ¹æ®,æ¥åˆ‡å‰²æˆ‘ä»¬å†™çš„ basePackage ä¿¡æ¯.æ‰«æç±»çš„ä¿¡æ¯,æœ€åè¿˜æ˜¯å€Ÿç”¨äº† org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan æ¥è¿›è¡Œæ‰«æçš„. //  doScan(basePackages) æ˜¯å¯¹ xml è¿›è¡Œæ‰«æçš„.\n// AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); æ˜¯å¯¹æ³¨è§£è¿›è¡Œæ‰«æçš„.\n// æœ€åè¿”å›æ³¨å†Œåˆ° Spring å®¹å™¨ä¸­çš„ bean ä¸ªæ•°\n// æ‰€ä»¥å¦‚æœæˆ‘ä»¬é…ç½®äº†ä¸‹é¢çš„æ ‡ç­¾,é‚£ä¹ˆåœ¨è¿™é‡Œéƒ½ä¼šè¢«æ‰«æåˆ°å¹¶ä¸”æ³¨å†Œåˆ°Springå®¹å™¨ä¸­.\n//     <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n//        <property name=\"basePackage\" value=\"com.iyang.sm.mapper\" ></property>\n//    </bean>\n// è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯:  org.mybatis.spring.mapper.ClassPathMapperScanner#processBeanDefinitions\n//   definition.setBeanClass(this.mapperFactoryBeanClass);  è¿™é‡Œçš„è¿™è¡Œä»£ç ,æ˜¯ç»™bdçš„beanClassç»™æ¢æˆäº† MapperFactoryBean.class , \n//  definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName);     // è¿™å¥ä»£ç ,å°† beanClassName ç»™åˆ° dbä¹‹å, ç„¶åå°±æ‰ç”¨ beanClassNameæ¥newä¸€ä¸ª MapperFactoryBean å¯¹è±¡æ¥, æ‰€ä»¥è¿™é‡Œå¹¶ä¸æ˜¯ä½¿ç”¨æ— å‚æ„é€ å‡½æ•°.\n// ä¹Ÿè®¸ä¼šé—®,æ€ä¹ˆè¯å®æ²¡æœ‰èµ°æ— å‚æ•°æ„é€ å‡½æ•°å‘¢ ? è€Œæ˜¯å»èµ°çš„ set æ–¹æ³•å‘¢ ? \n// å†ä¸èƒ½åŠ¨æºç çš„æƒ…å†µä¸‹, é¢å¯¹è¿™ç§æƒ…å†µæƒ…å†µæœ€å¥½çš„åŠæ³•å°±æ˜¯, åœ¨æ— å‚æ„é€ å‡½æ•°ä¸Šæ‰“ä¸Šæ–­ç‚¹.\n// å¦‚æœæ²¡èµ°åˆ°æ–­ç‚¹ä¸Š,é‚£å°±è¯´æ˜ä¸æ˜¯èµ°çš„æ— å‚æ„é€ å‡½æ•°æ¥åˆå§‹åŒ–çš„.      \n    scanner.scan(\n        StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));\n  }\n```\n\næ‰€ä»¥åˆ°è¿™é‡Œ, å¯ä»¥çœ‹åˆ° MyBatis ä¸ Spring æ•´åˆçš„è¿‡ç¨‹å°±å·²ç»å®Œæˆäº†.\n\næˆ‘ä»¬è¿™é‡Œæ˜¯ä¸»è¦å¯¹ SqlSessionFactoryBean å’Œ MapperScannerConfigurer æ¥è¿›è¡Œåˆ†æçš„, å¯ä»¥å¾ˆæ˜æ˜¾çš„æ„Ÿè§‰åˆ°,æˆ‘ä»¬æ˜¯é…ç½®å¥½è¿™äºŒä¸ªbeanå,å°±å¯ä»¥ä½¿ç”¨äº†. ç€é‡çœ‹ç¬¬äºŒä¸ª, org.mybatis.spring.mapper.MapperScannerConfigurer è¿™ä¸ªbean,å°±æ˜¯åšäº†å¦‚ä½•å°† MyBatis çš„ mapperæ¥å£æ–‡ä»¶ç»™åŠ è½½åˆ° Spring ä¸­æ¥çš„. **é‚£ä¹ˆè¿™é‡Œæˆ‘åœ¨æƒ³, å¦‚æœæœ‰å¤©æˆ‘è‡ªå·±å¼€å‘å‡ºä¸€ä¸ªå¥½ç”¨çš„æ¡†æ¶æ¥,è¦ä¸ Spring è¿›è¡Œæ•´åˆçš„è¯,æ˜¯ä¸æ˜¯ä¹Ÿè¿™æ ·æ•´åˆå°±å¯ä»¥äº†ï¼Ÿ**\n\n```\n<!-- é…ç½®sqlSessionFactoryï¼ŒSqlSessionFactoryBeanæ˜¯ç”¨æ¥äº§ç”ŸsqlSessionFactoryçš„ -->\n<bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n    <!-- åŠ è½½mybatisçš„å…¨å±€é…ç½®æ–‡ä»¶ï¼Œæ”¾åœ¨classpathä¸‹çš„mybatisæ–‡ä»¶å¤¹ä¸­äº† -->\n    <property name=\"configLocation\" value=\"mybatis/SqlMapConfig.xml\" />\n    <!-- åŠ è½½æ•°æ®æºï¼Œä½¿ç”¨ä¸Šé¢é…ç½®å¥½çš„æ•°æ®æº -->\n    <property name=\"dataSource\" ref=\"dataSource\" />\n</bean>\n\n<!--  é…ç½®æ‰«æ MyBatis æ¥å£çš„åŒ… -->\n<bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n    <property name=\"basePackage\" value=\"com.iyang.sm.mapper\" ></property>\n</bean>\n```\n\n#### æ€»ç»“\n\n å¯ä»¥çœ‹åˆ° MyBatis ä¸ Spring æ•´åˆå, å¯¹äºè§£æ MyBatis çš„ mapper é…ç½®æ–‡ä»¶ç­‰ï¼Œéƒ½æ˜¯èµ°çš„ä¹‹å‰å•ä¸ª mybatis çš„é€»è¾‘, æ˜¯æ²¡æœ‰ä»€ä¹ˆå˜åŒ–çš„. ä¸»è¦çš„æ˜¯å°† , SqlSessionFactory å’Œ Mapper.class(æ¥å£ç±») ç»™æ³¨å…¥åˆ° Spring å®¹å™¨ä¸­.ç„¶åæ¥å£çš„è¯, æ˜¯æ€ä¹ˆä½¿ç”¨çš„ä»£ç†ç±»æ¥è¿›è¡Œå®ä¾‹åŒ–å®Œå, å°†å¯¹è±¡ç»™æ³¨å…¥åˆ° Spring å®¹å™¨ä¸­çš„å‘¢ ï¼Ÿ è¿™é‡Œçœ‹ org.mybatis.spring.mapper.MapperScannerConfigurer åšçš„äº‹æƒ…å°±æ˜ç™½äº†.\n\n ä¸è¿‡åœ¨çœ‹ mybatis ä¸ Spring æ•´åˆçš„æ—¶å€™, è¿˜æ˜¯å»ºè®®è¦æœ‰å¯¹ BeanDefinitionRegistryPostProcessor / InitializingBean / ApplicationContextAware / BeanNameAware æœ‰ä¸€å®šçš„äº†æ¥. å°±æ˜¯æœ‰äº†äº†è§£å, ä½ å°±ä¼šå¾ˆæ˜æ˜¾çš„æ„Ÿå—åˆ°ï¼Œ mybatis ä¸ºä»€ä¹ˆæ˜¯å®ç°è¿™ä¸ªæ¥å£ï¼Œå®ç°è¿™ä¸ªæ¥å£å¹¶ä¸”é‡å†™è¿™ä¸ªæ–¹æ³•ï¼Œåœ¨åé¢æ˜¯ä»€ä¹ˆæ—¶å€™è¢«è°ƒç”¨çš„. æ„æ€ä¹Ÿå°±æ˜¯ï¼Œä½ è‡³å°‘å¾—æ˜ç™½ç‚¹ Spring å¯¹å¤–æä¾›çš„ä¸€äº›æ‰©å±•ç‚¹ï¼Œæ‰èƒ½å¾ˆå¥½çš„ç†è§£è¿™äº›ä¸œè¥¿.\n","tags":["javaæ¡†æ¶","mybatis"],"categories":["javaæ¡†æ¶","mybatis"]},{"title":"mybatiså·¥ä½œæµç¨‹é˜…è¯»","url":"/2021/11/04/mybatis/mybatiså·¥ä½œæµç¨‹é˜…è¯»/","content":"\n\n\n#### MyBatis çš„å·¥ç¨‹æµç¨‹åˆ†æ\n\n MyBatis æ˜¯æˆ‘ä»¬åœ¨å­¦ä¹ Javaæ¡†æ¶ï¼Œä¹Ÿå°±æ˜¯å­¦ä¹ å®ŒJavaWebçš„çŸ¥è¯†å,è¦å­¦ä¹ åˆ°çš„ä¸€ä¸ªORMçš„æ¡†æ¶. æˆ‘ä¹Ÿæ˜¯å­¦ä¹ &ä½¿ç”¨è¿‡åï¼Œå†æ¬¡å¯¹æºç è¿›è¡Œé˜…è¯»çš„. æ‰€ä»¥è¿™ç¯‡æ–‡ç« è®°å½• MyBatis çš„ä¸€ä¸ª work flow.\n\n å…ˆæ”¾ä¸Šé¡¹ç›®åœ°å€ : https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-work-flow\n\n æœ‰å…´è¶£çš„åŒå­¦,å¯ä»¥cloneä¸‹æ¥çœ‹çœ‹.\n\n#### æ¡ˆä¾‹ä»£ç \n\nå…ˆæ”¾ä¸Šæ¡ˆåˆ—çš„ä»£ç , ç„¶åæˆ‘ä»¬å¯ä»¥æŒ¨ä¸ªçš„åˆ†æ.\n\n```\npublic class InitHelloMyBatis {\n\n    public static void main(String[] args) throws IOException {\n        // è¯»å–é…ç½®æ–‡ä»¶.\n        InputStream mybatisInputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\n        // ä¼ å…¥è¯»å–é…ç½®æ–‡ä»¶çš„æµ,ä½¿ç”¨SqlSessionFactoryBuilderæ¥\n        // æ„å»º SqlSessionFactory.\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mybatisInputStream);\n        // ä» SqlSessionFactory ä¸­è·å–SqlSessionä¼šè¯.\n        SqlSession session = sqlSessionFactory.openSession();\n\n        // ä»ä¼šè¯ä¸­è·å– Mapper.\n        BlogMapper blogMapper = session.getMapper(BlogMapper.class);\n        \n        // è°ƒç”¨æŸ¥è¯¢æ–¹æ³•.\n        TbBlog tbBlog = blogMapper.selectBlog(1);\n        System.out.println(tbBlog);\n        \n    }\n\n}\n```\n\nè¿™é‡Œè¯´ä¸‹å¤§è‡´æµç¨‹ :\n\n- ä½¿ç”¨ Resources æ¥è¯»å– mybatis-config.xmlé…ç½®æ–‡ä»¶, å¦‚æœè¯¥æ–‡ä»¶ä¸å­˜åœ¨æˆ–è€…è¯»å–å‡ºæ¥ InputStream æ˜¯ null çš„è¯,ç¨‹åºå°±ä¼šæŠ›å‡º IOException çš„é”™è¯¯æ¥.\n- è¯»å–é…ç½®æ²¡æœ‰é—®é¢˜,æ¥åˆ° new SqlSessionFactoryBuilder().build(io) æ¥æ„å»ºå‡ºä¸€ä¸ª SqlSessionFactory æ¥, è¿™é‡Œæ„å»ºå‡ºæ¥çš„ SqlSessionFactory è‚¯å®šæ˜¯æœ‰å·²ç»è®²é…ç½®æ–‡ä»¶ç»™å…¨éƒ¨åŠ è½½è¿›å»äº†çš„.\n- SqlSessionFactory.openSession() ä» SqlSessionFactory ä¸­è·å–ä¸€æ¬¡ä¼šè¯, ç„¶åå¯ä»¥ä»ä¼šè¯ä¸­è·å–å‡ºæ¥å£(BlogMapper)æ¥,è¿™é‡Œæ˜¯ä¸æ˜¯æœ‰ç‚¹å¥½å¥‡,æ˜æ˜è¿™å°±æ˜¯ä¸€ä¸ªæ¥å£,ä¹Ÿæ²¡æœ‰å®ç°ç±»,æ€ä¹ˆå°±å¯ä»¥getå‡ºä¸€ä¸ªæ¥å£å¯¹è±¡æ¥?è·å–å‡ºæ¥å£æ¥,ç„¶åå°±å¯ä»¥è°ƒç”¨æ¥å£ä¸­çš„æ–¹æ³•, æ ¹æ®idæŸ¥è¯¢å‡ºæ•°æ®æ¥.\n\nå¯ä»¥çœ‹åˆ°,æ ¹æ®ä»å®˜ç½‘å†™çš„ä¸€ä¸ªåˆ—å­,ä»è¡¨é¢æ¥çœ‹,ä»£ç é‡å¹¶ä¸æ˜¯å¾ˆå¤š. æ‰€ä»¥æ¥ä¸‹æ¥ç‚¹å»æºç ,å»è·Ÿè¿›æºç ä¸­çš„æ¯ä¸ªæ–¹æ³•,åˆ°åº•åšäº†äº›ä»€ä¹ˆäº‹æƒ….\n\n**è¯»å–é…ç½®æ–‡ä»¶**\n\n```\nInputStream mybatisInputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\n```\n\norg.apache.ibatis.io.Resources (Class).\n\nå¯ä»¥çœ‹åˆ°MyBatisæºç è¿˜å†™äº†ä¸€ä¸ª ClassLoaderçš„åŒ…è£…ç±»ï¼Œé€šè¿‡ClassLoaderWrapperåŒ…è£…ç±»æ¥è®²é…ç½®æ–‡ä»¶è½¬åŒ–ä¸ºInputSream.\n\nå¦‚æœè¿”å›çš„InputStreamæ˜¯nullï¼Œå°±ä¼šæŠ›å‡ºIOExceptionæ¥.\n\n```\n/**\n * Returns a resource on the classpath as a Stream object\n *\n * @param loader   The classloader used to fetch the resource\n * @param resource The resource to find\n * @return The resource\n * @throws java.io.IOException If the resource cannot be found or read\n */\nprivate static ClassLoaderWrapper classLoaderWrapper = new ClassLoaderWrapper();\n\npublic static InputStream getResourceAsStream(ClassLoader loader, String resource) throws IOException {\n  // åˆ©ç”¨ ClasssLoaderWrapper.  \n  InputStream in = classLoaderWrapper.getResourceAsStream(resource, loader);\n  if (in == null) {\n    throw new IOException(\"Could not find resource \" + resource);\n  }\n  return in;\n}\n```\n\näºæ˜¯æˆ‘ä»¬æ¥ç€çœ‹ ClassLoaderWrapper æ˜¯æ€ä¹ˆ è¯»å–é…ç½®æ–‡ä»¶ & è½¬åŒ–ä¸º InputStream æµçš„.\n\n```\n// è¿™é‡Œè¿”å›çš„æ˜¯ ClassLoaderçš„æ•°ç»„,å¦‚æœå¯¹ClassLoaderä¸æ˜¯å¾ˆäº†è§£çš„è¯,å¯ä»¥å…ˆå»ç™¾åº¦äº†è§£ä¸‹.\nClassLoader[] getClassLoaders(ClassLoader classLoader) {\n  return new ClassLoader[]{\n      // ä¼ é€’è¿›æ¥çš„ \n      classLoader,\n      // é»˜è®¤çš„ ClassLoader\n      defaultClassLoader,\n      // æ ¹æ®å½“å‰çº¿ç¨‹è·å–å‡ºæ¥çš„\n      Thread.currentThread().getContextClassLoader(),\n      // æ ¹æ®å½“å‰ Class è·å–å‡ºæ¥çš„.\n      getClass().getClassLoader(),\n      // ç³»ç»Ÿçš„ClassLoader.\n      systemClassLoader};\n}\n\n\n// è·å–åˆ°äº† classLoaderçš„æ•°ç»„,ç„¶åå¯¹å…¶è¿›è¡Œè¿­ä»£.\n// ä¹Ÿå°±æ˜¯ä½¿ç”¨ ClassLoaderçš„  getResourceAsStream æ–¹æ³•,æ¥è®² mybatis-config.xml\n// é…ç½®æ–‡ä»¶è½¬åŒ–ä¸º InputStream.\n// æœ€åå¦‚æœè·å–åˆ°InputStreaméƒ½æ˜¯nullçš„è¯,é‚£ä¹ˆè¿”å›çš„ä¹Ÿå°±æ˜¯nulläº†.\n// æ ¹æ®ä¸Šé¢çš„è¯´æ³•,è¿”å›çš„å¦‚æœæ˜¯nullçš„è¯,å°±ä¼šå‡º IOExceptionæ¥.\nInputStream getResourceAsStream(String resource, ClassLoader[] classLoader) {\n    for (ClassLoader cl : classLoader) {\n      if (null != cl) {\n\n        // try to find the resource as passed\n        InputStream returnValue = cl.getResourceAsStream(resource);\n\n        // now, some class loaders want this leading \"/\", so we'll add it and try again if we didn't find the resource\n        if (null == returnValue) {\n          returnValue = cl.getResourceAsStream(\"/\" + resource);\n        }\n\n        if (null != returnValue) {\n          return returnValue;\n        }\n      }\n    }\n    return null;\n  }\n```\n\n**è‡³æ­¤,MyBatisè¯»å– mybatis-config.xml é…ç½®æ–‡ä»¶ä¹Ÿå°±æ˜¯è§£æå®Œæ¯•,å¯ä»¥çœ‹åˆ°é‡‡ç”¨äº†è‡ªå·±å†™çš„ ClassLoaderWrapperæ¥æ“ä½œçš„, ä¼ é€’ä¸€ç§ ClassLoaderè¿›æ¥,å…¶é»˜è®¤çš„&ç³»ç»Ÿ&çº¿ç¨‹çš„,åŠ ä¸€èµ·ä¹Ÿæ˜¯æœ‰å››ç§. æœ€åæŒ¨ä¸ªè¿›æ¥è¿­ä»£ï¼Œæ»¡è¶³æ¡ä»¶çš„ä¼šè¯»å–æ–‡ä»¶è½¬åŒ–ä¸ºInputStream,å¦‚æœéƒ½æ˜¯nullçš„è¯,ä¹Ÿä¼šè¿”å›null.**\n\n------\n\n**è·å–SqlSessionFactory & è§£æé…ç½®æ–‡ä»¶**\n\nnew SqlSessionFactoryBuilder() ä¹Ÿæ˜¯newäº†ä¸€ä¸ª SqlSessionFactoryBuild,ä¸ªäººç†è§£ SqlSessionFactoryBuilder å°±æ˜¯ä¸“ç¨‹ç”¨æ¥æ„å»ºå‡º SqlSessionFactory æ¥çš„,æ¯•ç«Ÿå…¶åé¢æœ‰ä¸€ä¸ª build æ–¹æ³•.\n\nProblem ? è¿™é‡Œæœ‰ä¸ªé—®é¢˜,ä¸ºä»€ä¹ˆä¸å°† SqlSessionFactoryBuilder çš„build æ–¹æ³•,ä¿®æ”¹ä¸ºé™æ€çš„ ? å¦‚æœä¿®æ”¹ä¸ºé™æ€çš„è¯ï¼Œé‚£å°±ä¸ç”¨newäº†,å°±å¯ä»¥ç›´æ¥ SqlSessionFactoryBuilder.build(mybatisInputStream);\n\n```\nSqlSessionFactory sqlSessionFactory = new                     SqlSessionFactoryBuilder().build(mybatisInputStream);\n```\n\n**SqlSessionFactory**\n\næ¥ç€æˆ‘ä»¬æ¥åˆ° SqlSessionFactory çš„ build æ–¹æ³•.\n\nè¿™é‡Œåœ¨ finnaly ä¸­, å¯ä»¥çœ‹åˆ° ErrorContext åˆ©ç”¨äº† ThreadLocal , åˆšå¥½è¿™å‘¨å‡ºäº† ThreadLocal çš„è§†é¢‘.\n\nè§†é¢‘åœ°å€ : https://www.bilibili.com/video/BV1Ga4y1W72w\n\næœ‰å…´è¶£&ä¹äºå­¦ä¹ &åˆ†äº«çš„,å¯ä»¥å…±åŒè¿›æ­¥.\n\n```\npublic SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {\n  try {\n    // åˆ©ç”¨ä¼ å…¥è¿›æ¥çš„å‚æ•°,newå‡ºæ¥äº†ä¸€ä¸ª XMLConfigBuilder.\n    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);\n    return build(parser.parse());\n  } catch (Exception e) {\n    throw ExceptionFactory.wrapException(\"Error building SqlSession.\", e);\n  } finally {\n    // è¿™é‡Œå¯¹ ThreadLocal ä¸­è¿›è¡Œ remove() æ“ä½œ   \n    ErrorContext.instance().reset();\n    try {\n      // å…³é—­æµ.  \n      inputStream.close();\n    } catch (IOException e) {\n      // Intentionally ignore. Prefer previous error.\n    }\n  }\n}\n```\n\nnew XmlConfigBuilder() æ–¹æ³•:\n\n```\npublic XMLConfigBuilder(InputStream inputStream, String environment, Properties props) {\n  // å…ˆnewä¸€ä¸ªXMLMapperEntityResolver,å†newä¸€ä¸ªXPathParser,ç„¶åå°±èµ°åˆ°ä¸‹é¢çš„æ„é€ å‡½æ•°.\n  this(new XPathParser(inputStream, true, props, new XMLMapperEntityResolver()), environment, props);\n}\n\n// æœ€åè¿˜æ˜¯èµ°åˆ°è¿™ä¸ªæ„é€ æ–¹æ³•ä¸­æ¥.\nprivate XMLConfigBuilder(XPathParser parser, String environment, Properties props) {\n  super(new Configuration());\n  ErrorContext.instance().resource(\"SQL Mapper Configuration\");\n  this.configuration.setVariables(props);\n  this.parsed = false;\n  this.environment = environment;\n  this.parser = parser;\n}\n\n\n----------------------------------------\n// new XPathParserä»£ç :\n    \n  public XPathParser(InputStream inputStream, boolean validation, Properties variables, EntityResolver entityResolver) {\n    // æ™®é€šçš„æ„é€ æ–¹æ³•.\n    // å¯¹ XPathParserçš„validation/entityResolver/variables/xpath\n    // çš„å±æ€§è¿›è¡Œèµ‹å€¼æ“ä½œ.\n    commonConstructor(validation, variables, entityResolver);\n    this.document = createDocument(new InputSource(inputStream));\n  }    \n\n\n// createDocument æ–¹æ³•\n  private Document createDocument(InputSource inputSource) {\n    // important: this must only be called AFTER common constructor\n    try {\n      // è¿™é‡Œé€šè¿‡debugçœ‹,è¿”å›çš„å¯¹è±¡æ˜¯DocumentBuilderFactoryImpl\n      // ä¹Ÿå°±æ˜¯å…¶å®ç°ç±».  \n      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n     // å¯¹ factory çš„ features(HashMap) æ·»åŠ å€¼,   \n      factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n     // å¯¹ factory çš„ validating è¿›è¡Œèµ‹å€¼  \n      factory.setValidating(validation);\n\t // è¿™ä¸‹é¢éƒ½æ˜¯å¯¹ factoryçš„å±æ€§è¿›è¡Œèµ‹å€¼æ“ä½œ.\t\n      factory.setNamespaceAware(false);\n      factory.setIgnoringComments(true);\n      factory.setIgnoringElementContentWhitespace(false);\n      factory.setCoalescing(false);\n      factory.setExpandEntityReferences(true);\n\t\t\n      // å¯ä»¥çœ‹åˆ° return new DocumentBuilderImpl\n      // æœ€åè¿”å›çš„ä¹Ÿæ˜¯å…¶å®ç°ç±». \n      DocumentBuilder builder = factory.newDocumentBuilder();\n      builder.setEntityResolver(entityResolver);\n      // è®¾ç½®é”™è¯¯çš„handler,å¯ä»¥çœ‹åˆ°ErrorHandleræ˜¯æ¥å£,è¿™é‡Œæ˜¯åŒ¿åå®ç°çš„\n      // ä¹Ÿå°±æ˜¯ç›´æ¥newäº†æ¥å£,ç„¶åé‡å†™å…¶æ–¹æ³•.  \n      builder.setErrorHandler(new ErrorHandler() {\n        @Override\n        public void error(SAXParseException exception) throws SAXException {\n          throw exception;\n        }\n\n        @Override\n        public void fatalError(SAXParseException exception) throws SAXException {\n          throw exception;\n        }\n\n        @Override\n        public void warning(SAXParseException exception) throws SAXException {\n          // NOP\n        }\n      });\n      //   DocumentBuilderImpl çš„ parse è§£ææ–¹æ³•\n      return builder.parse(inputSource);\n    } catch (Exception e) {\n      throw new BuilderException(\"Error creating document instance.  Cause: \" + e, e);\n    }\n  }\n\n-------------\n//   builder.parse(inputSource)\n\n    public Document parse(InputSource is) throws SAXException, IOException {\n        if (is == null) {\n            throw new IllegalArgumentException(\n                DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN,\n                \"jaxp-null-input-source\", null));\n        }\n    // fSchemaValidator æ˜¯ null ,è·³è¿‡.\n        if (fSchemaValidator != null) {\n            if (fSchemaValidationManager != null) {\n                fSchemaValidationManager.reset();\n                fUnparsedEntityHandler.reset();\n            }\n            resetSchemaValidator();\n        }\n  // ä½¿ç”¨ xml çš„ç›¸å…³ç±»å¯¹ is è¿›è¡Œè§£æ  \n        domParser.parse(is);\n //  ?   \n        Document doc = domParser.getDocument();\n // ? è¿™äº›è§£æ Document çš„åœ°æ–¹.....   \n        domParser.dropDocumentReferences();\n        return doc;\n    }    \n\n\n---------------\n// æœ€åçœ‹åˆ° this æ„é€ å‡½æ•°.\n\n  private XMLConfigBuilder(XPathParser parser, String environment, Properties props) {\n    /** new Configuration() ä¸­,TypeAliasRegistry typeAliasRegistryä¸­çš„ typeAliases,\n    *   åœ¨åˆå§‹åŒ–è¿™ä¸ªå¯¹è±¡çš„æ—¶å€™,å°±é»˜è®¤è®¾ç½®äº†ä¸€äº›åˆ«åé…ç½®.\n    *   åˆå§‹åŒ–çš„æ—¶å€™,è¿˜æœ‰å¯¹ LanguageDriverRegistry çš„ LANGUAGE_DRIVER_MAP èµ‹å€¼.\n    *  çˆ¶ç±» :  BaseBuilderæŠ½è±¡ç±».\n    *  ç„¶åè°ƒç”¨superæ–¹æ³•,å°†configurationèµ‹å€¼çˆ¶ç±»çš„configuration\n    *  åŒæ—¶å°† configurationçš„typeAliasRegistryå’ŒtypeHandlerRegistryä¹Ÿèµ‹å€¼\n    *  ç»™å½“å‰çš„è¿™ä¸ªå¯¹è±¡.\n    *   \n    */\n    super(new Configuration());\n    // instance() æ–¹æ³•æ˜¯å¾€ ThreadLocalé‡Œé¢å»setäº†ä¸€ä¸ªErrorContext\n    // æœ€åä¼šåœ¨finnalyä¸­è¿›è¡Œremoveæ‰.\n    ErrorContext.instance().resource(\"SQL Mapper Configuration\");\n    // å°† props èµ‹å€¼åˆ° configuration çš„ variable å‚æ•°.\n    this.configuration.setVariables(props);\n    // è¡¨ç¤ºè¿˜æ²¡æœ‰è¢«è§£æ\n    this.parsed = false;\n    this.environment = environment;\n    this.parser = parser;\n  }\n```\n\nåˆ°è¿™é‡Œ,å°±å¯ä»¥çœ‹åˆ° thisæ„é€ æ–¹æ³•ä»¥åŠå…¶ä¹‹å‰è¿˜æœ‰newå¯¹è±¡çš„æ–¹æ³•,éƒ½å·²ç»èµ°å®Œäº†. è¿™ä¸Šé¢çš„æ–¹æ³•,åŸºæœ¬éƒ½æ˜¯å†ä¸ºåé¢çš„è§£æxmlæ–‡ä»¶åšå‡†å¤‡, å¹¶ä¸”è¿˜æœ‰ä¸€äº›åˆå§‹åŒ–æ•°æ®çš„èµ‹å€¼æ“ä½œ.\n\n**Note** : æ³¨æ„è¿™é‡Œçš„ BaseBuilderæ˜¯æŠ½è±¡ç±»,å…¶å®ç°ç±»æ˜¯æœ‰å¥½å‡ ä¸ªçš„. è¿™ç§å†™æ³•,å…¶å®æ˜¯å°†å­ç±»çš„ä¸€äº›commonçš„æ–¹æ³•,å†™å…¥åˆ° BaseBuilderçˆ¶ç±»ä¸­,ç„¶åä¸åŒçš„æ–¹æ³•,éœ€è¦å­ç±»è‡ªå·±å»é‡å†™è¿™ä¸ªæ–¹æ³•å®ç°è‡ªå·±çš„ä¸šåŠ¡é€»è¾‘. å½“ç„¶ä¸€äº›å‚æ•°ä¹Ÿæ˜¯å¯ä»¥æ”¾åœ¨æŠ½è±¡ç±»ä¸­.\n\n**build(parser.parse())** : è§£æä»£ç .\n\nparser.parse() æ–¹æ³• :\n\n```\npublic Configuration parse() {\n  // ç”¨ parsed æ¥æ§åˆ¶æ˜¯å¦è§£æè¿‡,å¦‚æœå·²ç»è§£æè¿‡äº†,é‚£å°±æŠ›å‡ºå¼‚å¸¸.  \n  if (parsed) {\n    throw new BuilderException(\"Each XMLConfigBuilder can only be used once.\");\n  }\n  parsed = true;\n  //   \n  parseConfiguration(parser.evalNode(\"/configuration\"));\n  return configuration;\n}\n\n\n\n---------------------------------\n// parseConfiguration\n// è¿™é‡Œ debug å¯ä»¥çœ‹åˆ° root æ˜¯ configuration çš„é…ç½®æ–‡ä»¶ä¿¡æ¯.   \n// è¿™é‡Œå¯ä»¥åˆæ­¥çœ‹åˆ°å®å¯¹ æˆ‘ä»¬çš„é…ç½®æ–‡ä»¶mybatis-config.xmlè¿›è¡Œè§£æ,å¹¶ä¸”åŠ è½½åˆ° configurationä¸­.\n// åé¢æˆ‘ä»¬è·Ÿç€å®˜ç½‘æ–‡æ¡£ä¸€æ­¥ä¸€æ­¥çš„é˜…è¯»,ä¼šæœ‰ä¸“é—¨å¯¹è§£æé…ç½®çš„æºç è¿›è¡Œåˆ†æ.    \n  private void parseConfiguration(XNode root) {\n    try {\n      //issue #117 read properties first\n      //   \n      propertiesElement(root.evalNode(\"properties\"));\n      Properties settings = settingsAsProperties(root.evalNode(\"settings\"));\n      loadCustomVfs(settings);\n      loadCustomLogImpl(settings);\n      typeAliasesElement(root.evalNode(\"typeAliases\"));\n      pluginElement(root.evalNode(\"plugins\"));\n      objectFactoryElement(root.evalNode(\"objectFactory\"));\n      objectWrapperFactoryElement(root.evalNode(\"objectWrapperFactory\"));\n      reflectorFactoryElement(root.evalNode(\"reflectorFactory\"));\n      settingsElement(settings);\n      // read it after objectFactory and objectWrapperFactory issue #631\n      environmentsElement(root.evalNode(\"environments\"));\n      databaseIdProviderElement(root.evalNode(\"databaseIdProvider\"));\n      typeHandlerElement(root.evalNode(\"typeHandlers\"));\n      mapperElement(root.evalNode(\"mappers\"));\n    } catch (Exception e) {\n      throw new BuilderException(\"Error parsing SQL Mapper Configuration. Cause: \" + e, e);\n    }\n  }\n```\n\n**build(parser.parse()) æ–¹æ³•**\n\nè¿™é‡Œæ˜¯å¯¹ parser.parse() è°ƒç”¨ç©è¿”å›çš„ Configuration ä¼ å…¥åˆ°æ–°åˆ›å»ºçš„ DefaultSqlSessionFactory å¯¹è±¡ä¸­.\n\nä¹Ÿå°±æ˜¯è¯´,æˆ‘ä»¬æ‹¿åˆ°çš„ SqlSessionFactory æ˜¯ DefaultSqlSessionFactory.\n\n```\npublic SqlSessionFactory build(Configuration config) {\n  return new DefaultSqlSessionFactory(config);\n}\n```\n\n**è·å– SqlSession**\n\n```\nSqlSession session = sqlSessionFactory.openSession();\n\n// org.apache.ibatis.session.defaults.DefaultSqlSessionFactory#openSessionFromDataSource\n// çœ‹åˆ°è¿™ä¸ªæ–¹æ³•,ç›´æ¥è·Ÿè¿›åˆ°è¿™ä¸ªæ–¹æ³•æ¥.\n\n  private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {\n    Transaction tx = null;\n    try {\n        \n// ä» configurationä¸­è·å–å‡ºenvironmentæ¥,è¿™é‡Œçš„ getEnvironmentå¯¹åº”çš„æ˜¯\n// æ ‡ç­¾çš„ <environment>  é‡Œé¢çš„å†…å®¹\n// org.apache.ibatis.mapping.Environment\n// å¯ä»¥çœ‹åˆ°è¿™ä¸ªå¯¹è±¡,idå¯¹åº”mybatis-config.xmlä¸­çš„environment id\n// datasource å¯¹åº”  environment > dataSource å­—æ®µ.\n      final Environment environment = configuration.getEnvironment();\n// æ ¹æ®    environment æ¥è·å– TransactionFactory,ä¹Ÿå°±æ˜¯MyBatisçš„äº‹åŠ¡å·¥å‚.\n// debug æ˜¯å¯ä»¥çœ‹åˆ°  environment ä¸­æ˜¯æœ‰ä¸€ä¸ªJdbcTransactionFactoryçš„,\n// å¦‚æœæ²¡ç”¨çš„è¯,å°±ä¼šè‡ªå·±newä¸€ä¸ª ManagedTransactionFactory æ¥.        \n      final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);\n\n// åœ¨ JdbcTransactionFactory ä¸­newå‡ºäº†ä¸€ä¸ª JdbcTransaction\n// ä¹Ÿå°±æ˜¯newäº†ä¸€ä¸ªJDBCäº‹åŠ¡.\n// org.apache.ibatis.transaction.jdbc.JdbcTransaction,\n// å¯ä»¥çœ‹åˆ° JdbcTransaction ä¸­æœ‰commit / rollbackçš„æ–¹æ³•,\n// ä¹Ÿå°±æ˜¯è¯´è¿™ä¸ªåœ°æ–¹å°±æ˜¯å¯¹äº‹åŠ¡è¿›è¡Œæ“ä½œçš„åœ°æ–¹        \n      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);\n// è¿™é‡Œæ˜¯è·å–æ˜¯æ‰§è¡Œå™¨,\n// å…·ä½“ä»£ç : org.apache.ibatis.session.Configuration#newExecutor(org.apache.ibatis.transaction.Transaction, org.apache.ibatis.session.ExecutorType)\n// è¿™é‡Œæœ‰ SIMPLE, REUSE, BATCH ,CachingExecutor è¿˜å¯ä»¥åœ¨ plugin ä¸­è‡ªå·±å®šä¹‰.\n//executor = (Executor) interceptorChain.pluginAll(executor); ä»è¿™è¡Œä»£ç å¯ä»¥çœ‹åˆ°,\n// å…¶å®è¿˜æ˜¯å¯ä»¥è‡ªå·±æ‰©å±•çš„.        \n//org.apache.ibatis.plugin.InterceptorChain        \n      final Executor executor = configuration.newExecutor(tx, execType);\n// æœ€å new å‡ºäº†ä¸€ä¸ªé»˜è®¤çš„ SqlSession ä¼šè¯.\n// è¯¥ä¼šè¯ä¸­å­˜æœ‰ configuration / executor ç­‰æ ¸å¿ƒä¸œè¥¿.        \n      return new DefaultSqlSession(configuration, executor, autoCommit);\n    } catch (Exception e) {\n      closeTransaction(tx); // may have fetched a connection so lets call close()\n      throw ExceptionFactory.wrapException(\"Error opening session.  Cause: \" + e, e);\n    } finally {\n// æœ€åè¿˜æ˜¯ä¸å¿˜è®°å¯¹ä½¿ç”¨è¿‡çš„ThreadLocal è¿›è¡Œremove æ“ä½œ.        \n      ErrorContext.instance().reset();\n    }\n  }\n```\n\nè‡³æ­¤, å¯ä»¥çœ‹åˆ° MyBatis ä»SqlSessionFactoryä¸­è·å–å‡ºæ¥SqlSessionä¼šè¯, ä¹Ÿå¯ä»¥ç†è§£ä¸ºå‡ ä¸ªæ­¥éª¤.\n\né¦–å…ˆè·å–äº‹åŠ¡å·¥å‚, ç„¶åå†ä»äº‹åŠ¡å·¥å‚ä¸­è·å–ä¸€ä¸ªäº‹åŠ¡æ¥, JdbcTransaction æœ‰å…´è¶£çš„åŒå­¦å¯ä»¥çœ‹ä¸‹è¿™ä¸ªç±»,é‡Œé¢ä¹Ÿæ˜¯å°è£…äº†å†™ commit / rollbackç­‰æ–¹æ³•. å†æ¥ç€è·å–å‡º æ‰§è¡Œå™¨(Executor),è¿™é‡Œä»ä»£ç å“ªé‡Œçœ‹,æ‰§è¡Œå™¨è¿˜æ˜¯æœ‰å‡ ç§ç±»å‹çš„,ä¹Ÿæ‰§è¡Œè‡ªå®šä¹‰. æœ€ånewäº†ä¸€ä¸ª DefaultSqlSession å›å».\n\n**session.getMapper(BlogMapper.class);**\n\næ¥ç€çœ‹,ä¸Šä¸€æ­¥è¿”å›çš„session,æ˜¯æ€ä¹ˆè·å–åˆ°æˆ‘ä»¬å†™çš„Mapperæ¥å£æ–‡ä»¶(Mapperè¿™ç§æ–‡ä»¶,åœ¨è§£æé…ç½®æ–‡ä»¶çš„æ—¶å€™,å…¶å®å°±å·²ç»è§£æåˆ°MyBatisçš„configurationé‡Œé¢å»äº†).\n\n```\n@SuppressWarnings(\"unchecked\")\npublic <T> T getMapper(Class<T> type, SqlSession sqlSession) {\n // knownMappers  ä¸­ key æ˜¯æˆ‘ä»¬å®šä¹‰æ¥å£çš„Class,valueæ˜¯MapperProxyFactory,\n// MapperProxyFactoryä¸­çš„mapperInterfaceä¸­å­˜æ”¾äº†æˆ‘ä»¬çš„æ¥å£class    \n  final MapperProxyFactory<T> mapperProxyFactory = (MapperProxyFactory<T>) knownMappers.get(type);\n    \n// å¦‚æœè·å–å‡ºæ¥çš„æ˜¯null,é‚£ä¹ˆMyBatiså°±è®¤ä¸ºä½ ä¼ å…¥è¿›æ¥çš„æ¥å£æ˜¯ä¸å­˜åœ¨çš„,å°±ä¼šæŠ›å‡ºå¼‚å¸¸æ¥.    \n  if (mapperProxyFactory == null) {\n    throw new BindingException(\"Type \" + type + \" is not known to the MapperRegistry.\");\n  }\n  try {\n// æ»¡è¶³æ¡ä»¶çš„è¯,è°ƒç”¨newInstanceæ–¹æ³•,ä»æ–¹æ³•åå­—ä¸Šçœ‹,æ˜¯åˆ›å»ºä¸€ä¸ªinstanceçš„å®ä¾‹.      \n    return mapperProxyFactory.newInstance(sqlSession);\n  } catch (Exception e) {\n    throw new BindingException(\"Error getting mapper instance. Cause: \" + e, e);\n  }\n}\n\n-------------------------------------------\n// mapperProxyFactory.newInstance(sqlSession) ä»£ç \n\n    \n  public T newInstance(SqlSession sqlSession) {\n    // new äº†ä¸€ä¸ª MapperProxyå¯¹è±¡.\n    final MapperProxy<T> mapperProxy = new MapperProxy<>(sqlSession, mapperInterface, methodCache);\n    return newInstance(mapperProxy);\n  }    \n\n// æœ€åå¯ä»¥çœ‹åˆ°ä½¿ç”¨ Proxy.newProxyInstanceæ–¹æ³•æ¥åˆ›å»ºçš„ä¸€ä¸ªå¯¹è±¡.\n  @SuppressWarnings(\"unchecked\")\n  protected T newInstance(MapperProxy<T> mapperProxy) {\n    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);\n  }\n\n\n\n-------\n// å¦‚æœä½ æ˜¯debugæ¨¡å¼çš„è¯,é‚£ä¹ˆä½ å¯ä»¥çœ‹åˆ°BlogMapperçš„å¯¹è±¡åœ°å€æ± åœ¨ debug ä¸­æ˜¾ç¤ºçš„å€¼.\n// org.apache.ibatis.binding.MapperProxy@ef9296d    \nBlogMapper blogMapper = session.getMapper(BlogMapper.class);\n```\n\nä»SqlSession ä¸­è·å– BlogMapperæˆ‘ä»¬å†™çš„mapperæµç¨‹, å…ˆä» knownMappers ä¸­æ ¹æ®keyè·å–å‡ºæ¥ä¹‹å‰åŠ è½½é…ç½®å·²ç»åŠ è½½å®Œæ¯•çš„ä¿¡æ¯,å¦‚æœæ²¡ç”¨çš„è¯,å°±ä¼šæŠ›å‡ºæ²¡æœ‰çš„å¼‚å¸¸. æœ€åä½¿ç”¨ Proxy.newProxyIntsanceæ¥ç”Ÿæˆçš„ä¸€ä¸ªç±»ä¼¼æ¥å£å®ç°ç±»çš„ä»£ç ,ä¸åŒçš„æ˜¯, åœ¨ new MapperProxy çš„æ—¶å€™,å°±å·²ç»å°†æ¥ä¸‹æ¥éœ€è¦çš„ä¿¡æ¯å…¨éƒ¨ä¼ å…¥è¿›å».\n\n**blogMapper.selectBlog(1) æ–¹æ³•**\n\nç«Ÿç„¶ BlogMapperæ˜¯é€šè¿‡Proxy.newInstanceè·å–å‡ºæ¥çš„,é‚£å®ƒæ˜¯æ€ä¹ˆæŸ¥è¯¢çš„æ•°æ®åº“? åˆæ˜¯æ€ä¹ˆå°†å­—æ®µç»™æ˜ å°„åˆ° Objectä¸€ä¸€å¯¹åº”çš„å‘¢ ?\n\ndebugä¼šèµ°åˆ° MapperProxyçš„invokeæ–¹æ³•æ¥\n\n```\n@Override\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n  try {\n    if (Object.class.equals(method.getDeclaringClass())) {\n      return method.invoke(this, args);\n    } else {\n      return cachedInvoker(method).invoke(proxy, method, args, sqlSession);\n    }\n  } catch (Throwable t) {\n    throw ExceptionUtil.unwrapThrowable(t);\n  }\n}\n\n\n\n------------------\n// é€šè¿‡ invoke æ–¹æ³•, èµ° mapperMethodçš„executeæ–¹æ³•,æ¥åˆ°äº†è¿™é‡Œ.\n// switch æœ‰ INSERT/UPDATE/DELETE/SELECT/FLUSH,å¦‚æœè¿™å‡ ç§æ²¡æœ‰åŒ¹é…åˆ°çš„è¯,å°±ä¼šæŠ›å‡ºå¼‚å¸¸æ¥.    \n  public Object execute(SqlSession sqlSession, Object[] args) {\n    Object result;\n    switch (command.getType()) {\n            \n// ä¸éš¾çœ‹åˆ° INSERT/UPDATE/DELETEéƒ½æ˜¯å…ˆè°ƒç”¨ convertArgsToSqlCommandParam æ–¹æ³•,\n// ä¹Ÿå°±æ˜¯å…ˆå°†å‚æ•°è½¬åŒ–ä¸ºsql,ç„¶åå°†æ‰§è¡Œçš„ç»“æœ èµ‹å€¼ ç»™ result å‚æ•°.            \n      case INSERT: {\n        Object param = method.convertArgsToSqlCommandParam(args);\n        result = rowCountResult(sqlSession.insert(command.getName(), param));\n        break;\n      }\n      case UPDATE: {\n        Object param = method.convertArgsToSqlCommandParam(args);\n        result = rowCountResult(sqlSession.update(command.getName(), param));\n        break;\n      }\n      case DELETE: {\n        Object param = method.convertArgsToSqlCommandParam(args);\n        result = rowCountResult(sqlSession.delete(command.getName(), param));\n        break;\n      }\n// å¦‚æœæ˜¯ select è¯­å¥,å¯ä»¥æ ¹æ®è¿”å›å€¼æ¥åˆ†ç±»,å¦‚æœæ˜¯void&&method.hasResultHandler,å°±ä¼šè¿”å›null\n// å¤šä¸ª / Mapç±»å‹  /    Cursor ç±»å‹   /  æœ€åæŸ¥è¯¢ä¸€ä¸ª        \n      case SELECT:\n        if (method.returnsVoid() && method.hasResultHandler()) {\n          executeWithResultHandler(sqlSession, args);\n          result = null;\n        } else if (method.returnsMany()) {\n          result = executeForMany(sqlSession, args);\n        } else if (method.returnsMap()) {\n          result = executeForMap(sqlSession, args);\n        } else if (method.returnsCursor()) {\n          result = executeForCursor(sqlSession, args);\n        } else {\n          Object param = method.convertArgsToSqlCommandParam(args);\n          result = sqlSession.selectOne(command.getName(), param);\n          if (method.returnsOptional()\n              && (result == null || !method.getReturnType().equals(result.getClass()))) {\n            result = Optional.ofNullable(result);\n          }\n        }\n        break;\n // åˆ·æ–°ä¼šè¯.           \n      case FLUSH:\n        result = sqlSession.flushStatements();\n        break;\n      default:\n        throw new BindingException(\"Unknown execution method for: \" + command.getName());\n    }\n// å¦‚æœresult æ˜¯ null, æ–¹æ³•è¿”å›çš„ä¿®é¥°ç¬¦æ˜¯privateå¹¶ä¸” è¿”å›å€¼ä¸æ˜¯voidçš„è¯,å°±ä¼šæŠ›å‡ºå¼‚å¸¸.    \n    if (result == null && method.getReturnType().isPrimitive() && !method.returnsVoid()) {\n      throw new BindingException(\"Mapper method '\" + command.getName()\n          + \" attempted to return null from a method with a primitive return type (\" + method.getReturnType() + \").\");\n    }\n    return result;\n  }\n```\n\nè¿™é‡Œå¯ä»¥çœ‹åˆ°,å…ˆæ˜¯å¯¹ INSERT / UPDATE / DELETE / SELECT è¿›è¡Œåˆ†ç±»å¤„ç†, ç„¶åå¯¹å†åˆ†åˆ«æ ¹æ®ä¸åŒçš„ç±»å‹è¿›è¡Œå¤„ç†. éƒ½æ˜¯å…ˆæœ‰è½¬åŒ–ä¸ºsql,ç„¶åå°†æ‰§è¡Œç»“æœèµ‹å€¼ç»™result.\n\nè‡³äºé‡Œé¢è¯¦ç»†çš„æŸ¥è¯¢æ‰§è¡Œsql,è¿˜æœ‰åŠ¨æ€sql,æ¯æ¬¡ä¼šè¯ç¼“å­˜ç­‰,åé¢çœ‹åˆ°è¯¦ç»†çš„æƒ…å†µå†ä¸€ä¸€è¯´æ˜. è¿™é‡Œåªæ˜¯å¯¹MyBatisçš„åŸºæœ¬å·¥ä½œè¿›è¡Œäº†ä¸€ä¸ªæ¢³ç†. ç„¶ååé¢å†æ ¹æ®åŸºç¡€æ¢³ç†,å†æ¥æŒ¨ä¸ªå‡»ç¢ä»–ä»¬.\n\nè‡³æ­¤, MyBatisçš„å…¥é—¨åˆ†ææµç¨‹æ˜¯ç»“æŸçš„. ç†è§£èµ·æ¥,åº”è¯¥è¿˜ä¸æ˜¯é‚£ä¹ˆéš¾.\n\n#### æ€»ç»“\n\næ ¹æ® com.iyang.mybatis.InitHelloMyBatis , ä¹Ÿå°±æ˜¯å…¥é—¨çš„demoæ¥æ¢³ç†ä¸‹æµç¨‹.\n\n1. è¯»å–é…ç½®æ–‡ä»¶,ä¹Ÿå°±æ˜¯å°†é…ç½®æ–‡ä»¶è¯»å–,è½¬åŒ–ä¸ºinptStreamæµ.\n2. åˆ©ç”¨ SqlSessionFactoryBuilder æ¥ è§£ææµ, èµ·å†…éƒ¨åˆåˆ©ç”¨ BaseBuilder(å…¶åˆå¾ˆå¤šå®ç°ç±»,è¿™é‡Œç”¨çš„XMLConfigBuilder)ä¹Ÿè§£æxmlé…ç½®æ–‡ä»¶. Configuration configuration è¯¥ç±»ä¸­æ˜¯ä¿å­˜ç€xmlé…ç½®æ–‡ä»¶çš„å¾ˆå¤šä¿¡æ¯. ç„¶å DefaultSqlSessionFactory ä¸­æœ‰configurationå­—æ®µ,ä¹Ÿå°±æ˜¯å±æ€§.\n3. ç„¶åä» DefaultSqlSessionFactory ä¸­è·å– SqlSessionæ¥, å¹¶ä¸”ä¹Ÿä¼šæ˜¯å¦å¼€å¯äº‹åŠ¡(å‚è€ƒ:org.apache.ibatis.transaction.jdbc.JdbcTransaction)ç±»,ç„¶åè·å– Executor,Executorä¹Ÿæ˜¯æœ‰å‡ ç§ç§ç±»çš„,ä¹Ÿå¯ä»¥è‡ªå·±è‡ªå®šä¹‰,æœ€åè¿”å›ä¸€ä¸ª DefaultSqlSession æ¥.\n4. ç„¶åä» SqlSession ä¸­è·å–æˆ‘ä»¬çš„æ¥å£Mapper, æœ€åä¹Ÿæ˜¯åˆ©ç”¨ Proxy.newProxyInstance æ¥ç”Ÿæˆçš„æ¥å£,ä¹Ÿå°±æ˜¯ä»£ç†(è¿™é‡Œæ‰“å°å‡ºåœ°å€æ± æˆ–è€…debugçœ‹åœ°å€æ± ,å°±ä¼šå¾ˆæ˜æ˜¾çš„çœ‹åˆ°æ˜¯ä»£ç†å¯¹è±¡).\n5. æœ€åèµ°æŸ¥è¯¢çš„æ–¹æ³•, ä¹Ÿå°±æ˜¯èµ°åˆ°äº† MapperProxy æ¥. å¯ä»¥çœ‹åˆ°MapperProxyé‡Œé¢æ˜¯æœ‰sqlSessionçš„,è€ŒSqlSessionæ˜¯æœ‰ Executor/configuration/autoCommitç­‰ä¿¡æ¯çš„, æœ‰äº†sqlSession,å°±å‰©ä¸‹æ‰§è¡Œsqlå’Œæ˜ å°„sqlæŸ¥è¯¢å‡ºæ¥çš„ç»“æœæ¥äº†(è¿™é‡Œæ˜¯ mapperMethod.execute(sqlSession, args) â€”> org.apache.ibatis.binding.MapperMethod#execute èµ°åˆ°è¿™é‡Œæ¥äº†,è¿™é‡Œä¹‹åå°±ä¼šåˆ†ç±»è¿›è¡Œå¤„ç†,ç„¶åæ˜ å°„sqlè¯­å¥).\n6. è‡³æ­¤,ä¸€ä¸ª MyBatis çš„ HelloWorldåˆ†ææµç¨‹æ˜¯å®Œæ¯•çš„.\n","tags":["javaæ¡†æ¶","mybatis"],"categories":["javaæ¡†æ¶","mybatis"]},{"title":"mybatisä¸­mapperæ–‡ä»¶é˜…è¯»","url":"/2021/11/04/mybatis/mybatisä¸­mapperæ–‡ä»¶é˜…è¯»/","content":"\n\n\n#### é¢˜è®°\n\nMyBatisæ˜¯å¦‚ä½•å¯¹ Mapper æ–‡ä»¶ä¸­çš„sqlè¿›è¡Œå¤„ç†å‘¢ï¼Ÿ è™½ç„¶ä¸Šç¯‡è§£æ mybatis-config.xml æ˜¯æœ‰è¿›è¡Œè¯´æ˜çš„, ä½†æ˜¯åº”è¯¥æ‹¿å‡ºæ¥å•ç‹¬ä»”ç»†è§£æä¸‹. å› ä¸ºè¿™ä¸ªé‡Œé¢æ¶‰åŠåˆ°åŠ¨æ€sql, åŠ ä¸Šmapperæ–‡ä»¶è‡ªèº«ä¹Ÿæœ‰å¾ˆå¤šæ ‡ç­¾å†…å®¹,ç„¶åMyBatisæ˜¯æ€ä¹ˆè¯»å–å‡ºè¿™äº›å†…å®¹çš„å‘¢ï¼Ÿè¯»å–å‡ºæ¥å,åˆæ˜¯åšäº†æ€ä¹ˆæ ·çš„å¤„ç†, ç„¶åè¾¾åˆ°äº†sqlé‚£ç§æ‰§è¡Œæ•ˆæœçš„å‘¢ï¼Ÿ\n\næ„æ€ä¹Ÿå°±æ˜¯,Mapper + åŠ¨æ€sql , å†…å®¹è¿˜æ˜¯æœ‰ç‚¹å¤šçš„, å¹¶ä¸”ä¹Ÿå¾ˆé‡è¦, æ˜¯éå¸¸æœ‰å¿…è¦æ‹¿å‡ºæ¥å•ç‹¬çš„ä»”ç»†è®²è§£ä¸‹çš„.\n\n#### Target\n\nåœ¨ä¹‹å‰å¯¹æ ‡ç­¾çš„è¿›è¡Œè§£æçš„æ—¶å€™,æ˜¯æœ‰å¯¹ æ ‡ç­¾è¿›è¡Œä¸€ä¸ªåˆæ­¥çš„è§£æ. ç„¶åé‡Œé¢å…¶å®æ˜¯å¾ˆå¤šå†…å®¹è¿˜æ²¡å¡«è¡¥å¾ˆè¯¦ç»†,æ‰€ä»¥ç‰¹æ„è®°å½•ä¸‹å¯¹ è¯¦ç»†æ“ä½œçš„. é‚£ä¹ˆï¼Œä¸‹æ–‡å°±å¼€å§‹æ“ä½œå§.\n\n**org.apache.ibatis.builder.xml.XMLMapperBuilder#parse**\n\nä¸»è¦æ¥çœ‹è¿™æ®µè§£æçš„ä»£ç  :\n\n```\npublic void parse() {\n    \n// åˆ©ç”¨ org.apache.ibatis.session.Configuration çš„ loadedResources\n// æ¥åˆ¤æ–­æ˜¯ä¸æ˜¯å·²ç»åŠ è½½è¿‡äº†çš„.    \n  if (!configuration.isResourceLoaded(resource)) {\n    configurationElement(parser.evalNode(\"/mapper\"));\n// è¿™é‡Œæ·»åŠ åˆ° loadedResources ä¸­æ¥,ä¹Ÿå°±æ˜¯ç”¨æ¥æ§åˆ¶æ˜¯ä¸æ˜¯å·²ç»è§£æè¿‡äº†çš„.      \n    configuration.addLoadedResource(resource);\n    bindMapperForNamespace();\n  }\n\n// è¿™ä¸‰ä¸ªæ–¹æ³•ç»™æˆ‘ä¸€ç§å¥½åƒè§£æé‚£ç§æ²¡æœ‰è¿˜æ²¡è§£æå®Œçš„ ? è¿™ä¸ªåœ°æ–¹æœ‰å¾…å®Œå–„.    \n  parsePendingResultMaps();\n  parsePendingCacheRefs();\n  parsePendingStatements();\n}\n\n\n// configurationElement æ–¹æ³•,\n// å¯ä»¥çœ‹åˆ°è¿™ä¸ªæ–¹æ³•ä¸­,å¾ˆå¤šæ ‡ç­¾(namespace/parameterMa/resultMap/sql)\n// è¿˜æœ‰ä¸‹é¢çš„select/insert/update/delete\n// è¿™äº›ç†Ÿæ‚‰çš„æ ‡ç­¾\n  private void configurationElement(XNode context) {\n    try {\n      String namespace = context.getStringAttribute(\"namespace\");\n      if (namespace == null || namespace.equals(\"\")) {\n        throw new BuilderException(\"Mapper's namespace cannot be empty\");\n      }\n// å°† namespace èµ‹å€¼è¿›å»,ä¹Ÿå°±æ˜¯å½“å‰æ­£åœ¨è§£æçš„ namespace.        \n      builderAssistant.setCurrentNamespace(namespace);\n        \n// è¿™é‡Œæ˜¯å¯¹ç¼“å­˜æ ‡ç­¾è¿›è¡Œè§£æ.        \n      cacheRefElement(context.evalNode(\"cache-ref\"));\n      cacheElement(context.evalNode(\"cache\"));\n \n// è§£æ parameterMapæ ‡ç­¾        \n      parameterMapElement(context.evalNodes(\"/mapper/parameterMap\"));\n        \n//         \n      resultMapElements(context.evalNodes(\"/mapper/resultMap\"));\n      sqlElement(context.evalNodes(\"/mapper/sql\"));\n      buildStatementFromContext(context.evalNodes(\"select|insert|update|delete\"));\n    } catch (Exception e) {\n      throw new BuilderException(\"Error parsing Mapper XML. The XML location is '\" + resource + \"'. Cause: \" + e, e);\n    }\n  }\n```\n\n**resultMapElements æ–¹æ³• :**\n\n```\n// è¿™é‡Œçš„ list æ˜¯ xml æ–‡ä»¶ä¸­çš„æ‰€æœ‰ <resultMap> æ ‡ç­¾æ–‡ä»¶.\nprivate void resultMapElements(List<XNode> list) {\n  for (XNode resultMapNode : list) {\n    try {\n//  æœ‰ç‚¹å¥½å¥‡,è¯¥æ–¹æ³•è¿”å›çš„ ResultMap è¿™è¾¹å¥½åƒå¹¶æ²¡æœ‰å‚æ•°,æœ‰ç‚¹å°´å°¬.\n//  ä¸è¿‡æ˜¯å·²ç»å­˜å‚¨åœ¨ org.apache.ibatis.session.Configuration#resultMaps ä¸­.       \n      resultMapElement(resultMapNode);\n    } catch (IncompleteElementException e) {\n      // ignore, it will be retried\n    }\n  }\n}\n\n----------\n// æœ€åè·Ÿè¿›åˆ°è¿™ä¸ªæ–¹æ³•ä¸­æ¥.\n  private ResultMap resultMapElement(XNode resultMapNode, List<ResultMapping> additionalResultMappings, Class<?> enclosingType) {\n    ErrorContext.instance().activity(\"processing \" + resultMapNode.getValueBasedIdentifier());\n \n// è·å–å‡º type , è¿™é‡Œæˆ‘ä»¬è·å–å‡ºæ¥çš„ type æ˜¯ TbBlog.    \n    String type = resultMapNode.getStringAttribute(\"type\",\n        resultMapNode.getStringAttribute(\"ofType\",\n            resultMapNode.getStringAttribute(\"resultType\",\n                resultMapNode.getStringAttribute(\"javaType\"))));\n// å…ˆåˆ¤æ–­ org.apache.ibatis.type.TypeAliasRegistry#typeAliases ä¸­æœ‰æ²¡æœ‰,\n// å¦‚æœæ²¡æœ‰çš„è¯,å°±ä¼šè‡ªå·±newä¸€ä¸ªå‡ºæ¥.    \n    Class<?> typeClass = resolveClass(type);\n    if (typeClass == null) {\n// TODO,å¦‚æœæ²¡æœ‰è¯?        \n      typeClass = inheritEnclosingType(resultMapNode, enclosingType);\n    }\n    Discriminator discriminator = null;\n    List<ResultMapping> resultMappings = new ArrayList<>(additionalResultMappings);\n    \n // è·å–è¯¥ <resultMap> ä¸‹çš„å­æ ‡ç­¾\n// é‚£ä¹ˆè¿™é‡Œä¹Ÿå°±æ˜¯è·å– <id> å’Œ <result> è¿™äºŒä¸ª.    \n    List<XNode> resultChildren = resultMapNode.getChildren();\n    for (XNode resultChild : resultChildren) {\n// åˆ†ä¸º constructor / discriminator / å…¶ä»– è¿™ä¸‰ç±»æƒ…å†µ        \n      if (\"constructor\".equals(resultChild.getName())) {\n        processConstructorElement(resultChild, typeClass, resultMappings);\n      } else if (\"discriminator\".equals(resultChild.getName())) {\n        discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);\n      } else {\n // éå‰äºŒè€…æƒ…å†µ.         \n        List<ResultFlag> flags = new ArrayList<>();\n        if (\"id\".equals(resultChild.getName())) {\n         // å¦‚æœæ ‡ç­¾æ˜¯idçš„è¯,å°±ä¼šç»™flagsæ·»åŠ ResultFlag.ID.\n          flags.add(ResultFlag.ID);\n        }\n  //  å°†è¿”å›å›æ¥çš„ ResultMapping æ·»åŠ è¿›æ¥.       \n        resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));\n      }\n    }\n// è¿™é‡Œè·å–çš„æ˜¯ <resultMap> æ ‡ç­¾çš„ id å­—æ®µ.    \n    String id = resultMapNode.getStringAttribute(\"id\",\n            resultMapNode.getValueBasedIdentifier());\n// è¿™é‡Œè¿˜å¯ä»¥ä½¿ç”¨ extends å±æ€§, ä¸æ˜¯çœ‹åˆ°è¿™é‡Œ, éƒ½å¥½å¥‡è¿˜æœ‰è¿™ç§æ ‡ç­¾.    \n    String extend = resultMapNode.getStringAttribute(\"extends\");\n    Boolean autoMapping = resultMapNode.getBooleanAttribute(\"autoMapping\");\n// è¿™é‡Œ new äº†ä¸€ä¸ª ResultMapResolver å¯¹è±¡.   \n    ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);\n    try {\n// è¿™é‡Œæœ€åå°±æ˜¯ new äº†ä¸€ä¸ª ResultMap å¯¹è±¡, è¯¥å¯¹è±¡çš„ id æ˜¯ namespace + æ–¹æ³•ID æ‹¼æ¥.\n// ç„¶åå°†è¯¥å¯¹è±¡ç»™æ·»åŠ åˆ°  org.apache.ibatis.session.Configuration#resultMaps ä¸­æ¥,\n// key å°±æ˜¯å…¶id, æœ€åå°±æ˜¯æ ¹æ® local / global æ¥åˆ†åˆ«è¿›è¡ŒäºŒç§æƒ…å†µæ£€æŸ¥.        \n      return resultMapResolver.resolve();\n    } catch (IncompleteElementException  e) {\n      configuration.addIncompleteResultMap(resultMapResolver);\n      throw e;\n    }\n  }    \n\n\n//  buildResultMappingFromContext æ–¹æ³•\n// è¯¥æ–¹æ³•æ˜¯å¯¹ resultMap ä¸­çš„å­—æ®µè¿›è¡Œè§£æ.\n  private ResultMapping buildResultMappingFromContext(XNode context, Class<?> resultType, List<ResultFlag> flags) {\n    String property;\n    if (flags.contains(ResultFlag.CONSTRUCTOR)) {\n      property = context.getStringAttribute(\"name\");\n    } else {\n      property = context.getStringAttribute(\"property\");\n    }\n    String column = context.getStringAttribute(\"column\");\n    String javaType = context.getStringAttribute(\"javaType\");\n    String jdbcType = context.getStringAttribute(\"jdbcType\");\n    String nestedSelect = context.getStringAttribute(\"select\");\n    String nestedResultMap = context.getStringAttribute(\"resultMap\", () ->\n      processNestedResultMappings(context, Collections.emptyList(), resultType));\n    String notNullColumn = context.getStringAttribute(\"notNullColumn\");\n    String columnPrefix = context.getStringAttribute(\"columnPrefix\");\n    String typeHandler = context.getStringAttribute(\"typeHandler\");\n    String resultSet = context.getStringAttribute(\"resultSet\");\n    String foreignColumn = context.getStringAttribute(\"foreignColumn\");\n    boolean lazy = \"lazy\".equals(context.getStringAttribute(\"fetchType\", configuration.isLazyLoadingEnabled() ? \"lazy\" : \"eager\"));\n      \n// è·å– javaType , typeHandler , jdbcType ç­‰å¯¹è±¡.      \n    Class<?> javaTypeClass = resolveClass(javaType);\n    Class<? extends TypeHandler<?>> typeHandlerClass = resolveClass(typeHandler);\n    JdbcType jdbcTypeEnum = resolveJdbcType(jdbcType);\n// org.apache.ibatis.builder.MapperBuilderAssistant#buildResultMapping(java.lang.Class<?>, java.lang.String, java.lang.String, java.lang.Class<?>, org.apache.ibatis.type.JdbcType, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.Class<? extends org.apache.ibatis.type.TypeHandler<?>>, java.util.List<org.apache.ibatis.mapping.ResultFlag>, java.lang.String, java.lang.String, boolean)\n// å¯ä»¥çœ‹åˆ°è¿™é‡Œä¼ é€’è¿›æ¥çš„å‚æ•°è¿˜æ˜¯å¾ˆå¤šçš„.\n// æœ€åè¿”å› ResultMapping å¯¹è±¡,ä¹Ÿå°±æ˜¯è¯´è¿™ä¹ˆå¤šå‚æ•°&buildResultMappingæ–¹æ³•ä¸­çš„å‚æ•°,\n//éƒ½è®¾ç½®åˆ°è¯¥å¯¹è±¡ä¸­æ¥äº†.     \n    return builderAssistant.buildResultMapping(resultType, property, column, javaTypeClass, jdbcTypeEnum, nestedSelect, nestedResultMap, notNullColumn, columnPrefix, typeHandlerClass, flags, resultSet, foreignColumn, lazy);\n  }\n```\n\n**SqlElement æ–¹æ³•**\n\nè¯¥æ–¹æ³•å¯ä»¥å¾ˆæ˜æ˜¾çš„æ„Ÿå—åˆ°æ˜¯å¯¹ æ ‡ç­¾è¿›è¡Œè§£æçš„.\n\n```\nprivate void sqlElement(List<XNode> list) {\n // configuration è·å–å‡ºæ¥ dataBaseIdæ˜¯null,è·³è¿‡æ­¤æ–¹æ³•  \n  if (configuration.getDatabaseId() != null) {\n    sqlElement(list, configuration.getDatabaseId());\n  }\n//    \n  sqlElement(list, null);\n}\n\n// æœ‰ç‚¹å¥½å¥‡å†™ä»£ç é£æ ¼:  sqlElement(list,configuration.getDatabaseId());\n------------------------\n\n//  sqlElement æ–¹æ³•\n  private void sqlElement(List<XNode> list, String requiredDatabaseId) {\n    for (XNode context : list) {\n        \n // è·å– databaseId å’Œ id è¿™äºŒä¸ªå±æ€§çš„å€¼.       \n      String databaseId = context.getStringAttribute(\"databaseId\");\n      String id = context.getStringAttribute(\"id\");\n //  org.apache.ibatis.builder.MapperBuilderAssistant#applyCurrentNamespace   \n // è¯¥æ–¹æ³•æœ€åè¿”å›çš„idçš„å€¼æ˜¯: namespace + id       \n      id = builderAssistant.applyCurrentNamespace(id, false);\n//sqlFragments ä¸åŒ…å«è¯¥idå°±è¿”å›true,ä¹Ÿå°±è¯´è¯¥Mapæ˜¯ç¡®å®šæ˜¯å¦å·²ç»è§£æè¿‡äº†çš„.         \n      if (databaseIdMatchesCurrent(id, databaseId, requiredDatabaseId)) {\n// æ·»åŠ åˆ° org.apache.ibatis.builder.xml.XMLMapperBuilder#sqlFragments ä¸­æ¥.          \n        sqlFragments.put(id, context);\n      }\n    }\n  }\n```\n\næœ€å è§£æåçš„å€¼,æ˜¯ä½¿ç”¨ namespace + id å­˜æ”¾åœ¨ org.apache.ibatis.builder.xml.XMLMapperBuilder#sqlFragments çš„å±æ€§ä¸­çš„.\n\n**buildStatementFromContext() æ–¹æ³• :**\n\nè¿™é‡Œæ˜¯å¯¹ select / insert / update / delete æ ‡ç­¾è¿›è¡Œè§£æ.\n\n```\nbuildStatementFromContext(context.evalNodes(\"select|insert|update|delete\"));\n\n\n// å¯ä»¥çœ‹åˆ° databaseId çš„è·å–ä¸ sql æ ‡ç­¾æ˜¯ä¸€æ ·çš„æ“ä½œ\nprivate void buildStatementFromContext(List<XNode> list) {\n  if (configuration.getDatabaseId() != null) {\n    buildStatementFromContext(list, configuration.getDatabaseId());\n  }\n  buildStatementFromContext(list, null);\n}\n\n\n// æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è·Ÿè¿›åˆ°è¿™ä¸ªæ–¹æ³•æ¥.\n  private void buildStatementFromContext(List<XNode> list, String requiredDatabaseId) {\n    for (XNode context : list) {\n// å…ˆ new äº†ä¸€ä¸ª XMLStatementBuilder å¯¹è±¡, ç´§æ¥ç€å°±è°ƒç”¨è¯¥å¯¹è±¡çš„ è§£æ æ–¹æ³•.        \n      final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);\n      try {\n        statementParser.parseStatementNode();\n      } catch (IncompleteElementException e) {\n        configuration.addIncompleteStatement(statementParser);\n      }\n    }\n  }\n\n\n// è§£ææ–¹æ³•\n  public void parseStatementNode() {\n    String id = context.getStringAttribute(\"id\");\n    String databaseId = context.getStringAttribute(\"databaseId\");\n// ç”¨ namespace + id ç»„åˆä¸º id\n// org.apache.ibatis.session.Configuration#mappedStatements\n// æ¥ç€å°±æ˜¯åˆ¤æ–­åœ¨ mappedStatements ä¸­æ˜¯ä¸æ˜¯æœ‰è¯¥id,å¦‚æœä¸å­˜åœ¨å°±è¿”å›ture,\n// å­˜åœ¨å°±è¿”å›false,è¿™é‡Œä¹Ÿå°±ä¼šç›´æ¥returnå‡ºå»,ä¹Ÿå°±æ˜¯ä¸ä¼šå¾€åé¢æ‰§è¡Œäº†.      \n    if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) {\n      return;\n    }\n// è·å–æ ‡ç­¾åå­—,  select / insert/ update /delete.\n    String nodeName = context.getNode().getNodeName();\n// è½¬åŒ–ä¸ºå¤§å†™çš„ SELECT      \n    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));\n    boolean isSelect = sqlCommandType == SqlCommandType.SELECT;\n// æ˜¯å¦åˆ·æ–° cache,ä¹Ÿå°±æ˜¯selectæ˜¯ä¸åˆ·æ–°çš„,é‚£ä¹ˆå…¶ä»–çš„å°±åº”è¯¥æ˜¯è¦åˆ·æ–°çš„.      \n    boolean flushCache = context.getBooleanAttribute(\"flushCache\", !isSelect);\n// ä½¿ç”¨ä½¿ç”¨ cache,è¿™é‡Œåº”è¯¥æ˜¯ä¸€çº§ç¼“å­˜ï¼Œé»˜è®¤å¼€å¯çš„.      \n    boolean useCache = context.getBooleanAttribute(\"useCache\", isSelect);\n// ç»“æœæ’åº, å¦‚æœæ²¡æœ‰é…ç½®çš„è¯,é»˜è®¤å°±æ˜¯false.      \n    boolean resultOrdered = context.getBooleanAttribute(\"resultOrdered\", false);\n\n    // Include Fragments before parsing\n// åˆ›å»ºäº†ä¸€ä¸ª XMLIncludeTransformer å¯¹è±¡,è¯¥å¯¹è±¡åº”è¯¥æ˜¯è¿›è¡Œè½¬åŒ–çš„.      \n    XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant);\n //  TODO ? è¯¥æ–¹æ³•æœ‰å¾…æ›´æ–°     \n    includeParser.applyIncludes(context.getNode());\n\n//è·å– parameterType å±æ€§,å¦‚æœæœ‰çš„è¯,ä¹Ÿä¼šè·å–å‡ºè¯¥å±æ€§å¯¹åº”çš„ Class.    \n    String parameterType = context.getStringAttribute(\"parameterType\");\n    Class<?> parameterTypeClass = resolveClass(parameterType);\n\n// lang : null,è¿™é‡Œæ˜¯æ²¡æœ‰è®¾ç½®çš„.      \n    String lang = context.getStringAttribute(\"lang\");\n    LanguageDriver langDriver = getLanguageDriver(lang);\n\n    // Parse selectKey after includes and remove them.\n// è¿™é‡Œå¯¹æ˜¯å¦æœ‰ selectKey è¿›è¡Œå¤„ç†.æˆ‘ä»¬è¿™é‡Œç›®å‰æ²¡æœ‰ä½¿ç”¨ selectKey\n    processSelectKeyNodes(id, parameterTypeClass, langDriver);\n\n    // Parse the SQL (pre: <selectKey> and <include> were parsed and removed)\n    KeyGenerator keyGenerator;\n // selectBlog!selectKey     \n    String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;\n// è¿™é‡Œæ‹¼æ¥ä¸Š namespace :  com.iyang.mybatis.mapper.BlogMapper.selectBlog!selectKey      \n    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, true);\n\n// è¿™é‡Œæ˜¯åˆ¤æ–­æ˜¯å¦æœ‰ ä¸»é”®è‡ªåŠ¨ç”Ÿæˆ. è¿™é‡Œæ˜¯æŸ¥è¯¢è¯­å¥,åº”è¯¥æ˜¯æ²¡æœ‰çš„. \n    if (configuration.hasKeyGenerator(keyStatementId)) {\n      keyGenerator = configuration.getKeyGenerator(keyStatementId);\n    } else {\n      keyGenerator = context.getBooleanAttribute(\"useGeneratedKeys\",\n          configuration.isUseGeneratedKeys() && SqlCommandType.INSERT.equals(sqlCommandType))\n          ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;\n    }\n\n// åˆ›å»ºä¸€ä¸ª XMLScriptBuilder å¯¹è±¡,ä½¿ç”¨è¯¥å¯¹è±¡çš„parseScriptNodeæ–¹æ³•æ¥è§£æ\n// org.apache.ibatis.scripting.xmltags.XMLScriptBuilder#parseScriptNode\n// è·å–å‡ºsql, æœ‰ä¸ª isDynamic å‚æ•°,æ¥åˆ¤æ–­æ˜¯ä¸æ˜¯åŠ¨æ€sqlè¯­å¥.\n// è¿™é‡Œä¸æ˜¯åŠ¨æ€sql,æœ€ånewäº†ä¸€ä¸ªRawSqlSource.\n// org.apache.ibatis.builder.SqlSourceBuilder#parse,æˆ‘ä»¬çš„#{id} æ›¿æ¢æˆ ? å°±æ˜¯åœ¨\n// è¿™é‡Œè¿›è¡Œæ›¿æ¢çš„.\n// å¦‚æœæ˜¯åŠ¨æ€ sql çš„è¯,å°±ä¼šåˆ›å»ºå‡º DynamicSqlSource è¯¥å¯¹è±¡æ¥.\n// å¯ä»¥çœ‹åˆ° SqlSource ä¸‹é¢æ˜¯æœ‰ å››ä¸ªå®ç°ç±»çš„.\n// è¿™é‡Œè¿”å›çš„ SqlSourceé‡Œé¢æœ‰sqlè¯­å¥çš„,å’Œè¿”å›ç±»å‹çš„.      \n    SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);\n \n// è·å–å±æ€§.      \n    StatementType statementType = StatementType.valueOf(context.getStringAttribute(\"statementType\", StatementType.PREPARED.toString()));\n    Integer fetchSize = context.getIntAttribute(\"fetchSize\");\n    Integer timeout = context.getIntAttribute(\"timeout\");\n    String parameterMap = context.getStringAttribute(\"parameterMap\");\n// è·å–è¿”å›ç±»å‹. è·å–å‡ºæ¥çš„ resultTypeClass æ˜¯ class com.iyang.mybatis.pojo.TbBlog      \n    String resultType = context.getStringAttribute(\"resultType\");\n    Class<?> resultTypeClass = resolveClass(resultType);\n    String resultMap = context.getStringAttribute(\"resultMap\");      \n    String resultSetType = context.getStringAttribute(\"resultSetType\");\n    ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);\n    if (resultSetTypeEnum == null) {\n      resultSetTypeEnum = configuration.getDefaultResultSetType();\n    }\n// è·å–å±æ€§çš„å€¼      \n    String keyProperty = context.getStringAttribute(\"keyProperty\");\n    String keyColumn = context.getStringAttribute(\"keyColumn\");\n    String resultSets = context.getStringAttribute(\"resultSets\");\n\n// åˆ›å»ºä¸€ä¸ª MappedStatement.Builder å¯¹è±¡å‡ºæ¥.\n// å†é€šè¿‡ builder æ„å»ºå‡ºä¸€ä¸ª MappedStatement å¯¹è±¡æ¥.\n// æœ€åæ”¾å…¥åˆ° org.apache.ibatis.session.Configuration#mappedStatements ä¸­æ¥.      \n    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,\n        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,\n        resultSetTypeEnum, flushCache, useCache, resultOrdered,\n        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);\n  }\n\n  private void processSelectKeyNodes(String id, Class<?> parameterTypeClass, LanguageDriver langDriver) {\n    List<XNode> selectKeyNodes = context.evalNodes(\"selectKey\");\n    if (configuration.getDatabaseId() != null) {\n      parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, configuration.getDatabaseId());\n    }\n    parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, null);\n    removeSelectKeyNodes(selectKeyNodes);\n  }\n```\n\n#### æ€»ç»“\n\næ€»ç»“ä¸‹ MyBatis è§£æ Mapperçš„xml æ–‡ä»¶æµç¨‹ã€‚ å¯ä»¥æ„Ÿå—åˆ°,å¯¹äºMybatiså¤„ç†Mapper,å¯¹å…¶å­—æ®µå±æ€§éƒ½æ˜¯æŒ¨ä¸ªè§£æçš„,è¿˜æ˜¯ä¸‹äº†å¾ˆå¤§çš„åŠŸå¤«.\n\nå…ˆæ˜¯æœ‰ä¸€ä¸ªé›†åˆæ¥æ§åˆ¶æ˜¯å¦å·²ç»è§£æè¿‡äº†,ç®—æ˜¯ä¸€ç§æ˜¯å¦è§£æçš„å¼€å…³é…ç½®. å¯ä»¥çœ‹åˆ°å…¶å…ˆåçš„è§£æé¡ºåº,\n\nnamespace â€“> cache-ref â€“> cache â€”> mapper/parameterMap â€”> mapper/resultMap â€”> mapper/sql â€”> select/insert/update/detele.\n\nå½“è§£æè¿™äº›æ ‡ç­¾çš„æ—¶å€™, åˆä¼šå¯¹æ ‡ç­¾é‡Œé¢çš„å±æ€§è¿›è¡Œè§£æ. è¿™é‡Œ,ä¸»è¦çœ‹ä¸‹æˆ‘ä»¬å¹³å¸¸ä½¿ç”¨åˆ°æœ€å¤šçš„æ ‡ç­¾, MyBatis å¯¹è¿™äº›æ ‡ç­¾è§£æäº†å,å…¶åæœ‰æ˜¯æ€ä¹ˆåˆ©ç”¨çš„å‘¢ï¼Ÿå¯ä»¥çœ‹åˆ°ç›®å‰MyBatisæ˜¯å­˜æ”¾åœ¨ä¸€äº›configurationç­‰ç±»ä¿¡æ¯é‡Œé¢,é‚£ä¹ˆç­‰åˆ°çœŸæ­£å»æŸ¥è¯¢sqlè¯­å¥çš„æ—¶å€™, MyBatis åˆæ˜¯æ€ä¹ˆç”¨ä¸Šçš„å‘¢ï¼Ÿ è¿™é‡Œç›®å‰åªè®²äº†å¦‚ä½•è§£æ.\n\nè§£æå®Œäº†ï¼Œæ²¡å¼‚å¸¸ï¼Œé‚£å°±æ˜¯è§£æéƒ½okäº†ï¼Œå‰©ä¸‹çš„å°±æ˜¯çœ‹å½“ MyBatis å»æŸ¥è¯¢çš„æ—¶å€™, æ˜¯æ€ä¹ˆåˆ©ç”¨ä¸Šè¿™äº›èµ„æºçš„å‘¢ï¼Ÿæ‰€ä»¥çœ‹æ¥ä¸‹æ¥çš„æ›´æ–°.\n","tags":["javaæ¡†æ¶","mybatis"],"categories":["javaæ¡†æ¶","mybatis"]},{"title":"mybatisæœ¬åœ°ç¼“å­˜é˜…è¯»","url":"/2021/11/04/mybatis/mybatisæœ¬åœ°ç¼“å­˜é˜…è¯»/","content":"\n#### é¢˜è®°\n\n####  ç¼“å­˜è¿™ä¸ªçŸ¥è¯†ç‚¹åœ¨è®¸å¤šåœ°æ–¹éƒ½æœ‰çš„ï¼Œåˆ©ç”¨åˆ°å¥½çš„è¯ï¼Œå¯¹ç³»ç»Ÿçš„å¾ˆå¤šåœ°æ–¹æŸ¥è¯¢æ˜¯æœ‰å¾ˆå¤§çš„æå‡çš„. å¯ä»¥çœ‹åˆ°,MyBatis ä¹Ÿæ˜¯æœ‰ cache çš„ï¼Œé‚£MyBatis æ˜¯æ€ä¹ˆåˆ©ç”¨è¿™ä¸ªç¼“å­˜çš„å‘¢ï¼Ÿ åœ¨ INSERT/UPDATE/DELETE/SELECTä¸­,æ˜¯ä¸æ˜¯åªæœ‰SELECTçš„æ—¶å€™ç”¨åˆ°äº†ç¼“å­˜ï¼Œå¦‚æœæ˜¯ INSERT/UPDATE/DELETE æ˜¯å¦ä¼šå¯¹ç¼“å­˜æœ‰å½±å“ï¼Ÿ\n\n å¯ä»¥çœ‹ç»“æœæ¥åˆ†æï¼Œç„¶åè·Ÿè¿›æºç æ¥ä»”ç»†åˆ†æ.\n\n MyBatis æ˜¯åˆ†ä¸º ä¸€çº§ç¼“å­˜ å’Œ äºŒçº§ç¼“å­˜çš„. é‚£ä¹ˆï¼Œæˆ‘ä»¬å°±å…ˆä»ä¸€çº§ç¼“å­˜å¼€å§‹.\n\n#### ä¸€çº§ç¼“å­˜\n\n æ¡ˆä¾‹ä»£ç  :\n\n è¿™é‡Œæˆ‘ä»¬æ˜¯æ‰“å°çš„æŸ¥è¯¢sqlçš„è¯­å¥ï¼Œå†ç¬¬äºŒæ¬¡å†æŸ¥è¯¢çš„æ—¶å€™ï¼Œæ˜¯\n\n```\nInputStream mybatisInputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\n\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mybatisInputStream);\nSqlSession session = sqlSessionFactory.openSession();\nBlogMapper blogMapper = session.getMapper(BlogMapper.class);\nTbBlog tbBlog = blogMapper.selectBlog(1);\nSystem.out.println(blogMapper.selectBlog(1));\nSystem.out.println(tbBlog);\n\n\n// ç»“æœå¯ä»¥çœ‹åˆ°,ç¬¬äºŒæ¬¡å¹¶æ²¡æœ‰å†æ‰“å°å‡º sql è¯­å¥æ¥.\n==>  Preparing: select * from tb_blog where id = ? \n==> Parameters: 1(Integer)\n<==    Columns: id, name\n<==        Row: 1, 6565\n<==      Total: 1\nTbBlog{id=1, name='6565'}\nTbBlog{id=1, name='6565'}\n```\n\næ¡ˆä¾‹äºŒ : æˆ‘ä»¬å†ç¬¬äºŒæ¬¡æŸ¥è¯¢ä¹‹å‰ åŠ å…¥ ä¸€ä¸ªadd æ–¹æ³•\n\n```\nInputStream mybatisInputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\n\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mybatisInputStream);\nSqlSession session = sqlSessionFactory.openSession();\nBlogMapper blogMapper = session.getMapper(BlogMapper.class);\nTbBlog tbBlog = blogMapper.selectBlog(1);\n\nSystem.out.println(blogMapper.addBlog(\"GavinYang\"));\nSystem.out.println(blogMapper.selectBlog(1));\nSystem.out.println(tbBlog);\n\n// çœ‹ç»“æœ,å¯ä»¥çœ‹åˆ°å½“ä¸­é—´ç©¿æ’ä¸€ä¸ª insert çš„sqlè¯­å¥,é‚£ä¹ˆåœ¨ç¬¬äºŒæ¬¡æŸ¥è¯¢çš„æ—¶å€™,å°±ä¼šæ‰§è¡Œsqlè¯­å¥.\n// é‚£ä¹ˆä¹Ÿå°±è¯´ï¼Œè¿™ä¸ªæ—¶å€™ç¼“å­˜æ˜¯å¤±æ•ˆäº†.\n==>  Preparing: select * from tb_blog where id = ? \n==> Parameters: 1(Integer)\n<==    Columns: id, name\n<==        Row: 1, 6565\n<==      Total: 1\n==>  Preparing: insert into tb_blog (name) values(?) \n==> Parameters: GavinYang(String)\n<==    Updates: 1\n1\n==>  Preparing: select * from tb_blog where id = ? \n==> Parameters: 1(Integer)\n<==    Columns: id, name\n<==        Row: 1, 6565\n<==      Total: 1\nTbBlog{id=1, name='6565'}\nTbBlog{id=1, name='6565'}\n```\n\næ¡ˆä¾‹ä¸‰ : ä½¿ç”¨äºŒä¸ª SqlSession æ¡ˆä¾‹\n\nå¯ä»¥å¾ˆæ˜æ˜¾çš„çœ‹åˆ° , åœ¨ç¬¬äºŒæ¬¡çš„æ—¶å€™è¿˜å‡ºç°äº†è„æ•°æ®.\n\nè¿™é‡Œä¹Ÿå¯ä»¥çœ‹åˆ°ä¸€çº§ç¼“å­˜æ˜¯åªåœ¨ SqlSession ä¸­å­˜åœ¨çš„,ä¹Ÿå°±æ˜¯æ•°æ®åº“ä¼šè¯å†…éƒ¨å…±äº«çš„.\n\n```\nInputStream mybatisInputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mybatisInputStream);\n\nSqlSession openSession1 = sqlSessionFactory.openSession();\nSqlSession openSession2 = sqlSessionFactory.openSession();\nBlogMapper blogMapper1 = openSession1.getMapper(BlogMapper.class);\nBlogMapper blogMapper2 = openSession2.getMapper(BlogMapper.class);\n\nSystem.out.println(\"blogMapper1 è¯»å–æ•°æ® \" + blogMapper1.selectBlog(1));\nSystem.out.println(\"blogMapper2 è¯»å–æ•°æ®\" + blogMapper2.selectBlog(1));\n\nSystem.out.println(blogMapper1.updateHashCode(\"PeterWong\"));\n\nSystem.out.println(\"blogMapper1 è¯»å–æ•°æ® \" + blogMapper1.selectBlog(1));\nSystem.out.println(\"blogMapper2 è¯»å–æ•°æ®\" + blogMapper2.selectBlog(1));\n\n// ç„¶åæˆ‘ä»¬å¯ä»¥çœ‹åˆ° log æ‰“å°å‡ºæ¥çš„å†…å®¹\n==>  Preparing: select * from tb_blog where id = ? \n==> Parameters: 1(Integer)\n<==    Columns: id, name\n<==        Row: 1, 6565\n<==      Total: 1\nblogMapper1 è¯»å–æ•°æ® TbBlog{id=1, name='6565'}\nCreated connection 433287555.\nSetting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@19d37183]\n==>  Preparing: select * from tb_blog where id = ? \n==> Parameters: 1(Integer)\n<==    Columns: id, name\n<==        Row: 1, 6565\n<==      Total: 1\nblogMapper2 è¯»å–æ•°æ®TbBlog{id=1, name='6565'}\n==>  Preparing: update tb_blog set name = ? where id = 1; \n==> Parameters: PeterWong(String)\n<==    Updates: 1\n1\n==>  Preparing: select * from tb_blog where id = ? \n==> Parameters: 1(Integer)\n<==    Columns: id, name\n<==        Row: 1, PeterWong\n<==      Total: 1\nblogMapper1 è¯»å–æ•°æ® TbBlog{id=1, name='PeterWong'}\nblogMapper2 è¯»å–æ•°æ®TbBlog{id=1, name='6565'}\n```\n\nå¯ä»¥çœ‹åˆ°æˆ‘ä»¬è¯´äº†ä¸‰é¢çš„è¿™ä¸‰ç§æƒ…å†µ, å…·ä½“çš„æ‰§è¡Œæµç¨‹å¯ä»¥æˆ‘ä»¬å¯ä»¥ç°åœ¨ æ¡ˆä¾‹ä¸€é‡Œé¢å¯¹ç¬¬äºŒæ¬¡ query è¿›è¡Œ debug åˆ†ææ“ä½œ. å½“æˆ‘ä»¬debugåˆ° org.apache.ibatis.executor.BaseExecutor#query(org.apache.ibatis.mapping.MappedStatement, java.lang.Object, org.apache.ibatis.session.RowBounds, org.apache.ibatis.session.ResultHandler, org.apache.ibatis.cache.CacheKey, org.apache.ibatis.mapping.BoundSql) çš„æ—¶å€™ï¼Œå¯ä»¥çœ‹åˆ° org.apache.ibatis.executor.BaseExecutor#localCache åªæœ‰ä¸€ä¸ª ç¼“å­˜çš„å€¼çš„ ï¼Œ æ ¹æ® getObject æ–¹æ³•å¯ä»¥è·Ÿè¿›åˆ° org.apache.ibatis.cache.impl.PerpetualCache#cache ä¸­æ¥,\n\nä¼ å…¥è¿›æ¥çš„ key å€¼æ˜¯ : -1896651191:1062027004:com.iyang.mybatis.mapper.BlogMapper.selectBlog:0:2147483647:select * from tb_blog where id = ?:1:development ç„¶åä» cache ä¸­è·å–å‡ºå€¼æ¥, æ‰€ä»¥è¿™é‡Œå°±æ²¡æœ‰èµ° query çš„æŸ¥è¯¢è¯­å¥.\n\nè¿™æ˜¯å‘½ä¸­ç¼“å­˜çš„æƒ…å†µ.\n\nä¸‹é¢æˆ‘ä»¬æ¥çœ‹ä¸‹, åœ¨ç¬¬äºŒæ¬¡ query ä¹‹å‰å¦‚æœæ‰§è¡Œäº†ä¸€ä¸ª add æ–¹æ³•ï¼Œä¸ºä»€ä¹ˆå°±å‘½ä¸­ä¸äº†äº†å‘¢ï¼Ÿ\n\nè¿™é‡Œå¯ä»¥å¤§è‡´çŒœæµ‹ä¸‹ï¼Œåœ¨æ‰§è¡Œå®Œ add æ–¹æ³•åï¼Œæ˜¯ä¸æ˜¯ç»™ cache ç»™æ¸…é™¤æ‰äº†ï¼Œç„¶åå†å»æŸ¥è¯¢çš„æ—¶å€™ï¼Œå°±æŸ¥è¯¢ä¸åˆ°äº†.\n\näºæ˜¯æˆ‘ä»¬åœ¨ add æ–¹æ³•ä¸Šè¿›è¡Œ debug æŸ¥çœ‹ä¸‹ :\n\næœ€åæˆ‘ä»¬ debug è·Ÿè¿›åˆ°è¿™é‡Œ : org.apache.ibatis.executor.BaseExecutor#clearLocalCache å°±å¯ä»¥å‘ç°\n\nè¿™é‡Œæ˜¯æœ‰äºŒä¸ª clear æ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯æ¸…é™¤æ–¹æ³•.\n\nlocalCache.clear() â€”-> org.apache.ibatis.cache.impl.PerpetualCache#clear å¯¹åº”çš„å°±æ˜¯è¿™é‡Œçš„æ¸…æ¥šæ–¹æ³•ï¼Œç›´æ¥è°ƒç”¨ HashMap çš„clear æ–¹æ³•è¿›è¡Œæ¸…é™¤.\n\n```\nlocalCache.clear();\nlocalOutputParameterCache.clear();\n```\n\næ‰€ä»¥è¿™é‡Œå¯ä»¥çœ‹å‡ºåœ¨ç¬¬äºŒæ¬¡è°ƒç”¨ query ä¹‹å‰ï¼Œå¦‚æœæ˜¯æœ‰ insert/update/delete ç­‰æ–¹æ³•çš„è¯ï¼Œå°±ä¼šå»é‡ç½®è¿™äºŒä¸ªåœ°æ–¹çš„ç¼“å­˜çš„.\n\nMyBatis çš„ä¸€çº§ç¼“å­˜çš„æ˜¯è·Ÿéš SqlSession çš„ï¼Œè¿™é‡Œæ˜¯å¯ä»¥æ ¹æ®ç®€å•çš„æ¡ˆä¾‹æ•ˆæœçœ‹å‡ºæ¥çš„.\n\nä¸€çº§ç¼“å­˜åªæ˜¯ä½¿ç”¨äº†ä¸€ä¸ª HashMap , æœ€åæ¸…é™¤ç¼“å­˜çš„æ—¶å€™ï¼Œä¹Ÿæ˜¯è°ƒç”¨ HashMap çš„clear æ–¹æ³•\n\næœ€åä»æ¡ˆä¾‹ä¸‰å¯ä»¥çœ‹å‡ºæ¥ï¼Œå½“å¤šä¸ª SqlSession çš„æ—¶å€™ï¼Œç”±äºå„è‡ªæœ‰å­˜æœ‰å„è‡ªçš„ç¼“å­˜ï¼Œæ‰€ä»¥æ˜¯å¾ˆå®¹æ˜“å¼•èµ·è„æ•°æ®çš„, å°†ç¼“å­˜çº§åˆ«è®¾ç½®ä¸º Statement.\n\n#### äºŒçº§ç¼“å­˜\n\n å¯ä»¥çœ‹åˆ°ä¸€çº§ç¼“å­˜çš„è¯ï¼Œæ˜¯å±€é™äº SqlSession . å¦‚æœè¦å¤šä¸ª sqlSession ä¹‹é—´å…±äº«ç¼“å­˜çš„è¯ï¼Œå°±éœ€è¦å¼€å¯äºŒçº§ç¼“å­˜. å¼€å¯çš„è¯,æˆ‘ä»¬åœ¨ MyBatis é…ç½®æ–‡ä»¶ä¸­åŠ ä¸Š:\n\n```\n<settings>\n    <setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/>\n\n    <!-- å¼€å¯äºŒçº§ç¼“å­˜ -->\n    <setting name=\"cacheEnabled\" value=\"true\"/>\n</settings>\n```\n\n **æ¡ˆä¾‹ä¸€ : æ˜¯å¦æäº¤äº‹åŠ¡**\n\n```\npublic static void main(String[] args) throws Exception {\n\n    InputStream mybatisInputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\n    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mybatisInputStream);\n    SqlSession sqlSession1 = sqlSessionFactory.openSession(true);\n    SqlSession sqlSession2 = sqlSessionFactory.openSession(true);\n\n    BlogMapper blogMapper1 = sqlSession1.getMapper(BlogMapper.class);\n    BlogMapper blogMapper2 = sqlSession2.getMapper(BlogMapper.class);\n\n    System.out.println(\"blogMapper1 è·å–æ•°æ®\" + blogMapper1.selectBlog(1));\n    \n    // sqlSession1.commit();\n    \n    System.out.println(\"blogMapper2 è·å–æ•°æ®\" + blogMapper2.selectBlog(1));\n\n}\n\n//   ----------------   trueç»“æœ   -----------------------\n\nCreated connection 492079624.\n==>  Preparing: select * from tb_blog where id = ? \n==> Parameters: 1(Integer)\n<==    Columns: id, name\n<==        Row: 1, 6565\n<==      Total: 1\nblogMapper1 è·å–æ•°æ®TbBlog{id=1, name='6565'}\nOpening JDBC Connection\n    \nCreated connection 433287555.\n==>  Preparing: select * from tb_blog where id = ? \n==> Parameters: 1(Integer)\n<==    Columns: id, name\n<==        Row: 1, 6565\n<==      Total: 1\nblogMapper2 è·å–æ•°æ®TbBlog{id=1, name='6565'}    \n    \n\n// ------------   åŠ ä¸Šcommit()æ–¹æ³•ç»“æœ   ---------------\n\nCreated connection 630074945.\n==>  Preparing: select * from tb_blog where id = ? \n==> Parameters: 1(Integer)\n<==    Columns: id, name\n<==        Row: 1, 6565\n<==      Total: 1\nblogMapper1 è·å–æ•°æ®TbBlog{id=1, name='6565'}\nCache Hit Ratio [com.iyang.mybatis.mapper.BlogMapper]: 0.5\nblogMapper2 è·å–æ•°æ®TbBlog{id=1, name='6565'}\n```\n\n ä»è¿™é‡Œçœ‹, æ˜¯å¦æäº¤äº‹åŠ¡å¯ä»¥çœ‹å‡ºæ¥ï¼Œæ˜¯ä¼šå½±å“äºŒçº§ç¼“å­˜çš„.\n\n**æ¡ˆä¾‹äºŒ : ä¸­é—´ç©¿æ’æ›´æ–°è¯­å¥**\n\n```\npublic static void main(String[] args)  throws Exception {\n\n    InputStream mybatisInputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\n    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mybatisInputStream);\n    SqlSession sqlSession1 = sqlSessionFactory.openSession(false);\n    SqlSession sqlSession2 = sqlSessionFactory.openSession(false);\n    SqlSession sqlSession3 = sqlSessionFactory.openSession(false);\n\n    BlogMapper blogMapper1 = sqlSession1.getMapper(BlogMapper.class);\n    BlogMapper blogMapper2 = sqlSession2.getMapper(BlogMapper.class);\n    BlogMapper blogMapper3 = sqlSession3.getMapper(BlogMapper.class);\n\n    System.out.println(\" blogMapper1 æŸ¥è¯¢å‡ºæ¥çš„æ•°æ® : \" + blogMapper1.selectBlog(1));\n    sqlSession1.commit();\n\n    System.out.println(\" blogMapper2 æŸ¥è¯¢å‡ºæ¥çš„ç»“æœ : \" + blogMapper2.selectBlog(1));\n\n    System.out.println(blogMapper3.updateHashCode(\"GavinYang\"));\n    sqlSession3.commit();\n\n    System.out.println(\" blogMapper2 æŸ¥è¯¢å‡ºæ¥çš„ç»“æœ : \" + blogMapper2.selectBlog(1));\n}\n\n//  ------------------  æ‰“å°ç»“æœ ------\n\nCreated connection 630074945.\nSetting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@258e2e41]\n==>  Preparing: select * from tb_blog where id = ? \n==> Parameters: 1(Integer)\n<==    Columns: id, name\n<==        Row: 1, 6565\n<==      Total: 1\n blogMapper1 æŸ¥è¯¢å‡ºæ¥çš„æ•°æ® : TbBlog{id=1, name='6565'}\nCache Hit Ratio [com.iyang.mybatis.mapper.BlogMapper]: 0.5\n blogMapper2 æŸ¥è¯¢å‡ºæ¥çš„ç»“æœ : TbBlog{id=1, name='6565'}\n\nCreated connection 603443293.\nSetting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@23f7d05d]\n==>  Preparing: update tb_blog set name = ? where id = 1; \n==> Parameters: GavinYang(String)\n<==    Updates: 1\n1\nCommitting JDBC Connection [com.mysql.jdbc.JDBC4Connection@23f7d05d]\nCache Hit Ratio [com.iyang.mybatis.mapper.BlogMapper]: 0.3333333333333333\nOpening JDBC Connection\n    \n    \nCreated connection 707976812.\nSetting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@2a32de6c]\n==>  Preparing: select * from tb_blog where id = ? \n==> Parameters: 1(Integer)\n<==    Columns: id, name\n<==        Row: 1, GavinYang\n<==      Total: 1\n blogMapper2 æŸ¥è¯¢å‡ºæ¥çš„ç»“æœ : TbBlog{id=1, name='GavinYang'}\n```\n\nè¿™é‡Œæ˜¯å¯ä»¥çœ‹åˆ°åœ¨æ›´æ–°ä¹‹åå¹¶ä¸” commit äº†äº‹åŠ¡ä¹‹åï¼Œåé¢ç´§è·Ÿçš„ sql æ˜¯å»æŸ¥è¯¢ æ•°æ®åº“äº†çš„. æ‰€ä»¥è¿™é‡Œæ˜¯å¯ä»¥çœ‹å‡ºæ¥ï¼Œupdateç­‰æ“ä½œæ˜¯ä¼šå» æ¸…ç©ºå¯¹åº”çš„ç¼“å­˜çš„ã€‚\n\nè¿™é‡Œæˆ‘ä»¬æ ¹æ® æ¡ˆä¾‹ä¸€ çš„æƒ…å†µæ¥åˆ†æï¼Œåœ¨å¼€å¯äº† äºŒçº§ç¼“å­˜ çš„æ—¶å€™ï¼Œæ˜¯ä»å“ªé‡Œè·å–å‡ºæ¥çš„æ•°æ®çš„å‘¢ï¼Ÿ\n\ndebug è·Ÿè¿›æ¥ : org.apache.ibatis.executor.CachingExecutor#query(org.apache.ibatis.mapping.MappedStatement, java.lang.Object, org.apache.ibatis.session.RowBounds, org.apache.ibatis.session.ResultHandler, org.apache.ibatis.cache.CacheKey, org.apache.ibatis.mapping.BoundSql)\n\n```\n@Override\npublic <E> List<E> query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)\n    throws SQLException {\n  Cache cache = ms.getCache();\n  if (cache != null) {\n    flushCacheIfRequired(ms);\n    if (ms.isUseCache() && resultHandler == null) {\n      ensureNoOutParams(ms, boundSql);\n      @SuppressWarnings(\"unchecked\")\n// debug åˆ°è¿™é‡Œï¼Œå¯ä»¥çœ‹åˆ°,å°±å·²ç»è¿”å›äº†æˆ‘ä»¬éœ€è¦çš„æ•°æ®.        \n      List<E> list = (List<E>) tcm.getObject(cache, key);\n      if (list == null) {\n        list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n        tcm.putObject(cache, key, list); // issue #578 and #116\n      }\n      return list;\n    }\n  }\n  return delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n}\n```\n\norg.apache.ibatis.executor.CachingExecutor#tcm è°ƒç”¨è¿™ä¸ªå¯¹è±¡çš„ getObject æ–¹æ³•è·å–åˆ°äº†æˆ‘ä»¬éœ€è¦çš„å€¼, è·Ÿè¿›æ¥åˆä» org.apache.ibatis.cache.decorators.TransactionalCache çš„ getObject è·å–å‡ºæˆ‘ä»¬çš„å€¼, æœ€åä» org.apache.ibatis.cache.decorators.TransactionalCache#delegate è·å–å‡ºå€¼, è¿”å›å›æ¥çš„.\n\norg.apache.ibatis.cache.decorators.TransactionalCache#getObject\n\n```\n@Override\npublic Object getObject(Object key) {\n  // issue #116\n// ä»ç¼“å­˜ä¸­è·å–å‡ºå€¼.    \n  Object object = delegate.getObject(key);\n  if (object == null) {\n// å¦‚æœè·å–å‡ºæ¥æ˜¯null,ä¹Ÿå°±æ˜¯ç¼“å­˜ä¸­æ²¡æœ‰çš„è¯,org.apache.ibatis.cache.decorators.TransactionalCache#entriesMissedInCache å°±æ·»åŠ åˆ°è¿™ä¸ªé›†åˆä¸­æ¥.      \n    entriesMissedInCache.add(key);\n  }\n  // issue #146\n// commit åéœ€è¦ clear çš„è¯ï¼Œå°±ä¼šè¿”å› null.\n// è¿™é‡Œæƒ³ä¸‹è¿™ä¸ªå˜é‡ä¼šä¸ä¼šå’Œæˆ‘é—¨æ¡ˆä¾‹äºŒä¸­çš„ update æ“ä½œæœ‰å…³ç³»å‘¢ï¼Ÿ\n// è¿™é‡Œå† updateåå† debug å‘ç°,  delegate ä¸­è·å–å‡ºæ¥çš„æ˜¯ null ,ä¹Ÿå°±æ˜¯ç¡®å®æ˜¯è·å–ä¸åˆ°ç¼“å­˜äº†\n// å’Œè¿™ä¸ªå‚æ•°æ²¡å…³ç³».    \n  if (clearOnCommit) {\n    return null;\n  } else {\n    return object;\n  }\n}\n```\n\nMyBatis äºŒçº§ç¼“å­˜ä¸é€‚åº”äºé…ç½®æ–‡ä»¶ä¸­å­˜åœ¨å¤šè¡¨æŸ¥è¯¢çš„æƒ…å†µ. ä¸€èˆ¬æˆ‘ä»¬æ˜¯å•è¡¨çš„ cache, ç”±äº mybatis çš„äºŒçº§ç¼“å­˜æ˜¯åŸºäº namespace çš„, å¤šè¡¨æŸ¥è¯¢è¯­å¥æ‰€åœ¨çš„ namespace æ— æ³•æ„Ÿåº”åˆ°å…¶ä»–çš„ namespace ä¸­çš„è¯­å¥å¯¹å¤šè¡¨ä¸­è®¾è®¡ä¿®æ”¹ï¼Œå°±ä¼šå¼•å‘è„æ•°æ®. è¿™ä¸ªæ—¶å€™ï¼Œå¯ä»¥é‡‡ç”¨ cache-ref æ¥åšå¤„ç†ï¼Œä½†æ˜¯è¿™æ ·çš„è¯,ç¼“å­˜çš„é¢—ç²’åº¦å°±å˜ç²—äº†.\n\næ‰§è¡Œæµç¨‹ : å¦‚æœå¼€å¯äº†äºŒçº§ç¼“å­˜çš„è¯ï¼Œ MyBatis ä¼šå…ˆèµ°äºŒçº§ç¼“å­˜ï¼Œå¦‚æœäºŒçº§ç¼“å­˜æ²¡æœ‰çš„è¯ï¼Œå°±ä¼šå»ä¸€çº§ç¼“å­˜çœ‹çœ‹ï¼Œå¦‚æœéƒ½æ²¡æœ‰çš„è¯ï¼Œå°±å»æŸ¥è¯¢æ•°æ®åº“.\n\näºŒçº§ç¼“å­˜ : ç”¨ org.apache.ibatis.executor.CachingExecutor è£…é¥°äº† org.apache.ibatis.executor.BaseExecutor çš„å­ç±», å§”æ‰˜å…·ä½“èŒè´£ç»™ delegate ä¹‹å‰ï¼Œå®ç°äº†äºŒçº§ç¼“å­˜çš„æŸ¥è¯¢å’Œå†™å…¥åŠŸèƒ½.\n\n#### æ€»ç»“\n\næœ€åçœ‹ ä¸€çº§ç¼“å­˜å’ŒäºŒçº§ç¼“å­˜ï¼Œéƒ½æ˜¯åˆ©ç”¨çš„ HashMap è¿™ç§æ¥åšåˆ°æœ¬åœ°ç¼“å­˜ï¼Œ åªæ˜¯äºŒçº§ç¼“å­˜çš„ä½œç”¨èŒƒå›´æ¯”èµ·ä¸€çº§ç¼“å­˜çš„è¯ï¼Œæ˜¯è¦å¤§çš„ï¼Œå¹¶ä¸”ä¹Ÿåˆ©ç”¨äº†ä¸€äº› è£…é¥°è€… ç­‰è®¾è®¡æ¨¡å¼æ¥è®¾è®¡äºŒçº§ç¼“å­˜çš„.\n\nå¦‚æœæ˜¯éƒ¨ç½²çš„åˆ†å¸ƒå¼é¡¹ç›®çš„è¯ï¼Œé‚£ä¹ˆè¿˜æ˜¯ å¾—åˆ‡æ¢åˆ° redis è¿™ç§ç¼“å­˜æ¥äº†ï¼Œ æœ¬åœ°åˆ©ç”¨ HashMap è¿™ç§ç¼“å­˜æ»¡è¶³ä¸äº†çš„.\n\næ–‡çŒ®å‚è€ƒåœ°å€ : https://tech.meituan.com/2018/01/19/mybatis-cache.html\n","tags":["javaæ¡†æ¶","mybatis"],"categories":["javaæ¡†æ¶","mybatis"]},{"title":"mybatisä¸­config-xmlä»£ç é˜…è¯»","url":"/2021/11/04/mybatis/mybatisä¸­config-xmlä»£ç é˜…è¯»/","content":"\n\n\n#### é¢˜è®°\n\nå¯¹äºé…ç½®æ–‡ä»¶çš„è§£æ, è¿˜æ˜¯ç›¸å¯¹æ¯”è¾ƒå¥½ç†è§£çš„, å°±æ˜¯è¯»å–é…ç½®æ–‡ä»¶, ç„¶ååœ¨ä»£ç éœ€è¦çš„åœ°æ–¹ç»™ä½¿ç”¨åˆ°.\n\nè¿™é‡Œ,å¯ä»¥æ‰©å±•ä¸‹, Spring / SpringBoot ç­‰æ˜¯æ€ä¹ˆè¯»å–é…ç½®æ–‡ä»¶å‘¢ ? å¹¶ä¸”é…ç½®æ–‡ä»¶è¿˜æ˜¯æœ‰ xml / properties/yaml ç­‰æ ¼å¼çš„ ï¼Œ å…¶è¯»å–ä»£ç æ˜¯æ€ä¹ˆå†™çš„ ? ç„¶ååŸºäº é˜¿æ³¢ç½—(æºç¨‹å¼€æº) çš„é…ç½®ä¸­å¿ƒ , å…¶å®ç°é…ç½®åˆæ˜¯æ€ä¹ˆå®ç°çš„å‘¢ ? ç„¶åè¿™é‡Œï¼Œçœ‹äº† Mybatis è¯»å–é…ç½®æ–‡ä»¶, åç»­å†å‡º Spring é…ç½®æ–‡ä»¶çš„æ—¶å€™ï¼Œå¦‚æœäºŒè€…è¯»å–é…ç½®è¿›è¡Œå¯¹æ¯”, ä½ ä¸ªäººæ›´å€¾å‘ä½¿ç”¨ä»£ç å‘¢ ?\n\næ‰€ä»¥,è¿™é‡Œå°±å¼€å¯è¯»å– Mybatis æ˜¯å¦‚ä½•è§£æé…ç½®æ–‡ä»¶çš„æ“ä½œ.\n\n#### é…ç½®æ–‡ä»¶\n\nè¿™é‡Œçš„é…ç½®æ–‡ä»¶è§£è¯»,æ˜¯æ ¹æ® MyBatiså®˜ç½‘æ¥ä¸€æ­¥ä¸€æ­¥çš„è§£æé˜…è¯». å¦‚æœæœ‰å®˜ç½‘æ²¡æœ‰æ¶‰åŠåˆ°çš„,å‘ç°äº†ä¹Ÿä¼šåœ¨åç»­åŠ ä¸Šå»çš„. è§£æå¤šè¡Œä»£ç , æ‰èƒ½ç†è§£ ä½•ä¸ºä¼˜ç§€.\n\n**æ ‡ç­¾ä¸€ : properties**\n\norg.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfiguration â€”> propertiesElement(root.evalNode(â€œpropertiesâ€)) æ–¹æ³•ä¸­æ¥.\n\n```\n// è¿™é‡Œä¼ å…¥è¿›æ¥çš„ XNode çš„å€¼,å°±æ˜¯æˆ‘ä»¬å†™çš„ properties æ ‡ç­¾.\n// å¯ä»¥çœ‹åˆ° XNodeçš„å±æ€§,nameæ ‡ç­¾çš„åå­—,attributeså°±æ˜¯key/valueå±æ€§\n// æ¯”å¦‚è¿™é‡Œ: key å°±æ˜¯ resource , value å°±æ˜¯ ./db.properties.\nprivate void propertiesElement(XNode context) throws Exception {\n  if (context != null) {\n// è¿™é‡Œè°ƒç”¨çš„node.getChildNodes(),å¦‚æœæœ‰ç‚¹è¯,ä¼šéå†æŒ¨ä¸ªè§£æ,æœ€åå°è£…æˆä¸ºkey/valueç»“æ„.      \n    Properties defaults = context.getChildrenAsProperties();\n// è·å– resource / url äºŒè€…çš„å€¼.      \n    String resource = context.getStringAttribute(\"resource\");\n    String url = context.getStringAttribute(\"url\");\n// å¦‚æœäºŒè€…éƒ½æ˜¯null,å°±ä¼šæŠ›å‡ºå¼‚å¸¸æ¥.      \n    if (resource != null && url != null) {\n      throw new BuilderException(\"The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.\");\n    }\n      \n // è¿™é‡Œå…ˆå¤„ç†resource,å†å¤„ç†url,ä¹Ÿå°±æ˜¯æœ‰å¯èƒ½urlä¼šè¦†ç›–æ‰resourceçš„å†…å®¹.\n // äºŒè€…è¯»å–çš„æ–¹å¼ä¸ä¸€æ ·,å‰è€…æ˜¯æ ¹æ® resourceå¼€å§‹è¯»,urlæ˜¯æ ¹æ®ç»å¯¹è·¯å¾„å¼€å§‹è¯».\n // æœ€å defaults é‡Œé¢æ”¾å…¥çš„å…¨éƒ¨æ˜¯ key/value å¯¹åº”çš„é”®å€¼å¯¹\n // ä¹Ÿå°±æ˜¯db.propertiesä¸­çš„ key / value ç›¸å¯¹åº”ièµ·æ¥.     \n    if (resource != null) {\n      defaults.putAll(Resources.getResourceAsProperties(resource));\n    } else if (url != null) {\n      defaults.putAll(Resources.getUrlAsProperties(url));\n    }\n  \n// è¿™é‡Œçœ‹çš„æ˜¯ xml é‡Œé¢æ˜¯ä¸æ˜¯ç›´æ¥æœ‰ porperties é…ç½®.     \n// å¦‚æœæœ‰çš„è¯,å°±ä¼šputAllè¿›å».      \n    Properties vars = configuration.getVariables();\n    if (vars != null) {\n      defaults.putAll(vars);\n    }\n// æœ€åå§ defaults,ä¹Ÿå°±æ˜¯propertiesç»™æ”¾å…¥åˆ° BaseBuilder å’Œ Confifurationä¸­å».      \n    parser.setVariables(defaults);\n    configuration.setVariables(defaults);\n  }\n}\n\n\n-----------------------------\n//  å¦‚ä½•è®© Properties vars = configuration.getVariables(); æœ‰å€¼å‘¢ ?\n//  å¦‚æœåªæ˜¯å•ä¸ªçš„ MyBatis é¡¹ç›®çš„è¯, å°±è‡ªå·±æ‰‹åŠ¨newä¸€ä¸ªpropertieså¯¹è±¡\n//  ç„¶åkeyè¾“å…¥è‡ªå·±è¦è¦†ç›–æ‰çš„keyå°±å¯ä»¥äº†\n        Properties dbConfigProperties = new Properties();\n        dbConfigProperties.setProperty(\"jdbc.password\",\"GavinYang\");\n\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mybatisInputStream,dbConfigProperties);\n```\n\n**æ ‡ç­¾äºŒ : settings**\n\nè¿™æ˜¯ MyBatiså¯¹ settings çš„æ“ä½œ.\n\nå…·ä½“çš„ settings ä¸­æ¯é¡¹é…ç½®å‚è€ƒå®˜ç½‘é“¾æ¥ : https://mybatis.org/mybatis-3/configuration.html#properties\n\n```\n// è§£æ setting ---> è½¬åŒ–ä¸º key /value\nProperties settings = settingsAsProperties(root.evalNode(\"settings\"));\n// \nloadCustomVfs(settings);\nloadCustomLogImpl(settings);\n```\n\nsettingsAsProperties æ–¹æ³•\n\nå¯ä»¥çœ‹åˆ°, è¯¥æ–¹æ³•å°±æ˜¯è¿›è¡ŒåŠ è½½,è½¬åŒ–ä¸ºkey/valueé”®å€¼å¯¹ç±»å‹, ç„¶åå¯¹å…¶keyæ£€éªŒæ˜¯å¦åœ¨\n\nConfiguration ä¸­éƒ½æœ‰ set æ–¹æ³•.\n\nNotes : ä¸ºäº†éªŒè¯ä¸‹, æˆ‘ä»¬åŠ ä¸Šä¸€ä¸ªæ²¡æœ‰çš„æ ‡ç­¾, å¯ä»¥çœ‹åˆ°ä¸‹é¢çš„å¼‚å¸¸. æ‰€ä»¥æˆ‘ä»¬çœ‹åˆ°è¿™ç§å¼‚å¸¸çš„æ—¶å€™ï¼Œæ˜¯å¯ä»¥å»æ£€æŸ¥ä¸‹æ˜¯ä¸æ˜¯åå­—ä»€ä¹ˆæœ‰é—®é¢˜.\n\n### Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: org.apache.ibatis.builder.BuilderException: The setting nnnnn is not known. Make sure you spelled it correctly (case sensitive).\n\n```\nprivate Properties settingsAsProperties(XNode context) {\n  if (context == null) {\n    return new Properties();\n  }\n // å¯¹ settings ä¸‹çš„ setting è¿›è¡Œè§£æ å¹¶ä¸” è½¬åŒ–ä¸º key / value æ“ä½œ.   \n  Properties props = context.getChildrenAsProperties();\n  // Check that all settings are known to the configuration class\n // å¯¹ Configuration è¿›è¡Œæ ¡éªŒ, ç¡®è®¤ä¸Šé¢çš„ props ä¸­çš„key åœ¨ Configuration\n// ä¸­æ˜¯éƒ½æœ‰set æ–¹æ³•çš„,ç›®æµ‹æ˜¯åé¢åå°„éœ€è¦ä½¿ç”¨åˆ°.    \n  MetaClass metaConfig = MetaClass.forClass(Configuration.class, localReflectorFactory);\n  for (Object key : props.keySet()) {\n    if (!metaConfig.hasSetter(String.valueOf(key))) {\n      throw new BuilderException(\"The setting \" + key + \" is not known.  Make sure you spelled it correctly (case sensitive).\");\n    }\n  }\n  return props;\n}\n```\n\nloadCustomVfs(settings) æ–¹æ³•\n\nè¯¥æ–¹æ³•,ä¸»è¦å°±æ˜¯è¯»å– vfsImpl å¯¹ç”¨çš„value,åˆ‡å‰²ä¸‹,ç„¶åç”¨ classForName æ¥è·å– class,\n\næœ€åèµ‹å€¼åˆ° configuration ä¸­å». è¿™é‡Œç®—æ˜¯å¯¹ vfs çš„ä¸€ç§è‡ªå®šä¹‰çš„æ‰©å±•,è™½ç„¶ç›®å‰è¿˜ä¸å¤ªæ¸…æ¥švfså…·ä½“ä½œç”¨.\n\n```\nprivate void loadCustomVfs(Properties props) throws ClassNotFoundException {\n  // è·å– vfsImpl çš„ value.  \n  String value = props.getProperty(\"vfsImpl\");\n  if (value != null) {\n   // æ ¹æ® , è¿›è¡Œåˆ‡å‰².   \n    String[] clazzes = value.split(\",\");\n    for (String clazz : clazzes) {\n      if (!clazz.isEmpty()) {\n        @SuppressWarnings(\"unchecked\")\n        // åå°„,è·å–å‡º Class , æœ€åèµ‹å€¼åˆ° configuration ä¸­å».  \n        Class<? extends VFS> vfsImpl = (Class<? extends VFS>)Resources.classForName(clazz);\n        configuration.setVfsImpl(vfsImpl);\n      }\n    }\n  }\n}\n```\n\nloadCustomLogImpl(settings) æ–¹æ³•\n\n```\nprivate void loadCustomLogImpl(Properties props) {\n  Class<? extends Log> logImpl = resolveClass(props.getProperty(\"logImpl\"));\n  // å°† log set åˆ° configuration ä¸­å».  \n  configuration.setLogImpl(logImpl);\n}\n\n-----------------------\n// resolve æœ€åå¦‚æœä¸æ˜¯ null çš„è¯,\norg.apache.ibatis.type.TypeAliasRegistry#resolveAlias\n\n // å°±ä¼šèµ°åˆ°è¿™é‡Œ,è¿™é‡Œå¯ä»¥çœ‹å…ˆæ˜¯åœ¨ typeAliases(HashMap) ä¸­åˆ¤æ–­ä¸‹,å¦‚æœå­˜åœ¨å°±ç›´æ¥è·å–\n// å¦‚æœä¸å­˜åœ¨å°±ç”¨ Resources.ClassForNameæ¥æ“ä½œ\n// è¿™é‡Œçš„ HashMapå°±ç±»ä¼¼äº,è®°å½•ä¹‹å‰æ˜¯å¦å·²ç»åŠ è½½äº†æˆ–è€…é¢„çƒ­.\n// å¦‚æœæ˜¯ç”¨æ¥åšcacheçš„è¯, é‚£å°±åº”è¯¥æœ€åä¼šåœ¨ return ä¹‹å‰ç»§ç»­æŠŠå€¼ç»™æ”¾å…¥è¿›å».    \n  public <T> Class<T> resolveAlias(String string) {\n    try {\n      if (string == null) {\n        return null;\n      }\n      // issue #748\n      String key = string.toLowerCase(Locale.ENGLISH);\n      Class<T> value;\n      if (typeAliases.containsKey(key)) {\n        value = (Class<T>) typeAliases.get(key);\n      } else {\n        value = (Class<T>) Resources.classForName(string);\n      }\n      return value;\n    } catch (ClassNotFoundException e) {\n      throw new TypeException(\"Could not resolve type alias '\" + string + \"'.  Cause: \" + e, e);\n    }\n  }    \n\n\n------------\n// å¦‚æœæˆ‘ä»¬åœ¨é…ç½®æ–‡ä»¶ä¸­æ²¡æœ‰å®šä¹‰çš„è¯,è¿™é‡Œé»˜è®¤æ˜¯null,ä¹Ÿå°±æ˜¯è¯´ä¸ä¼šsetè¿›å».    \n  public void setLogImpl(Class<? extends Log> logImpl) {\n    if (logImpl != null) {\n      this.logImpl = logImpl;\n      LogFactory.useCustomLogging(this.logImpl);\n    }\n  }\n```\n\n**æ ‡ç­¾ä¸‰ :**\n\nå…³äºåˆ«åçš„é…ç½®.\n\n```\ntypeAliasesElement(root.evalNode(\"typeAliases\"));\nprivate void typeAliasesElement(XNode parent) {\n  if (parent != null) {\n   // å¯¹ typeAliases ä¸‹çš„å­æ ‡ç­¾è¿›è¡Œè¿­ä»£.\n   // åˆ†ä¸ºæ˜¯ package å’Œé package   \n    for (XNode child : parent.getChildren()) {\n      if (\"package\".equals(child.getName())) {\n       // è·å–ä½ è¾“å…¥çš„åŒ…   \n        String typeAliasPackage = child.getStringAttribute(\"name\");\n        configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);\n      } else {\n // <typeAlias type=\"com.iyang.mybatis.pojo.TbBlog\" alias=\"TbBlog\" />\n // è¿™é‡Œå°±æ˜¯å¯¹è¿™ç§è¿›è¡Œè§£æçš„         \n        String alias = child.getStringAttribute(\"alias\");\n        String type = child.getStringAttribute(\"type\");\n        try {\n          Class<?> clazz = Resources.classForName(type);\n   // å¦‚æœæ²¡å†™åˆ«å,å°±åªä¼ å…¥ clazz.         \n          if (alias == null) {\n            typeAliasRegistry.registerAlias(clazz);\n          } else {\n   // å†™äº†åˆ«å,å°±åˆ«åå’Œclazzä¸€èµ·ä¼ å…¥è¿›æ¥.           \n            typeAliasRegistry.registerAlias(alias, clazz);\n          }\n        } catch (ClassNotFoundException e) {\n          throw new BuilderException(\"Error registering typeAlias for '\" + alias + \"'. Cause: \" + e, e);\n        }\n      }\n    }\n  }\n}\n\n\n----------------\n// è¿™é‡Œå¯ä»¥çœ‹åˆ°æ˜¯æ ¹æ® packageName æ¥ registerè¿›æ¥çš„.    \n  public void registerAliases(String packageName, Class<?> superType) {\n    // new ä¸€ä¸ªè§£æå™¨å·¥å…·ç±»\n    ResolverUtil<Class<?>> resolverUtil = new ResolverUtil<>();\n    // è·å–åŒ…çš„path,ç„¶åè·å–è¯¥åŒ…ä¸‹çš„æ–‡ä»¶,å¦‚æœæ–‡ä»¶æ˜¯.classç»“å°¾çš„è¯\n    // æœ€ååœ¨ ResolverUtil ä¸­matchessæ˜¯æœ‰è¯¥åŒ…ä¸‹çš„å…¨åç§°.\n    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);\n    // è¿™é‡Œè¿”å›çš„æ˜¯ä¸Šä¸€æ­¥è¯´çš„ matches\n    Set<Class<? extends Class<?>>> typeSet = resolverUtil.getClasses();\n    for (Class<?> type : typeSet) {\n      // Ignore inner classes and interfaces (including package-info.java)\n      // Skip also inner classes. See issue #6\n      // å¦‚æœä¸æ˜¯æ¥å£,ä¸æ˜¯å†…éƒ¨ç±»ç­‰æ¡ä»¶çš„è¯,å°±èµ°  registerAlias æ–¹æ³•\n      if (!type.isAnonymousClass() && !type.isInterface() && !type.isMemberClass()) {\n // å…ˆè·å–ç±»åå­—,åˆ¤æ–­è¯¥ç±»ä¸Šæœ‰æ²¡æœ‰ @Alias æ³¨è§£,å¦‚æœæœ‰æ³¨è§£çš„è¯,å°±ç”¨æ³¨è§£çš„å€¼ä½œä¸ºç¼©å†™çš„.\n // æœ€ååˆ¤æ–­æ˜¯ä¸æ˜¯null,æ˜¯nullå°±ä¼šæŠ›å‡ºå¼‚å¸¸æ¥.æœ€åå°†ä¸Šé¢è·å–å‡ºæ¥çš„ç¼©å†™åå­—,è½¬åŒ–ä¸ºå¤§å†™.\n // å¦‚æœæ­¤æ—¶ typeAliases æ˜¯å·²ç»æœ‰äº†è¯¥å€¼çš„è¯,å°±ä¼šæŠ›å‡ºå¼‚å¸¸æ¥.å¦åˆ™å°±æ”¾å…¥åˆ°typeAliasesæ¥\n // private final Map<String, Class<?>> typeAliases = new HashMap<>();\n // å¯ä»¥çœ‹åˆ° typeAliases æ˜¯ä¸€ä¸ªHashMap,å¹¶ä¸”å…¶å­˜å‚¨çš„Key/Valueè¿˜æ˜¯è›®æ˜æ˜¾çš„.         \n        registerAlias(type);\n      }\n    }\n  }\n```\n\n**æ ‡ç­¾å››**\n\næ‰©å±•çš„ demo å¯ä»¥å‚è€ƒ MyBatiså®˜ç½‘ : https://mybatis.org/mybatis-3/configuration.html\n\nç„¶åçœ‹ MyBatis æ˜¯å¦‚ä½•å°†æ’ä»¶ç»™åˆ©ç”¨ä¸Šçš„å‘¢ ?\n\né¦–å…ˆåœ¨ mybatis-config.xml ä¸­é…ç½®å¥½æˆ‘ä»¬è‡ªå·±å®šä¹‰çš„ plugin\n\nè¿™é‡Œä»¥æˆ‘é…ç½®äº†äºŒä¸ªæ’ä»¶\n\n```\n<plugins>\n    <plugin interceptor=\"com.iyang.mybatis.plugins.ExamplePlugin\">\n        <property name=\"name\" value=\"GavinYang\"/>\n        <property name=\"age\" value=\"22\"/>\n        <property name=\"hobby\" value=\"lwf\"/>\n    </plugin>\n\n    <plugin interceptor=\"com.iyang.mybatis.plugins.QuerySqlPlugin\">\n\n        <property name=\"name\" value=\"GavinYang\"/>\n    </plugin>\n</plugins>\n```\n\n// å¤„ç† plugin çš„ä»£ç \n\n```\nprivate void pluginElement(XNode parent) throws Exception {\n  // è¿™é‡Œä¼ å…¥è¿›æ¥çš„å°±æ˜¯ <plugins>æ•´ä¸ªæ ‡ç­¾å†…å®¹.  \n  if (parent != null) {\n   // è·å– <plugins> ä¸‹çš„ <plugin> é›†åˆ,è¿›è¡Œè¿­ä»£å¤„ç†.   \n    for (XNode child : parent.getChildren()) {\n     // è·å–æ’ä»¶çš„ å…¨é™å®šåå­—.   \n      String interceptor = child.getStringAttribute(\"interceptor\");\n     // è·å–æˆ‘ä»¬å®šä¹‰åœ¨ plugin ä¸‹çš„ properties.   \n      Properties properties = child.getChildrenAsProperties();\n// resolveClassæ˜¯æœ€åæ³¨å†Œåˆ°typeAliasRegistryæ¥.    \n// å®ä¾‹åŒ–,è¿™é‡Œå°±å¯ä»¥çœ‹åˆ°æˆ‘ä»¬åœ¨å®šä¹‰çš„Pluginä¸­,æ— å‚æ„é€ å‡½æ•°æ‰“å°å‡ºæ¥çš„å†…å®¹äº†.        \n      Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).getDeclaredConstructor().newInstance();\n// å°† properties èµ‹å€¼ç»™  interceptorInstance\n// ä¹Ÿå°±æ˜¯æ”¾å…¥åˆ° interceptorInstance æ¥.        \n      interceptorInstance.setProperties(properties);\n// org.apache.ibatis.plugin.InterceptorChain\n// è¿™æ˜¯æ˜¯å°†interceptorInstanceæ·»åŠ åˆ°InterceptorChainçš„interceptorsä¸­æ¥.        \n      configuration.addInterceptor(interceptorInstance);\n    }\n  }\n}\n```\n\nå¯ä»¥çœ‹åˆ° MyBatisåœ¨åŠ è½½pluginçš„æ—¶å€™,æ˜¯åˆ©ç”¨äº†åå°„æ¥newå‡ºä¸€ä¸ªå¯¹è±¡æ¥,å¹¶ä¸”æ³¨å†Œåˆ° typeAliasRegistry ä¸­æ¥. è¿™é‡Œä¸»è¦æ˜¯è§£æ plugin çš„é…ç½®, åé¢åœ¨æ‰§è¡Œsqlçš„æ—¶å€™,éƒ½æ˜¯å¦‚ä½•ä½¿ç”¨åˆ°è¿™äº› plugin çš„å‘¢ ? è‚¯å®šæ˜¯æœ‰ä¸€ä¸ªä»InterceptorChainä¸­è·å–interceptorsæ¥,ç„¶åè¿›è¡Œå¤„ç†.\n\n**æ ‡ç­¾äº” : < objectFactory >**\n\nobjectFactory çš„å¤„ç†æ–¹å¼æ˜¯å’Œ æ ‡ç­¾å››ç›¸ä¼¼çš„,åªæ˜¯æœ€ååœ¨ä½¿ç”¨åœºæ™¯æ˜¯æœ‰ç‚¹ä¸åŒçš„.\n\nä»£ç ä¸Šçš„æ“ä½œä¹Ÿæ˜¯ç±»ä¼¼çš„.\n\n```\nprivate void objectFactoryElement(XNode context) throws Exception {\n  if (context != null) {\n    String type = context.getStringAttribute(\"type\");\n    Properties properties = context.getChildrenAsProperties();\n    ObjectFactory factory = (ObjectFactory) resolveClass(type).getDeclaredConstructor().newInstance();\n    factory.setProperties(properties);\n    configuration.setObjectFactory(factory);\n  }\n}\n```\n\n**æ ‡ç­¾äº” :**\n\nè¯¥æ ‡ç­¾åœ¨ MyBatis å®˜ç½‘æ˜¯æ²¡æœ‰demo, æˆ‘æ˜¯æ ¹æ®ä»£ç æ¥é¡ºè—¤æ‘¸ç“œå†™çš„ä¸€ä¸ª.\n\nå‚è€ƒ : org.apache.ibatis.reflection.wrapper.DefaultObjectWrapperFactory è¿™ä¸ªæºç ,æ¥æ¨¡ä»¿å†™çš„ä¸€ä¸ª.\n\n```\nobjectWrapperFactoryElement(root.evalNode(\"objectWrapperFactory\"));\nprivate void objectWrapperFactoryElement(XNode context) throws Exception {\n  if (context != null) {\n   // è·å– é…ç½®æ–‡ä»¶ä¸­çš„typeå€¼   \n    String type = context.getStringAttribute(\"type\");\n // å…ˆæ³¨å†Œåˆ°  typeAliasRegistry æ¥,ç„¶åå®ä¾‹åŒ–è¿™ä¸ªç±».\n // æˆ‘ä»¬åœ¨è‡ªå·±å®šä¹‰çš„ç±»ä¸­,å†™ä¸€ä¸ªæ— å‚æ„é€ å‡½æ•°,å°±å¯ä»¥çœ‹åˆ°æˆ‘ä»¬æ‰“å°çš„å†…å®¹äº†.     \n    ObjectWrapperFactory factory = (ObjectWrapperFactory) resolveClass(type).getDeclaredConstructor().newInstance();\n// æœ€åèµ‹å€¼åˆ° confifuration ä¸­æ¥.      \n    configuration.setObjectWrapperFactory(factory);\n  }\n}\n```\n\n**æ ‡ç­¾å…­ : < reflectorFactory >**\n\nå¤„ç†æ–¹å¼å’Œä¸Šé¢ç±»ä¼¼.\n\nè¿™é‡Œæˆ‘ä»¬è‡ªå·±å†™ä¸€ä¸ª com.iyang.mybatis.factory.GavinReflectorFactory æ¥ç»§æ‰¿DefaultReflectorFactory,åœ¨æ— å‚æ•°æ„é€ å‡½æ•°ä¸­æ‰“å°ä¸‹å†…å®¹, ç„¶ådebugè·Ÿè¿›.\n\n```\nprivate void reflectorFactoryElement(XNode context) throws Exception {\n  if (context != null) {\n    String type = context.getStringAttribute(\"type\");\n    ReflectorFactory factory = (ReflectorFactory) resolveClass(type).getDeclaredConstructor().newInstance();\n    configuration.setReflectorFactory(factory);\n  }\n}\n```\n\n**æ ‡ç­¾ä¸ƒ :**\n\nenvironments æ ‡ç­¾éƒ½æ˜¯æ”¾å…¥ä¸€äº› db çš„é…ç½®ä¿¡æ¯ç­‰.\n\n```\n<environments default=\"development\">\n    <environment id=\"development\">\n        <!-- äº‹åŠ¡ -->\n        <transactionManager type=\"JDBC\"/>\n        \n        <!-- DB è¿æ¥é…ç½® -->\n        <dataSource type=\"POOLED\">\n            <property name=\"driver\" value=\"${jdbc.driver}\" />\n            <property name=\"url\" value=\"${jdbc.url}\" />\n            <property name=\"username\" value = \"${jdbc.username}\" />\n            <property name=\"password\" value=\"${jdbc.password}\" />\n        </dataSource>\n    </environment>\n</environments>\nprivate void environmentsElement(XNode context) throws Exception {\n  if (context != null) {\n    if (environment == null) {\n// è·å– default å¯¹åº”å­—æ®µçš„å€¼         \n      environment = context.getStringAttribute(\"default\");\n    }\n// è¿™é‡Œçš„ getChildren è·å–çš„æ˜¯ <environments> --> <environment>ä¸‹çš„å­æ ‡ç­¾      \n    for (XNode child : context.getChildren()) {\n      String id = child.getStringAttribute(\"id\");\n// ç¡®ä¿ id å’Œ  ä¸Šä¸€æ­¥çš„environment çš„å€¼æ˜¯ç›¸åŒçš„,å°±ä¼šè¿”å›true.      \n      if (isSpecifiedEnvironment(id)) {\n/**\n*  è·å–å‡º transactionManager å¯¹åº”çš„æ ‡ç­¾.\n*  ç„¶åæ ¹æ® JBDC(é…ç½®æ–‡ä»¶ä¸­çš„å€¼),ç„¶åä» typeAliasRegistryä¸­è·å–å‡ºæ¥ï¼Œ\n*  è°ƒç”¨åå°„æ¥ å®ä¾‹åŒ– è¿™ä¸ªå¯¹è±¡. \n*  æœ€åè¿˜æ˜¯å¯ä»¥é…ç½® properties,ä¼šè¢«setåˆ°txFactoryä¸­å»çš„.\n*  ä½†æ˜¯ JdbcTransactionFactory å¥½åƒæ²¡æœ‰é‡å†™ setProperties æ–¹æ³•.\n*/          \n        TransactionFactory txFactory = transactionManagerElement(child.evalNode(\"transactionManager\"));\n// å…ˆè·å–  dataSource å­—æ®µ\n/**\n*  å…ˆè·å–typeçš„å€¼,ç„¶åå†è·å– propertiesçš„æ ‡ç­¾å­—æ®µå€¼.\n*  æ ¹æ®æˆ‘ä»¬çš„é…ç½® : org.apache.ibatis.datasource.pooled.PooledDataSourceFactory,åº”è¯¥ä¼šè·å–å‡ºè¿™ä¸ªå¯¹è±¡.è¯¥å¯¹è±¡å…¶å†…éƒ¨æ˜¯æœ‰ä¸€ä¸ª,org.apache.ibatis.datasource.pooled.PooledDataSourceçš„,é‡Œé¢æœ‰éƒ¨åˆ†é»˜è®¤å€¼çš„.\n*æœ€åå°†  properties è°ƒç”¨ org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory#setPropertiesæ–¹æ³•,\næœ€åæ˜¯å°† properties é‡Œé¢çš„key/value éƒ½è®¾ç½®åˆ° MetaObject metaDataSource = SystemMetaObject.forObject(dataSource);æ¥äº†.\n*/\n        DataSourceFactory dsFactory = dataSourceElement(child.evalNode(\"dataSource\"));\n// ä»  PooledDataSourceFactory ä¸­è·å– datasource å±æ€§.         \n        DataSource dataSource = dsFactory.getDataSource();\n// è¿™é‡Œé‡‡ç”¨é“¾å¼ç¼–ç¨‹,ä¹Ÿå°±æ˜¯å°†id/txFactory/dataSource éƒ½ç»™setåˆ° Environment.Builderæ¥äº†.         \n        Environment.Builder environmentBuilder = new Environment.Builder(id)\n            .transactionFactory(txFactory)\n            .dataSource(dataSource);\n  //    environmentBuilder.build() ä¹Ÿå°±æ˜¯new äº†ä¸€ä¸ª Environment \n  // æœ€å èµ‹å€¼åˆ° configuration ä¸­æ¥äº†.        \n        configuration.setEnvironment(environmentBuilder.build());\n      }\n    }\n  }\n}\n```\n\nè§£æ environments ,åˆ©ç”¨ typeAliasRegistry ä¸­å·²ç»æ³¨å†Œå¥½äº†çš„ä¿¡æ¯,ç„¶åæ ¹æ®åå­—ç¼©å†™(æ¯”å¦‚JDBC)è¿™ç§,æ¥è·å–classå¯¹è±¡, ç”¨ åå°„æ¥ new ä¸€æ³¢å¯¹è±¡å‡ºæ¥,çœŸæ˜¯ç¾æ»‹æ»‹. æ¥ç€å°±æ˜¯è§£æ äº‹åŠ¡/JDBCè¿æ¥é…ç½®ä¿¡æ¯ç­‰, æœ€åå°†ä¿¡æ¯ä¿å­˜åˆ° DataSource ä¸­æ¥. åæ‰‹å†æ¥ä¸€æ³¢ é“¾å¼ç¼–ç¨‹ æ¥newå¯¹è±¡å‡ºæ¥, æœ€åå°±æ˜¯ä¸€ä¸ª Environment å¯¹è±¡å‡ºæ¥,ç»™set åˆ° configuration ä¸­æ¥.\n\n**æ ‡ç­¾å…«**\n\nåˆ°è¿™é‡Œ,å¯ä»¥çœ‹åˆ°å¯¹xmlçš„è§£ææ“ä½œ. å…ˆè§£æ æ ‡ç­¾ çš„å€¼å‡ºæ¥,ç„¶åæ ¹æ®å€¼è¿›è¡Œåˆ†ç±»å¤„ç†æˆ–è€…æ ¹æ®è‡ªå·±çš„éœ€æ±‚æ¥è¿›è¡Œå¤„ç†.\n\n```\nprivate void typeHandlerElement(XNode parent) {\n  if (parent != null) {\n    for (XNode child : parent.getChildren()) {\n      // å¦‚æœå­æ ‡ç­¾æ˜¯ package   \n      if (\"package\".equals(child.getName())) {\n       // è·å–å‡º name å¯¹åº”çš„å€¼.   \n        String typeHandlerPackage = child.getStringAttribute(\"name\");\n      // æ³¨å†Œåˆ°   typeHandlerRegistry ä¸­æ¥.  \n        typeHandlerRegistry.register(typeHandlerPackage);\n      } else {\n // è¿™é‡Œè·å–å‡ºä¸‰ç§å€¼æ¥,   javaType/jdbcType/  handler    \n        String javaTypeName = child.getStringAttribute(\"javaType\");\n        String jdbcTypeName = child.getStringAttribute(\"jdbcType\");\n        String handlerTypeName = child.getStringAttribute(\"handler\");\n        Class<?> javaTypeClass = resolveClass(javaTypeName);\n        JdbcType jdbcType = resolveJdbcType(jdbcTypeName);\n        Class<?> typeHandlerClass = resolveClass(handlerTypeName);\n  // åˆ†ä¸º  javaTypeClass æ˜¯ä¸æ˜¯ null çš„æƒ…å†µ       \n        if (javaTypeClass != null) {\n         // åŸºäº javaTypeClass æ˜¯ä¸æ˜¯ nullçš„æƒ…å†µ,å†åˆ¤æ–­ jdbcType æ˜¯ä¸æ˜¯null  \n          if (jdbcType == null) {\n            typeHandlerRegistry.register(javaTypeClass, typeHandlerClass);\n          } else {\n            typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass);\n          }\n        } else {\n// è¿™æ˜¯æ ¹æ®   handlerTypeName æ³¨å†Œåˆ° typeHandlerRegistry ä¸­æ¥.           \n          typeHandlerRegistry.register(typeHandlerClass);\n        }\n      }\n    }\n  }\n}\n```\n\n**æ ‡ç­¾ä¹ :**\n\nè¯¥æ ‡ç­¾æ˜¯å¯¹æˆ‘ä»¬å¯¹åº”çš„å¯¹è±¡,å…¶sqlè¯­å¥å­˜æ”¾çš„åœ°å€. ä¹Ÿå°±æ˜¯é‡Œé¢æ”¾å…¥çš„æ˜¯äºmapperæ¥å£å¯¹åº”çš„æ–¹æ³•,æŸ¥è¯¢çš„sqlè¯­å¥.\n\næ¥ä¸‹æ¥çœ‹ä¸‹ MyBatis æ˜¯å¯¹ mappers æ ‡ç­¾çš„å†…å®¹è¿›è¡Œäº†è¯´æ˜è§£æå’Œå¤„ç†.\n\n```java\nprivate void mapperElement(XNode parent) throws Exception {\n  if (parent != null) {\n      \n // getChildren è·å–çš„æ˜¯ mappers ä¸‹çš„ mapper æ ‡ç­¾\n    for (XNode child : parent.getChildren()) {\n// å¦‚æœé…ç½®çš„æ˜¯ package.        \n      if (\"package\".equals(child.getName())) {\n        String mapperPackage = child.getStringAttribute(\"name\");\n        configuration.addMappers(mapperPackage);\n      } else {\n// è·å–å‡º    resource/url/class è¿™ä¸‰ç±»çš„å€¼.       \n        String resource = child.getStringAttribute(\"resource\");\n        String url = child.getStringAttribute(\"url\");\n        String mapperClass = child.getStringAttribute(\"class\");\n // å¯¹ resource å¤„ç†         \n        if (resource != null && url == null && mapperClass == null) {\n          // å°† resource èµ‹å€¼ç»™ ErrorContext ä¸­  \n          ErrorContext.instance().resource(resource);\n     // è¯»å–æ–‡ä»¶.       \n          InputStream inputStream = Resources.getResourceAsStream(resource);\n// ä½¿ç”¨ XMLMapperBuilder æ¥å¯¹è§£æxmlå†…å®¹.            \n          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());\n          mapperParser.parse();\n// url å¤„ç†            \n        } else if (resource == null && url != null && mapperClass == null) {\n          ErrorContext.instance().resource(url);\n          InputStream inputStream = Resources.getUrlAsStream(url);\n          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());\n          mapperParser.parse();\n// mapperClass å¤„ç†            \n        } else if (resource == null && url == null && mapperClass != null) {\n          Class<?> mapperInterface = Resources.classForName(mapperClass);\n          configuration.addMapper(mapperInterface);\n        } else {\n          throw new BuilderException(\"A mapper element may only specify a url, resource or class, but not more than one.\");\n        }\n      }\n    }\n  }\n}\n\n\n\n-----------------------\n// è¿™é‡Œæˆ‘ä»¬è·Ÿè¿› mapperParser.parse() æ–¹æ³•æ¥\n// org.apache.ibatis.builder.xml.XMLMapperBuilder\n  public void parse() {\n  // åˆ¤æ–­ configuration çš„ loadedResources æ˜¯å¦å«æœ‰è¯¥å€¼,å¦‚æœä¸å«æœ‰çš„è¯,å°±ä¼šå»è§£æ.  \n    if (!configuration.isResourceLoaded(resource)) {\n// å¯¹mapper æ ‡ç­¾è¿›è¡Œè§£æ        \n      configurationElement(parser.evalNode(\"/mapper\"));\n      configuration.addLoadedResource(resource);\n      bindMapperForNamespace();\n    }\n\n    parsePendingResultMaps();\n    parsePendingCacheRefs();\n    parsePendingStatements();\n  }    \n\n-----------------------------------\n//   configurationElement æ–¹æ³•\n\n  private void configurationElement(XNode context) {\n    try {\n // è·å– namespace       \n      String namespace = context.getStringAttribute(\"namespace\");\n      if (namespace == null || namespace.equals(\"\")) {\n        throw new BuilderException(\"Mapper's namespace cannot be empty\");\n      }\n//  MapperBuilderAssistant å°† namespace ç»‘å®šåˆ°è¯¥ç±»çš„å‚æ•°ä¸­æ¥.        \n      builderAssistant.setCurrentNamespace(namespace);\n  \n   // è¿™é‡Œçš„ cache-ref / cache éƒ½æ˜¯æš‚æ—¶æ²¡æœ‰é…ç½®çš„.     \n      cacheRefElement(context.evalNode(\"cache-ref\"));\n      cacheElement(context.evalNode(\"cache\"));\n        \n //  /mapper/parameterMap ä¹Ÿæ˜¯æš‚æ—¶æ²¡æœ‰é…ç½®çš„  \n      parameterMapElement(context.evalNodes(\"/mapper/parameterMap\"));\n        \n// resultMap æ˜¯å¯¹å¯¹è±¡å­—æ®µçš„æ˜ å°„\n// mapper/sql æ˜¯å¯¹ä¸€äº›å…¬ç”¨çš„sqlè¿›è¡ŒæŠ½å–\n// äºŒè€…æš‚æ—¶éƒ½æ²¡æœ‰é…ç½®        \n      resultMapElements(context.evalNodes(\"/mapper/resultMap\"));\n      sqlElement(context.evalNodes(\"/mapper/sql\"));\n// è·å– select / insert / update / delete ç­‰ æ ‡ç­¾.        \n      buildStatementFromContext(context.evalNodes(\"select|insert|update|delete\"));\n    } catch (Exception e) {\n      throw new BuilderException(\"Error parsing Mapper XML. The XML location is '\" + resource + \"'. Cause: \" + e, e);\n    }\n  }    \n\n// å¾€ä¸‹è·Ÿæ–¹æ³•\n  private void buildStatementFromContext(List<XNode> list, String requiredDatabaseId) {\n    for (XNode context : list) {\n      final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);\n      try {\n        statementParser.parseStatementNode();\n      } catch (IncompleteElementException e) {\n        configuration.addIncompleteStatement(statementParser);\n      }\n    }\n  }\n```\n\n","tags":["javaæ¡†æ¶","mybatis"],"categories":["javaæ¡†æ¶","mybatis"]},{"title":"SpringBootåŠ¨æ€æ·»åŠ æ¥å£","url":"/2021/11/04/spring/SpringBootåŠ¨æ€æ·»åŠ æ¥å£/","content":"\n\n\n## èƒŒæ™¯\n\næœ€è¿‘çœ‹äº†å…¬å¸çš„äº§å“,æœ‰ä¸€ä¸ªè¿™æ ·çš„åŠ¨æ€,å°±æ˜¯æ ¹æ®inputè¾“å…¥çš„å†…å®¹,è¿›è¡ŒåŠ¨æ€æ¥å£çš„æ·»åŠ .\n\næ¯”å¦‚ æˆ‘åœ¨æ²¡æœ‰æ·»åŠ ä¹‹å‰,è®¿é—® http://localhost:8080/test è¯¥åœ°å€æ˜¯404, äºæ˜¯é€šè¿‡inputçš„è¾“å…¥åˆ›å»º,å°±ç›¸å½“äºåŠ¨æ€æ·»åŠ äº†ä¸€ä¸ªæ¥å£,äºæ˜¯å°±å¯ä»¥è®¿é—®äº†.\n\nå®ç°çš„æ–¹å¼æœ‰å¾ˆå¤šç§, å…·ä½“çš„æƒ³è¦çš„æ•ˆæœè‚¯å®šæ˜¯éœ€è¦æ ¹æ®è‡ªå·±çš„ä¸šåŠ¡è§’åº¦æ¥.\n\n## å®ç°æ€è·¯\n\nè¿™é‡Œæ˜¯è¯´ä¸‹ä¸ªäººçš„å®ç°æ€è·¯ :\n\n- æ–¹æ¡ˆä¸€ : å…ˆå®šä¹‰å¥½ç±»,ç„¶åä½¿ç”¨åå°„æ ¹æ®å®šä¹‰çš„ç±»,åˆ›å»ºå¥½ä¸€ä¸ªå¯¹è±¡å‡ºæ¥,ç„¶åå°†è¿™ä¸ªå¯¹è±¡ç»™æ³¨å…¥åˆ°Springå®¹å™¨ä¸­æ¥,è¿™é‡Œä¸ä»…ä»…æ˜¯æ³¨å…¥è¿›æ¥è¿™ä¹ˆç®€å•,è¿˜æ˜¯éœ€è¦ç»è¿‡ MVC(ä¹Ÿå°±æ˜¯Controllerç­‰æ³¨è§£çš„åŒ¹é…æ“ä½œ)æ¥å®ç°\n- æ–¹æ¡ˆäºŒ : åŸºäºè¯·æ±‚404çš„æ‹¦æˆªæ¥ç°å®. æ¯”å¦‚ä½ æ–°æ·»åŠ çš„æ¥å£è®¿é—®è‚¯å®šæ˜¯404,äºæ˜¯æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªæ‹¦æˆª,ç„¶åè·å–å‡ºè¯·æ±‚çš„è·¯å¾„,æ ¹æ®æå‰å®šå¥½çš„ä¸€äº›è®¾ç½®,è¿›è¡Œé€»è¾‘çš„å¤„ç†.\n\nè¿™é‡Œè‚¯å®šè¿˜ä¼šæœ‰å¾ˆå¤šå¥½çš„å®ç°æ€è·¯,å¹¶ä¸”åŸºäºæ¯ä¸ªæ¡†æ¶éƒ½æ˜¯ä¸ä¸€æ ·çš„,è¿™é‡Œæ›´å¤šçš„æ˜¯åŸºäº SpringBootæ¡†æ¶æ¥å®ç°è¿™ä¸ªæ€è·¯çš„.\n\n## ä»£ç å®ç°\n\n### åŸºäºåå°„åˆ›å»ºbeanæ³¨å…¥ä»£ç å®ç°\n\nå®šä¹‰ä¸€ä¸ªç±»çš„æ¨¡æ¿\n\n```java\npublic String templateValue = \"import org.springframework.web.bind.annotation.GetMapping;\\n\" +\n        \"import org.springframework.web.bind.annotation.RequestMapping;\\n\" +\n        \"import org.springframework.web.bind.annotation.RestController;\\n\" +\n        \"@RestController\\n\" +\n        \"@RequestMapping(\\\"/test\\\")\\n\" +\n        \"public class TestController {\\n\" +\n        \"    @GetMapping(\\\"/test\\\")\\n\" +\n        \"    public String test(){\\n\" +\n        \"        return \\\"æµ‹è¯•Testæ¥å£\\\";\\n\" +\n        \"    }\\n\" +\n        \"}\";\n```\n\næä¾›ä¸€ä¸ªæ¥å£æ¥åå°„åˆ›å»ºå¯¹è±¡å¹¶ä¸”æ³¨å…¥åˆ°springå®¹å™¨ä¸­æ¥:\n\n```java\n@GetMapping(\"/create\")\n    public void createTemplate() throws Exception {\n\n        Map<String, byte[]> bytecode = DynamicLoader.compile(\"TestController.java\", templateValue);\n        MemoryClassLoader classLoader = new MemoryClassLoader(bytecode);\n        Class clazz = classLoader.loadClass(\"TestController\");\n        Object object = clazz.newInstance();\n\n        // æ³¨å…¥ bean å®¹å™¨çš„ä»£ç  : å®¹å™¨ä¸­æ˜¯å­˜åœ¨è¿™ä¸ª bean å¯¹è±¡çš„,ä½†æ˜¯Controllerå´æ²¡æœ‰è®¿é—®åˆ°.\n        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(object.getClass());\n        ConfigurableApplicationContext context = springUtils.getContext();\n        DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) context.getBeanFactory();\n        beanFactory.registerBeanDefinition(\"testController\",builder.getBeanDefinition());\n\n        RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class);\n        Object oj = context.getBean(\"testController\");\n        Map<Method, RequestMappingInfo> methods = MethodIntrospector.selectMethods(oj.getClass(),(MethodIntrospector.MetadataLookup<RequestMappingInfo>) method ->{\n            try{\n                RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(method, RequestMapping.class);\n                RequestMappingInfo.Builder mappping = RequestMappingInfo.paths(requestMapping.path())\n                                  .methods(requestMapping.method())\n                                  .params(requestMapping.params())\n                                  .headers(requestMapping.headers())\n                                  .consumes(requestMapping.consumes())\n                                  .produces(requestMapping.produces())\n                                  .mappingName(requestMapping.name());\n                return mappping.build();\n            } catch (Exception e){\n                e.printStackTrace();\n            }\n            return null;\n        });\n\n        Method rmhmMethod = mappingHandlerMapping.getClass()\n                            .getDeclaredMethod(\"registerHandlerMethod\",new Class[]{Object.class, Method.class, Object.class});\n\n        rmhmMethod.setAccessible(true);\n        methods.forEach((method,mapping) -> {\n            try{\n                rmhmMethod.invoke(mappingHandlerMapping,new Object[]{oj,method,mapping} );\n            }catch (Exception e){\n                e.printStackTrace();\n            }\n        });\n\n    }\n```\n\nSpringå·¥å…·ç±»\n\n```java\n@Component\npublic class SpringUtils implements ApplicationContextAware {\n\n    private ApplicationContext context;\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        context = applicationContext;\n    }\n\n    public ConfigurableApplicationContext getContext() {\n        return (ConfigurableApplicationContext)context;\n    }\n\n    public void setContext(ApplicationContext context) {\n        this.context = context;\n    }\n}\n```\n\nåˆ°æ­¤,å°±å¯ä»¥åŠ¨æ€çš„åˆ›å»ºå‡ºä¸€ä¸ªæ¥å£æ¥äº†ã€‚\n\nå½“ç„¶äº†,è¿™é‡Œçš„ä»£ç éƒ½æ˜¯å†™å›ºå®šåœ¨ä»£ç é‡Œé¢çš„,å¯ä»¥æä¾› template æˆ–è€… é€šè¿‡é¡µé¢å®šä¹‰ç»™æ·»åŠ è¿›æ¥, ç„¶åè°ƒç”¨ åå°„/æ³¨å…¥åˆ°Springå®¹å™¨ä¸­ç­‰æ“ä½œå³å¯.\n\n### åŸºäº 404 æ‹¦æˆªè¯·æ±‚\n\nè¿™æ˜¯ SpringBoot æœ¬æ¥å°±æœ‰çš„ 404 æ‹¦æˆªå®ç°, å¦‚æœä¸åšä»€ä¹ˆå¤„ç†çš„è¯,é‚£ä¹ˆè¿›å…¥åˆ°è¿™é‡Œæ¥çš„urlåœ°å€å°±ä¼šæ˜¯/error,æ˜¯æ— æ³•æ»¡è¶³å®ç°çš„.\n\n```java\n@Slf4j\n@RestController\npublic class SelfErrorController implements ErrorController {\n\n    private final static String ERROR_PATH = \"/error\";\n\n    /**\n     * Supports the HTML Error View\n     *\n     * @param request\n     * @return\n     */\n    @RequestMapping(value = ERROR_PATH)\n    public String errorHtml(HttpServletRequest request) {\n        Integer statusCode = (Integer) request.getAttribute(\"javax.servlet.error.status_code\");\n        String requestURI = request.getRequestURI();\n        log.info(\"åœ¨SelfErrorControllerä¸­è¯·æ±‚çš„è·¯å¾„ : {} \" ,requestURI);\n\n        // æ‹¿åˆ°è·¯å¾„åå°±å¯ä»¥æ‰§è¡Œç›¸åº”çš„ä»£ç é€»è¾‘.\n        String realUrlName = request.getAttribute(\"realName\").toString();\n        log.info(\"åœ¨SelfErrorControllerä¸­çœŸå®å­˜åœ¨çš„è¯·æ±‚è·¯å¾„æ˜¯ : --> {} \" , realUrlName);\n\n        if(statusCode == 401){\n            return  \"{ \\\"code\\\": \\\"401\\\"}\";\n        }else if(statusCode == 404){\n            return \"{ \\\"code\\\": \\\"404\\\"}\";\n        }else if(statusCode == 403){\n            return \"{ \\\"code\\\": \\\"403\\\"}\";\n        }else{\n            return \"{ \\\"code\\\": \\\"500\\\"}\";\n        }\n    }\n    @Override\n    public String getErrorPath() {\n        return null;\n    }\n}\n```\n\nå› ä¸ºä¸Šé¢æ— æ³•æ»¡è¶³çš„å‰æä¸‹,æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ‹¦æˆªæ¥é…ç½®åŸæ¥çš„è·¯å¾„.\n\né…ç½®ç±»:\n\n```java\n@Configuration\npublic class MyWebAppConfigurer implements WebMvcConfigurer {\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new SelfInterceptor()).addPathPatterns(\"/**\");\n    }\n}\n```\n\nè‡ªå®šä¹‰æ‹¦æˆªå™¨:\n\nè¿™é‡Œå¯ä»¥çœ‹åˆ°å°†åŸæœ‰çš„è·¯å¾„ç»™setå­—æ®µrealNameäº†.\n\næ‰€ä»¥åœ¨ä¸Šé¢çš„erroræ¥å£,æˆ‘ä»¬è°ƒç”¨è¿™ä¸ªrealNameå­—æ®µå°±å¯ä»¥è·å–åˆ°äº†åŸæœ‰çš„è·¯å¾„.\n\n```java\n@Component\n@Slf4j\npublic class SelfInterceptor implements HandlerInterceptor {\n    \n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,\n                             Object handler) throws Exception {\n        // å‰ç½®æ‹¦æˆªå™¨\n        log.info(\"å‰ç½®æ‹¦æˆªå™¨è°ƒç”¨ : com.iyang.hello.boot.config.SelfInterceptor.preHandle ä¸­æ¥.\" );\n        String requestURI = request.getRequestURI();\n        log.info(\"åœ¨preHandleæ–¹æ³•ä¸­æ•æ‰åˆ°çš„è¯·æ±‚è·¯å¾„ : ---> {} \" , requestURI);\n        // handler æ˜¯ ResourceHttpRequestHandler\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response,\n                           Object handler, ModelAndView modelAndView) throws Exception {\n        String requestURI = request.getRequestURI();\n        request.setAttribute(\"realName\",requestURI);\n        if(response.getStatus() == 404){\n            log.info(\"çŠ¶æ€æ˜¯404æ­£å¸¸æ“ä½œ\");\n        }\n        log.info(\"è¯·æ±‚çš„urlè·¯å¾„æ˜¯ ---> {} \" , requestURI);\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,\n                                Object handler, Exception ex) throws Exception {\n\n    }\n}\n```\n\n## æ€»ç»“\n\nè¯¥æŠ€èƒ½çœ‹åˆ°æ¯”è¾ƒæœ‰æ„æ€,å…·ä½“çš„å®ç°å’Œè®¾è®¡æ€è·¯å…¶å®æ˜¯æœ‰å¾ˆå¤šç§çš„,å…·ä½“å¾—çœ‹é¡¹ç›®çš„ä¸šåŠ¡æ˜¯ä¸æ˜¯éœ€è¦ä½¿ç”¨.\n\nå¹¶ä¸”å®ç°çš„æ€è·¯å¹¶ä¸æ˜¯åªæœ‰è¿™ä¸€ç§,è‚¯å®šæ˜¯è¿˜æœ‰å¾ˆå¤šç§çš„.\n\né€‚åˆè‡ªå·±çš„ä¸šåŠ¡æ˜¯æœ€å¥½çš„.\n","tags":["java","springBoot"],"categories":["java","springBoot"]},{"title":"springçš„refreshæ–¹æ³•é˜…è¯»","url":"/2021/11/04/spring/springçš„refreshæ–¹æ³•é˜…è¯»/","content":"\n\n\n#### å‰è¨€\n\nè¿™é‡Œæ˜¯ç›¸å¯¹ä¸Šä¸€æ¬¡å†æ¬¡çš„é˜…è¯»å’Œè®°å½•,æ¯”ä¸Šæ¬¡æœ‰äº†æ›´æ·±å…¥çš„ç†è§£.\n\nè¿™é‡Œæ˜¯å†æ¬¡æ•´ç†çš„é˜…è¯» Spring çš„æºç , ç›¸å¯¹æ¯”ä¸Šæ¬¡çš„é˜…è¯»ï¼Œæˆ‘å¸Œæœ›è¿™æ¬¡å¯ä»¥æ›´æ¸…æ™°&æ›´æ·±åˆ»çš„ç†è§£Spring,ä¹Ÿä¸ä»…ä»…ä¼šä»ä¸€ä¸ªæ¡ˆä¾‹æ¥è¿›è¡Œåˆ†æï¼Œä¼šç»“åˆå¤šæ–¹é¢çš„çŸ¥è¯†æ¥è¿›è¡Œæ•´ç†åˆ†æ.\n\n è¿™é‡Œæ”¾ä¸Šä¹‹å‰é˜…è¯»çš„æ¯”ä¾‹ : https://github.com/baoyang23/source-notes/tree/master/java/spring_bean\n\n è¯¥ç›®å½•ä¸‹é¢æœ‰ : bean/get/extend ä¸‰ä¸ªä¸»è¦åœ°æ–¹çš„åˆ†æ.\n\n æ­¤æ¨¡å—è¿˜æ˜¯è®²è¿° æ•´ä½“çš„ flow,åé¢ä¼šå¯¹å•ä¸ªè¿›è¡Œåˆ†æ&Springæä¾›æ€ä¹ˆæ ·çš„æ‰©å±•æ–¹å¼æ¥è¿›è¡Œå¢å¼ºæ‰©å±•ç­‰.\n\næ¡ˆä¾‹å…¥é—¨æ“ä½œçš„è¯,å¯ä»¥å‚è€ƒä¹‹å‰çš„åšå®¢.\n\n#### åˆ†æ\n\n è¿™é‡Œæˆ‘ä»¬å…ˆä¸å¿™è¿™å…¶ä»–ç±»å‹çš„beanåˆ†æ, å°±å¯¹æˆ‘ä»¬ä½œä¸º config çš„ bean è¿›è¡Œåˆ†æ. å…ˆå•ä¸ªåˆ†æå®¹æ˜“ç†è§£äº›.\n\n å…¥å£ç±» :\n\n```java\npublic class InitWorkFlowSpring {\n\n\n    public static void main(String[] args) {\n\n        AnnotationConfigApplicationContext context =\n                new AnnotationConfigApplicationContext(YangBeanScannerConfig.class);\n        YangBeanScannerConfig yangBeanScannerConfig = context.getBean(YangBeanScannerConfig.class);\n        yangBeanScannerConfig.say();\n\n    }\n\n}\n```\n\n é…ç½®ç±»:\n\n```java\n@ComponentScan(basePackages = \"com.iyang.spring\")\n@Description(value = \"This is GavinYang DemoWorld.\")\npublic class YangBeanScannerConfig {\n\n    public YangBeanScannerConfig(){\n        System.out.println(\"é…ç½®æ‰«æåˆå§‹åŒ–æ‰“å°\");\n    }\n\n    public void say(){\n        System.out.println(\"æˆ‘æ˜¯ä»Springå®¹å™¨ä¸­è·å–å‡ºæ¥çš„\");\n    }\n}\n```\n\nå¯ä»¥çœ‹åˆ°ï¼Œå½“æˆ‘ä»¬å¯åŠ¨ main æ–¹æ³•çš„æ—¶å€™ï¼Œæ˜¯å¯ä»¥çœ‹åˆ° YangBeanScannerConfig ä¸­æ„é€ å‡½æ•°æ‰“å°çš„å†…å®¹å’Œè°ƒç”¨sayæ–¹æ³•æ‰“å°å‡ºæ¥çš„å†…å®¹.\n\nåŸºäºè¿™ä¸ªåŸºç¡€ä¸Š,æˆ‘ä»¬debugä¸€å±‚ä¸€å±‚çš„èµ°è¿›å»çœ‹,Springåšäº†ä»€ä¹ˆäº‹æƒ….\n\nå…ˆè¿›å…¥åˆ°æˆ‘ä»¬newå‡ºæ¥çš„AnnotationConfigApplicationContextä¸­æ¥\n\nè°ƒç”¨è‡ªèº«çš„æ— å‚æ„é€ å‡½æ•°\n\nè°ƒç”¨ register æ³¨å†Œæ–¹æ³•\n\næœ€åè°ƒç”¨ä¸€ä¸ª refresh, refresh æ–¹æ³•ä¸­æ˜¯åšäº†å¾ˆå¤šäº‹çš„.\n\n```java\npublic AnnotationConfigApplicationContext(Class<?>... componentClasses) {\n   this();\n   register(componentClasses);\n   refresh();\n}\n```\n\né‚£ä¹ˆæœ‰äº†å…¥å£ï¼Œæˆ‘ä»¬å°±æ ¹æ®è¿™äº›æ–¹æ³•æ¥ä¸€ä¸ªä¸€ä¸ªçš„åˆ†æ.\n\n#### this() æ–¹æ³• â€”> org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext()\n\nå…ˆæ¥çœ‹ this æ–¹æ³•åšäº†ä»€ä¹ˆäº‹æƒ….\n\nåˆ›å»ºäº†äºŒä¸ªå¯¹è±¡ï¼Œåˆ†åˆ«æ˜¯ æ³¨è§£bdè¯»å–/ç±»è·¯å£dbæ‰«æ.\n\næ¯”å¦‚æœ‰æ„æ€çš„æ˜¯,ä¼ å…¥this(AnnotationConfigApplicationContext), ç„¶åè¿”å›æ¥çš„reader/scanneråˆå±äºthis.ä¹Ÿæ˜¯ç›¸äº’ä¹‹é—´å„è‡ªéƒ½æŒæœ‰å„è‡ªçš„å¼•ç”¨.\n\n```java\npublic AnnotationConfigApplicationContext() {\n   this.reader = new AnnotatedBeanDefinitionReader(this);\n   this.scanner = new ClassPathBeanDefinitionScanner(this);\n}\n```\n\n##### new AnnotatedBeanDefinitionReader\n\næ¥ï¼Œçœ‹ä¸‹newä¸€ä¸ªå¯¹è±¡åšäº†ä»€ä¹ˆäº‹æƒ….\n\n```java\npublic AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) {\n// è¿™é‡Œçš„ getOrCreateEnvironment æ–¹æ³•ä¸­,AnnotationConfigApplicationContextæ˜¯EnvironmentCapableçš„å­ç±»,\n// æ‰€ä»¥Environmentä¹Ÿæ˜¯ä»AnnotationConfigApplicationContextä¸­è·å–å‡ºæ¥çš„.    \n   this(registry, getOrCreateEnvironment(registry));\n}\n\n--------------\n    \npublic AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {\n // æ£€éªŒ registry/environmentéƒ½ä¸èƒ½ä¸ºnull.   \n\t\tAssert.notNull(registry, \"BeanDefinitionRegistry must not be null\");\n\t\tAssert.notNull(environment, \"Environment must not be null\");\n\t\tthis.registry = registry;\n// è¿™é‡Œå°† registry/environment ç»™ä¼ å…¥æ„é€ åˆ° org.springframework.context.annotation.ConditionEvaluator ä¸­æ¥.\n// ConditionEvaluatoråˆå€ŸåŠ©org.springframework.context.annotation.ConditionEvaluator.ConditionContextImpl#ConditionContextImpl æ¥å­˜å‚¨è¿™äº›ä¿¡æ¯,æ‰€ä»¥è¿™é‡Œæœ€åçš„ä¿¡æ¯æ˜¯åœ¨ConditionContextImplä¸­æ¥äº†.    \n\t\tthis.conditionEvaluator = new ConditionEvaluator(registry, environment, null);\n// org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors(org.springframework.beans.factory.support.BeanDefinitionRegistry, java.lang.Object)\n// ä»è¯¥æ–¹æ³•çš„åå­—ä¸Šçœ‹,æ˜¯å¯¹æ³¨å†Œæ³¨è§£é…ç½®è¿›è¡Œå¤„ç†.    \n\t\tAnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);\n}\n```\n\n###### org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors(org.springframework.beans.factory.support.BeanDefinitionRegistry, java.lang.Object) åˆ†æ\n\nè¿™é‡Œæ ¹æ®æˆ‘ä»¬çš„æ¡ˆåˆ—ï¼Œä¼ å…¥è¿›æ¥çš„sourceæ˜¯null.\n\n```java\npublic static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(\n      BeanDefinitionRegistry registry, @Nullable Object source) {\n// æ ¹æ® registry çš„ç±»å‹æ¥è·å– DefaultListableBeanFactory.\n// è¿™é‡Œçš„registryå±äºGenericApplicationContext,è°ƒç”¨å…¶getDefaultListableBeanFactoryæ¥è·å–.    \n   DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);\n   if (beanFactory != null) {\n// beanFactory.getDependencyComparator() è¿”å›çš„æ˜¯null,æ»¡è¶³æ¡ä»¶.       \n      if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {\n// è®¾ç½® AnnotationAwareOrderComparator åˆ°beanFactoryä¸­æ¥          \n         beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);\n      }\n// getæ–¹æ³•è·å–å‡ºæ¥çš„æ˜¯SimpleAutowireCandidateResolver,       \n      if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {\n// è®¾ç½®ContextAnnotationAutowireCandidateResolveråˆ°beanFactoryä¸­æ¥.          \n         beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());\n      }\n   }\n\n   Set<BeanDefinitionHolder> beanDefs = new LinkedHashSet<>(8);\n\n// å¯ä»¥çœ‹åˆ°æ¯ä¸ªéƒ½æœ‰ internal æ¥ç‰¹æ„è¡¨æ˜å†…éƒ¨çš„æ„æ€.    \n// org.springframework.context.annotation.internalConfigurationAnnotationProcessor --->  ConfigurationClassPostProcessor\n// org.springframework.context.annotation.internalAutowiredAnnotationProcessor  --> AutowiredAnnotationBeanPostProcessor\n// org.springframework.context.annotation.internalCommonAnnotationProcessor   ---> CommonAnnotationBeanPostProcessor \n// org.springframework.context.annotation.internalPersistenceAnnotationProcessor  ---> PersistenceAnnotationBeanPostProcessor\n// org.springframework.context.event.internalEventListenerProcessor   ---> EventListenerMethodProcessor\n// org.springframework.context.event.internalEventListenerFactory  --- > DefaultEventListenerFactory\n   if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n      RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);\n      def.setSource(source);\n      beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));\n   }\n\n   if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n      RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);\n      def.setSource(source);\n      beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));\n   }\n\n   // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.\n   if (jsr250Present && !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n      RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);\n      def.setSource(source);\n      beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));\n   }\n\n   // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.\n   if (jpaPresent && !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n      RootBeanDefinition def = new RootBeanDefinition();\n      try {\n         def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,\n               AnnotationConfigUtils.class.getClassLoader()));\n      }\n      catch (ClassNotFoundException ex) {\n         throw new IllegalStateException(\n               \"Cannot load optional framework class: \" + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);\n      }\n      def.setSource(source);\n      beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));\n   }\n\n   if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {\n      RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);\n      def.setSource(source);\n      beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));\n   }\n\n   if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {\n      RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);\n      def.setSource(source);\n      beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));\n   }\n\n   return beanDefs;\n}\n```\n\nè¿™é‡Œéƒ½æ˜¯å…ˆåˆ¤æ–­è¿™äº›å†…éƒ¨çš„bean,æ˜¯ä¸æ˜¯å·²ç»åœ¨ registry ä¸­å·²ç»å­˜åœ¨äº†,å¦‚æœæ²¡æœ‰å­˜åœ¨çš„è¯ï¼Œå°±ä¼šåˆ©ç”¨ç±»ä¿¡æ¯æ¥æ„é€ å‡ºä¸€ä¸ªRootBeanDefinitionæ¥,æ¥ç€å°±æ˜¯è°ƒç”¨ registerPostProcessor æ–¹æ³•ç»™æ³¨å†Œåˆ° registry ä¸­æ¥.\n\næœ€åè¿”å›ä¸€ä¸ªæ³¨å†Œè¿‡çš„ bean çš„ Set é›†åˆå›å».\n\næ€»ç»“ä¸‹è¿™é‡Œå°±æ˜¯ä¸ºäº†ç»™springå®¹å™¨ä¸­æ³¨å†Œä¸€äº›å†…éƒ¨çš„ bean è¿›å». è¿™äº›æ³¨å†Œè¿›å»çš„bean,éƒ½æ˜¯åœ¨åé¢åˆå§‹åŒ–bean&è§£æbeanç­‰æƒ…å†µæœ‰ä½¿ç”¨åˆ°çš„.\n\n##### new ClassPathBeanDefinitionScanner() æ–¹æ³•\n\n```java\npublic ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters) {\n   this(registry, useDefaultFilters, getOrCreateEnvironment(registry));\n}\n\n-----------------------------------------------------\n// æœ€åèµ°åˆ° org.springframework.context.annotation.ClassPathBeanDefinitionScanner#ClassPathBeanDefinitionScanner(org.springframework.beans.factory.support.BeanDefinitionRegistry, boolean, org.springframework.core.env.Environment, org.springframework.core.io.ResourceLoader) æ„é€ å‡½æ•°æ¥.    \npublic ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters,\n\t\t\tEnvironment environment, @Nullable ResourceLoader resourceLoader) {\n\n\t\tAssert.notNull(registry, \"BeanDefinitionRegistry must not be null\");\n// èµ‹å€¼ registry æ¥.    \n\t\tthis.registry = registry;\n\n\t\tif (useDefaultFilters) {\n// æ·»åŠ  filter åˆ° includeFilters ä¸­æ¥.\n// AnnotationTypeFilter(Component.class)\n// AnnotationTypeFilter(((Class<? extends Annotation>) ClassUtils.forName(\"javax.annotation.ManagedBean\", cl)     \n// ç­‰ä¿¡æ¯è¿›æ¥      \n\t\t\tregisterDefaultFilters();\n\t\t}\n// org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#setEnvironment\n// è®¾ç½® enviornmentåˆ°çˆ¶ç±»ä¸­æ¥.    \n\t\tsetEnvironment(environment);\n// è¿™é‡Œä¹Ÿæ˜¯è¿™æ˜¯åˆ°çˆ¶ç±»æ¥äº†.\n// è¿”å›çš„resourcePatternResolveræ˜¯AnnotationConfigApplicationContext.\n// metadataReaderFactory æ˜¯ CachingMetadataReaderFactory å¯¹è±¡æ¥.\n// componentsIndex æ˜¯ null.    \n\t\tsetResourceLoader(resourceLoader);\n}\n```\n\nè¯¥æ–¹æ³•å¯ä»¥çœ‹åˆ°,æ·»åŠ äº†ä¸‰ä¸ª filter åˆ° includeFilters ä¸­æ¥.\n\nè®¾ç½®environment / resource åˆ° å…¶çˆ¶ç±»org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider ä¸­æ¥.\n\nä¹Ÿå°±æ˜¯setXXXæ–¹æ³•æ˜¯è°ƒç”¨çš„çˆ¶ç±».\n\n#### register(componentClasses) æ–¹æ³•\n\n```java\n@Override\npublic void register(Class<?>... componentClasses) {\n   //  æ£€éªŒä¼ å…¥è¿›æ¥çš„ comonpentClassesæ˜¯ä¸€å®šè¦æœ‰å€¼çš„. \n   Assert.notEmpty(componentClasses, \"At least one component class must be specified\");\n   this.reader.register(componentClasses);\n}\n\n-------------------------\n// è¿™é‡Œä»åå­—ä¸Šå°±å¯ä»¥å¾ˆå®¹æ˜“çœ‹å‡ºæ˜¯æ³¨å†Œ bean çš„    \npublic void register(Class<?>... componentClasses) {\n\t\tfor (Class<?> componentClass : componentClasses) {\n\t\t\tregisterBean(componentClass);\n\t\t}\n\t}\n\n-----------------------------\nprivate <T> void doRegisterBean(Class<T> beanClass, @Nullable String name,\n\t\t\t@Nullable Class<? extends Annotation>[] qualifiers, @Nullable Supplier<T> supplier,\n\t\t\t@Nullable BeanDefinitionCustomizer[] customizers) {\n// new ä¸€ä¸ª bd å‡ºæ¥.\n\t\tAnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(beanClass);\n// è¿™é‡Œæ²¡æœ‰ @Conditional æ³¨è§£å’Œ metadata æ˜¯ null å°±ä¼šç›´æ¥è¿”å› false æ¥.    \n\t\tif (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {\n\t\t\treturn;\n\t\t}\n\n\t\tabd.setInstanceSupplier(supplier);\n \n// åœ¨å¯¹è±¡ä¸Šè·å– @Scope æ³¨è§£,è¿™é‡Œæ²¡æœ‰,æ‰€ä»¥å°±ä¸ä¼šå¾€ä¸‹èµ°.\n// è¿™é‡Œè¿”å›çš„ ScopeMetadataåº”è¯¥æ˜¯é»˜è®¤çš„,scopeNameæ˜¯singleton,scopedProxyModeæ˜¯No/1    \n\t\tScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);\n\t\tabd.setScope(scopeMetadata.getScopeName());\n// è·å– beanName æ¥    \n\t\tString beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));\n\n// å¯¹ä¸€äº›æ³¨è§£çš„å¤„ç†.\n// @Lazy , @Primary , @DependsOn , @Role , @Description å¦‚æœæœ‰è¿™äº›æ³¨è§£çš„è¯,å°±ä¼šè¿›è¡Œå¤„ç†.\n// æ ¹æ®æ³¨è§£çš„åå­—,æ¥è°ƒç”¨ç›¸åº”çš„setæ–¹æ³•.    \n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(abd);\n    \n // è¿™é‡Œæ˜¯å¯¹æ˜¯å¦æœ‰ @Primary / @Lazy /   @Qualifier æ³¨è§£è¿›è¡Œåˆ¤æ–­.\n\t\tif (qualifiers != null) {\n\t\t\tfor (Class<? extends Annotation> qualifier : qualifiers) {\n\t\t\t\tif (Primary.class == qualifier) {\n\t\t\t\t\tabd.setPrimary(true);\n\t\t\t\t}\n\t\t\t\telse if (Lazy.class == qualifier) {\n\t\t\t\t\tabd.setLazyInit(true);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tabd.addQualifier(new AutowireCandidateQualifier(qualifier));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//è¿™é‡Œ BeanDefinitionCustomizer[] customizers æ•°ç»„å¦‚æœæœ‰å€¼çš„è¯,\n// ä¼šè°ƒç”¨ customizer çš„ customize æ–¹æ³•ä¼ å…¥ bd.\n// TODO , è¿™é‡Œç”±äºæ²¡æœ‰å…·ä½“çš„å€¼,ä¹Ÿä¸æ˜¯å¾ˆæ¸…æ¥šåšäº†ä»€ä¹ˆäº‹æƒ….    \n\t\tif (customizers != null) {\n\t\t\tfor (BeanDefinitionCustomizer customizer : customizers) {\n\t\t\t\tcustomizer.customize(abd);\n\t\t\t}\n\t\t}\n\n// ç”¨ bd å’Œ beançš„åå­—ï¼Œåˆ›å»ºå‡ºä¸€ä¸ª bd çš„æŒæœ‰è€….    \n\t\tBeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);\n// è¿™é‡Œç”±äºä¼ å…¥è¿›æ¥çš„ scopeMetadataçš„å€¼æ˜¯NO,æ‰€ä»¥å°±ç›´æ¥è¿”å›bdHolderçš„æŒæœ‰è€…äº†.\n// å¯ä»¥çœ‹åˆ°è¿”å›ä¸‹é¢çš„ä»£ç ,æ˜¯æ»¡è¶³ä¸€ä¸ªå¢å¼ºç±»çš„æ¦‚å¿µçš„.    \n\t\tdefinitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); \n// org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition\n//èµ°åˆ°beanFactoryä¸­çš„registerBeanDefinitionæ–¹æ³•æ¥,å…ˆæ˜¯å¯¹bdè¿›è¡Œæ ¡éªŒ,ç„¶ååˆ©ç”¨org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionMap+beaNameæ¥åˆ¤æ–­æ˜¯ä¸æ˜¯å·²ç»åŒ…å«äº†è¯¥bean\n// æ­¤æ—¶å¦‚æœä½ æ˜¯debugçš„è¯,ä½ ä¼šå‘ç°æœ‰äº”ä¸ªå†…ç½®çš„beanå·²ç»åœ¨è¯¥beanDefinitionMapä¸­äº†.è¿™ä¹Ÿæ˜¯å¯¹åº”äº†AnnotatedBeanDefinitionReaderä¸­å¤„ç†çš„å†…ç½®çš„bean.\n//å¦‚æœbeanDefinitionMapä¸­æ²¡æœ‰çš„è¯,å°±åˆ†ä¸ºæ˜¯ä¸æ˜¯å·²ç»å¼€å§‹åˆ›å»ºbeanäº†.\n//å¦‚æœæ²¡æœ‰å·²ç»å¼€å§‹åˆ›å»ºäº†,å°±æ·»åŠ åˆ°beanDefinitionMapä¸­æ¥,beanNameä¹Ÿä¼šæ·»åŠ åˆ°beanDefinitionNames,å…¶å®è¿™é‡Œæœ‰ä¸ªé—®é¢˜, beanDefinitionMapçš„keyé›†åˆå°±å·²ç»æ˜¯beanNameé›†åˆäº†,ä¸ºä»€ä¹ˆè¿˜å•ç‹¬ä½¿ç”¨ä¸€ä¸ªé›†åˆæ¥ç»´æŠ¤å‘¢ï¼Ÿ\n// è¿™æ ·è¿™ä¸ªbeançš„ä¿¡æ¯å’Œbdå°±æ”¾å…¥åˆ° BeanFactoryä¸­æ¥äº†.    \n// å¦‚æœæœ‰åˆ«åçš„æ³¨è§£æˆ–è€…é…ç½®çš„è¯,å°±ä¼šèµ°åˆ°registry.registerAlias(beanName, alias);æ¥è¿›è¡Œåˆ«åçš„æ³¨å†Œ. \n\t\tBeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);\n\t}\n```\n\nè¿™é‡Œå¯ä»¥æ€»ç»“ä¸‹çœ‹åˆ° register æ–¹æ³•å°±æ˜¯å¯¹æˆ‘ä»¬çš„é…ç½®ç±»è¿›è¡Œæ‰«æ, ç„¶åå¯¹æ˜¯å¦æœ‰ä¸€äº›æ³¨è§£è¿›è¡Œåˆ¤æ–­ç­‰. æœ€åä½¿ç”¨ BeanDefinitionReaderUtils å·¥å…·ç±»çš„æ–¹æ³•å°† bd ç»™ æ³¨å†Œåˆ° Spring å®¹å™¨ä¸­æ¥, æ³¨æ„è¿™æ—¶å€™æ˜¯æ²¡æœ‰å®ä¾‹åŒ–æˆ‘ä»¬çš„ YangBeanScannerConfig,åªæ˜¯å°è£…æˆ bd + beanName ç»™æ³¨å†Œåˆ° BeanFactory çš„ beanDefinitionMap ä¸­æ¥äº†.\n\n#### refresh() æ–¹æ³•\n\n æ›´æ–°æ–¹æ³•ï¼Œå¯ä»¥çœ‹åˆ°è¿™ä¸ªæ–¹æ³•å†…éƒ¨æ˜¯èµ°äº†å¾ˆå¤šæ–¹æ³•,å…¶é€»è¾‘ä¹Ÿæ˜¯æ¯”è¾ƒç»•çš„. ä¸è¿‡æ²¡äº‹ï¼Œæˆ‘ä»¬ä¸€ä¸ªä¸€ä¸ªæ–¹æ³•çš„æ¥çœ‹.\n\norg.springframework.context.support.AbstractApplicationContext#refresh()\n\nå¯ä»¥çœ‹åˆ°å…¶å†…éƒ¨çš„æ¯ä¸ªæ–¹æ³•ä¸Šé¢éƒ½æ˜¯æœ‰ä¸€è¡Œæ³¨é‡Šçš„.\n\näºæ˜¯æˆ‘ä»¬æŒ¨ä¸ªæ–¹æ³•æ¥debugè¿›æ¥åˆ†æ.\n\n```java\n// åˆ©ç”¨ Object æ¥å½“é”å¯¹è±¡,é¿å…å¤šä¸ªçº¿ç¨‹åŒæ—¶è°ƒç”¨åˆ° refresh æ–¹æ³•æ¥.\nprivate final Object startupShutdownMonitor = new Object();\n\n@Override\npublic void refresh() throws BeansException, IllegalStateException {\n   synchronized (this.startupShutdownMonitor) {\n      // Prepare this context for refreshing.\n  \n      prepareRefresh();\n\n      // Tell the subclass to refresh the internal bean factory.\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n      // Prepare the bean factory for use in this context.\n      prepareBeanFactory(beanFactory);\n\n      try {\n         // Allows post-processing of the bean factory in context subclasses.\n         postProcessBeanFactory(beanFactory);\n\n         // Invoke factory processors registered as beans in the context.\n         invokeBeanFactoryPostProcessors(beanFactory);\n\n         // Register bean processors that intercept bean creation.\n         registerBeanPostProcessors(beanFactory);\n\n         // Initialize message source for this context.\n         initMessageSource();\n\n         // Initialize event multicaster for this context.\n         initApplicationEventMulticaster();\n\n         // Initialize other special beans in specific context subclasses.\n         onRefresh();\n\n         // Check for listener beans and register them.\n         registerListeners();\n\n         // Instantiate all remaining (non-lazy-init) singletons.\n         finishBeanFactoryInitialization(beanFactory);\n\n         // Last step: publish corresponding event.\n         finishRefresh();\n      }\n\n      catch (BeansException ex) {\n         if (logger.isWarnEnabled()) {\n            logger.warn(\"Exception encountered during context initialization - \" +\n                  \"cancelling refresh attempt: \" + ex);\n         }\n\n         // Destroy already created singletons to avoid dangling resources.\n         destroyBeans();\n\n         // Reset 'active' flag.\n         cancelRefresh(ex);\n\n         // Propagate exception to caller.\n         throw ex;\n      }\n\n      finally {\n         // Reset common introspection caches in Spring's core, since we\n         // might not ever need metadata for singleton beans anymore...\n         resetCommonCaches();\n      }\n   }\n}\n```\n\n##### prepareRefresh() æ–¹æ³•\n\nä»æ³¨é‡Šæ¥çœ‹, è®¾ç½®startupæ•°æ® & æ ‡è¯†activeæ¥è¡¨ç¤ºçŠ¶æ€,åŒæ—¶ä¹Ÿä¼šåˆå§‹åŒ–ä¸€äº›èµ„æº.\n\n```java\n/**\n * Prepare this context for refreshing, setting its startup date and\n * active flag as well as performing any initialization of property sources.\n */\nprotected void prepareRefresh() {\n   // Switch to active.\n   this.startupDate = System.currentTimeMillis();\n// å¯¹çŠ¶æ€æ ‡è¯†çš„è®¾ç½®.    \n   this.closed.set(false);\n   this.active.set(true);\n\n   if (logger.isDebugEnabled()) {\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"Refreshing \" + this);\n      }\n      else {\n         logger.debug(\"Refreshing \" + getDisplayName());\n      }\n   }\n\n   // Initialize any placeholder property sources in the context environment.\n// è¿™é‡Œæš‚æ—¶æ²¡æœ‰å®ç°æ¥åšäº‹æƒ….    \n   initPropertySources();\n\n   // Validate that all properties marked as required are resolvable:\n   // see ConfigurablePropertyResolver#setRequiredProperties\n// org.springframework.core.env.AbstractEnvironment#validateRequiredProperties\n// å¯¹ org.springframework.core.env.AbstractPropertyResolver#requiredProperties è¿›è¡Œæ£€éªŒ,å¦‚æœæ£€éªŒåˆ°æœ‰é—®é¢˜çš„è¯,å°±ä¼šæŠ›å‡ºå¼‚å¸¸æ¥.\n// è¿™é‡Œæ˜¯å¯¹ properties è¿›è¡Œæ£€éªŒ.    \n   getEnvironment().validateRequiredProperties();\n\n   // Store pre-refresh ApplicationListeners...\n// earlyApplicationListenersæ˜¯nullçš„è¯,åˆ©ç”¨applicationListenersæ¥åˆå§‹åŒ–.   \n   if (this.earlyApplicationListeners == null) {\n      this.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);\n   }\n   else {\n// å¦‚æœå·²ç»å­˜åœ¨å€¼äº†,å°±å¯¹  applicationListeners æ¸…ç©ºï¼Œç„¶åå…¨éƒ¨æ·»åŠ applicationListenersæ¥.     \n      // Reset local application listeners to pre-refresh state.\n      this.applicationListeners.clear();\n      this.applicationListeners.addAll(this.earlyApplicationListeners);\n   }\n\n   // Allow for the collection of early ApplicationEvents,\n   // to be published once the multicaster is available...\n   this.earlyApplicationEvents = new LinkedHashSet<>();\n}\n```\n\nå¯ä»¥çœ‹åˆ°è¯¥æ–¹æ³•çš„è¯,å¯¹çŠ¶æ€æ ‡è¯†è¿›è¡Œè®¾ç½®. æ¥ç€åœ° propertySources èµ„æºæ¥è¿›è¡Œåˆå§‹åŒ–, äºæ˜¯å°±å¯¹propertyæ¥è¿›è¡Œæ£€éªŒ. æ¥ä¸‹æ¥æ˜¯å¯¹ earlyApplicationListeners/earlyApplicationEventsæ ¹æ®æ¡ä»¶æ¥åˆå§‹åŒ–æ“ä½œ.\n\n##### obtainFreshBeanFactroy()\n\n```\nprotected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n   refreshBeanFactory();\n   return getBeanFactory();\n}\n\n---------------------------\norg.springframework.context.support.GenericApplicationContext#refreshBeanFactory\n  \n// çœ‹åˆ° compareAndSet æœ‰ç‚¹cas çš„å‘³é“.    \nprotected final void refreshBeanFactory() throws IllegalStateException {    \n\t\tif (!this.refreshed.compareAndSet(false, true)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once\");\n\t\t}\n// private String id = ObjectUtils.identityToString(this);\n// è¿™é‡Œè·å–å‡ºæ¥çš„idåœ¨è¿™ä¸ªç±»è¢«newæˆ–è€…å­ç±»è°ƒç”¨çˆ¶ç±»çš„super()æ„é€ æ–¹æ³•çš„æ—¶å€™,å°±å·²ç»è¢«åˆå§‹åŒ–å€¼äº†çš„.    \n\t\tthis.beanFactory.setSerializationId(getId());\n\t}    \n    \n-----------------\norg.springframework.context.support.GenericApplicationContext#getBeanFactory\n\n// è¿™é‡Œå°±ç›´æ¥è¿”å›äº† DefaultListableBeanFactory.   \n\t@Override\n\tpublic final ConfigurableListableBeanFactory getBeanFactory() {\n\t\treturn this.beanFactory;\n\t}\n```\n\nè¯¥æ–¹æ³• è®¾ç½®äº†ä¸€ä¸ª SerializationId åˆ° beanFactory ä¸­æ¥. æœ€åä¹Ÿæ˜¯è¿”å›äº†ä¸€ä¸ª DefaultListableBeanFactory æ¥.\n\n##### prepareBeanFactory() æ–¹æ³•\n\n```java\n/**\n * Configure the factory's standard context characteristics,\n * such as the context's ClassLoader and post-processors.\n * @param beanFactory the BeanFactory to configure\n */\nprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n   // Tell the internal bean factory to use the context's class loader etc.\n// org.springframework.core.io.DefaultResourceLoader#getClassLoader   \n// è®¾ç½® class åŠ è½½å™¨&èµ‹å€¼è¿›å».    \n   beanFactory.setBeanClassLoader(getClassLoader());\n// å°† beanClassLoaderæ”¾å…¥SpelParserConfigurationä¸­æ¥,SpelExpressionParserä¸­æœ‰å«æœ‰SpelParserConfigurationä½œä¸ºconfiguration,StandardBeanExpressionResolverå±æ€§åˆå«æœ‰SpelExpressionParser. è¿™ä¹Ÿå°±å¯ä»¥ç†è§£ä¸ºbeanClassLoaderæœ€åæ˜¯æ”¾å…¥åˆ°SpelParserConfigurationæ¥.\n   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n    \n// ä¼ å…¥applicationContextå’Œenvironmentåˆ°ResourceEditorRegistrarå¯¹è±¡æ¥.\n//ç„¶åæ·»åŠ åˆ°beanFactoryä¸­æ¥.    \n   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));\n\n   // Configure the bean factory with context callbacks.\n// æ·»åŠ ApplicationContextAwareProcessoråç½®å¤„ç†å™¨åˆ°org.springframework.beans.factory.support.AbstractBeanFactory#beanPostProcessorsä¸­æ¥.\n// åœ¨æ·»åŠ åç½®å¤„ç†å™¨åˆ°Springå®¹å™¨ä¹‹å‰,ä¼šåˆ¤æ–­è¿™ä¸ªåç½®å¤„ç†èµ·æ˜¯ä¸æ˜¯InstantiationAwareBeanPostProcessor/DestructionAwareBeanPostProcessor è¿™äºŒç§æƒ…å†µ.\n// æœ€åæ·»åŠ åˆ° beanPostProcessors ä¸­æ¥.    \n   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n// ç„¶åè¿™é‡Œå¿½ç•¥äº†å…­ç§æƒ…å†µçš„æ¥å£. ä¸ºä»€ä¹ˆè¦å¿½ç•¥å‘¢? çœ‹ä¸€ä¸ªåœ°æ–¹.\n// org.springframework.context.support.ApplicationContextAwareProcessor#postProcessBeforeInitialization &  org.springframework.context.support.ApplicationContextAwareProcessor#invokeAwareInterfaces ç»“åˆè¿™äºŒä¸ªæ–¹æ³•æ¥çœ‹,æ˜¯å·²ç»å¯¹è¿™å…­ç§æƒ…å†µçš„æ¥å£åšäº†å¤„ç†çš„.    \n   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n\n   // BeanFactory interface not registered as resolvable type in a plain factory.\n   // MessageSource registered (and found for autowiring) as a bean.\n// private final Map<Class<?>, Object> resolvableDependencies = new ConcurrentHashMap<>(16);    \n// org.springframework.beans.factory.support.DefaultListableBeanFactory#resolvableDependencies,è¿™é‡Œå°† BeanFactory.classå’ŒbeanFactoryç»™æ·»åŠ åˆ° resolvableDependenciesä¸­æ¥äº†,è¿™é‡Œå¯ä»¥çœ‹åˆ°resolvableDependenciesçš„keyæ˜¯ä¸€ä¸ªClassç±»å‹.\n   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n   beanFactory.registerResolvableDependency(ResourceLoader.class, this);\n   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n   beanFactory.registerResolvableDependency(ApplicationContext.class, this);\n\n   // Register early post-processor for detecting inner beans as ApplicationListeners.\n// è¿™é‡Œåˆæ·»åŠ äº†ä¸€ä¸ªåç½®å¤„ç†å™¨.\n// ä¼ å…¥ä¸€ä¸ª ApplicationContext ç»™åç½®å¤„ç†å™¨,ç„¶åæ·»åŠ åˆ°BeanFactoryä¸­æ¥.\n// org.springframework.beans.factory.support.AbstractBeanFactory#beanPostProcessors,ä¹Ÿå³æ˜¯æ·»åŠ åˆ°ä¸“é—¨å­˜æ”¾ åç½®å¤„ç†å™¨çš„é›†åˆä¸­æ¥äº†.    \n   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));\n\n   // Detect a LoadTimeWeaver and prepare for weaving, if found.\n// beanFactoryå¦‚æœæœ‰loadTimeWeaver,é‚£ä¹ˆå°±æ·»åŠ  LoadTimeWeaverAwareProcessor åç½®å¤„ç†å™¨è¿›æ¥   \n   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n      // Set a temporary ClassLoader for type matching.\n      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n   }\n\n   // Register default environment beans.\n// ä¸åŒ…å«environment/systemProperties/systemEnvironmentï¼Œå°±ä¼šæ·»åŠ åˆ°org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#singletonObjectsä¸­æ¥.    \n   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());\n   }\n   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());\n   }\n   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());\n   }\n}\n```\n\nè¿™é‡Œå¯ä»¥çœ‹åˆ°,prepareBeanFactory ä¸­åšäº†è¿™äº›äº‹æƒ… : æ·»åŠ äº† beanClassLoader,æ·»åŠ äº†äºŒä¸ªåç½®å¤„ç†å™¨,ç„¶åæ³¨å†Œäº†å››ä¸ª BeanFactory/ResourceLoader/ApplicationEventPublisher/ApplicationContext åˆ°DefaultListableBeanFactory#resolvableDependenciesä¸­æ¥äº†.\n\næœ€ååˆ¤æ–­beanFactoryæ˜¯ä¸æ˜¯ä¸åŒ…å«ä¸€äº›å…³äºç¯å¢ƒçš„bean,å¦‚æœæ˜¯çš„è¯,é‚£å°±è°ƒç”¨registerSingletonæ–¹æ³•ç»™æ³¨å†Œè¿›æ¥.\n\nè¿˜æ˜¯å¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡Œéƒ½æ˜¯åœ¨ä¸ºç¯å¢ƒåšå‡†å¤‡å·¥ä½œ.\n\n##### postProcessBeanFactory() æ–¹æ³•\n\nç•¥ç•¥ç•¥, è¯¥æ–¹æ³•æš‚æ— å®ç°ç±»æ¥æäº‹æƒ…â€¦..\n\n```java\n/**\n * Modify the application context's internal bean factory after its standard\n * initialization. All bean definitions will have been loaded, but no beans\n * will have been instantiated yet. This allows for registering special\n * BeanPostProcessors etc in certain ApplicationContext implementations.\n * @param beanFactory the bean factory used by the application context\n */\nprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n}\n```\n\n##### invokeBeanFactoryPostProcessors æ–¹æ³•\n\nè¿™äº›æ˜¯å¯¹beanFactoryPostProcessorsè¿›è¡Œå¤„ç†. æ˜¯å€Ÿç”¨äº† PostProcessorRegistrationDelegate.\n\n```java\n/**\n * Instantiate and invoke all registered BeanFactoryPostProcessor beans,\n * respecting explicit order if given.\n * <p>Must be called before singleton instantiation.\n */\nprotected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n// getBeanFactoryPostProcessors() è·å–å‡ºæ¥çš„æ˜¯ç©ºé›†åˆ.    \n   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());\n\n   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime\n   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)\n   if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n   }\n}\n```\n\n###### org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List<org.springframework.beans.factory.config.BeanFactoryPostProcessor>)\n\nè¯¥æ–¹æ³•ä»ä»£ç ä¸Šæ¥çœ‹,è¿˜æ˜¯åšäº†è›®å¤šçš„äº‹æƒ….\n\n```java\npublic static void invokeBeanFactoryPostProcessors(\n      ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {\n\n   // Invoke BeanDefinitionRegistryPostProcessors first, if any.\n   Set<String> processedBeans = new HashSet<>();\n\n// è¿™é‡Œæ˜¯æ»¡è¶³æ¡ä»¶çš„    \n   if (beanFactory instanceof BeanDefinitionRegistry) {\n      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;\n      List<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();\n      List<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();\n\n// å¯¹ beanFactoryçš„åç½®å¤„ç†å™¨è¿›è¡Œè¿­ä»£å¤„ç†æ“ä½œ.       \n      for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {\n         if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {\n            BeanDefinitionRegistryPostProcessor registryProcessor =\n                  (BeanDefinitionRegistryPostProcessor) postProcessor;\n            registryProcessor.postProcessBeanDefinitionRegistry(registry);\n            registryProcessors.add(registryProcessor);\n         }\n         else {\n            regularPostProcessors.add(postProcessor);\n         }\n      }\n\n      // Do not initialize FactoryBeans here: We need to leave all regular beans\n      // uninitialized to let the bean factory post-processors apply to them!\n      // Separate between BeanDefinitionRegistryPostProcessors that implement\n      // PriorityOrdered, Ordered, and the rest.\n      List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();\n\n      // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.\n// æ ¹æ® BeanDefinitionRegistryPostProcessor.class æ¥è·å–beanNamesæ•°ç»„,\n// org.springframework.context.annotation.internalConfigurationAnnotationProcessor è¿™é‡Œæ˜¯è·å–åˆ°äº†ä¸€ä¸ªå†…ç½®çš„BeanFactroyPostProcessor.      \n      String[] postProcessorNames =\n            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n      for (String ppName : postProcessorNames) {\n // åˆ¤æ–­æ˜¯ä¸æ˜¯æœ‰PriorityOrdered,         \n         if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n // è¿™é‡Œçš„getBeanå°±å·²ç»å¯¹beanè¿›è¡Œåˆå§‹åŒ–ï¼Œæ˜¯çœŸæ­£çš„èµ°åå°„æ„é€ å‡½æ•°æ‹¿å‡ºæ¥çš„å®ä¾‹å¯¹è±¡.\n // getBeanéœ€è¦ä»”ç»†åˆ†æä¸‹ï¼Œå› ä¸ºå…¶å†…éƒ¨åœ¨ createBeanæ˜¯èµ°äº†å¾ˆå¤šåç½®å¤„ç†èµ·æ¥è¿›è¡Œå¢å¼ºçš„. \n// ConfigurationClassPostProcessor ç»™æ·»åŠ è¿›æ¥.             \n            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n// beanName æ·»åŠ åˆ° processedBeansé›†åˆä¸­æ¥äº†.             \n            processedBeans.add(ppName);\n         }\n      }\n// å¯¹é›†åˆè¿›è¡Œæ’åº,ä»beanFactoryä¸­è·å–å‡ºdependencyComparatoræ¥,å¦‚æœæ²¡æœ‰çš„è¯,å°±ç”¨OrderComparator.INSTANCEé»˜è®¤çš„\n      sortPostProcessors(currentRegistryProcessors, beanFactory);\n// å…¨éƒ¨æ·»åŠ åˆ° registryProcessors ä¸­æ¥.       \n      registryProcessors.addAll(currentRegistryProcessors);\n// org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry\n//è¿™é‡Œæ˜¯è¿›å…¥åˆ°ConfigurationClassPostProcessorä¸­æ¥äº†,å¯ä»¥çœ‹åˆ°å…¶æ¥å£ BeanDefinitionRegistryPostProcessor,æ˜¯é‡å†™äº†æ¥å£çš„æ–¹æ³•. \n// ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry åšäº†ä»€ä¹ˆäº‹æƒ…å‘¢?\n// ç”¨System.identityHashCode(registry);è®¡ç®—å‡ºregistryIdæ¥,å¦‚æœåœ¨org.springframework.context.annotation.ConfigurationClassPostProcessor#registriesPostProcessed/factoriesPostProcessed(äºŒä¸ªé›†åˆ)ä¸­å·²ç»åŒ…å«äº†çš„è¯,å°±ä¼šæŠ›å‡ºå·²ç»è¢«è°ƒç”¨è¿‡çš„å¼‚å¸¸æ¥.å¦‚æœæ²¡æœ‰çš„è¯,å°±ä¼šæ·»åŠ åˆ°registriesPostProcessedä¸­æ¥\n// ç»§ç»­çœ‹ org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions æ–¹æ³•,\n//å…ˆä»registryä¸­è·å–beanNamesæ¥,è¿™å…¶ä¸­å°±æœ‰Springå†…ç½®çš„å’Œæˆ‘ä»¬è‡ªå·±å®šä¹‰çš„yangBeanScannerConfig\n//å¯¹beanNamesè¿­ä»£å¤„ç†,æ¥ç€å°±ç”¨ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)æ¥åˆ¤æ–­è¦ä¸è¦æ·»åŠ åˆ°List<BeanDefinitionHolder> configCandidatesé›†åˆä¸­æ¥,æœ€åæ˜¯æˆ‘ä»¬å®šä¹‰çš„beanNameç»™æ·»åŠ è¿›æ¥äº†.\n// å¯¹configCandidatesé›†åˆè¿›è¡Œæ’åº,\n// åˆ›å»ºä¸€ä¸ªConfigurationClassParserå¯¹è±¡æ¥è§£ææ¯ä¸ª@Configurationæ³¨è§£ç±».è°ƒç”¨å…¶parseå’Œvalidateæ–¹æ³•,è§£æå®Œåå°±æ˜¯ä¸€ä¸ªConfigurationClassçš„Seté›†åˆ,æ¥ç€å°±æ˜¯newäº†ä¸€ä¸ªConfigurationClassBeanDefinitionReaderå¯¹è±¡æ¥,\n// this.reader.loadBeanDefinitions(configClasses); è¿™è¡Œä»£ç æœ‰ç‚¹æ ¹æ®Configå»è§£æbeançš„æ„æ€.    \n// å…·ä½“è¦ç­‰åˆ°åé¢æ·±åº¦è§£æå†åè¿‡æ¥å®šä½æ¯è¡Œä»£ç çš„æ„æ€.\n// æœ€åå†æ¸…é™¤ä¸‹ç¼“å­˜.       \n      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n// æ¸…ç©º currentRegistryProcessors é›†åˆ      \n      currentRegistryProcessors.clear();\n\n      // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.\n      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n      for (String ppName : postProcessorNames) {\n// å¦‚æœprocessedBeansé›†åˆä¸­ä¸åŒ…å«å¹¶ä¸”typeæ˜¯Ordered.classæ‰æ»¡è¶³è¿›æ¥çš„æ¡ä»¶.          \n         if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {\n            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n            processedBeans.add(ppName);\n         }\n      }\n// æ‰€ä»¥è¿™é‡Œçš„currentRegistryProcessorsé›†åˆæ˜¯ç©ºé›†åˆ.       \n      sortPostProcessors(currentRegistryProcessors, beanFactory);\n      registryProcessors.addAll(currentRegistryProcessors);\n      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n      currentRegistryProcessors.clear();\n\n      // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.\n// è¿™é‡Œç”¨ while å¾ªç¯æ¥æœ€åè§£æ,åˆ¤æ–­ä»getBeanNamesForTypeè·å–å‡ºæ¥çš„beanæ˜¯ä¸æ˜¯è¢«è§£æè¿‡äº†çš„. \n// ä¹Ÿæ˜¯ç”¨ processedBeans é›†åˆæ¥è¿›è¡Œæ§åˆ¶çš„. \n      boolean reiterate = true;\n      while (reiterate) {\n         reiterate = false;\n         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n         for (String ppName : postProcessorNames) {\n            if (!processedBeans.contains(ppName)) {\n               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n               processedBeans.add(ppName);\n               reiterate = true;\n            }\n         }\n         sortPostProcessors(currentRegistryProcessors, beanFactory);\n         registryProcessors.addAll(currentRegistryProcessors);\n         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n         currentRegistryProcessors.clear();\n      }\n\n      // Now, invoke the postProcessBeanFactory callback of all processors handled so far.\n// org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanFactory,è¿™é‡Œæ˜¯èµ°åˆ°äº†postProcessBeanFactoryå›è°ƒæ–¹æ³•æ¥äº†.ç”¨org.springframework.context.annotation.ConfigurationClassPostProcessor#factoriesPostProcessedé›†åˆæ¥æ§åˆ¶æ˜¯å¦è§£æè¿‡äº†.ç”¨registriesPostProcessedé›†åˆæ¥åˆ¤æ–­ä¸Šæ¬¡æ˜¯å¦è¿›å…¥åˆ°postProcessBeanDefinitionRegistryæ–¹æ³•ä¸­æ¥. å¦‚æœæ²¡æœ‰çš„è¯,å°±ä¼šå†èµ°ä¸€è¾¹processConfigBeanDefinitions,å¯ä»¥çœ‹åˆ° postProcessBeanDefinitionRegistry æ–¹æ³•æœ€åä¹Ÿæ˜¯èµ°åˆ°äº†processConfigBeanDefinitionsä¸­æ¥äº†.\n//org.springframework.context.annotation.ConfigurationClassPostProcessor#enhanceConfigurationClasses è¯¥æ–¹æ³•åˆ¤æ–­æ˜¯ä¸æ˜¯éœ€è¦ä»£ç†æ¥å¢å¼º,è¿™é‡Œæ˜¯æ²¡æœ‰çš„,æ‰€ä»¥å°±ç›´æ¥returnæ‰äº†.\n// æœ€åæ·»åŠ ä¸€ä¸ª ImportAwareBeanPostProcessor åç½®å¤„ç†å™¨è¿›æ¥.       \n      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);\n// è¿™é‡Œçš„regularPostProcessors é›†åˆæ˜¯empty.       \n      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);\n   }\n\n   else {\n      // Invoke factory processors registered with the context instance.\n      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);\n   }\n\n   // Do not initialize FactoryBeans here: We need to leave all regular beans\n   // uninitialized to let the bean factory post-processors apply to them!\n // org.springframework.context.annotation.internalConfigurationAnnotationProcessorå’Œorg.springframework.context.event.internalEventListenerProcessorè¿™é‡Œè·å–å‡ºæ¥çš„æ˜¯äºŒä¸ª.   \n   String[] postProcessorNames =\n         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);\n\n   // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,\n   // Ordered, and the rest.\n   List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();\n   List<String> orderedPostProcessorNames = new ArrayList<>();\n   List<String> nonOrderedPostProcessorNames = new ArrayList<>();\n   for (String ppName : postProcessorNames) {\n // è¿™é‡Œæ˜¯å¯¹ä¸Šé¢å·²ç»å¤„ç†è¿‡äº†çš„è¿›è¡Œè¿‡æ»¤å¤„ç†.      \n      if (processedBeans.contains(ppName)) {\n         // skip - already processed in first phase above\n      }\n       \n// è¿™é‡Œåˆ†ä¸º PriorityOrdered&Ordered&éå‰äºŒè€…,åˆ†è¿™ä¸‰ç§æƒ…å†µåˆ†åˆ«æ”¾å…¥åˆ°ä¸‰ä¸ªä¸åŒçš„é›†åˆä¸­.\n      else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));\n      }\n      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n         orderedPostProcessorNames.add(ppName);\n      }\n      else {\n         nonOrderedPostProcessorNames.add(ppName);\n      }\n   }\n\n// è¿™é‡Œæ˜¯å¯ä»¥çœ‹åˆ°å…ˆæ˜¯å¯¹PriorityOrderedè¿›è¡Œå¤„ç†,å†å¯¹Orderedå¤„ç†,æœ€åå¯¹éå‰äºŒè€…è¿›è¡Œå¤„ç†.    \n   // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.\n   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\n   // Next, invoke the BeanFactoryPostProcessors that implement Ordered.\n   List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());\n   for (String postProcessorName : orderedPostProcessorNames) {\n // æ³¨æ„è¿™é‡Œæ˜¯è°ƒç”¨äº†getBeanæ–¹æ³•.      \n      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n   }\n// æ’åº    \n   sortPostProcessors(orderedPostProcessors, beanFactory);\n   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);\n\n   // Finally, invoke all other BeanFactoryPostProcessors.\n   List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());\n   for (String postProcessorName : nonOrderedPostProcessorNames) {\n // æ³¨æ„è¿™é‡Œä¹Ÿæ˜¯è°ƒç”¨äº† getBean æ–¹æ³•çš„.      \n      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n   }\n// org.springframework.context.event.EventListenerMethodProcessor#postProcessBeanFactory\n// è¿™é‡Œç”±äºåªæœ‰ä¸€ä¸ªEventListenerMethodProcessorå¤„ç†å™¨,æ‰€ä»¥å¯¹åº”èµ·æ¥çš„èµ°åˆ°å…¶postProcessBeanFactoryæ–¹æ³•ä¸­æ¥.\n// è¿™é‡Œä¹Ÿæ˜¯è°ƒç”¨ postProcessBeanFactory æ–¹æ³•çš„æ„æ€,ä¹Ÿå°±æ˜¯å›è°ƒæ–¹æ³•.    \n   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);\n\n   // Clear cached merged bean definitions since the post-processors might have\n   // modified the original metadata, e.g. replacing placeholders in values...\n// org.springframework.beans.factory.support.DefaultListableBeanFactory#clearMetadataCache\n// å¯¹ ä¸€äº›é›†åˆç­‰è¿›è¡Œæ¸…é™¤.    \n   beanFactory.clearMetadataCache();\n}\n```\n\nè‡³æ­¤å°±å¯ä»¥çœ‹åˆ°,è¯¥æ–¹æ³•ä¸»è¦æ˜¯å¯¹BeanDefinitionRegistryPostProcessor.classå’ŒBeanFactoryPostProcessor.classæ¥è¿›è¡Œå¤„ç†.\n\nBeanDefinitionRegistryPostProcessor åˆæ˜¯å…ˆå¤„ç†PriorityOrdered,ç„¶åä¼šå°†å¤„ç†è¿‡çš„æ”¾å…¥processedBeansé›†åˆä¸­åšä¸€ä¸ªæ€»çš„è®°å½•ï¼Œå†å¤„ç†éå†processedBeansé›†åˆè®°å½•ä¸­çš„å’Œæ˜¯Orderedçš„,æœ€åç”¨whileå¾ªç¯æ¥å†ç¡®è®¤ä¸€éæ˜¯ä¸æ˜¯æœ‰è¿˜æ²¡å¤„ç†çš„,è¿™ä¸ªæ—¶å€™æ§åˆ¶æ¡ä»¶ä¹Ÿæ˜¯é€šè¿‡ processedBeansæ¥æ§åˆ¶æ˜¯ä¸æ˜¯å¤„ç†è¿‡äº†çš„. è¿™é‡Œæ³¨æ„, å®ä¾‹åŒ–æ˜¯é€šè¿‡è°ƒç”¨ getBeanæ–¹æ³•æ¥å®ç°çš„,æ‰€ä»¥ä½ ä¼šå‘ç°å†è°ƒç”¨invokeBeanDefinitionRegistryPostProcessorsæ–¹æ³•ä¹‹å‰,éƒ½æ˜¯ä¼šæœ‰è°ƒç”¨getBeanæ–¹æ³•çš„.\n\nBeanFactoryPostProcessor çš„å¤„ç†,è¿™é‡Œæ˜¯ä¸€æ¬¡è·å–å‡º,ç„¶ååˆ†ä¸º PriorityOrdered/Ordered/éå‰äºŒè€…ï¼Œåˆ†åˆ«æ”¾å…¥ä¸‰ä¸ªé›†åˆä¸­è¿›è¡Œå¤„ç†,å‰ææ˜¯éƒ½æ²¡å† processedBeans é›†åˆä¸­. è¿™é‡Œå¯ä»¥çœ‹åˆ°,å¦‚æœæ˜¯PriorityOrderedç±»å‹çš„è¯ï¼Œé‚£ä¹ˆåœ¨åˆ†ç±»çš„æ—¶å€™å°±å·²ç»è°ƒç”¨getBeanæ–¹æ³•æ¥å®ä¾‹åŒ–è¿™ä¸ªå¯¹è±¡äº†ï¼Œå…¶ä»–äºŒè€…éƒ½æ˜¯æœ€åè¿­ä»£éå†çš„æ—¶å€™è°ƒç”¨getBeanæ–¹æ³•çš„. æœ€åéƒ½æ˜¯sortPostProcessorsèµ°ä¸‹æ’åºï¼Œç„¶åè°ƒç”¨invokeBeanFactoryPostProcessorsæ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•çš„æ„æ€ï¼Œä¹Ÿå°±æ˜¯è°ƒç”¨ é‡å†™çš„ postProcessBeanFactory çš„æ–¹æ³•.\n\n##### registerBeanPostProcessors æ–¹æ³•\n\nè¯¥æ–¹æ³•ä¼ å…¥ beanFactoryè¿›æ¥,ç„¶åç›´æ¥å€ŸåŠ© PostProcessorRegistrationDelegate æ¥å®ç°.\n\n```java\nprotected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n   PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);\n}\n```\n\n###### registerBeanPostProcessors æ–¹æ³•\n\nä»åå­—ä¸Šä¸éš¾ç†è§£ï¼Œæ³¨å†Œ Beançš„åç½®å¤„ç†å™¨è¿›æ¥.\n\nè¿™é‡Œä¼ å…¥è¿›æ¥çš„ beanFactory æ˜¯ DefaultListableBeanFactory , applicationContextæ˜¯AnnotationConfigApplicationContext\n\n```java\npublic static void registerBeanPostProcessors(\n      ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {\n\n// è·å–å‡º BeanPostProcessor çš„åå­—.\n// org.springframework.context.annotation.internalAutowiredAnnotationProcessor\n// org.springframework.context.annotation.internalCommonAnnotationProcessor\n// è¿™é‡Œè·å–å‡ºæ¥çš„æ˜¯äºŒä¸ªå†…éƒ¨çš„åç½®å¤„ç†å™¨,å› ä¸ºæˆ‘è¿™é‡Œå¹¶æ²¡æœ‰æ‰©å±•,åªæ˜¯ç®€å•çš„è¿›è¡Œè¯´æ˜äº†ä¸‹,åé¢ä¼šè¯¦ç»†åˆ†æã€‚\n// å°±æ˜¯è¿™è¡Œä»£ç è·å–çš„æ˜¯ä»€ä¹ˆ.    \n   String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);\n\n   // Register BeanPostProcessorChecker that logs an info message when\n   // a bean is created during BeanPostProcessor instantiation, i.e. when\n   // a bean is not eligible for getting processed by all BeanPostProcessors.\n // 6   \n   int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;\n// ä¼ å…¥beanFactoryå’Œä¸ªæ•°,åˆ›å»ºå‡ºä¸€ä¸ªæ£€æŸ¥beançš„åç½®å¤„ç†å™¨æ¥.\n// org.springframework.context.support.PostProcessorRegistrationDelegate.BeanPostProcessorChecker\n// æœ‰å…´è¶£çš„åŒå­¦å¯ä»¥çœ‹åˆ°è¯¥åç½®å¤„ç†å™¨é‡å†™çš„æ–¹æ³•åšäº†ä»€ä¹ˆäº‹æƒ….\n// æœ€åæ·»åŠ åˆ° beanFactory ä¸­æ¥.    \n   beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));\n\n   // Separate between BeanPostProcessors that implement PriorityOrdered,\n   // Ordered, and the rest.\n   List<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();\n   List<BeanPostProcessor> internalPostProcessors = new ArrayList<>();\n   List<String> orderedPostProcessorNames = new ArrayList<>();\n   List<String> nonOrderedPostProcessorNames = new ArrayList<>();\n    \n // å¯¹åç½®å¤„ç†å™¨è¿›è¡Œè¿­ä»£   \n   for (String ppName : postProcessorNames) {\n      if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n   // æ³¨æ„è¿™é‡Œè°ƒç”¨ getBean æ–¹æ³•æ˜¯å·²ç»å®ä¾‹åŒ–è¿™ä¸ªåç½®å¤„ç†èµ·äº†.\n// AutowiredAnnotationBeanPostProcessor\n// CommonAnnotationBeanPostProcessor\n // è¿™é‡Œå®ä¾‹åŒ–çš„æ˜¯Springå†…ç½®çš„äºŒä¸ª         \n         BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n         priorityOrderedPostProcessors.add(pp);\n      // å†…éƒ¨çš„äºŒä¸ªåç½®å¤„ç†å™¨éƒ½æ˜¯æœ‰å®ç°   MergedBeanDefinitionPostProcessor çš„. \n         if (pp instanceof MergedBeanDefinitionPostProcessor) {\n            internalPostProcessors.add(pp);\n         }\n      }\n      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n         orderedPostProcessorNames.add(ppName);\n      }\n      else {\n         nonOrderedPostProcessorNames.add(ppName);\n      }\n   }\n\n   // First, register the BeanPostProcessors that implement PriorityOrdered.\n// æ’åº    \n   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n// æ·»åŠ åˆ° org.springframework.beans.factory.support.AbstractBeanFactory#beanPostProcessors,ä¹Ÿå°±æ˜¯æ·»åŠ åˆ°Springçš„BanFactoryä¸­æ¥.    \n   registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);\n\n   // Next, register the BeanPostProcessors that implement Ordered.\n// è¿™é‡Œæ˜¯å¯¹å®ç°äº† Ordered ç±»å‹çš„å¤„ç†ï¼Œå¾ˆæ˜¾ç„¶æˆ‘è¿™é‡Œæ˜¯æ²¡æœ‰çš„.    \n   List<BeanPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());\n   for (String ppName : orderedPostProcessorNames) {\n      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n      orderedPostProcessors.add(pp);\n      if (pp instanceof MergedBeanDefinitionPostProcessor) {\n         internalPostProcessors.add(pp);\n      }\n   }\n   sortPostProcessors(orderedPostProcessors, beanFactory);\n   registerBeanPostProcessors(beanFactory, orderedPostProcessors);\n\n   // Now, register all regular BeanPostProcessors.\n// æœ€åæ˜¯å¯¹é PriorityOrderedå’ŒOrderedçš„å¤„ç†ï¼Œ    \n   List<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());\n   for (String ppName : nonOrderedPostProcessorNames) {\n      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n      nonOrderedPostProcessors.add(pp);\n      if (pp instanceof MergedBeanDefinitionPostProcessor) {\n         internalPostProcessors.add(pp);\n      }\n   }\n   registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);\n\n   // Finally, re-register all internal BeanPostProcessors.\n// è¿™é‡Œå¯ä»¥çœ‹åˆ°,æœ€åå¯¹å†…éƒ¨çš„åç½®å¤„ç†å™¨åˆé‡æ–°æ³¨å†Œäº†ä¸€é.    \n   sortPostProcessors(internalPostProcessors, beanFactory);\n   registerBeanPostProcessors(beanFactory, internalPostProcessors);\n\n   // Re-register post-processor for detecting inner beans as ApplicationListeners,\n   // moving it to the end of the processor chain (for picking up proxies etc).\n// ApplicationListenerDetector è¿™é‡Œä¹Ÿæ˜¯å¯¹  ApplicationListenerDetector ä¹Ÿæ˜¯é‡æ–°æ³¨å†Œä¸€é.   \n   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));\n}\n```\n\nè¯¥æ–¹æ³• å€ŸåŠ© org.springframework.context.support.PostProcessorRegistrationDelegate#registerBeanPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, org.springframework.context.support.AbstractApplicationContext) æ¥ï¼Œè·å–BeanPostProcessorçš„åç½®å¤„ç†å™¨,ä¹Ÿæ˜¯åˆ†ä¸º PriorityOrdered / Ordered/ å‰äºŒè€…éƒ½æ²¡æœ‰ï¼Œåœ¨ PriorityOrdered åˆ†ç±»çš„æ—¶å€™ï¼Œå°±å·²ç»è°ƒç”¨äº† getBeanæ–¹æ³•æ¥è·å–å‡º bean å¯¹è±¡æ¥(è¿™é‡Œä¾ç„¶æ˜¯åˆ†ä¸ºäº†ä¸‰ä¸ªé›†åˆæ¥è£…æ•°æ®&å¤„ç†). ç„¶åè°ƒç”¨getBeanæ–¹æ³•å,å°±è°ƒç”¨registerBeanPostProcessorsæ–¹æ³•ï¼Œå°†åç½®å¤„ç†å™¨ç»™æ³¨å†Œåˆ° Spring çš„BeanFactory ä¸­æ¥.\n\næœ€åè¿˜ä¼šæœ€å†…éƒ¨çš„ BeanPoståç½®å¤„ç†å™¨ & ApplicationListenerDetector å†é‡æ–°æ³¨å†Œä¸€é.\n\nå¯èƒ½ä¼šæ¯”è¾ƒå¥½å¥‡è¿™ä¸ªåç½®å¤„ç†å™¨æ˜¯å¹²ä»€ä¹ˆç”¨çš„ ï¼Ÿ åœ¨åé¢å®ä¾‹åŒ– bean çš„æ—¶å€™ï¼Œå°±å¯ä»¥çœ‹åˆ°æ˜¯æœ‰èµ°å¾ˆå¤šåç½®å¤„ç†å™¨çš„.\n\næ‰€ä»¥è¯¥æ–¹æ³•æ˜¯å¯¹ beanPostçš„åç½®å¤„ç†å™¨è¿›è¡Œå®ä¾‹åŒ–å¹¶ä¸”æ³¨å†Œåˆ° Spring çš„ BeanFactory ä¸­æ¥çš„.\n\n##### initMessageSource () æ–¹æ³•\n\nåˆå§‹åŒ– messageSource .\n\n```java\n/**\n * Initialize the MessageSource.\n * Use parent's if none defined in this context.\n */\nprotected void initMessageSource() {\n // è·å–å‡º beanFactory   \n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n// å¦‚æœ beanFactory åŒ…å«äº†åå­—æ˜¯messageSourceçš„æœ¬åœ°bean.    \n   if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {\n  // ä» beanFactory ä¸­è·å–å‡ºæ¥.     \n      this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);\n      // Make MessageSource aware of parent MessageSource.\n// this.parentä¸æ˜¯nullå¹¶ä¸”   messageSourceæ˜¯   HierarchicalMessageSourceç±»å‹ \n      if (this.parent != null && this.messageSource instanceof HierarchicalMessageSource) {\n  // å¼ºè½¬,åˆ¤æ–­  getParentMessageSource æ˜¯ä¸æ˜¯null,å¦‚æœæ˜¯nullçš„è¯,å°±è°ƒç”¨ getInternalParentMessageSource() å°†è·å–å‡ºæ¥çš„å€¼ç»™setè¿›å».     \n         HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;\n         if (hms.getParentMessageSource() == null) {\n            // Only set parent context as parent MessageSource if no parent MessageSource\n            // registered already.\n            hms.setParentMessageSource(getInternalParentMessageSource());\n         }\n      }\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"Using MessageSource [\" + this.messageSource + \"]\");\n      }\n   }\n   else {\n// è¿™é‡Œæ˜¯ä¸åŒ…å«çš„æƒ…å†µ.       \n      // Use empty MessageSource to be able to accept getMessage calls.\n      DelegatingMessageSource dms = new DelegatingMessageSource();\n// getInternalParentMessageSource() è¿”å›çš„æ˜¯null       \n      dms.setParentMessageSource(getInternalParentMessageSource());\n      this.messageSource = dms;\n// æ³¨å†Œåˆ° beanFactory ä¸­æ¥       \n      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"No '\" + MESSAGE_SOURCE_BEAN_NAME + \"' bean, using [\" + this.messageSource + \"]\");\n      }\n   }\n}\n```\n\nè¯¥æ–¹æ³•å¯ä»¥çœ‹åˆ°æ˜¯å¯¹ messageSource çš„åˆå§‹åŒ–è¿›è¡Œæ“ä½œ.\n\n##### initApplicationEventMulticaster æ–¹æ³•\n\nè¿™é‡Œå¦‚æœäº†è§£è¿‡ Spring çš„Event æœºåˆ¶çš„è¯,æ˜¯å¯ä»¥æ¯”è¾ƒæ¸…æ™°çš„æ„Ÿè§‰åˆ°,æ˜¯å¯¹ ApplicationEventMulticaster çš„åˆå§‹åŒ–.\n\n```java\n/**\n * Initialize the ApplicationEventMulticaster.\n * Uses SimpleApplicationEventMulticaster if none defined in the context.\n * @see org.springframework.context.event.SimpleApplicationEventMulticaster\n */\nprotected void initApplicationEventMulticaster() {\n  // è·å–å‡º beanFactory æ¥.  \n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n// åˆ¤æ–­ beanFactory æ˜¯å¦åŒ…å«  applicationEventMulticaster    \n   if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {\n// å¦‚æœåŒ…å«çš„è¯ï¼Œå°±ç›´æ¥ä»beanFactroyä¸­è·å–å‡ºæ¥,å¹¶ä¸”èµ‹å€¼ç»™  applicationEventMulticaster  \n      this.applicationEventMulticaster =\n            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"Using ApplicationEventMulticaster [\" + this.applicationEventMulticaster + \"]\");\n      }\n   }\n   else {\n // å¦‚æœä¸åŒ…å«çš„è¯,ä¼ å…¥beanFactoryæ¥ç€å°±æ˜¯newä¸€ä¸ªSimpleApplicationEventMulticasterå‡ºæ¥      \n      this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);\n// ç„¶åæ³¨å†Œåˆ° beanFactory ä¸­æ¥.      \n      beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"No '\" + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + \"' bean, using \" +\n               \"[\" + this.applicationEventMulticaster.getClass().getSimpleName() + \"]\");\n      }\n   }\n}\n```\n\nè¿™é‡Œå¯ä»¥çœ‹åˆ°, ä¸»è¦æ˜¯å¯¹ applicationEventMulticaster çš„åˆå§‹åŒ–.\n\nå¦‚æœbeanFactoryæœ‰çš„è¯ï¼Œå°±ä»å…¶ä¸­æ‹¿ï¼Œå¦‚æœæ²¡æœ‰å°±è‡ªå·±newä¸€ä¸ª,æœ€åæ³¨å†Œåˆ°beanFactoryä¸­æ¥.\n\n##### onRefresh() æ–¹æ³•\n\nè¿™é‡Œæ˜¯æ²¡æœ‰åšä»»ä½•äº‹æƒ…çš„ï¼Œå¦‚æœæ˜¯SpringBootçš„æºç çš„ï¼Œè¿™é‡Œå°±æ˜¯å¯åŠ¨tomcatçš„.\n\n```java\n/**\n * Template method which can be overridden to add context-specific refresh work.\n * Called on initialization of special beans, before instantiation of singletons.\n * <p>This implementation is empty.\n * @throws BeansException in case of errors\n * @see #refresh()\n */\nprotected void onRefresh() throws BeansException {\n   // For subclasses: do nothing by default.\n}\n```\n\n##### registerListeners() æ–¹æ³•\n\nä»åå­—æ¥çœ‹,è¿™é‡Œæ˜¯æ³¨å†Œç›‘å¬å™¨çš„æ„æ€.\n\norg.springframework.context.event.AbstractApplicationEventMulticaster.ListenerRetriever#applicationListeners è¿™é‡Œæ˜¯å­˜æ”¾ç›‘å¬å™¨çš„åœ°æ–¹ã€‚\n\n```java\n/**\n * Add beans that implement ApplicationListener as listeners.\n * Doesn't affect other listeners, which can be added without being beans.\n */\nprotected void registerListeners() {\n   // Register statically specified listeners first.\n// getApplicationListeners() è·å–å‡ºæ¥çš„æ˜¯ç©ºé›†åˆ.    \n   for (ApplicationListener<?> listener : getApplicationListeners()) {\n      getApplicationEventMulticaster().addApplicationListener(listener);\n   }\n\n   // Do not initialize FactoryBeans here: We need to leave all regular beans\n   // uninitialized to let post-processors apply to them!\n// æ ¹æ®ApplicationListeneræ¥è·å–å‡ºç›‘å¬å™¨ï¼Œè¿™ä¹Ÿä¹Ÿæ˜¯æ²¡æœ‰çš„.     \n   String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);\n   for (String listenerBeanName : listenerBeanNames) {\n      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);\n   }\n\n   // Publish early application events now that we finally have a multicaster...\n// è¿™é‡Œä¹Ÿæ˜¯è·å–æ—©åˆå§‹çš„ ApplicationEvent.    \n   Set<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;\n   this.earlyApplicationEvents = null;\n   if (earlyEventsToProcess != null) {\n      for (ApplicationEvent earlyEvent : earlyEventsToProcess) {\n         getApplicationEventMulticaster().multicastEvent(earlyEvent);\n      }\n   }\n}\n```\n\norg.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType) å¯ä»¥çœ‹ä¸‹è¿™ä¸ªæ–¹æ³•æˆ–è€…åç»­æˆ‘ä»¬å†è¯¦ç»†çš„çœ‹ï¼ŒSpringæ˜¯å¦‚ä½•å‘é€eventçš„ï¼Œä»¥åŠé‚£äº›ç›‘å¬å™¨æ˜¯æ€ä¹ˆè·å–åˆ° event çš„.\n\nTODO : è¿™é‡Œåé¢æ˜¯æœ‰å¾…è¯¦ç»†çš„è®²è§£çš„.\n\n##### finishBeanFactoryInitialization() æ–¹æ³•\n\nä»åå­—ç†è§£ä¸Š,è¿™é‡Œæ˜¯å¯¹ beanFactoryçš„åˆå§‹åŒ–ç»“æŸ.\n\n```java\n/**\n * Finish the initialization of this context's bean factory,\n * initializing all remaining singleton beans.\n */\nprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n   // Initialize conversion service for this context.\n // å¦‚æœbeanFactroyåŒ…å«conversionServiceå¹¶ä¸”typeæ˜¯ConversionService.classçš„è¯ï¼Œ\n   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&\n         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {\n// å°±ä¼šä»beanFactoryä¸­è·å–å‡ºå¯¹è±¡è®¾ç½®åˆ°beanFactoryçš„ConversionServiceæ¥.       \n      beanFactory.setConversionService(\n            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));\n   }\n\n   // Register a default embedded value resolver if no bean post-processor\n   // (such as a PropertyPlaceholderConfigurer bean) registered any before:\n   // at this point, primarily for resolution in annotation attribute values.\n   if (!beanFactory.hasEmbeddedValueResolver()) {\n//org.springframework.beans.factory.support.AbstractBeanFactory#addEmbeddedValueResolver //æ·»åŠ åˆ°org.springframework.beans.factory.support.AbstractBeanFactory#embeddedValueResolversä¸­æ¥.      \n      beanFactory.addEmbeddedValueResolver(strVal -> getEnvironment().resolvePlaceholders(strVal));\n   }\n\n   // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.\n// æ ¹æ®  LoadTimeWeaverAware.class æ¥è·å–ä¿¡æ¯.   \n// å¾ˆæ˜æ˜¾è¿™é‡Œæˆ‘ä»¬æ˜¯æ²¡æœ‰é…ç½®çš„,æ‰€ä»¥ä¹Ÿå°±æ˜¯æ²¡æœ‰çš„.    \n   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);\n   for (String weaverAwareName : weaverAwareNames) {\n      getBean(weaverAwareName);\n   }\n\n   // Stop using the temporary ClassLoader for type matching.\n   beanFactory.setTempClassLoader(null);\n\n   // Allow for caching all bean definition metadata, not expecting further changes.\n//org.springframework.beans.factory.support.DefaultListableBeanFactory#freezeConfiguration\n// è®¾ç½®configurationFrozenæ˜¯true,\n// å°†beanDefinitionNamesé›†åˆè½¬å“ˆä¸ºStringç±»å‹çš„æ•°ç»„. StringUtils.toStringArray(this.beanDefinitionNames);ä½¿ç”¨è¿™ä¸ªæ–¹æ³•å³å¯.    \n   beanFactory.freezeConfiguration();\n\n   // Instantiate all remaining (non-lazy-init) singletons.\n   beanFactory.preInstantiateSingletons();\n}\n```\n\n###### preInstantiateSingletons æ–¹æ³•\n\nè¿™é‡Œå°±æ˜¯å¯¹ å•ä¾‹æ±  é‡Œé¢çš„å¯¹è±¡è¿›è¡Œåˆå§‹åŒ–,å¯ä»¥çœ‹åˆ°æ˜¯æœ‰ getBean æ–¹æ³•çš„.\n\n```java\n@Override\npublic void preInstantiateSingletons() throws BeansException {\n   if (logger.isTraceEnabled()) {\n      logger.trace(\"Pre-instantiating singletons in \" + this);\n   }\n\n   // Iterate over a copy to allow for init methods which in turn register new bean definitions.\n   // While this may not be part of the regular factory bootstrap, it does otherwise work fine.\n// è¿™é‡Œè·å–å‡ºæ¥çš„ beanNames æ˜¯æœ‰6ä¸ªçš„,å…¶ä¸­äº”ä¸ªæ˜¯åŒ…å«äº†å†…éƒ¨çš„\n//org.springframework.context.annotation.internalConfigurationAnnotationProcessor\n//org.springframework.context.annotation.internalAutowiredAnnotationProcessor\n//org.springframework.context.annotation.internalCommonAnnotationProcessor\n//org.springframework.context.event.internalEventListenerProcessor\n//org.springframework.context.event.internalEventListenerFactory\n//yangBeanScannerConfig    \n   List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);\n\n   // Trigger initialization of all non-lazy singleton beans...\n   for (String beanName : beanNames) {\n      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n       \n  // bd ä¸æ˜¯æŠ½è±¡çš„&æ˜¯å•ä¾‹çš„&ä¸æ˜¯èµ–åŠ è½½çš„     \n      if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {\n  // åˆ¤æ–­æ˜¯ä¸æ˜¯ FactroyBean        \n         if (isFactoryBean(beanName)) {\n            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);\n            if (bean instanceof FactoryBean) {\n               final FactoryBean<?> factory = (FactoryBean<?>) bean;\n               boolean isEagerInit;\n               if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {\n                  isEagerInit = AccessController.doPrivileged((PrivilegedAction<Boolean>)\n                              ((SmartFactoryBean<?>) factory)::isEagerInit,\n                        getAccessControlContext());\n               }\n               else {\n                  isEagerInit = (factory instanceof SmartFactoryBean &&\n                        ((SmartFactoryBean<?>) factory).isEagerInit());\n               }\n               if (isEagerInit) {\n                  getBean(beanName);\n               }\n            }\n         }\n         else {\n    // è¿™é‡Œä¸æ˜¯ FactoryBean  \n// å¯ä»¥çœ‹åˆ°å½“æˆ‘èµ°åˆ°yangBeanScannerConfig,æˆ‘ä»¬å®šä¹‰çš„ç±»çš„æ—¶å€™,èµ°å®Œè¿™ä¸ªæ–¹æ³•ï¼Œå°±å¯ä»¥çœ‹åˆ°com.iyang.spring.config.YangBeanScannerConfig#YangBeanScannerConfigä¸­æ‰“å°çš„è¯­å¥äº†,ä¹Ÿå°±æ˜¯è¯´èµ°å®Œè¿™é‡Œï¼Œæˆ‘ä»¬å®šä¹‰çš„beanå°±å·²ç»è¢«Springè¢«å®ä¾‹åŒ–äº†.             \n            getBean(beanName);\n         }\n      }\n   }\n\n   // Trigger post-initialization callback for all applicable beans...\n// è¿™é‡Œå†å¯¹ beanNames è¿›è¡Œè¿­ä»£,å¦‚æœæ˜¯ SmartInitializingSingleton çš„è¯ï¼Œå°±ä¼šå†è°ƒç”¨    afterSingletonsInstantiated æ–¹æ³•.\n   for (String beanName : beanNames) {\n      Object singletonInstance = getSingleton(beanName);\n      if (singletonInstance instanceof SmartInitializingSingleton) {\n         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;\n         if (System.getSecurityManager() != null) {\n            AccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n               smartSingleton.afterSingletonsInstantiated();\n               return null;\n            }, getAccessControlContext());\n         }\n         else {\n            smartSingleton.afterSingletonsInstantiated();\n         }\n      }\n   }\n}\n```\n\nå¯ä»¥å¯¹æˆ‘ä»¬å®šä¹‰çš„ bean è¿›è¡Œå®ä¾‹åŒ–ï¼Œæœ€åæ˜¯è°ƒç”¨äº† getBean æ–¹æ³•ï¼Œ getBean æ–¹æ³•è¡¨é¢çœ‹ä¸Šå»æ˜¯è·å–ï¼Œå…¶å®å¦‚æœæ²¡æœ‰çš„è¯ï¼Œè°ƒç”¨çš„æ˜¯createBeanæ–¹æ³•, ä¹Ÿå°±æ˜¯ä¼šå®ä¾‹åŒ–æˆ‘ä»¬çš„beanã€‚å½“ç„¶å®ƒè‚¯å®šä¸ä¼šå¾ˆç®€å•çš„å»è°ƒç”¨åå°„å°±å®ä¾‹åŒ–å®Œä¸€ä¸ªæˆ‘ä»¬çš„bean,è‚¯å®šæ˜¯æœ‰ä¸€ç³»åˆ—çš„èµ°Springå†…ç½®çš„æˆ–è€…æˆ‘ä»¬è‡ªå·±å®šä¹‰çš„åç½®å¤„ç†å™¨ç­‰æ“ä½œ.\n\ngetBean æ–¹æ³•éœ€è¦åé¢ä¸“é—¨é¢†å‡ºæ¥åˆ†æï¼Œä¸èƒ½ç®€å•çš„è¿‡ï¼Œè¿™é‡Œå¯¹ Spring å®¹å™¨è¿›è¡Œå¤§è‡´çš„flowè¿‡,æ‰€ä»¥è¿˜æ˜¯æ¯”è¾ƒè½»ææ·¡å†™çš„å†™è¿‡å».\n\n##### finishRefresh æ–¹æ³•\n\nä¸­æ–‡å¼çš„è‹±è¯­ : ç»“æŸåˆ·æ–°æ–¹æ³•.\n\næ˜¾ç¤ºæ¸…é™¤ç¼“å­˜,å†æ˜¯initäº†LifecycleProcessor,è°ƒç”¨å…¶onRefresh()æ–¹æ³•,æ¥è¿‘å°±æ˜¯å‘é€ä¸€ä¸ªContextRefreshedEventäº‹ä»¶å‡ºæ¥.\n\n```java\n/**\n * Finish the refresh of this context, invoking the LifecycleProcessor's\n * onRefresh() method and publishing the\n * {@link org.springframework.context.event.ContextRefreshedEvent}.\n */\nprotected void finishRefresh() {\n   // Clear context-level resource caches (such as ASM metadata from scanning).\n//å¯¹org.springframework.core.io.DefaultResourceLoader#resourceCachesè¿›è¡Œæ¸…é™¤.    \n   clearResourceCaches();\n\n   // Initialize lifecycle processor for this context.\n   initLifecycleProcessor();\n\n   // Propagate refresh to lifecycle processor first.\n//org.springframework.context.support.DefaultLifecycleProcessor\n//org.springframework.context.support.DefaultLifecycleProcessor#startBeans\n    \n   getLifecycleProcessor().onRefresh();\n\n   // Publish the final event.\n// æ¨é€Event,è¿™é‡Œçš„Eventæ˜¯ ContextRefreshedEvent.    \n   publishEvent(new ContextRefreshedEvent(this));\n\n   // Participate in LiveBeansView MBean, if active.\n//org.springframework.context.support.LiveBeansView#registerApplicationContext\n//å…ˆæ ¹æ®key:spring.liveBeansView.mbeanDomainè·å–value,è¿™é‡Œè·å–å‡ºæ¥çš„æ˜¯null,\n// æ‰€ä»¥ä¹Ÿå°±æ˜¯æ²¡æœ‰ä¸‹æ–‡äº†.    \n   LiveBeansView.registerApplicationContext(this);\n}\n```\n\n###### initLifecycleProcessor æ–¹æ³• ()\n\n```\n/**\n * Initialize the LifecycleProcessor.\n * Uses DefaultLifecycleProcessor if none defined in the context.\n * @see org.springframework.context.support.DefaultLifecycleProcessor\n */\nprotected void initLifecycleProcessor() {\n  // è·å–å‡º beanFactory æ¥.  \n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n// åˆ¤æ–­beanFactoryä¸­æ˜¯å¦åŒ…å«lifecycleProcessor    \n   if (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) {\n// åŒ…å«çš„è¯,å°±ä¼šè·å–å‡ºæ¥,æŒ‡å‘this.lifecycleProcessor       \n      this.lifecycleProcessor =\n            beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor.class);\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"Using LifecycleProcessor [\" + this.lifecycleProcessor + \"]\");\n      }\n   }\n   else {\n   // å¦‚æœä¸åŒ…å«çš„è¯ï¼Œå°±è‡ªå·±newä¸€ä¸ª,ç„¶åæ³¨å†Œåˆ°Springå®¹å™¨ä¸­æ¥.    \n      DefaultLifecycleProcessor defaultProcessor = new DefaultLifecycleProcessor();\n      defaultProcessor.setBeanFactory(beanFactory);\n      this.lifecycleProcessor = defaultProcessor;\n      beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, this.lifecycleProcessor);\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"No '\" + LIFECYCLE_PROCESSOR_BEAN_NAME + \"' bean, using \" +\n               \"[\" + this.lifecycleProcessor.getClass().getSimpleName() + \"]\");\n      }\n   }\n}\n```\n\n###### publishEvent æ–¹æ³•\n\n```java\n/**\n * Publish the given event to all listeners.\n * @param event the event to publish (may be an {@link ApplicationEvent}\n * or a payload object to be turned into a {@link PayloadApplicationEvent})\n * @param eventType the resolved event type, if known\n * @since 4.2\n */\nprotected void publishEvent(Object event, @Nullable ResolvableType eventType) {\n   Assert.notNull(event, \"Event must not be null\");\n\n   // Decorate event as an ApplicationEvent if necessary\n   ApplicationEvent applicationEvent;\n    \n// å¯¹ä¼ å…¥è¿›æ¥çš„ event è¿›è¡Œç±»å‹çš„åˆ¤æ–­.    \n   if (event instanceof ApplicationEvent) {\n      applicationEvent = (ApplicationEvent) event;\n   }\n   else {\n      applicationEvent = new PayloadApplicationEvent<>(this, event);\n      if (eventType == null) {\n         eventType = ((PayloadApplicationEvent<?>) applicationEvent).getResolvableType();\n      }\n   }\n\n   // Multicast right now if possible - or lazily once the multicaster is initialized\n   if (this.earlyApplicationEvents != null) {\n      this.earlyApplicationEvents.add(applicationEvent);\n   }\n   else {\n//org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType)\n//èµ°åˆ°äº†è¿™é‡Œæ¥å‘é€eventçš„,       \n      getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);\n   }\n\n   // Publish event via parent context as well...\n// è¿™é‡Œçš„ parentæ˜¯null.    \n   if (this.parent != null) {\n      if (this.parent instanceof AbstractApplicationContext) {\n         ((AbstractApplicationContext) this.parent).publishEvent(event, eventType);\n      }\n      else {\n         this.parent.publishEvent(event);\n      }\n   }\n}\n```\n\nè¿™é‡Œæ˜¯å‘é€ContextRefreshedEventäº‹ä»¶å‡ºæ¥.\n\n##### resetCommonCaches æ–¹æ³•()\n\nå¯ä»¥çœ‹åˆ° finally ä»£ç å—ä¸­æ˜¯ç–¯ç‹‚çš„æ¸…é™¤å„ç§ç¼“å­˜.\n\nå¯ä»¥å¤§å®¶å¯ä»¥ç‚¹è¿›å»è¯¦ç»†çš„çœ‹ä¸‹ï¼Œå…·ä½“å°±ä¸ä»”ç»†æè¿°äº†.\n\n```java\n/**\n * Reset Spring's common reflection metadata caches, in particular the\n * {@link ReflectionUtils}, {@link AnnotationUtils}, {@link ResolvableType}\n * and {@link CachedIntrospectionResults} caches.\n * @since 4.2\n * @see ReflectionUtils#clearCache()\n * @see AnnotationUtils#clearCache()\n * @see ResolvableType#clearCache()\n * @see CachedIntrospectionResults#clearClassLoader(ClassLoader)\n */\nprotected void resetCommonCaches() {\n   ReflectionUtils.clearCache();\n   AnnotationUtils.clearCache();\n   ResolvableType.clearCache();\n   CachedIntrospectionResults.clearClassLoader(getClassLoader());\n}\n```\n\n#### æ€»ç»“\n\næœ€åæ€»ç»“ä¸‹,Springåœ¨åŠ è½½ bean & å¤„ç†å†…ç½®çš„ä¸€äº›é…ç½® & å†…éƒ¨å¤„ç†å™¨çš„æ—¶å€™,æ˜¯ä¸‹äº†å¾ˆå¤šçš„åŠŸå¤«ã€‚å¯ä»¥çœ‹ç€è¿™äº›æ–¹æ³•ä¸€æ­¥ä¸€æ­¥çš„åˆ†æä¸‹å»,ç†è§£èµ·æ¥ï¼Œä¸ªäººæ„Ÿè§‰è¿™é‡Œè¿˜ä¸æ˜¯ç‰¹åˆ«æ·±å…¥çš„è·Ÿè¿›å»äº†ä»£ç ï¼Œåªæ˜¯ä¸€ä¸ªç®€å•çš„å¤§æ¦‚æè¿°ï¼Œæ›´æ·±å…¥çš„çŸ¥è¯†éœ€è¦æ›´åŠ è¯¦ç»†çš„ç†è§£ç­‰äº†.\n\nè¿™é‡Œåªæ˜¯ç®€å•çš„å¯¹è¿™ä¸ªæ•´ä¸ªflowæ¥è¿›è¡Œæè¿°ï¼Œè¿˜ä¸æ˜¯ç‰¹åˆ«æœ‰è¯¦ç»†çš„é‚£ç§.\n","tags":["java","spring"],"categories":["java","spring"]},{"title":"springåˆå§‹åŒ–(ä¸‰)","url":"/2021/11/04/spring/springåˆå§‹åŒ–-ä¸‰/","content":"\n\n\n#### é¢˜è®°\n\n å‰é¢è®²åˆ°äº†è¿™ä¹ˆå¤šçš„ä»€ä¹ˆBeanPostProcessor,äº‹ä»¶ä»€ä¹ˆçš„. å¦‚æœä¸å†™å‡ ä¸‹ä»£ç è¿™é‡Œæ€•æ˜¯å¾ˆéš¾å¼„æ¸…æ¥šæ˜¯ä¸ªæ€ä¹ˆå›äº‹. æ‰€ä»¥åªæœ‰çœ‹åˆ°ä»£ç è·‘,å°±å¤§è‡´å¯ä»¥çœ‹åˆ°å…¶æ•ˆæœè¿˜æ˜¯å¾ˆæ˜æ˜¾çš„.\n\n#### BeanDefinitionRegistryPostProcessor\n\n å…ˆå†™ä¸€ä¸ªç±»ç®€å•å®ç°ä¸‹ BeanDefinitionRegistryPostProcessor è¿™ä¸ªæ¥å£ :\n\n è¿è¡Œåçš„ç»“æœæ˜¯å¯ä»¥å¾ˆæ˜æ˜¾çš„çœ‹åˆ°æˆ‘ä»¬çš„æ‰“å°æ•°æ®è¾“å‡ºç»“æœçš„.\n\n ç¨‹åºæ˜¯æ€ä¹ˆè¿è¡Œåˆ°è¿™ä¸ªåœ°æ–¹æ¥çš„å‘¢ï¼Ÿ\n\norg.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List<org.springframework.beans.factory.config.BeanFactoryPostProcessor>) èµ°åˆ°è¿™ä¸ªæ–¹æ³•çš„\n\nbeanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.classâ€¦..),ä»è¿™ä¸ªç±»ä¸­è·å–å‡ºæ¥çš„postProcessorNames,å°±æœ‰åŒ…å«æˆ‘ä»¬çš„è‡ªå·±å®šä¹‰çš„ä¸€ä¸ª.\n\nç”±äºæˆ‘ä»¬è‡ªå·±æ‰©å±•çš„è¿™ä¸ªç±»,æ˜¯æ²¡æœ‰å®ç° PriorityOrdered/Orderedçš„,æ‰€ä»¥å°±æ”¾åˆ°æœ€åæ¥å¤„ç†äº†.\n\nä¹Ÿå°±æ˜¯åœ¨è¿™ä¸ªæ–¹æ³•,while (reiterate) { â€¦ invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);}\n\nèµ°çš„è¿™ä¸ªæ–¹æ³•çš„æ—¶å€™,æ‰ä¼šå»èµ°åˆ°æˆ‘ä»¬å®šä¹‰çš„ç±»ã€‚\n\né‚£æ˜¯å› ä¸ºè¿™ä¸ªåœ°æ–¹ Springæ˜¯æœ‰å¤„ç†é¡ºåºçš„ã€‚ å…ˆå¤„ç† PriorityOrdered.class , å†å¤„ç† Ordered.class , æœ€åå¤„ç†æ—¢æ²¡æœ‰PriorityOrdered,ä¹Ÿæ²¡æœ‰Orderedçš„.\n\n```java\n@Component\npublic class GavinYangRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {\n\n    public GavinYangRegistryPostProcessor(){\n        System.out.println(\"GavinYangRegistryPostProcessor æ„é€ æ–¹æ³•æ‰§è¡Œ\");\n    }\n\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n        System.out.println(\"è°ƒç”¨åˆ° GavinYangRegistryPostProcessor#postProcessBeanDefinitionRegistryæ–¹æ³•\");\n        String[] beanDefinitionNames = registry.getBeanDefinitionNames();\n        String bdNamesString = Arrays.toString(beanDefinitionNames);\n        System.out.println(\"GavinYangRegistryPostProcessor ç±»ä¸­\" + bdNamesString);\n    }\n\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\n    }\n}\n```\n\n#### BeanFactoryPostProcessor\n\n ç®€å•å®ç°ä¸€ä¸‹ BeanFactoryPostProcessor è¿™ä¸ªæ¥å£æ¥çœ‹ä¸€ä¸‹æ•ˆæœ.\n\n å…ˆå†™ä¸€ä¸ªç±» : ç„¶åå®ç°ä¸€ä¸‹è¿™ä¸ªæ¥å£ BeanFactoryPostProcessor , æˆ‘ä»¬è¿™é‡Œå°±è·å–ä¸‹beanFactoryä¸­çš„æ‰€æœ‰beanDefinitionNamesçš„æ•°ç»„, ç„¶åæ‰“å°å‡ºæ¥çœ‹ä¸‹æ•ˆæœ. æ‰“å°ç»“æœä¹Ÿæ˜¯è´´åœ¨ä¸‹é¢çš„. æ¥ç€æˆ‘ä»¬çœ‹ä¸‹å…¶æºç æ˜¯ä¸€ä¸ªæ€ä¹ˆæ ·çš„èµ°å‘.\n\n```java\n@Component\npublic class GavinYangBeanFactoryPostProcessor implements BeanFactoryPostProcessor {\n\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n        String[] beanDefinitionNames = beanFactory.getBeanDefinitionNames();\n        System.out.println(Arrays.toString(beanDefinitionNames));\n    }\n}\n\n//[org.springframework.context.annotation.internalConfigurationAnnotationProcessor, org.springframework.context.annotation.internalAutowiredAnnotationProcessor, org.springframework.context.annotation.internalCommonAnnotationProcessor, org.springframework.context.event.internalEventListenerProcessor, org.springframework.context.event.internalEventListenerFactory, yangBeanOne, gavinYangBeanFactoryPostProcessor, yangBeanPostProcessor, gavinYangLifeImpl]\n```\n\nç›´æ¥çœ‹è¿™ä¸ªç±»çš„è¿™ä¸ªæ–¹æ³•ï¼Œæˆ‘è¿™é‡Œåªæˆªå–äº†ä¸€éƒ¨åˆ†ä»£ç ,ä¹Ÿå°±æ˜¯å’Œ BeanFactoryPostProcessor æœ‰å…³çš„ä»£ç .\n\nå’Œå®ƒæ²¡å…³ç³»çš„ä»£ç ,è¿™é‡Œå°±æ²¡æœ‰å»æˆªå–äº†.\n\norg.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List<org.springframework.beans.factory.config.BeanFactoryPostProcessor>) .\n\nçœ‹æºç çœ‹æ˜¯å¦‚ä½•è°ƒç”¨åˆ°è¿™ä¸ªæ–¹æ³•çš„,è¿˜æ˜¯æ¯”è¾ƒå¥½ç†è§£ã€‚å…ˆæ˜¯æ ¹æ® BeanFactoryPostProcessor.classè·å–å‡ºbeanNameçš„é›†åˆ,ç„¶åè€è§„çŸ©è¿›è¡Œä¸€äº›ç‰¹å®šçš„æ’åº,å½“ç„¶æˆ‘è¿™é‡Œä»€ä¹ˆéƒ½æ²¡åš,ä¹Ÿå°±æ˜¯æœ€åå¤„ç†å“¦ã€‚\n\nç„¶åè·Ÿåˆ°invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);è¿™ä¸ªæ–¹æ³•é‡Œé¢,å¯ä»¥çœ‹åˆ°å®ƒè¿­ä»£è¿™ä¸ªé›†åˆçš„å…ƒç´ ,å½“ç„¶äº†,æˆ‘ä»¬åªéœ€è¦å…³æ³¨æˆ‘ä»¬è‡ªå·±å®šä¹‰çš„å“ªä¸ªå°±å¯ä»¥äº†,ç„¶åå°±ä¼šèµ°å…¶postProcessBeanFactoryæ–¹æ³•,ä¹Ÿå°±æ˜¯èµ°åˆ°äº†æˆ‘ä»¬å®šä¹‰çš„ç±»çš„è¿™ä¸ªæ–¹æ³•ä¸Šæ¥äº†.\n\nOKå•¦ã€‚å¤§è‡´æµç¨‹å°±æ˜¯è¿™ä¸ªæ ·å­çš„,è¿˜æ˜¯æ¯”è¾ƒå¥½ç†è§£çš„.\n\n```java\n// Do not initialize FactoryBeans here: We need to leave all regular beans\n// uninitialized to let the bean factory post-processors apply to them!\n// è¿™ä¸ªåœ°æ–¹è·å–å‡ºæ¥çš„æ•°ç»„é‡Œé¢çš„å€¼,å°±æœ‰æˆ‘ä»¬æƒ³çœ‹åˆ°çš„.\n//org.springframework.context.annotation.internalConfigurationAnnotationProcessor\n//org.springframework.context.event.internalEventListenerProcessor\n//gavinYangBeanFactoryPostProcessor\n//å½“çœ‹åˆ°ç¬¬ä¸‰ä¸ªæ˜¯ä¸æ˜¯éå¸¸çš„ç†Ÿæ‚‰.æ²¡é”™,è¿™å°±æ˜¯æˆ‘ä»¬è‡ªå·±å®šä¹‰çš„.\nString[] postProcessorNames =\n      beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);\n\n// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,\n// Ordered, and the rest.\nList<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();\nList<String> orderedPostProcessorNames = new ArrayList<>();\nList<String> nonOrderedPostProcessorNames = new ArrayList<>();\n// ç„¶åå…ˆç»è¿‡ä¸€è½®æ’åº,å°±å¯ä»¥çœ‹åˆ° æˆ‘ä»¬è‡ªå·±å®šä¹‰çš„å°±æ”¾å…¥åˆ°äº†nonOrderedPostProcessorNamesè¿™ä¸ªé›†åˆä¸­,\n//\nfor (String ppName : postProcessorNames) {\n   if (processedBeans.contains(ppName)) {\n      // skip - already processed in first phase above\n   }\n   else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n      priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));\n   }\n   else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n      orderedPostProcessorNames.add(ppName);\n   }\n   else {\n      nonOrderedPostProcessorNames.add(ppName);\n   }\n}\n\n// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.\nsortPostProcessors(priorityOrderedPostProcessors, beanFactory);\ninvokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\n// Next, invoke the BeanFactoryPostProcessors that implement Ordered.\nList<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());\nfor (String postProcessorName : orderedPostProcessorNames) {\n   orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n}\nsortPostProcessors(orderedPostProcessors, beanFactory);\ninvokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);\n\n// Finally, invoke all other BeanFactoryPostProcessors.\nList<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());\nfor (String postProcessorName : nonOrderedPostProcessorNames) {\n   nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n}\n// ç„¶åæˆ‘ä»¬ç›´æ¥çœ‹åˆ°å¤„ç†nonOrderedPostProcessorsè¿™ä¸ªé›†åˆçš„æ–¹æ³•,\n//å› ä¸ºè¿™ä¸ªæ–¹æ³•ä¹Ÿä¼šèµ°åˆ°æˆ‘ä»¬è‡ªå·±å®šä¹‰çš„ç±»ä¸­å»\n//æ–¹æ³•é‡Œé¢å¯¹nonOrderedPostProcessorsè¿›è¡Œè¿­ä»£,ç„¶åä¸€æ¬¡è°ƒç”¨å…¶postProcessBeanFactoryæ–¹æ³•,åŒæ—¶ä¹Ÿä¼ å…¥äº†beanFactoryåˆ°é‡Œé¢å».\ninvokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);\n```\n\n#### BeanPostProcessor\n\næˆ‘ä»¬å…ˆå†™ä¸€ä¸ª Bean. ç„¶åå¯ä»¥é‡Œé¢å†™ä¸€ä¸ªå±æ€§,æ–¹ä¾¿æ ‡è¯†.\n\n```java\n@Service\npublic class YangBeanOne {\n\n    private String name;\n\n    /**\n     * æ— å‚æ„é€ å‡½æ•°\n     */\n    public YangBeanOne(){\n\n        System.out.println(\"YangBeanOneæ— å‚æ•°æ„é€ å‡½æ•°\");\n\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n```\n\nç„¶åæˆ‘ä»¬è‡ªå®šä¹‰ä¸€ä¸ªBeanPostProcessor,å…¶å®ç°äº†BeanPostProcessoræ¥å£.\n\nå¯ä»¥çœ‹åˆ°çš„æ˜¯,æˆ‘ä»¬åœ¨ifä¸­åšäº†beanNameçš„åˆ¤æ–­,å¦‚æœæ˜¯çš„è¯,é‚£ä¹ˆæˆ‘ä»¬å°±ä¼šå¼ºè½¬,ç„¶åç»™nameå­—æ®µèµ‹å€¼ä¸ŠGavinYangçš„å€¼.\n\næˆ‘ä»¬ç»™æ–­ç‚¹æ‰“åˆ° ifè¿™é‡Œï¼Œç„¶åçœ‹è¿›æ¥çš„å †æ ˆä¿¡æ¯,å‘ç°å…¶æ˜¯åœ¨åˆå§‹åŒ–beanä¸­,ç„¶åè°ƒç”¨beanPostProcessorçš„postProcessAfterInitializationçš„æ–¹æ³•æ‰ä¼šèµ°åˆ°è¿™é‡Œ,ä¹Ÿå°±æ˜¯åœ¨doCreateBeanè¿™ä¸ªæ–¹æ³•é‡Œé¢.\n\nç„¶åè¿™ä¸ª YangBeanPostProcessor æ˜¯ä»€ä¹ˆæ—¶å€™ç»™æ·»åŠ åˆ° beanFactoryä¸­å»çš„å‘¢ï¼Ÿ\n\norg.springframework.context.support.PostProcessorRegistrationDelegate#registerBeanPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, org.springframework.context.support.AbstractApplicationContext)åœ¨è¿™ä¸ªæ–¹æ³•æ‰“ä¸Šæ–­ç‚¹,ç„¶åä½ ä¼šå‘ç°å…¶getå‡ºæ¥çš„postProcessorNamesæ•°ç»„,å°±æœ‰æˆ‘ä»¬çš„è¿™ä¸ªYangBeanPostProcessorï¼Œç„¶åèµ°registerBeanPostProcessorsæ–¹æ³•çš„æ—¶å€™,å°±ä¼šç»™æ·»åŠ åˆ°beanFactoryä¸­å».\n\n```java\n@Component\npublic class YangBeanPostProcessor implements BeanPostProcessor {\n\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        return bean;\n    }\n\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        if(\"yangBeanOne\".equalsIgnoreCase(beanName)){\n            ((YangBeanOne) bean).setName(\"GavinYang\");\n        }\n        return bean;\n    }\n}\n```\n\nå¯åŠ¨ç±» :\n\nè¿™å°±æ‰“å°å‡ºæ¥çš„ç»“æœå°±å¯ä»¥çœ‹åˆ°çš„æ˜¯GavinYang,ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬åˆå§‹åŒ–è¿™ä¸ªbeanä¹‹å,ç„¶åç»™å…¶nameå±æ€§èµ‹å€¼ä¸Šäº†GavinYangè¿™ä¸ªå€¼.\n\n```java\npublic class SpringStartMain {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(\"com.iyang.spring\");\n        YangBeanOne yangBeanOne = context.getBean(YangBeanOne.class);\n        System.out.println(yangBeanOne.getName());\n    }\n}\n```\n\n#### Lifecycle æ‰©å±•\n\nLifecycle æ‰©å±•è¦æ¯”èµ· BeanPostProcessorè¦å¥½ç†è§£å¾—å¤š,å› ä¸ºä½ åªç”¨å»å®ç°è¿™ä¸ªæ¥å£(SmartLifecycle),ç„¶ååœ¨org.springframework.context.support.AbstractApplicationContext#finishRefreshåˆ°è¿™ä¸ªæ–¹æ³•çš„æ—¶å€™,å°±ä¼šå»è°ƒç”¨å®ç°è¿™ä¸ªæ¥å£çš„å¯¹ç”¨çš„æ–¹æ³•.\n\nè¿™é‡Œæˆ‘ä»¬è‡ªå·±å†™ä¸€ä¸ªç±»,ç„¶åå®ç° SmartLifecycle æ¥å£å³å¯ã€‚\n\nå¯ä»¥çœ‹åˆ°ä¸‹é¢çš„æ‰“å°å‚æ•°.è¿˜æ˜¯å¾ˆæ¸…æ¥šçš„æ˜ç™½.\n\n```java\n@Component\npublic class GavinYangLifeImpl implements SmartLifecycle {\n\n    public int getPhase() {\n        return Integer.MAX_VALUE;\n    }\n\n    public void start() {\n        System.out.println(\"è°ƒç”¨åˆ°äº†GavinYangLifeImpl.start()æ–¹æ³•\");\n    }\n\n    public void stop() {\n\n    }\n\n    public boolean isRunning() {\n        return false;\n    }\n}\n\n//YangBeanOneæ— å‚æ•°æ„é€ å‡½æ•°\n//è°ƒç”¨åˆ°äº†GavinYangLifeImpl.start()æ–¹æ³•\n//GavinYang\n```\n\nç„¶åæˆ‘ä»¬å†çœ‹ä¸‹æºç ,ä¸ºä»€ä¹ˆè¦å®ç° SmartLifecycle è¿™ä¸ªæ¥å£å‘¢ï¼Ÿ\n\norg.springframework.context.support.DefaultLifecycleProcessor\n\nè¿™é‡Œæˆ‘ä»¬å…ˆçœ‹åˆ° phases ,ä¹Ÿå°±æ˜¯æœ€åº•ä¸‹çš„ä»£ç , è¿™ä¸ªé›†åˆæ˜¯æœ‰å€¼çš„æƒ…å†µä¸‹å…ˆæ’åº,ç„¶åå†è¿­ä»£,ç„¶åè°ƒç”¨åˆ° start()æ–¹æ³•, è¿™ä¸ªstartæ–¹æ³•æ˜¯ä¸æ˜¯åœ¨æˆ‘ä»¬çš„å®ç°ç±»ä¸­å¯ä»¥çœ‹åˆ°,æ˜¯ä¸æ˜¯éå¸¸çš„ç†Ÿæ‚‰æ„Ÿè§‰.\n\nç„¶åæˆ‘ä»¬åœ¨çœ‹ä¸‹,æ€ä¹ˆæ ·è®©è¿™ä¸ªé›†åˆèƒ½æœ‰å€¼å‘¢ï¼Ÿ\n\nphases.put(phase, group); å¯ä»¥çœ‹åˆ° putæ–¹æ³•è¿™é‡Œ, autoStartupOnly æ˜¯false æˆ–è€…beanæ˜¯SmartLifecycleçš„å­ç±»,å¹¶ä¸”å…¶isAutoStartupæ–¹æ³•çš„æ˜¯true. ç‚¹åˆ°SmartLifecycleæºç ä¸­å»çœ‹,å¯ä»¥å‘ç°è¿™ä¸ªæ–¹æ³•é»˜è®¤æ˜¯è¿”å›çš„true.\n\næ¥ç€åœ¨è°ƒç”¨getPhaseæ–¹æ³•, è¯¥æ–¹æ³•ä¹Ÿå°±æ˜¯åˆ¤æ–­.æœ€æœ€å…³é”®çš„phasesé›†åˆæ¥äº†,å…ˆä»é‡Œé¢getå‡ºæ•°æ®,ç„¶ååˆ¤æ–­æ•°æ®æ˜¯ä¸æ˜¯null,å¦‚æœæ˜¯nullçš„è¯,å°±å…ˆnewä¸€ä¸ªGroupå‡ºæ¥,ç„¶åè°ƒç”¨phasesçš„putæ–¹æ³•,ä¹Ÿå°±æ˜¯æ”¾å…¥åˆ°è¿™ä¸ªé›†åˆä¸­å»äº†\n\næ‰€ä»¥è¿™é‡Œå°±æ˜¯æˆ‘ä»¬ä¸ºä»€ä¹ˆè¦å®ç° SmartLifecycle è¿™ä¸ªæ¥å£,å°±ä¼šæœ‰å¯åŠ¨çš„æ•ˆæœäº†çš„åŸå› .\n\n```java\n// Internal helpers\n// ä¼ å…¥è¿›æ¥çš„  autoStartupOnly å‚æ•°æ˜¯true.\nprivate void startBeans(boolean autoStartupOnly) {\n   Map<String, Lifecycle> lifecycleBeans = getLifecycleBeans();\n   Map<Integer, LifecycleGroup> phases = new HashMap<>();\n   lifecycleBeans.forEach((beanName, bean) -> {\n      if (!autoStartupOnly || (bean instanceof SmartLifecycle && ((SmartLifecycle) bean).isAutoStartup())) {\n         int phase = getPhase(bean);\n         LifecycleGroup group = phases.get(phase);\n         if (group == null) {\n            group = new LifecycleGroup(phase, this.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);\n            phases.put(phase, group);\n         }\n         group.add(beanName, bean);\n      }\n   });\n   if (!phases.isEmpty()) {\n      List<Integer> keys = new ArrayList<>(phases.keySet());\n      Collections.sort(keys);\n      for (Integer key : keys) {\n         phases.get(key).start();\n      }\n   }\n}\n```\n\n#### æ€»ç»“\n\nå¯ä»¥çœ‹åˆ°æˆ‘ä»¬åŸºäºæ¥å£æ‰©å±•çš„,è¿˜æ˜¯å¾ˆå¥½ç†è§£çš„ã€‚ è·Ÿç€æºç ä¸­çš„åˆå§‹åŒ–ä¸€äº›ç±»,çœ‹å“ªä¸ªç±»æ˜¯æ€ä¹ˆå†™çš„ï¼Œç„¶åæˆ‘ä»¬è·Ÿç€å†™ä¸€ä¸ªã€‚ å‰ææ˜¯,ä½ è¦å¼„å¾—æ˜ç™½ Spring è¿™ä¸ªæ‰§è¡Œè¿‡ç¨‹çš„. ä¸ç„¶ä½ è·Ÿç€å†™,ä¸æ˜¯å¾ˆæ˜ç™½çš„è¯,å°±å¯èƒ½ä¸æ˜¯å¾ˆå®¹æ˜“çœ‹æ˜ç™½æˆ–è€…çœ‹æ‡‚ä½ è¿™ä¸ªæ•ˆæœçš„.\n","tags":["java","spring"],"categories":["java","spring"]},{"title":"springåˆå§‹åŒ–(äºŒ)","url":"/2021/11/04/spring/springåˆå§‹åŒ–-äºŒ/","content":"\n\n\n#### é¢˜è®°\n\n æ˜¨å¤©è®°å½•äº†this()å’Œ register() è¿™äºŒä¸ªæ–¹æ³•, è¿™äºŒä¸ªæ–¹æ³•éƒ½æ˜¯ä¸ºåé¢çš„åšé“ºå«,ä¹Ÿå°±æ˜¯æå‰åˆå§‹åŒ–äº†ä¸€äº›ç¯å¢ƒå’Œè¯»å–classæ–‡ä»¶. refresh() è¿™ä¸ªæ–¹æ³•æ‰æ˜¯æœ€é‡è¦çš„,å…¶ä¸­åŒ…å«çš„å†…å®¹æ˜¯éå¸¸å¤šçš„. æ‰€ä»¥è¿™é‡Œæ…¢æ…¢è¿›è¡Œæ›´æ–°å…¶æ–¹æ³•çš„å†…å®¹.\n\n#### refresh æ–¹æ³•\n\nè¿™é‡Œå¯ä»¥çœ‹åˆ°çš„æ˜¯, refresh()è¯¥æ–¹æ³•é‡Œé¢,åŸºæœ¬éƒ½æ˜¯èµ°äº†å¾ˆå¤šæ–¹æ³•çš„. æ‰€ä»¥æŒ¨ä¸ªçœ‹æ–¹æ³•,æœ‰äº›æ–¹æ³•æ˜¯ç•™ç»™å­ç±»çš„,ä¹Ÿå°±æ˜¯è¿›è¡Œæ‰©å±•çš„. ä»synchronizedè¿™ä¸ªå…³é”®å­—æ¥çœ‹,è¿™é‡Œåªå®¹è®¸ä¸€æ¬¡åªæœ‰ä¸€ä¸ªçº¿ç¨‹æ¥æ‰§è¡Œè¿™ä¸ªæ–¹æ³•.\n\n```java\n@Override\npublic void refresh() throws BeansException, IllegalStateException {\n   synchronized (this.startupShutdownMonitor) {\n      // Prepare this context for refreshing.\n      prepareRefresh();\n\n      // Tell the subclass to refresh the internal bean factory.\n\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n      // Prepare the bean factory for use in this context.\n      /**\n       * org.springframework.beans.factory.support.DefaultListableBeanFactory\n       *\n       */\n      prepareBeanFactory(beanFactory);\n\n      try {\n         // Allows post-processing of the bean factory in context subclasses.\n         postProcessBeanFactory(beanFactory);\n\n         // Invoke factory processors registered as beans in the context.\n         invokeBeanFactoryPostProcessors(beanFactory);\n\n         // Register bean processors that intercept bean creation.\n         registerBeanPostProcessors(beanFactory);\n         // Initialize message source for this context.\n         initMessageSource();\n\n         // Initialize event multicaster for this context.\n         initApplicationEventMulticaster();\n         // Initialize other special beans in specific context subclasses.\n         onRefresh();\n         // Check for listener beans and register them.\n         registerListeners();\n         // Instantiate all remaining (non-lazy-init) singletons.\n         /**\n          */\n         finishBeanFactoryInitialization(beanFactory);\n\n         // Last step: publish corresponding event.\n         finishRefresh();\n      } catch (BeansException ex) {\n         if (logger.isWarnEnabled()) {\n            logger.warn(\"Exception encountered during context initialization - \" +\n                  \"cancelling refresh attempt: \" + ex);\n         }\n         // Destroy already created singletons to avoid dangling resources.\n         destroyBeans();\n         // Reset 'active' flag.\n         cancelRefresh(ex);\n         // Propagate exception to caller.\n         throw ex;\n      } finally {\n         // Reset common introspection caches in Spring's core, since we\n         // might not ever need metadata for singleton beans anymore...\n         resetCommonCaches();\n      }\n   }\n}\n```\n\n#### refresh.prepareRefresh() æ–¹æ³•\n\nprepareRefresh() æ–¹æ³•: å¯ä»¥çœ‹åˆ°è¯¥æ–¹æ³•å…ˆæ˜¯å¯¹closed/activeå‚æ•°è¿›è¡Œè®¾ç½®,ç„¶åå¯¹Enviornmentè¿›è¡Œè°ƒç”¨æ£€éªŒæ–¹æ³•,æ¥ç€åˆ¤æ–­this.earlyApplicationListenersæ˜¯å¦æœ‰å€¼æ¥æ“ä½œthis.applicationListeners. æœ€ååˆå§‹åŒ–earlyApplicationEventsè¿™ä¸ªé›†åˆ. è¿™é‡Œå¤§æ¦‚è¿˜æ˜¯è¿›è¡Œä¸€äº›åˆå§‹åŒ–æ“ä½œ.\n\n```java\n/**\n * Prepare this context for refreshing, setting its startup date and\n * active flag as well as performing any initialization of property sources.\n */\nprotected void prepareRefresh() {\n   // Switch to active.\n   this.startupDate = System.currentTimeMillis();\n  // closedè®¾ç½®ä¸ºfalse,activeè®¾ç½®ä¸ºtrue.  \n   this.closed.set(false);\n   this.active.set(true);\n\n   // æ ¹æ®logçº§åˆ«æ¥è¿›è¡Œè¾“å‡º \n   if (logger.isInfoEnabled()) {\n      logger.info(\"Refreshing \" + this);\n   }\n\n   // Initialize any placeholder property sources in the context environment.\n   // ç›®å‰è¯¥æ–¹æ³•æ²¡æœ‰è°ƒç”¨;ç›®å‰æ²¡æœ‰åšä»»ä½•äº‹æƒ…. ç›®æµ‹æ˜¯åº”è¯¥ç•™ç»™å­ç±»ä¹‹ç±»çš„è¿›è¡Œæ‰©å±•çš„.\n   initPropertySources();\n\n   // Validate that all properties marked as required are resolvable:\n   // see ConfigurablePropertyResolver#setRequiredProperties\n//å…ˆè°ƒç”¨getEnvironment()è·å–this()æ–¹æ³•ä¸­åˆ›å»ºå‡ºæ¥çš„Environmentæ¥,ç„¶åèµ°validateRequiredPropertiesæ–¹æ³•æ¥è¿›è¡Œä¸€äº›æ£€éªŒ,\n//org.springframework.core.env.AbstractPropertyResolver#validateRequiredProperties\n//æœ€åæ˜¯èµ°åˆ°äº†è¿™ä¸ªæ–¹æ³•,å¦‚æœthis.requiredPropertiesä¸­æ˜¯æœ‰å€¼çš„è¯,é‚£ä¹ˆè¿™é‡Œå°±ä¼šæŠ›å‡ºä¸€ä¸ªå¼‚å¸¸æ¥    \n   getEnvironment().validateRequiredProperties();\n    \n   // Store pre-refresh ApplicationListeners...\n// è¿™é‡Œæ˜¯å¯¹ earlyApplicationListeners è¿›è¡Œåˆ¤æ–­,å¦‚æœæœ‰å€¼çš„è¯,å°±å…ˆä¼šclearæ‰,ç„¶åå†addAll\n//å¦‚æœæ˜¯æ²¡æœ‰å€¼çš„è¯,å°±ä¼šnewä¸€ä¸ªé›†åˆ,ç„¶åèµ‹å€¼ç»™this.earlyApplicationListenerså‚æ•°   \n   if (this.earlyApplicationListeners == null) {\n      this.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);\n   }\n   else {\n      // Reset local application listeners to pre-refresh state.\n      this.applicationListeners.clear();\n      this.applicationListeners.addAll(this.earlyApplicationListeners);\n   }\n\n   // Allow for the collection of early ApplicationEvents,\n   // to be published once the multicaster is available...\n// æœ€ååˆå§‹åŒ–ä¸€ä¸‹ this.earlyApplicationEvents è¿™ä¸ªå‚æ•°\n   this.earlyApplicationEvents = new LinkedHashSet<>();\n}\n```\n\n#### refresh.obtainFreshBeanFactory()æ–¹æ³•\n\nè¿™ä¸ªæ–¹æ³•æ˜¯æœ‰æ–¹æ³•ä¸€ä¸ªBeanFactoryå›å»çš„.\n\nè¯¥æ–¹æ³•å¯¹beanFactoryè¿›è¡ŒSerializationId,ç„¶åè·å–BeanFactory,æœ€åè¿”å›è¿™ä¸ªBeanFactory.\n\n```java\n/**\n * Tell the subclass to refresh the internal bean factory.\n *  å‘Šè¯‰å­ç±»åˆ·æ–°å†…éƒ¨Beanå·¥å‚\n * @return the fresh BeanFactory instance\n * @see #refreshBeanFactory()\n * @see #getBeanFactory()\n */\nprotected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n//this.refreshed.compareAndSet(false, true)è¯¥æ–¹æ³•å¦‚æœè¿”å›çš„æ˜¯falseçš„è¯,å°±ä¼šæœ‰å¼‚å¸¸ç»™æŠ›å‡ºæ¥\n//ä¸æ˜¯falseçš„è¯,æ¥ç€å°±æ˜¯å¯¹beanFactoryè®¾ç½®SerializationId    \n   refreshBeanFactory();\n// org.springframework.context.support.GenericApplicationContext#getBeanFactory\n//è¯¥æ–¹æ³•ç›´æ¥è¿”å›DefaultListableBeanFactory    \n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n   if (logger.isDebugEnabled()) {\n      logger.debug(\"Bean factory for \" + getDisplayName() + \": \" + beanFactory);\n   }\n//è¿”å›è·å–çš„beanFactory.    \n   return beanFactory;\n}\n```\n\n#### refresh.prepareBeanFactory() æ–¹æ³•\n\nä»è¿™ä¸ªæ–¹æ³•æ¥çœ‹,æ˜¯å¯¹BeanFactoryçš„å‡†å¤‡.\n\nè¯¥æ–¹æ³•å¯ä»¥å…ˆæ˜¯å¯¹classLoader,expressionResolver,propertyEditorRegistraræ·»åŠ åˆ°beanFactoryä¸­å». ç„¶åæ·»åŠ ApplicationContextAwareProcessor(BeanPostProcessor)åˆ°BeanFactory,ç„¶åå¿½ç•¥åˆ°ä¸€äº›æ¥å£çš„æ³¨å…¥åˆ°beanFactoryä¸­å».\n\nè®¾ç½® BeanFactory , ResourceLoader , ApplicationEventPublisher, ApplicationContextç­‰beanåˆ°BeanFactoryä¸­å».\n\næœ€åå°±æ˜¯ä¸€äº›environment,systemProperties,systemEnvironmentç­‰æ³¨å…¥åˆ°BeanFactoryä¸­å».\n\n```java\n/**\n *\n * Configure the factory's standard context characteristics,\n * such as the context's ClassLoader and post-processors.\n * @param beanFactory the BeanFactory to configure\n */\nprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n   // Tell the internal bean factory to use the context's class loader etc.\n//ç»™beanFactoryè®¾ç½®classLoader(åŠ è½½bean) \n   beanFactory.setBeanClassLoader(getClassLoader());\n//è¿™é‡Œæ ¹æ®classLoaderæ¥è·å–è§£æå™¨,ç„¶åsetåˆ°BeanFactoryä¸­å».(è§£æbeanå®šä¹‰çš„è¡¨è¾¾å¼)\n   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n//å±æ€§ç¼–è¾‘æ³¨å†Œå™¨,setåˆ°BeanFactoryä¸­\n   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));\n\n   // Configure the bean factory with context callbacks.\n//æ·»åŠ ApplicationContextAwareProcessoråˆ°BeanFactoryä¸­.è¯¥ç±»æ˜¯æœ‰å®ç°BeanPostProcessorçš„\n//BeanPostProcessoræ˜¯åœ¨beanåˆå§‹åŒ–å®Œå,è°ƒç”¨BeanPostProcessorè¿›è¡Œæ‰©å±•.\n   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n//å¿½ç•¥æ‰EnvironmentAware/EmbeddedValueResolverAware....ApplicationContextAware\n//è¿™å…­ä¸ªæ¥å£çš„æ³¨å…¥(ä¾èµ–). å› ä¸ºApplicationContextAwareProcessorä¸­æœ‰åšäº†è¿™äº›äº‹\n   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n\n   // BeanFactory interface not registered as resolvable type in a plain factory.\n   // MessageSource registered (and found for autowiring) as a bean.\n// BeanFactory,ResourceLoader,ApplicationEventPublisher,ApplicationContextè¿™å››ä¸ªæ¥å£\n//å¯¹åº”çš„beanéƒ½setåˆ°beanFactoryä¸­å».    \n   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n   beanFactory.registerResolvableDependency(ResourceLoader.class, this);\n   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n   beanFactory.registerResolvableDependency(ApplicationContext.class, this);\n\n   // Register early post-processor for detecting inner beans as ApplicationListeners.\n//æ·»åŠ ApplicationListenerDetector(BeanPostProcessor)åˆ°beanFactoryä¸­å».\n   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));\n\n   // Detect a LoadTimeWeaver and prepare for weaving, if found.\n   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n      // Set a temporary ClassLoader for type matching.\n      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n   }\n\n   // Register default environment beans.\n//å¦‚æœbeanFactoryä¸­æ²¡æœ‰ENVIRONMENT_BEAN_NAMEè¿™ä¸ªbeançš„è¯,å°±æ³¨å…¥ä¸€ä¸ªè¿›å»\n   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());\n   }\n// SYSTEM_PROPERTIES_BEAN_NAMEä¹Ÿæ˜¯ä¸€æ ·,æ³¨å…¥åˆ°beanFactoryä¸­å»\n   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());\n   }\n//SYSTEM_ENVIRONMENT_BEAN_NAMEåŒä¸Š    \n   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());\n   }\n}\n```\n\n#### refresh.postProcessBeanFactory() æ–¹æ³•\n\nè¯¥æ–¹æ³•ç›®å‰åœ¨å•ä¸ª Springä¸­æ˜¯æ²¡æœ‰åšä»»ä½•äº‹æƒ…çš„ã€‚ ç­‰åˆ°çœ‹SpringBootæºç çš„æ—¶å€™,è¿™é‡Œå°±ä¼šæœ‰ä»£ç èµ°è¿›æ¥,æ˜¯è¿›è¡Œæ ¹æ®åŒ…æ¥æ‰«ææ¥è·å–classç­‰ä¿¡æ¯çš„. æ»¡è¶³æ¡ä»¶çš„class,å°±ä¼šå½“ä¸ºbdç»™æ³¨å†Œåˆ°beanFactoryä¸­å».\n\n```java\n/**\n * Modify the application context's internal bean factory after its standard\n * initialization. All bean definitions will have been loaded, but no beans\n * will have been instantiated yet. This allows for registering special\n * BeanPostProcessors etc in certain ApplicationContext implementations.\n * @param beanFactory the bean factory used by the application context\n */\nprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n}\n```\n\n#### refresh.invokeBeanFactoryPostProcessors() æ–¹æ³•\n\nå¯ä»¥çœ‹åˆ°è¿™ä¸ªæ–¹æ³•,å€ŸåŠ©PostProcessorRegistrationDelegateæ¥å¯¹PostProcessorè¿›è¡Œå¤„ç†ã€‚\n\nå…ˆæ˜¯å¯¹BeanDefinitionRegistryPostProcessorè¿›è¡Œä»beanFactoryä¸­è·å–å‡ºç›¸åº”çš„åå­—æ•°ç»„,ç„¶åè¿­ä»£è¿™ä¸ªæ•°ç»„,ç„¶åå¤„ç†PriorityOrderedâ€”>Orderedâ€”> æ²¡æœ‰,è¿™ä¸ªé¡ºåº,æœ€åè¿˜æœ‰ä¸€ä¸ªwhileå¾ªç¯è¿­ä»£æ¥æ£€æŸ¥BeanDefinitionRegistryPostProcessoræ˜¯å¦éƒ½å¤„ç†å®Œäº†.\n\nå†æ¥ç€å°±æ˜¯å¤„ç†BeanFactoryPostProcessor,å¤„ç†æ–¹å¼æ˜¯å’ŒBeanDefinitionRegistryPostProcessorä¸€æ ·çš„,é¡ºåºä¹Ÿæ˜¯ä¸€æ ·çš„.\n\næœ€åå°±æ˜¯è°ƒç”¨beanFactory.clearMetadataCache()æ¸…é™¤.\n\nå½“ç„¶,è¿™ä¸ªé‡Œé¢æœ‰äº›ä¸Šé¢ PostProcessorç­‰å¾…é˜…è¯»SpringBootçš„æ—¶å€™ç»™è¡¥ä¸Šæ¥,å› ä¸ºåˆ°æ—¶å€™SpringBootè¿™é‡Œä¼šæœ‰å¾ˆå¤šPostProcessor,è¿™é‡Œç›®å‰æ˜¯æ²¡æœ‰çš„.\n\n```java\n/**\n * Instantiate and invoke all registered BeanFactoryPostProcessor beans,\n * respecting explicit order if given.\n * <p>Must be called before singleton instantiation.\nBeanFactoryPostProcessor: ç”¨æ¥ä¿®æ”¹Springå®¹å™¨ä¸­å·²ç»å­˜åœ¨çš„beanå®šä¹‰.\nBeanDefinitionRegistryPostProcessor: æ˜¯BeanFactoryPostProcessorçš„å­ç±»,ä½œç”¨å’Œçˆ¶ç±»æ˜¯ä¸€æ ·çš„,ä¸åŒçš„æ˜¯,è¯¥ä½¿ç”¨çš„æ˜¯BeanDefinitionRegistryå¯¹beanè¿›è¡Œå¤„ç†\n */\nprotected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n//org.springframework.context.support.AbstractApplicationContext#getBeanFactoryPostProcessors,ç”±äºè¿™é‡Œåªæ˜¯å¯åŠ¨äº†å•ä¸ªSpring,è¿”å›çš„é›†åˆæ˜¯æ²¡æœ‰å€¼çš„.\n   List<BeanFactoryPostProcessor> postProcessorsList = getBeanFactoryPostProcessors();\n   //System.out.println(\"postProcessorsList value ---> \" + postProcessorsList);\n   // System.out.println(\"beanFactory  value 111111 ---> \" + beanFactory);\n//å€ŸåŠ©PostProcessorRegistrationDelegateæ¥å¤„ç†PostProcessors.\n//å¯¹ä¼ å…¥postProcessorsListè¿›è¡Œè¿­ä»£,å¦‚æœPostProcessoræ˜¯BeanDefinitionRegistryPostProcessorçš„è¯,å°±ä¼šå¼ºè½¬ç„¶åè°ƒç”¨postProcessBeanDefinitionRegistryæ–¹æ³•(ä¼ å…¥å‚æ•°æ˜¯beanFacotry),æ·»åŠ åˆ°registryProcessorsé›†åˆä¸­.å¦‚æœä¸æ˜¯çš„è¯,å°±ä¼šæ·»åŠ åˆ°regularPostProcessorsé›†åˆä¸­.\n//æ ¹æ®BeanDefinitionRegistryPostProcessor,ä»beanFactoryä¸­è·å–postProcessorNames,\n//è¿›è¡Œè¿­ä»£,å¦‚æœæ˜¯æœ‰PriorityOrderedæ¥å£çš„å­ç±»çš„è¯,å°±ä¼šä»beanFactoryä¸­æ ¹æ®beanåå­—,ç±».classæ¥è·å–BeanDefinitionRegistryPostProcessor,å¹¶ä¸”æ·»åŠ åˆ°currentRegistryProcessorsé›†åˆä¸­,ppName(åå­—çš„å€¼)ä¹Ÿä¼šæ·»åŠ åˆ°processedBeansè¯¥é›†åˆä¸­\n//å¯¹currentRegistryProcessorsè¿›è¡Œæ’åº,å…¨éƒ¨æ·»åŠ åˆ°registryProcessorsé›†åˆä¸­,invokeBeanDefinitionRegistryPostProcessors()è¯¥æ–¹æ³•æ˜¯è°ƒç”¨BeanDefinitionRegistryPostProcessorsçš„,è°ƒç”¨å®Œäº†ç„¶åæ¸…ç©ºcurrentRegistryProcessorsè¿™ä¸ªé›†åˆ.\n//åŒæ ·æ–¹æ³•è·å–postProcessorNames,processedBeansé›†åˆä¸­ä¸åŒ…å«å¹¶ä¸”æ˜¯Orderedçš„å­ç±»,ç„¶åæ·»åŠ åˆ°currentRegistryProcessorsé›†åˆä¸­,ppNameä¹Ÿä¼šæ·»åŠ åˆ°processedBeansé›†åˆä¸­,åŒæ ·çš„æ’åºæ–¹å¼,æ·»åŠ åˆ°registryProcessorsä¸­,å†è°ƒç”¨invokeBeanDefinitionRegistryPostProcessors()æ–¹æ³•,currentRegistryProcessorsæ¸…ç©ºè¯¥é›†åˆ.\n// ä¹Ÿå°±æ˜¯åˆ°è¿™é‡Œ,å¯ä»¥çœ‹å‡ºæ¥,å¤„ç†çš„é¡ºåº,å…ˆæ˜¯å¤„ç†PriorityOrdered,å†å¤„ç†Ordered.\n// ç„¶åä½¿ç”¨ä¸€ä¸ªwhileå¾ªç¯,ç»§ç»­è·å–BeanDefinitionRegistryPostProcessorå¯¹åº”çš„postProcessorNames,è¿™ä¸ªåœ°æ–¹æ˜¯ä¸ºäº†é˜²æ­¢æœ‰äº›æ²¡æœ‰è°ƒç”¨åˆ°çš„,å¹¶ä¸”æ˜¯processedBeansé›†åˆä¸­ä¸åŒ…å«çš„,ç„¶åå°±ä¼šæ”¾å…¥åˆ°currentRegistryProcessorsè¿™ä¸ªé›†åˆä¸­,æ’åºcurrentRegistryProcessorsé›†åˆ,å…¨éƒ¨æ·»åŠ åˆ°registryProcessorsä¸­,è°ƒç”¨invokeBeanDefinitionRegistryPostProcessors,ä¹Ÿå°±æ˜¯è°ƒç”¨å…·ä½“çš„PostProcessors.\n//invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);\n//invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);\n// ä¹‹å‰çš„äºŒä¸ªé›†åˆ,registryProcessorså’ŒregularPostProcessors,åœ¨è¿™é‡Œè¿˜æ˜¯ä¼šç»§ç»­è°ƒç”¨.\n//ç„¶åæ ¹æ®BeanFactoryPostProcessor.classè·å–postProcessorNamesæ•°ç»„,ä¸ä¸Šé¢çš„ä¹Ÿæ˜¯åŒæ ·çš„æ–¹æ³•,\n//å¯¹postProcessorNamesè¿›è¡Œè¿­ä»£,å¦‚æœæ˜¯processedBeans(ä¸Šé¢è£…çš„åå­—)å¦‚æœåŒ…å«äº†,å°±ä¼šè·³è¿‡.\n/** å¦‚æœppName,ä¹Ÿå°±æ˜¯è¿­ä»£çš„å€¼,æ˜¯æœ‰PriorityOrderedçš„å­ç±»çš„è¯,å°±ä¼šä»èµ°beanFactory.getBean(ppName, BeanFactoryPostProcessor.class)è·å–å‡ºBeanFactoryPostProcessoræ”¾å…¥åˆ°priorityOrderedPostProcessorsé›†åˆä¸­.  å¦‚æœæ˜¯Orderedçš„å­ç±»,å°±å°†åå­—æ”¾å…¥åˆ°orderedPostProcessorNamesé›†åˆä¸­,å¦‚æœä¸Šé¢ä¸‰ç§éƒ½ä¸æ»¡è¶³çš„è¯,å°±ä¼šæ”¾å…¥åˆ°nonOrderedPostProcessorNamesé›†åˆä¸­.\nç„¶åå…ˆæ’åºpriorityOrderedPostProcessors,å†èµ°invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);\næ¥ç€è¿­ä»£orderedPostProcessorNamesé›†åˆ,ç„¶åä»beanFactoryä¸­è·å–BeanFactoryPostProcessor,å†å°±åšä¸priorityOrderedPostProcessorsä¸€æ ·çš„æ“ä½œ.\næœ€ååœ¨åšnonOrderedPostProcessorsè¿™ä¸ªé›†åˆçš„,æ“ä½œæ˜¯ä¸orderedPostProcessorNamesä¸€æ‘¸ä¸€æ ·çš„.\n\næœ€ååœ¨è°ƒç”¨ä¸€ä¸ªbeanFactoryçš„clearMetadataCacheæ–¹æ³•.\nå¯ä»¥çœ‹åˆ°è¿™ä¸ªæ–¹æ³•æ˜¯å…ˆå¯¹BeanDefinitionRegistryPostProcessor.classè¿›è¡Œå¤„ç†,ç„¶åæ ¹æ®é¡ºåºPriorityOrdered-->Ordered--->æ²¡æœ‰, è¿™æ ·çš„é¡ºåºæ‰§è¡Œçš„.\nç„¶åå†å¤„ç†BeanFactoryPostProcessor.class,å¤„ç†æ–¹å¼æ˜¯å’ŒBeanDefinitionRegistryPostProcessor.classä¹Ÿæ˜¯ä¸€æ ·çš„,æ ¹æ®é¡ºåºæ¥è¿›è¡Œå¤„ç†.\n*/    \n   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, postProcessorsList);\n\n   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime\n   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)\n// è·å–beanFactoryçš„tempClassLoaderåŠ è½½,å¹¶ä¸”beanFactoryæ˜¯åŒ…å«äº†loadTimeWeaverè¿™ä¸ªbeançš„,\n//å°±ä¼šèµ°ifæ–¹æ³•,å¯ä»¥çœ‹åˆ°æ˜¯æ·»åŠ LoadTimeWeaverAwareProcessoråˆ°beanFactoryçš„postProcessorä¸­,\n//ç„¶åæ·»åŠ ä¸€ä¸ªClassLoaderåˆ°beanFactoryä¸­   \n   if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n   }\n}\n```\n\n#### refresh.registerBeanPostProcessors() æ–¹æ³•\n\nä»”ç»†çœ‹ä¸­è¿™ä¸ªæ–¹æ³•,å…¶å®å’Œä¸Šä¸€ä¸ªæ–¹æ³•èµ°çš„é€»è¾‘å¥½åƒæ˜¯æœ‰ç‚¹ç±»ä¼¼çš„. ä¹Ÿæ˜¯å€ŸåŠ©PostProcessorRegistrationDelegateæ¥å®Œæˆå…¶é€»è¾‘çš„.\n\nå…ˆæ˜¯ä»BeanFactoryä¸­è·å–BeanPostProcessorå¯¹ç”¨çš„postProcessorNamesæ•°ç»„ã€‚\n\nç„¶ååˆ†ä¸º PriorityOrdered â€“> Ordered â€“> æ—¢ä¸æ˜¯PriorityOrdered ,ä¹Ÿä¸æ˜¯Ordered â€“> MergedBeanDefinitionPostProcessorå­ç±», è¿™æ ·çš„å…ˆåé¡ºåº,èµ°registerBeanPostProcessors,è¿™ä¸ªæ˜¯å°†PostProcessrosæ³¨å†Œåˆ°Springçš„beanFactoryä¸­(Springå®¹å™¨).\n\n```java\n/**\n * Instantiate and register all BeanPostProcessor beans,\n * respecting explicit order if given.\n * <p>Must be called before any instantiation of application beans.\n */\nprotected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n   PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);\n}\n\n-------------------\n\tpublic static void registerBeanPostProcessors(\n\t\t\tConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {\n\n// å…ˆæ˜¯æ ¹æ®BeanPostProcessorè·å–å‡ºpostProcessorNamesæ•°ç»„,è¿™ä¸ªæ ¹æ®å’Œä¸Šé¢çš„æ–¹æ³•å¾ˆç›¸ä¼¼.    \n\t\tString[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class,\n\t\t\t\ttrue, false);\n\n\t\t// Register BeanPostProcessorChecker that logs an info message when\n\t\t// a bean is created during BeanPostProcessor instantiation, i.e. when\n\t\t// a bean is not eligible for getting processed by all BeanPostProcessors.\n//ç„¶åä»beanFactoryä¸­è·å–å‡ºä¸ªæ•° + postProcessorNamesæ•°ç»„é•¿åº¦å†åŠ ä¸Šä¸€ä¸ª1.     \n\t\tint beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;\n//æ·»åŠ ä¸€ä¸ªBeanPostProcessorCheckeråˆ°beanFactoryä¸­.ä»åå­—ä¸Šæ¥,è¿™ä¸ªPostProcessoråº”è¯¥æ˜¯è¿›è¡Œæ£€æŸ¥çš„æ“ä½œ.\n\t\tbeanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));\n\n\t\t// Separate between BeanPostProcessors that implement PriorityOrdered,\n\t\t// Ordered, and the rest.\n\t\tList<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();\n\t\tList<BeanPostProcessor> internalPostProcessors = new ArrayList<>();\n\t\tList<String> orderedPostProcessorNames = new ArrayList<>();\n\t\tList<String> nonOrderedPostProcessorNames = new ArrayList<>();\n\n\t\t// å¯¹ postProcessorNames è¿›è¡Œéå†;åŒæ—¶ä½¿ç”¨ä¸åŒç±»å‹çš„é›†åˆæ¥å­˜å‚¨æ•°æ®\n//ä¸»è¦æ˜¯æ ¹æ®æ˜¯å¦æ˜¯PriorityOrderedçš„å­ç±»,æ˜¯çš„è¯å°±ä¼šæ”¾å…¥åˆ°priorityOrderedPostProcessorsé›†åˆä¸­,æ¥ç€åœ¨åˆ¤æ–­æ˜¯å¦æ˜¯MergedBeanDefinitionPostProcessor,å¦‚æœæ˜¯çš„è¯,å°±ä¼šæ”¾å…¥åˆ°internalPostProcessorsé›†åˆä¸­\n//æ˜¯ä¸æ˜¯orderdçš„å­ç±»,æ˜¯çš„è¯,å°±ä¼šæ”¾å…¥åˆ°orderedPostProcessorNamesé›†åˆä¸­,\n//å¦‚æœä¸Šé¢äºŒè€…éƒ½ä¸çš„è¯,å°±ä¼šæ”¾å…¥åˆ°nonOrderedPostProcessorNamesé›†åˆä¸­  \n\t\tfor (String ppName : postProcessorNames) {\n\t\t\tif (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n\t\t\t\tBeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\t\tpriorityOrderedPostProcessors.add(pp);\n\t\t\t\tif (pp instanceof MergedBeanDefinitionPostProcessor) {\n\t\t\t\t\tinternalPostProcessors.add(pp);\n\t\t\t\t}\n\t\t\t} else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n\t\t\t\torderedPostProcessorNames.add(ppName);\n\t\t\t} else {\n\t\t\t\tnonOrderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t}\n\n\t\t// First, register the BeanPostProcessors that implement PriorityOrdered.\n//å…ˆå¤„ç†priorityOrderedPostProcessorsè¿™ä¸ªé›†åˆä¸­çš„æ•°æ®.å…ˆæ’åº,ç„¶åè°ƒç”¨registerBeanPostPtocessorsæ–¹æ³•.\n\t\tsortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\t\tregisterBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);\n\n\t\t// Next, register the BeanPostProcessors that implement Ordered.\n//åœ¨å¤„ç†orderedPostProcessorNamesé›†åˆä¸­çš„æ•°æ®,å‘ç°å¦‚æœä¹Ÿæ˜¯MergedBeanDefinitionPostProcessoræˆ–è€…å…¶å­ç±»çš„è¯,ä¹Ÿå°±æ”¾å…¥åˆ°internalPostProcessorsé›†åˆä¸­,ä¹Ÿå°±æ˜¯è¿™é‡Œå…ˆä¸å¤„ç†.\n\t\tList<BeanPostProcessor> orderedPostProcessors = new ArrayList<>();\n\t\tfor (String ppName : orderedPostProcessorNames) {\n\t\t\tBeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\torderedPostProcessors.add(pp);\n\t\t\tif (pp instanceof MergedBeanDefinitionPostProcessor) {\n\t\t\t\tinternalPostProcessors.add(pp);\n\t\t\t}\n\t\t}\n//æ’åº,å¤„ç†ä¸Šé¢ä¸æ˜¯MergedBeanDefinitionPostProcessorçš„æˆ–å…¶å­ç±»,å¹¶ä¸”æ˜¯ orderedPostProcessorNamesé›†åˆä¸­çš„æ•°æ®\n\t\tsortPostProcessors(orderedPostProcessors, beanFactory);\n\t\tregisterBeanPostProcessors(beanFactory, orderedPostProcessors);\n\n\t\t// Now, register all regular BeanPostProcessors.\n//æœ€åå°±å¤„ç†æ—¢ä¸æ˜¯PriorityOrdered,ä¹Ÿä¸æ˜¯Orderedçš„,å¦‚æœä¹Ÿæ˜¯MergedBeanDefinitionPostProcessoræˆ–è€…å…¶å­ç±»çš„è¯,è¿™é‡Œä¹Ÿä¼šæ”¾å…¥åˆ°internalPostProcessorsé›†åˆä¸­ \n\t\tList<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<>();\n\t\tfor (String ppName : nonOrderedPostProcessorNames) {\n\t\t\tBeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\tnonOrderedPostProcessors.add(pp);\n\t\t\tif (pp instanceof MergedBeanDefinitionPostProcessor) {\n\t\t\t\tinternalPostProcessors.add(pp);\n\t\t\t}\n\t\t}\n//è¿™é‡Œå…ˆå¤„ç†nonOrderedPostProcessorNamesä¸­çš„æ•°æ®å¹¶ä¸”ä¸æ˜¯ MergedBeanDefinitionPostProcessorçš„å­ç±».\n\t\tregisterBeanPostProcessors(beanFactory, nonOrderedPostProcessors);\n\n\t\t// Finally, re-register all internal BeanPostProcessors.\n//æœ€åæ’åºä¸‹ MergedBeanDefinitionPostProcessorå­ç±»çš„é›†åˆ,è°ƒç”¨registerBeanPostProcessorsæ–¹æ³•,æ³¨å†Œåˆ°BeanFactoryä¸­å».   \n\t\tsortPostProcessors(internalPostProcessors, beanFactory);\n\t\tregisterBeanPostProcessors(beanFactory, internalPostProcessors);\n\n\t\t// Re-register post-processor for detecting inner beans as ApplicationListeners,\n\t\t// moving it to the end of the processor chain (for picking up proxies etc).\n//æœ€åæ·»åŠ ä¸€ä¸ªApplicationListenerDetectoråˆ°beanFactoryä¸­å»,å¹¶ä¸”ApplicationListenerDetectoræ˜¯æœ‰å®ç°MergedBeanDefinitionPostProcessoræ¥å£çš„.\n\t\tbeanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));\n\t}\n```\n\n#### refersh.initMessageSource() æ–¹æ³•\n\nè¿™ä¸ªæ–¹æ³•ä¸»è¦æ˜¯å¯¹ MESSAGE_SOURCE_BEAN_NAME æ˜¯å¦åœ¨beanFactoryä¸­è¿›è¡Œåˆ¤æ–­.å¦‚æœå·²ç»åœ¨äº†çš„è¯,å°±ä¼šåˆ¤æ–­æ˜¯ä¸æ˜¯HierarchicalMessageSourceç±»å‹,ç»§ç»­åˆ¤æ–­å…¶ParentMessageSourceæ˜¯ä¸æ˜¯null,å¦‚æœæ˜¯nullçš„è¯,å°±ä¼šgetInternalParentMessageSourceè°ƒç”¨åˆå§‹åŒ–è·å–ä¸€äº›å€¼ç»™èµ‹å€¼è¿›å».\n\nå¦‚æœbeanFactoryä¸­æ²¡æœ‰çš„è¯,å°±ä¼šå…ˆnewä¸€ä¸ª,ç„¶åä¹Ÿä¼šsetParentMessageSourceå€¼è¿›å»,æœ€åæ³¨å†Œåˆ°beanFactoryä¸­å».\n\n```java\n/**\n * Initialize the MessageSource.\n * Use parent's if none defined in this context.\n */\nprotected void initMessageSource() {\n  //å…ˆè·å–BeanFactory.  \n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n// beanFactoryä¸­åŒ…å«MESSAGE_SOURCE_BEAN_NAME\n   if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {\n //è·å–å‡ºå‡ºæ¥çš„beanèµ‹å€¼ç»™this.messageSource      \n      this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);\n      // Make MessageSource aware of parent MessageSource.\n//this.parentä¸æ˜¯nullå¹¶ä¸”beanæ˜¯HierarchicalMessageSource\n      if (this.parent != null && this.messageSource instanceof HierarchicalMessageSource) {\n        //å¼ºè½¬  \n         HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;\n  // hmsè·å–å‡ºæ¥çš„parentMessageSourceæ˜¯nullæƒ…å†µä¸‹,getInternalParentMessageSource()è¿”å›çš„å€¼èµ‹å€¼ç»™hmsçš„ParentMessageSourceå±æ€§  \n         if (hms.getParentMessageSource() == null) {\n            // Only set parent context as parent MessageSource if no parent MessageSource\n            // registered already.\n            hms.setParentMessageSource(getInternalParentMessageSource());\n         }\n      }\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"Using MessageSource [\" + this.messageSource + \"]\");\n      }\n   }\n// beanFactoryä¸­ä¸åŒ…å«MESSAGE_SOURCE_BEAN_NAME    \n   else {\n      // Use empty MessageSource to be able to accept getMessage calls.\n//è‡ªå·±newä¸€ä¸ªDelegatingMessageSource,dms    \n      DelegatingMessageSource dms = new DelegatingMessageSource();\n//è°ƒç”¨getInternalParentMessageSource()æ–¹æ³•çš„è¿”å›å€¼ç»™setè¿›å».  \n      dms.setParentMessageSource(getInternalParentMessageSource());\n      this.messageSource = dms;\n// æ³¨å…¥åˆ° beanFactroyä¸­å»       \n      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);\n// æ ¹æ®logçš„çº§åˆ«æ¥æ‰“å°.       \n      if (logger.isDebugEnabled()) {\n         logger.debug(\"Unable to locate MessageSource with name '\" + MESSAGE_SOURCE_BEAN_NAME +\n               \"': using default [\" + this.messageSource + \"]\");\n      }\n   }\n}\n```\n\n#### refresh.initApplicationEventMulticaster() æ–¹æ³•\n\nè¯¥æ–¹æ³•å¯ä»¥çœ‹åˆ°ä¹Ÿæ˜¯å¯¹APPLICATION_EVENT_MULTICASTER_BEAN_NAMEæ˜¯å¦åœ¨beançš„åˆ¤æ–­ï¼Œå¦‚æœæœ‰çš„è¯,å°±ä¼šgetå‡ºæ¥,æ²¡æœ‰çš„è¯,å°±ä¼šnewä¸€ä¸ªå‡ºæ¥,ç„¶åæ³¨å†Œåˆ°beanFactoryä¸­å».\n\n```java\n/**\n * Initialize the ApplicationEventMulticaster.\n * Uses SimpleApplicationEventMulticaster if none defined in the context.\n * @see org.springframework.context.event.SimpleApplicationEventMulticaster\n */\nprotected void initApplicationEventMulticaster() {\n // å…ˆè·å–beanFactory   \n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n //åˆ¤æ–­beanFactoryæ˜¯ä¸æ˜¯æœ‰APPLICATION_EVENT_MULTICASTER_BEAN_NAMEè¿™ä¸ªbean,\n //å¦‚æœæ˜¯æœ‰çš„è¯,å°±ä¼šè·å–å‡ºæ¥.ç„¶åè¿›è¡Œlogçš„çº§åˆ«,åˆ¤æ–­è¦ä¸è¦æ‰“å°\n   if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {\n      this.applicationEventMulticaster =\n            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"Using ApplicationEventMulticaster [\" + this.applicationEventMulticaster + \"]\");\n      }\n   }\n   else {\n //å¦‚æœbeanFactoryæ˜¯ä¸åŒ…å«çš„è¯,é‚£ä¹ˆä¹…newä¸€ä¸ªSimpleApplicationEventMulticasterå‡ºæ¥,\n //ç„¶åæ³¨å†Œåˆ°beanFactoryä¸­å»,æœ€åæ ¹æ®logçš„çº§åˆ«æ¥åˆ¤æ–­æ‰“å°\n  \n      this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);\n      beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"Unable to locate ApplicationEventMulticaster with name '\" +\n               APPLICATION_EVENT_MULTICASTER_BEAN_NAME +\n               \"': using default [\" + this.applicationEventMulticaster + \"]\");\n      }\n   }\n}\n```\n\n#### refresh.onRefresh() æ–¹æ³•\n\nè¯¥æ–¹æ³•æ—¶ç•™ç»™å­ç±»çš„ã€‚ å¦‚æœæ˜¯SpringBootå¯åŠ¨çš„è¯,è¿™é‡Œå°±ä¼šå»new Tomcat,ç„¶åå¯åŠ¨webç›¸åº”çš„ç¯å¢ƒ.\n\n```java\n/**\n * Template method which can be overridden to add context-specific refresh work.\n * Called on initialization of special beans, before instantiation of singletons.\n * <p>This implementation is empty.\n * @throws BeansException in case of errors\n * @see #refresh()\n */\nprotected void onRefresh() throws BeansException {\n   // For subclasses: do nothing by default.\n}\n```\n\n#### refresh.registerListeners() æ–¹æ³•\n\nè¯¥æ–¹æ³•æ˜¯å…ˆè·å– ApplicationListeners,å¦‚æœæ˜¯æœ‰å€¼çš„è¯,å°±ä¼šæ·»åŠ åˆ°AbstractApplicationEventMulticasterçš„ListenerRetrieverçš„applicationListenersé›†åˆä¸­å».\n\næ ¹æ®ApplicationListener.classè·å–å¯¹åº”çš„beanä¿¡æ¯,ç„¶åè¿­ä»£,æœ€åä¼šæ·»åŠ åˆ°AbstractApplicationEventMulticasterçš„ListenerRetrieverçš„applicationListenerBeanså±æ€§ä¸­å»\n\næœ€åæ˜¯å¯¹this.earlyApplicationEventsä¸­çš„äº‹ä»¶è¿›è¡Œå‘å¸ƒ\n\n```java\n/**\n * Add beans that implement ApplicationListener as listeners.\n * Doesn't affect other listeners, which can be added without being beans.\n */\nprotected void registerListeners() {\n   // Register statically specified listeners first.\n//getApplicationListeners()è·å–AbstractApplicationContextä¸­çš„applicationListeners\n//getApplicationEventMulticaster()æ–¹æ³•è·å–çš„applicationEventMulticaster,æ˜¯åœ¨\n//initApplicationEventMulticasteræ–¹æ³•ä¸­æœ‰åˆå§‹åŒ–çš„.    \n//org.springframework.context.event.AbstractApplicationEventMulticaster#addApplicationListener,æœ€åæ˜¯èµ°åˆ°äº†è¿™é‡Œ, \n//this.defaultRetriever.applicationListeners.add(listener);æœ€ålisteneræ˜¯æ·»åŠ åˆ°\n//å…¶å†…éƒ¨å†…ListenerRetrieverçš„applicationListenerså‚æ•°ä¸­å»äº†.    \n   for (ApplicationListener<?> listener : getApplicationListeners()) {\n      getApplicationEventMulticaster().addApplicationListener(listener);\n   }\n\n   // Do not initialize FactoryBeans here: We need to leave all regular beans\n   // uninitialized to let post-processors apply to them!\n//æ ¹æ®ApplicationListenerè·å–ç›¸åº”çš„beanNamesæ•°ç»„,è¿™é‡Œå¯ä»¥çœ‹åˆ°å’Œä¹‹å‰è·å–PostProcessoræ˜¯ä¸€æ ·çš„\n   String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);\n//ç„¶åè¿­ä»£, getApplicationListenerBeanæ˜¯èµ°åˆ°äº†\n//org.springframework.context.event.AbstractApplicationEventMulticaster#addApplicationListenerBean,ä¹Ÿå°±æ˜¯æ·»åŠ åˆ°äº†å…¶å†…éƒ¨ç±»ListenerRetrieverçš„applicationListenerBeanså±æ€§é‡Œé¢    \n   for (String listenerBeanName : listenerBeanNames) {\n      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);\n   }\n\n   // Publish early application events now that we finally have a multicaster...\n//ä½¿ç”¨this.earlyApplicationEventsçš„é›†åˆçš„å€¼,èµ‹å€¼ç»™å˜é‡earlyEventsToProcess,\n//ç„¶åç»™this.earlyApplicationEventsé‡ç½®ä¸ºnull   \n   Set<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;\n   this.earlyApplicationEvents = null;\n //é›†åˆä¸æ˜¯nullå¹¶ä¸”æ˜¯æœ‰å€¼çš„è¯,   \n   if (earlyEventsToProcess != null) {\n      for (ApplicationEvent earlyEvent : earlyEventsToProcess) {\n  //org.springframework.context.event.SimpleApplicationEventMulticaster#invokeListener,è¿™é‡Œæ˜¯èµ°åˆ°äº†è¿™é‡Œ,å¯ä»¥çœ‹åˆ°æ˜¯å¯¹è¿™ä¸ªäº‹ä»¶è¿›è¡Œå‘å¸ƒ.\n // ç„¶åä¼šæ ¹æ®ApplicationListenerå»èµ°onApplicationEventæ–¹æ³•         \n         getApplicationEventMulticaster().multicastEvent(earlyEvent);\n      }\n   }\n}\n```\n\n#### refresh.finishBeanFactoryInitialization() æ–¹æ³•\n\nè¯¥æ–¹æ³•ä»åå­—ä¸Šæ¥,å°±æ˜¯ç»“æŸbeanFactoryçš„åˆå§‹åŒ–,ä¹Ÿå°±æ˜¯æˆ‘ä»¬å‰é¢å‡†å¤‡çš„bd,postProcessorç­‰ä¿¡æ¯,åœ¨è¿™é‡Œéƒ½ä¼šä½¿ç”¨åˆ°çš„.\n\nå¯ä»¥çœ‹åˆ°è¯¥æ–¹æ³•å°±æ˜¯çœŸæ­£çš„å®ä¾‹åŒ–beançš„æ–¹æ³•ã€‚ å¤§è‡´å°±æ˜¯getBeanå¾€ä¸‹èµ°,getBeanå¦‚æœæ˜¯æ²¡æœ‰çš„è¯,å°±ä¼šèµ°createBean,ä¹Ÿå°±æ˜¯æ²¡æœ‰å°±å»åˆ›å»ºå˜›ï¼Œå°±æ˜¯è¿™ä¸ªæ„æ€ã€‚ç„¶åå…¶åˆ›å»ºçš„æ¡ä»¶,æ˜¯èµ°å„ç§beanPostProcessorsæ¥è¿›è¡Œæ‰©å±•bean.\n\nbeanFactory.preInstantiateSingletons() æ˜¯éœ€è¦å»é˜…è¯»å¾ˆå¤šéçš„. ä¸æ˜¯ä¸€éæˆ–è€…ç®€å•çš„å‡ éå°±okäº†çš„.\n\n```java\n/**\n * Finish the initialization of this context's bean factory,\n * initializing all remaining singleton beans.\n */\nprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n   // Initialize conversion service for this context.\n//å¦‚æœbeanFactoryåŒ…å«CONVERSION_SERVICE_BEAN_NAME,å¹¶ä¸”è¯¥CONVERSION_SERVICE_BEAN_NAMEæ˜¯\n//ConversionServiceçš„å­ç±»çš„è¯,ä¹…æ»¡è¶³æ¡ä»¶,ç„¶åå…ˆä»beanFactoryä¸­è·å–å‡ºbean,setç»™beanFactoryä¸­çš„conversionServiceå±æ€§    \n   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&\n         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {\n      beanFactory.setConversionService(\n            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));\n   }\n\n   // Register a default embedded value resolver if no bean post-processor\n   // (such as a PropertyPlaceholderConfigurer bean) registered any before:\n   // at this point, primarily for resolution in annotation attribute values.\n// beanFactoryä¸­æ²¡æœ‰EmbeddedValueResolver,ä¹Ÿå°±æ˜¯è¯¥æ–¹æ³•è¿”å›çš„æ˜¯false,ç„¶åå°±ä»environmentä¸­è·å–å‡ºæ¥ä¸€ä¸ªç»™addåˆ°beanFactoryä¸­å».    \n   if (!beanFactory.hasEmbeddedValueResolver()) {\n      beanFactory.addEmbeddedValueResolver(strVal -> getEnvironment().resolvePlaceholders(strVal));\n   }\n\n   // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.\n//æ ¹æ®LoadTimeWeaverAwareè·å–å‡ºå¯¹ç”¨çš„namesæ•°ç»„\n   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class,\n         false, false);\n\n//ç„¶åè¿­ä»£ä¸Šé¢è·å–å‡ºæ¥çš„æ•°ç»„,æŒ¨ä¸ªè°ƒç”¨getBeanæ–¹æ³•    \n   for (String weaverAwareName : weaverAwareNames) {      \n      getBean(weaverAwareName);\n   }\n\n   // Stop using the temporary ClassLoader for type matching.\n// tempClassLoader,tempçš„ClassLoaderè®¾ç½®ä¸ºnull    \n   beanFactory.setTempClassLoader(null);\n\n   // Allow for caching all bean definition metadata, not expecting further changes.\n//org.springframework.beans.factory.support.DefaultListableBeanFactory#freezeConfiguration,è¯¥æ–¹æ³•æ—¶èµ°çš„è¿™é‡Œ. å…¶ä¸­å¯ä»¥çœ‹åˆ°æ˜¯ç»™configurationFrozenè®¾ç½®ä¸ºtrue,ç„¶åbeanNameçš„é›†åˆè½¬åŒ–ä¸ºæ•°ç»„,å¹¶ä¸”èµ‹å€¼ç»™this.frozenBeanDefinitionNamesè¿™ä¸ªæ•°ç»„    \n   beanFactory.freezeConfiguration();\n\n   // Instantiate all remaining (non-lazy-init) singletons.\n//è¿™é‡Œé¢åˆå§‹åŒ–bean,ç®€å•è¯´ä¸€ä¸‹é€»è¾‘. org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String)\n//getBean() ---> doGetBean() --->   createBean() --->  doCreateBean() \n//ç„¶åå†createBeanå’ŒdoCreateBean()æ–¹æ³•ä¹‹ä¸­,ä¼šæ ¹æ®æ¡ä»¶ä¸Šé¢çš„,è·å–BeanPostProcessors,ç„¶ååˆ¤æ–­èµ°å“¦ä¸èµ°å…¶å„ç§BeanPostProceesorsæä¾›çš„æ–¹æ³•.æ»¡è¶³æ¡ä»¶å°±ä¼šèµ°,ä¸æ»¡è¶³ä¹Ÿå°±è‡ªç„¶ä¸ä¼šèµ°äº†.\n//å½“ç„¶äº†è¿™ä¸ªæ–¹æ³•çš„å¤æ‚ç¨‹åº¦æ˜¯æ¯”è¾ƒé«˜çš„ï¼Œæ˜¯éœ€è¦å¥½å¥½ç†è§£çš„ã€‚ä¸æ˜¯è¿™ä¸ªç®€ç®€å•å•çš„å‡ å¥è¯,è¿˜éœ€è¦è‡ªå·±å»è¯».\n//èµ·å¤§è‡´æ‰“ä»£ç èµ°å‘å°±æ˜¯è¿™æ ·,ç„¶åå…¶ä¸­ä¼šèµ°å¾ˆå¤šè°ƒç”¨beanæ‰©å±•çš„BeanPostProcessorsï¼Œè¿˜æœ‰å®ç°Init...æ¥å£åæä¾›çš„afterS...ç­‰æ–¹æ³•.    \n   beanFactory.preInstantiateSingletons();\n}\n```\n\n#### \n\n#### refresh.finishRefresh() æ–¹æ³•\n\nå¯ä»¥çœ‹åˆ°è¿™ä¸ªæ–¹æ³•æ˜¯æ¸…é™¤äº†èµ„æºç¼“å­˜, ç„¶å å®ç°Lifecycleæ¥å£çš„å­ç±»,è¿™é‡Œå°±ä¼šå¯åŠ¨å…¶startæ–¹æ³•\n\nå‘é€ä¸€ä¸ªContextRefreshedEventäº‹ä»¶å‡ºå»\n\næœ€åå°†å½“å‰çš„ AbstractApplicationContext æ·»åŠ åˆ° LiveBeansViewçš„applicationContextsé›†åˆä¸­æ¥\n\n```java\n/**\n * Finish the refresh of this context, invoking the LifecycleProcessor's\n * onRefresh() method and publishing the\n * {@link org.springframework.context.event.ContextRefreshedEvent}.\n */\nprotected void finishRefresh() {\n   // Clear context-level resource caches (such as ASM metadata from scanning).\n  //æ¸…é™¤èµ„æºç¼“å­˜  \n   clearResourceCaches();\n\n   // Initialize lifecycle processor for this context.\n// è¿™ä¸ªæ–¹æ³•å°±ä¼šè°ƒç”¨å®ç°äº† Lifecycle æ¥å£çš„å­ç±»,å¹¶ä¸”æ‰§è¡Œå…¶startæ–¹æ³•    \n   initLifecycleProcessor();\n\n   // Propagate refresh to lifecycle processor first.\n   getLifecycleProcessor().onRefresh();\n\n   // Publish the final event.\n //å‘é€ä¸€ä¸ªåˆ·æ–°ä¸Šä¸‹æ–‡çš„Eventå‡ºå»   \n   publishEvent(new ContextRefreshedEvent(this));\n\n   // Participate in LiveBeansView MBean, if active.\n//org.springframework.context.support.LiveBeansView#applicationContexts\n//å°†AbstractApplicationContextæ·»åŠ åˆ°liveBeançš„applicationContextsé›†åˆä¸­    \n   LiveBeansView.registerApplicationContext(this);\n}\n```\n\n#### refresh.resetCommonCaches()\n\nå¯ä»¥çœ‹åˆ°è¿™ä¸ªæ–¹æ³•æ‰æ˜¯çœŸæ­£çš„æ¸…é™¤å„ç§é›†åˆç¼“å­˜å•¥çš„æ“ä½œ. æ˜¯åœ¨finallyä»£ç å¿«ä¸­,ä¹Ÿå°±æ˜¯è¯´æ˜¯å¿…é¡»è¦æ‰§è¡Œçš„ä»£ç \n\n```java\n/**\n * Reset Spring's common reflection metadata caches, in particular the\n * {@link ReflectionUtils}, {@link AnnotationUtils}, {@link ResolvableType}\n * and {@link CachedIntrospectionResults} caches.\n * @since 4.2\n * @see ReflectionUtils#clearCache()\n * @see AnnotationUtils#clearCache()\n * @see ResolvableType#clearCache()\n * @see CachedIntrospectionResults#clearClassLoader(ClassLoader)\n */\nprotected void resetCommonCaches() {\n   ReflectionUtils.clearCache();\n   AnnotationUtils.clearCache();\n   ResolvableType.clearCache();\n   CachedIntrospectionResults.clearClassLoader(getClassLoader());\n}\n```\n\n","tags":["java","spring"],"categories":["java","spring"]},{"title":"springåˆå§‹åŒ–(ä¸€)","url":"/2021/11/04/spring/springåˆå§‹åŒ–-ä¸€/","content":"\n\n\n#### é˜…è¯»æ–¹æ³•\n\næœ€ç®€å•çš„é˜…è¯»æ–¹æ³•,å°±æ˜¯åˆ›å»ºä¸€ä¸ªmavené¡¹ç›®,è®©å¼•å…¥Springçš„ä¾èµ–. ç„¶åå†™ä¸Šä¸€ä¸ªmainæ–¹æ³•,æ¥è¯»å–åŒ…ä¸‹çš„å†…å®¹,ç„¶åå†™ä¸€ä¸ªbean,å³å¯. è¿™ä¸ªbeanè¦åœ¨ä½ æ‰«æçš„åŒ…ä¸‹. äºæ˜¯æˆ‘ä»¬ç›´æ¥åœ¨newçš„åœ°æ–¹æ‰“ä¸Šæ–­ç‚¹è·Ÿè¿›å»å³å¯.\n\n```java\n<dependencies>\n\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.2.0.RELEASE</version>\n    </dependency>\n\n</dependencies>\npublic class SpringStartMain {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(\"com.iyang.spring\");\n        YangBeanOne yangBeanOne = context.getBean(YangBeanOne.class);\n        System.out.println(yangBeanOne.getClass().toString());\n    }\n}\n```\n\nè¿˜æœ‰ä¸€ç§å°±æ˜¯ä½ å»githubä¸Šcloneä¸€ä¸ªSpringçš„æºç ,ç„¶åå€’å…¥idea,å½“ç„¶ä½ éœ€è¦gradleç¯å¢ƒæ¥æ„å»º.ç„¶åæˆåŠŸçš„buildä¸€ä¸‹, å¦‚æœæˆåŠŸäº†çš„è¯,å°±åœ¨æºç çš„ç›®å½•åˆ›å»ºä¸€ä¸ªæ¨¡å—(xé¡¹ç›®),ç„¶ååƒä¸Šé¢ä¸€æ ·ã€‚è¿™æ ·åšçš„å¥½å¤„æ˜¯,ä½ å¯ä»¥éšä¾¿ä¿®æ”¹æºç çš„ä»£ç , ä½ è§‰å¾—å®ƒçš„å“ªä¸ªåœ°æ–¹çš„ä»£ç å†™åˆ°ä¸å¤Ÿå¥½çš„è¯,ä¹Ÿæ˜¯å¯ä»¥å»ä¿®æ”¹çš„.\n\n#### Debugé˜…è¯»\n\nå¼€å§‹debugè¿›è¡Œä»£ç çš„é˜…è¯» :\n\ndebugå°±ä¼šè¿›å…¥åˆ°è¿™ä¸ªæ„é€ å‡½æ•°ä¸­, è¿™é‡Œæˆ‘ä»¬å…ˆå¯¹ this() å’Œ scan(basePackages) è¿™äºŒä¸ªæ–¹æ³•è¿›è¡Œé˜…è¯», refresh()é‡Œé¢æ¶‰åŠåˆ°å†…å®¹æ¯”è¾ƒå¤š(BeanPostprocess,Aware,eventç­‰),ä¸æ˜¯ä¸€ä¸‹å­å°±èƒ½çœ‹æ˜ç™½çš„,æ˜¯éœ€è¦å¤§é‡çš„æ—¶é—´å»ä»”ç»†é˜…è¯»çš„.\n\n```java\n/**\n * Create a new AnnotationConfigApplicationContext, scanning for components\n * in the given packages, registering bean definitions for those components,\n * and automatically refreshing the context.\n * @param basePackages the packages to scan for component classes\n */\npublic AnnotationConfigApplicationContext(String... basePackages) {\n   this();\n   scan(basePackages);\n   refresh();\n}\n```\n\nthis () æ–¹æ³•\n\nå¯ä»¥çœ‹åˆ°thisæ–¹æ³•,åŸºæœ¬æ˜¯åœ¨åšä¸€äº›å¯¹ç¯å¢ƒåˆå§‹åŒ–çš„æ“ä½œ.\n\n```java\n/**\n * Create a new AnnotationConfigApplicationContext that needs to be populated\n * through {@link #register} calls and then manually {@linkplain #refresh refreshed}.\n åŒæ—¶è¿˜ä¼šèµ°åˆ° : org.springframework.context.support.GenericApplicationContext#GenericApplicationContext()è¿™ä¸ªæ–¹æ³•é‡Œé¢æ¥.  this.beanFactory = new DefaultListableBeanFactory(); å¯ä»¥çœ‹åˆ°è¿™é‡Œæ˜¯newäº†ä¸€ä¸ªbeanFactoryçš„,ä¹Ÿå°±æ˜¯æˆ‘ä»¬åé¢çš„refresh()æ–¹æ³•,å¯ä»¥çœ‹åˆ°DefaultListableBeanFactroyè¿™ä¸ªç±».\n å†å¾€çˆ¶ç±»èµ° : org.springframework.context.support.AbstractApplicationContext#AbstractApplicationContext()å°±ä¼šèµ°åˆ°è¿™ä¸ªç±»çš„è¿™ä¸ªæ–¹æ³•æ¥, this.resourcePatternResolver = getResourcePatternResolver(); è¿™é‡Œå¯ä»¥çœ‹åˆ°æ˜¯åˆå§‹åŒ–äº† resourcePatternResolver.å½“ç„¶äº†,è‚¯å®šè¿˜æœ‰ä¸€äº›newçš„å…¨å±€å˜é‡çš„åˆå§‹åŒ–ä¹Ÿä¼šè¿›è¡Œåˆå§‹åŒ–çš„.\n \n \n */\npublic AnnotationConfigApplicationContext() {\n   this.reader = new AnnotatedBeanDefinitionReader(this);\n//è¿™ä¸ªæ–¹æ³•å¯¹registry,environmentå’ŒresourceLoaderè¿›è¡Œèµ‹å€¼,ç„¶åæ ¹æ®filteræ˜¯true,æ·»åŠ äº†ä¸‰ä¸ªfilterè¿‡æ»¤å™¨.å¯ä»¥çœ‹åˆ°è¿™ä¸ªæ–¹æ³•è™½ç„¶å¸¦äº†scanneråå­—,ä½†æ˜¯çœ‹æ¯ä¸ªèµ°çš„æ–¹æ³•,å¥½åƒæ˜¯æ²¡æœ‰æ‰«æä»»ä½•ä¸œè¥¿,éƒ½æ˜¯å¯¹å…¨å±€å‚æ•°è¿›è¡Œèµ‹å€¼ç­‰æ“ä½œ.\n   this.scanner = new ClassPathBeanDefinitionScanner(this);\n}\n\n---------------------------------\n\n\t/**\n\t * Create a new {@code AnnotatedBeanDefinitionReader} for the given registry.\n\t * <p>If the registry is {@link EnvironmentCapable}, e.g. is an {@code ApplicationContext},\n\t * the {@link Environment} will be inherited, otherwise a new\n\t * {@link StandardEnvironment} will be created and used.\n\t * @param registry the {@code BeanFactory} to load bean definitions into,\n\t * in the form of a {@code BeanDefinitionRegistry}\n\t * @see #AnnotatedBeanDefinitionReader(BeanDefinitionRegistry, Environment)\n\t * @see #setEnvironment(Environment)\nè¿™é‡Œå¯ä»¥çœ‹åˆ°ä¼ å…¥è¿›æ¥çš„registryæ˜¯ this,ä¹Ÿå°±æ˜¯ä¼ å…¥äº†AnnotationConfigApplicationContextå®ƒè‡ªå·±. \n\nå¯ä»¥çœ‹åˆ°è¿™ä¸ªæ–¹æ³•ä¸»è¦åšçš„äº‹æƒ…æ˜¯,åˆå§‹åŒ–Environment,ç„¶ånewä¸€ä¸ªConditionEvaluatorå¯¹è±¡,å…¶ä¿å­˜äº†äº”ä¸ªä¿¡æ¯. æœ€åå°±åˆ†åˆ«æ·»åŠ äº”ä¸ª Processoråˆ°beanFactroyçš„beanDefinitionMapä¸­æ¥.\n\t */\n\tpublic AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) {\n        // getOrCreateEnvironment()æ–¹æ³•,å…ˆå¯¹registryè¿›è¡Œénullçš„åˆ¤æ–­,å¦‚æœæ˜¯Nullçš„è¯,å°±ä¼šæŠ›å‡ºå¯¹åº”çš„å¼‚å¸¸.æœ€åæ˜¯new StandardEnvironment()äº†ä¸€ä¸ªå¯¹è±¡è¿”å›æ¥. registryæ˜¯æ»¡è¶³EnvironmentCapable\n// this()æ–¹æ³•:å…ˆå¯¹ä¼ å…¥è¿›æ¥çš„registryå’Œenvironemntè¿›è¡Œénullçš„åˆ¤æ–­.this.registry = registry; ç´§ç€newäº†ä¸€ä¸ªConditionEvaluatorå¯¹è±¡,å…¶æ„é€ å‡½æ•°ä¸­,åˆå§‹åŒ–äº†registry,beanFactory,environment,resourceLoaderå’ŒclassLoaderè¿™äº”ä¸ªå‚æ•°,æ˜¯åœ¨å†…éƒ¨ç±»ConditionContextImplä¸­. æœ€åå¾€beanFactoryçš„beanDefinitionMapä¸­æ·»åŠ äº†äº”ä¸ªå€¼,åˆ†åˆ«æ˜¯:\n//org.springframework.context.annotation.internalConfigurationAnnotationProcessor\n//org.springframework.context.annotation.internalAutowiredAnnotationProcessor\n//org.springframework.context.annotation.internalCommonAnnotationProcessor\n//org.springframework.context.event.internalEventListenerProcessor\n//org.springframework.context.event.internalEventListenerFactory  \n//æ·»åŠ å®Œ,new AnnotatedBeanDefinitionReader()è¿™ä¸ªæ–¹æ³•å°±èµ°å®Œäº†.        \n\t\tthis(registry, getOrCreateEnvironment(registry));\n\t}\n\n----------------------------------\n\t/**\n\t * Create a new {@code ClassPathBeanDefinitionScanner} for the given bean factory.\n\t * @param registry the {@code BeanFactory} to load bean definitions into, in the form\n\t * of a {@code BeanDefinitionRegistry}\n\t */\n\tpublic ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry) {\n\t\tthis(registry, true);\n\t}\n\n// \n\tpublic ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters) {\n//è¿™é‡Œä¹Ÿæœ‰getOrCreateEnvironment()æ–¹æ³•æ¥è·å–ç¯å¢ƒ,åœ¨ä¸Šä¸€æ­¥å·²ç»åšäº†,æ‰€ä»¥è¿™æ­¥æ˜¯ç›´æ¥è·å–ä¸Šä¸€æ­¥çš„ç»“æœå³å¯.      \n\t\tthis(registry, useDefaultFilters, getOrCreateEnvironment(registry));\n\t}\n\n// å…ˆå¯¹ä¼ å…¥è¿›æ¥çš„ registry è¿›è¡Œénullçš„åˆ¤æ–­,\n\tpublic ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters,\n\t\t\tEnvironment environment, @Nullable ResourceLoader resourceLoader) {\n\n\t\tAssert.notNull(registry, \"BeanDefinitionRegistry must not be null\");\n\t\tthis.registry = registry;\n\t\t// è¿™é‡Œä¼ å…¥çš„æ˜¯ture,ä¹Ÿå°±æ˜¯ä¼šèµ°åˆ°è¿™ä¸ªifé‡Œé¢æ¥.\n\t\tif (useDefaultFilters) {\n//org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#registerDefaultFilters, å¾€includeFilters é›†åˆä¸­æ·»åŠ Filter,è¿™äº›æ·»åŠ çš„filter,ç‚¹è¿›å»çœ‹å³å¯.            \n\t\t\tregisterDefaultFilters();\n\t\t}\n// this.environmentèµ‹ä¸Šä¼ å…¥è¿›æ¥çš„environmentå€¼.        \n\t\tsetEnvironment(environment);\n// org.springframework.core.io.support.ResourcePatternUtils#getResourcePatternResolverè¿›è¡Œåˆ¤æ–­,è¿™é‡Œç”±äºæ˜¯ResourcePatternResolver,æ‰€ä»¥åœ¨ç¬¬ä¸€ä¸ªifå°±è¿”å›äº†.\n//æ¥ç€newä¸€ä¸ªCachingMetadataReaderFactory,ä¼ å…¥è¿›å»resourceLoader,newè¿™ä¸ªç±»çš„å†…éƒ¨ä¹Ÿæ˜¯å¯ä»¥çœ‹,å°±æ˜¯å¯¹å‚æ•°è¿›è¡Œèµ‹å€¼,å¹¶æ²¡æœ‰åšå…¶ä»–çš„ä»€ä¹ˆäº‹æƒ…äº†.      \n//this.componentsIndex = CandidateComponentsIndexLoader.loadIndex(this.resourcePatternResolver.getClassLoader());è·å–å‡ºæ¥çš„å€¼Null.        \n\t\tsetResourceLoader(resourceLoader);\n\t}\n```\n\nscan(basePackages) æ–¹æ³•\n\n```java\n// å¯¹ä¼ å…¥è¿›æ¥çš„å‚æ•°è¿›è¡Œä¸€ä¸ªæ ¡éªŒ.\n//scannerä¹Ÿæ˜¯ä¸Šé¢é‚£æ­¥this.scanner = new ClassPathBeanDefinitionScanner(this)ç»™newå‡ºæ¥çš„.\npublic void scan(String... basePackages) {\n   Assert.notEmpty(basePackages, \"At least one base package must be specified\");\n   this.scanner.scan(basePackages);\n}\n\n/**\n* Perform a scan within the specified base packages.\n* @param basePackages the packages to check for annotated classes\n* @return number of beans registered\n*/\npublic int scan(String... basePackages) {\n// org.springframework.beans.factory.support.DefaultListableBeanFactory#getBeanDefinitionCount èµ°åˆ°è¿™æ­¥æ¥è·å–ä¸ªæ•°,è¿˜è®°å¾—new AnnotatedBeanDefinitionReader(this)è¿™ä¸ªæ–¹æ³•é‡Œé¢æ·»åŠ äº†äº”ä¸ªprocessorå—?æ‰€ä»¥è¿™é‡Œè·å–å‡ºæ¥çš„beanCountAtScanStartå¤§å°å°±æ˜¯5(é»˜è®¤å¯¹åˆå§‹åŒ–åšä»»ä½•æ”¹åŠ¨çš„æƒ…å†µä¸‹).\n\tint beanCountAtScanStart = this.registry.getBeanDefinitionCount();\n//ä»åå­—ä¸Šçœ‹,è¿™ä¸ªæ–¹æ³•æ˜¯çœŸæ­£çš„åšæ‰«æçš„.å…¶å®Springä¸­,scanéƒ½ç®—ä¸åšäº‹çš„,doScanæ‰æ˜¯çœŸçš„åšäº‹çš„ã€‚åˆ°åé¢è¿˜æœ‰getBeanä¸æ˜¯åšäº‹çš„,doGetBeanæ‰æ˜¯åšäº‹çš„,createBeanä¹Ÿæ˜¯çš„. \n//doScanåšçš„äº‹æƒ…å¯ä»¥çœ‹åˆ°,è¯»å–åŒ…ä¸‹çš„ç±»,ç„¶åæ ¹æ®filteræ¡ä»¶æ¥è¿‡æ»¤,æ»¡è¶³æ¡ä»¶çš„è¯,å°±ä¼šå°è£…æˆScannedGenericBeanDefinition,æœ€åæ˜¯ä¸€ä¸ªé›†åˆåŒ…è£…çš„è¯¥åŒ…ä¸‹å…¨éƒ¨æ»¡è¶³æ¡ä»¶çš„. ç„¶åå°±æ˜¯æ¥ç€å¯¹ sbdè¿›è¡Œæ³¨è§£çš„å¤„ç†,æ¯”å¦‚æœ‰äº›æ‰“å…¥äº†Lazyç­‰æ³¨è§£çš„,éƒ½è¦è¯»å–å‡ºæ¥,å­˜å…¥bdçš„ä¿¡æ¯ä¸­.æœ€åå†æ£€æŸ¥ä¸€édb,å¦‚æœæ²¡é—®é¢˜çš„è¯,å°±ä¼šæ ¹æ®beanNameå’Œbd,newä¸€ä¸ªBeanDefinitionHolderå‡ºæ¥,æœ€åæ³¨å†Œåˆ°beanFactoryä¸­å»,ä¹Ÿå°±æ˜¯æ”¾å…¥BeanFactoryçš„beanDeifitionMapä¸­å».    \n\tdoScan(basePackages);\n\t// Register annotation config processors, if necessary.\n\tif (this.includeAnnotationConfig) {\n// å…ˆè·å–å‡ºbeanFactory,å…ˆè°ƒç”¨beanFactoryçš„getDependencyComparatorå’ŒgetAutowireCandidateResolveræ–¹æ³•,å¦‚æœæ»¡è¶³æ¡ä»¶çš„è¯,å°±ä¼šæœ‰å¯¹åº”çš„setæ–¹æ³•.ç„¶åç´§æ¥ç€å°±æ˜¯åˆ¤æ–­beanFactoryä¸­æ˜¯å¦åŒ…å«ä¸€äº›bd,å¦‚æœæ˜¯ä¸åŒ…å«çš„è¯,è¿™é‡Œå°±ä¼šæ·»åŠ è¿›å». è¿™é‡Œåˆ¤æ–­çš„å€¼,å†æœ€åˆnew reader()çš„æ—¶å€™å·²ç»æœ‰æ·»åŠ åˆ°BeanFactoryçš„beanDifitionMapä¸­å».        \n\t\tAnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);\n\t}\n    // è¿™é‡Œè¿”å›intå‚æ•°,ä½†æ˜¯ this.scanner.scan(basePackages); å¥½åƒå¹¶æ²¡æœ‰ä½¿ç”¨åˆ°è¿”å›å€¼.\n\treturn (this.registry.getBeanDefinitionCount() - beanCountAtScanStart);\n}\n\n/**\n* Perform a scan within the specified base packages,\n* returning the registered bean definitions.\n* <p>This method does <i>not</i> register an annotation config processor\n* but rather leaves this up to the caller.\n* @param basePackages the packages to check for annotated classes\n* @return set of beans registered if any for tooling registration purposes (never {@code null})\n\t */\nprotected Set<BeanDefinitionHolder> doScan(String... basePackages) {\n    // å…ˆæ˜¯å¯¹ä¼ å…¥è¿›æ¥çš„å‚æ•°è¿›è¡Œæ£€éªŒ.\n\tAssert.notEmpty(basePackages, \"At least one base package must be specified\");\n    // å­˜BeanDefinitionHolderçš„é›†åˆ,ä¹Ÿæ˜¯æœ€åè¦è¿”å›çš„.\n\tSet<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();\n\tfor (String basePackage : basePackages) {\n//æ ¹æ®ä¼ å…¥è¿›å»çš„åŒ…åå­—,è¯»å–å‡ºåŒ…åå­—ä¸‹çš„æ‰€æœ‰æ–‡ä»¶,ç„¶åè¿­ä»£è¿™äº›æ–‡ä»¶,è¿™äº›æ–‡ä»¶è¦æœ‰èƒ½è¯»çš„æƒé™,å†èµ°isCandidateComponent(metadataReader)è¿™ä¸ªæ–¹æ³•,å…¶ä¸­å°±æœ‰ä½¿ç”¨ excludeFilterså’ŒincludeFilters,è¿™äºŒä¸ªfilteræ¥è¿‡æ»¤è¿›è¡Œä¸€äº›åˆ¤æ–­æ“ä½œ. è¿”å›ture,å°±ä¼šå¾€ä¸‹èµ°,newä¸€ä¸ªScannedGenericBeanDefinition,å…¶ä¸­beanClasså°±æ˜¯è¿™ä¸ªç±»çš„å…¨é™å®šåå­—.æ¯”å¦‚è¿™é‡Œ(com.iyang.spring.bean.YangBeanOne),æˆ‘ä»¬çš„æ˜¯è¿™ä¸ª.\n//è¿™å°±æ˜¯è¿™ä¸ªæ–¹æ³•,æ‰«æ,ç„¶åæ ¹æ®ç‰¹å®šfilter,å¦‚æœæ˜¯æ»¡è¶³æ¡ä»¶çš„è¯,å°±ä¼šnewä¸€ä¸ªsbd,ç„¶åæ”¾å…¥Seté›†åˆä¸­,è¿”å›. \n\t\tSet<BeanDefinition> candidates = findCandidateComponents(basePackage);\n        \n\t\tfor (BeanDefinition candidate : candidates) {\n//org.springframework.context.annotation.AnnotationScopeMetadataResolver#resolveScopeMetadata,èµ°çš„è¿™ä¸ªæ–¹æ³•,å› AnnotationConfigUtils.attributesFor(...)æ–¹æ³•è¿”å›çš„æ˜¯null,æ‰€ä»¥è¿™ä¸ªé‡Œé¢å°±ä»…ä»…åªæ˜¯newäº†ä¸€ä¸ªScopeMetadataå¯¹è±¡è¿”å›äº†           \n\t\t\tScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);\n//scopeçš„å€¼æ˜¯singletone.è¿™ä¸å°±æ˜¯æˆ‘ä»¬ç†Ÿæ‚‰çš„å•ä¾‹å˜›.            \n\t\t\tcandidate.setScope(scopeMetadata.getScopeName());\n//è·å–å‡ºè¿™ä¸ªbeançš„åå­—            \n\t\t\tString beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);\n// dbæ˜¯ AbstractBeanDefinitionçš„è¯,è¿™é‡Œè‚¯å®šæ˜¯,ä»AbstractBeanDefinitionè¿™ä¸ªåå­—ä¸Šçœ‹,æ˜¯ä¸€ä¸ªæŠ½è±¡çš„ï¼Œä¹Ÿå°±æ˜¯åº”è¯¥æ˜¯çˆ¶ç±».            \n\t\t\tif (candidate instanceof AbstractBeanDefinition) {\n//beanDefinition.applyDefaults(this.beanDefinitionDefaults)è¯¥æ–¹æ³•æ˜¯å¯¹ä¸€äº›å‚æ•°è¿›è¡Œèµ‹å€¼æ“ä½œ. \n//                \n\t\t\t\tpostProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);\n\t\t\t}\n// bdæ˜¯AnnotatedBeanDefinitionæˆ–è€…å…¶å­ç±».            \n\t\t\tif (candidate instanceof AnnotatedBeanDefinition) {\n// è¯¥æ–¹æ˜¯å¯¹bdçš„Lazy.calss,Primary.class,DependsOn.class,Role.class,Description.classè¿™äº›æ³¨è§£è¿›è¡Œè·å–,å¦‚æœæœ‰çš„è¯,å°±ä¼šè°ƒç”¨bdå¯¹åº”çš„setæ–¹æ³•ç»™å€¼setè¿›å». å½“ç„¶æˆ‘ä»¬è¿™é‡Œçš„beanæ²¡æœ‰è¿™äº›å±æ€§.è¿™é‡Œå¯è‡ªè¡ŒåŠ å…¥ä¸€äº›æ³¨å…¥,ç„¶ådebugåˆ°è¿™ä¸ªåœ°æ–¹è¿›è¡Œçœ‹.\n                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);\n\t\t\t\t}\n// æ£€æŸ¥registryä¸­æ˜¯å¦å«æœ‰è¿™ä¸ªbeanName,å¦‚æœæ²¡åŒ…å«çš„è¯,å°±ç›´æ¥è¿”å›ture.            \n\t\t\tif (checkCandidate(beanName, candidate)) {\n// ä¼ å…¥beanå’ŒbeanName, newä¸€ä¸ªbeançš„Holderå‡ºæ¥,ä¹Ÿå°±æ˜¯beançš„æŒæœ‰è€…çš„æ„æ€.å…¶å®ä¸ªäººè§‰å¾—è¿™é‡Œæ˜¯å¯¹beanè¿›è¡Œä¸€å±‚å°è£…,Holderæ›´æŠ½è±¡åœ°ç†è§£ç‚¹.                \n\t\t\t\tBeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);\n//scopeMetadataä¸­è·å–å‡ºgetScopedProxyMode,å¦‚æœæ˜¯Noçš„è¯,å°±ç›´æ¥è¿”å›definitionHolder         \n\t\t\t\tdefinitionHolder =\n\t\t\t\t\t\t\tAnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);\n// æ·»åŠ åˆ°æœ€å¤–å±‚çš„é›†åˆä¸­                \n\t\t\t\tbeanDefinitions.add(definitionHolder);\n//org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition,æœ€åèµ°åˆ°äº†è¿™é‡Œ,è¯¥æ–¹æ³•ä¼šå…ˆå¯¹ä¼ å…¥è¿›æ¥çš„å‚æ•°è¿›è¡Œénullçš„åˆ¤æ–­,å¦‚æœbdæ˜¯AbstractBeanDefinitionçš„è¯,å°±ä¼šå¼ºè½¬è°ƒç”¨å…¶validate()æ–¹æ³•,è¿›è¡Œæ£€éªŒ. åœ¨ä»this.beanDefinitionMapä¸­è·å–,æ ¹æ®beanName,ç¬¬ä¸€æ¬¡è‚¯å®šæ˜¯è·å–ä¸åˆ°çš„,èµ°åˆ°else.elseä¸­åœ¨åˆ¤æ–­hasBeanCreationStarted(),è¿™é‡Œè¿”å›çš„æ˜¯flase,ä¹Ÿå°±æ˜¯èµ°åˆ°äº†elseçš„elseä¸­å»äº†,æ ¹æ®beanNameå’Œbeanå­˜å…¥åˆ°this.beanDefinitionMapä¸­,ç„¶åbeanNameæ·»åŠ åˆ°beanDefinitionNamesé›†åˆä¸­.  è¿™å°±æ˜¯è¿™æ­¥æ ¹æ®beanNameå’Œbeanæ”¾å…¥beanFactoryçš„beanDefinitionMapé›†åˆä¸­.               \n\t\t\t\tregisterBeanDefinition(definitionHolder, this.registry);\n\t\t\t}\n\t\t}\n\t}\n\treturn beanDefinitions;\n}\n```\n\n#### æ€»ç»“\n\n- this() æ–¹æ³• : è¯¥æ–¹æ³•ä¸­ä¸»è¦æ˜¯åˆå§‹åŒ–äº† this.reader å’Œ this.scannerè¿™ä¸ªå‚æ•°,å½“ç„¶äº†,å…¶ä¸­è¿˜æœ‰ä¸€äº›ç¯å¢ƒç­‰ä¿¡æ¯ çš„åˆå§‹åŒ–. this.readerçš„æ—¶å€™,æ˜¯æœ‰å¾€beanFactroyä¸­æ·»åŠ äº”ä¸ªé»˜è®¤è¦æ·»åŠ çš„bd,ä¹Ÿå°±æ˜¯æ·»åŠ åˆ°äº† BeanFactoryçš„BeanDefitionMapä¸­. this.scanner ä¹Ÿæ˜¯å¯¹ä¸€äº›ç¯å¢ƒç­‰ä¿¡æ¯åˆå§‹åŒ– , ç„¶åä¸‹æ¥æ¥çš„æ–¹æ³•å°±æ˜¯ä½¿ç”¨ this.scanneræ¥è¿›æ‰«æ class,ç„¶åæ»¡è¶³æ¡ä»¶çš„,å°±å°è£…æˆbd,æ³¨å†Œåˆ°beanFactoryä¸­å».\n- register() æ–¹æ³•é‡Œé¢è°ƒç”¨ this.reader.register(componentClasses); è¯¥æ–¹æ³•å°±æ˜¯è¯»å–åŒ…ä¸‹çš„classä¿¡æ¯,ç„¶åæ»¡è¶³æ¡ä»¶çš„å°±å°è£…æˆbd,åŒæ—¶è¿˜ä¼šå¯¹æ³¨è§£@Lazyç­‰ä¹Ÿä¼šè¯»å–,å¦‚æœæ˜¯æœ‰è¿™äº›æ³¨è§£çš„è¯,å°±ä¼šè°ƒç”¨bdå¯¹åº”çš„setæ–¹æ³•,ç»™èµ‹å€¼è¿›å»,æœ€åå°†bdç»™æ³¨å†Œåˆ°BeanFactoryçš„beanDefitionMapä¸­å»å³å¯.\n\nå¯ä»¥çœ‹åˆ° this() æ–¹æ³• å’Œ register()æ–¹æ³•,ä¸»è¦æ˜¯å¯¹ç¯å¢ƒçš„åˆå§‹åŒ–å’Œæ ¹æ®ä¼ å…¥è¿›æ¥çš„åŒ…åæ¥è¿›è¡Œæ‰«æè·å–classä¿¡æ¯,æ»¡è¶³æ¡ä»¶çš„classä¿¡æ¯å°±ä¼šè½¬åŒ–ä¸ºbd,ç„¶åæ³¨å†Œåˆ°beanFactoryä¸­å».\n","tags":["java","spring"],"categories":["java","spring"]},{"title":"ThreadLocalæºç é˜…è¯»","url":"/2021/11/04/java/ThreadLocalæºç é˜…è¯»/","content":"\n\n\nThreadLocal æ˜¯æ¥è¿™ä¸ªå…¬å¸æœ‰è¿‡ä½¿ç”¨ä¸€æ¬¡çš„æ„Ÿå—,æ‰€ä»¥å°±å­¦ä¹ é˜…è¯»ä¸‹æºç ã€‚ å…¶å®Thread è¿™ä¸ªé‡Œé¢,å°±æœ‰ä¸€ä¸ª Map(è¿™é‡Œæ˜¯ç”¨ThreadLocalå†…éƒ¨ç±»ä¸­å®ç°çš„) , é‡Œé¢çš„keyå°±æ˜¯ ThreadLocal, value å°±æ˜¯å­˜å‚¨çš„å€¼,æ‰€ä»¥ä¸€ä¸ªThreadæ˜¯æœ‰å¤šä¸ª ThreadLocalã€‚\n\n------\n\n#### å‚æ•°\n\nå‚æ•°éƒ¨åˆ†\n\n```\nprivate final int threadLocalHashCode = nextHashCode();\n\n/**\n * The next hash code to be given out. Updated atomically. Starts at\n * zero.\n   AtomicInteger æ˜¯ä¸€ä¸ªçº¿ç¨‹å®‰å…¨çš„,å®ç°åŸç†æ˜¯é‡‡ç”¨äº†cas.\t\n */\nprivate static AtomicInteger nextHashCode =\n    new AtomicInteger();\n```\n\n#### æ–¹æ³•\n\nset èµ‹å€¼\n\n```\n/**\n*\té¦–å…ˆè·å–å½“å‰çº¿ç¨‹.\n\tè°ƒç”¨ getMap æ–¹æ³•, ç›´æ¥è°ƒç”¨ t.trheadLocalsæ¥è·å– ThreadLocalMapã€‚(ThreadLocalMapè¿™é‡Œæ˜¯ThreadLocalå†…éƒ¨è‡ªå·±å®ç°çš„ç±»)\n\tå¦‚æœmapä¸æ˜¯nullçš„è¯,å°±è¿›è¡Œsetå€¼,è¿™é‡Œå¯ä»¥çœ‹åˆ° set çš„keyæ˜¯this,ä¹Ÿå°±æ˜¯ThreadLocalå®ƒè‡ªå·±.\n\tå¦åˆ™å°±æ˜¯è°ƒç”¨createMapæ–¹æ³•,èµ°è¿™ä¸ªæ–¹æ³•æ˜¯å¯ä»¥ç¡®è®¤ currentThreadä¸­çš„threadLocalsçš„å€¼æ˜¯null,æ‰€ä»¥ç›´æ¥newäº†ä¸€ä¸ªè¿›è¡Œèµ‹å€¼å³å¯.\n*/\npublic void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\n\nThreadLocalMap getMap(Thread t) {\n        return t.threadLocals;\n}\n\nvoid createMap(Thread t, T firstValue) {\n        t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n```\n\n#### Get æ–¹æ³•\n\nget æ–¹æ³•,è·å–å€¼.\n\n```\n/**\n\tè¿™é‡Œå¯ä»¥çœ‹åˆ°,è·å–ThreadLocalMap,å¦‚æœThreadLocalMapçš„æ˜¯nullçš„è¯,å°±ä¼šèµ°setInitialValueæ–¹æ³•ã€‚\n\tå¦‚æœæœ‰å€¼çš„è¯,å°±ä¼šè¿›è¡Œè·å–å€¼å¹¶ä¸”è¿”å›.\n*/\npublic T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    return setInitialValue();\n}\n\n/**\n\tå¦‚æœè·å–å‡ºæ¥çš„ThreadLocalMap ä¸æ˜¯nullçš„è¯,å°±ä¼šè¿›è¡Œset,è¿™ä¸ªæ—¶å€™setè¿›å»çš„å€¼,valueå°±æ˜¯nulläº†.\n\tå¦‚æœè·å–å‡ºæ¥æ˜¯nulld\n*/\nprivate T setInitialValue() {\n        T value = initialValue();\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n        return value;\n}\n\nprotected T initialValue() {\n        return null;\n}\n```\n\n#### remove æ–¹æ³•\n\nremove æ–¹æ³•å°±æ˜¯è·å–map,å¦‚æœmapä¸æ˜¯nullçš„è¯,å°±è°ƒç”¨m.remove(this)ï¼Œæ ¹æ®å½“å‰thisæ¥åˆ é™¤.\n\n```\npublic void remove() {\n    ThreadLocalMap m = getMap(Thread.currentThread());\n    if (m != null)\n        m.remove(this);\n}\n```\n\n------\n\n#### æ€»ç»“\n\nThreadLocalé‡Œé¢çš„æ–¹æ³•ä¹Ÿæ¯”è¾ƒå°‘,è¿˜æ˜¯æ¯”è¾ƒå¥½ç†è§£çš„ã€‚åªè¦å¼„æ¸…æ¥šThreadLocalå’ŒThreadæ˜¯æ€ä¹ˆåœ¨å­˜å‚¨çš„,å°±å¾ˆå¥½çš„ç†è§£äº†ã€‚\n\næ³¨æ„ : ä½¿ç”¨ThreadLocalä¸€å®šè¦è¿›è¡Œremove,å¦åˆ™å®¹æ˜“å‡ºç°å†…å­˜æ³„æ¼ï¼Œä»è€Œå¯¼è‡´å†…å­˜æº¢å‡ºã€‚\n","tags":["java","javaçº¿ç¨‹"],"categories":["java","javaçº¿ç¨‹"]},{"title":"ReentrantLockæºç é˜…è¯»","url":"/2021/11/04/java/ReentrantLockæºç é˜…è¯»/","content":"\n#### ä»‹ç»\n\n ReetrantLock æ•ˆæœæ˜¯å’Œ synchronized æ˜¯ä¸€æ ·çš„,åªä¸è¿‡ synchronized æ˜¯å†…ç½®é”,ReetrantLockæ˜¯è¯­æ³•çº§åˆ«çš„é”, ç›¸å¯¹äºè€Œè¨€æ˜¯æ¯”synchronizedçµæ´»æ€§é«˜äº›. ä¸è¿‡ä»æˆ‘ç›®å‰å…¬å¸å†™ä»£ç è§’åº¦æ¥çœ‹,éƒ½æ˜¯ç›´æ¥ä½¿ç”¨ synchronized . ä½†æ˜¯ä¸å¦¨ç¢æˆ‘ä»¬æ¥çœ‹ ReetrantLock é‡Œé¢çš„ä»£ç å®ç°.\n\n ä½¿ç”¨ä»£ç  : æœ‰lockæ–¹æ³•å°±ä¸€å®šè¦æœ‰ unlockæ–¹æ³•æ¥é‡Šæ”¾é”. ä¸€èˆ¬ä»£ç ä¸­è¿™æ ·å†™å³å¯.\n\n```\npublic class ReentrantLockCaseMain {\n\n    private ReentrantLock lock = new ReentrantLock();\n\n\n    public void lockUseCase(){\n\n        lock.lock();\n        try {\n            System.out.println(\"æ‰§è¡Œä¸šåŠ¡ä»£ç é€»è¾‘\");\n        }finally {\n            lock.unlock();\n        }\n\n\n    }\n\n}\n```\n\n#### ä»£ç åˆ†æ\n\n ReetrantLock ä¸­æ˜¯æ²¡æœ‰ä»€ä¹ˆå…¨å±€å‚æ•°,ç›¸æ¯”äºé›†åˆ,å°±æ²¡æœ‰é‚£ä¹ˆå¤šå…¨å±€å‚æ•°.ä½†æ˜¯æˆ‘ä»¬è¦çœ‹å…¶é‡Œé¢çš„å†…,è¿™é‡Œæœ‰ä¸‰ä¸ªç±», Sync , NonfairSync , FairSync. NonfairSyncå’ŒFairSync éƒ½æ˜¯æœ‰ç»§æ‰¿ Sync. å¯ä»¥çœ‹åˆ°NonfairSync æ˜¯éå…¬å¹³é” , FairSyncæ˜¯å…¬å¹³é”.\n\n Sync åˆé›†æˆ AQS, ä½¿ç”¨ç‹¬å é”, é‡å†™äº† tryRelease æ–¹æ³•.\n\n- æ„é€ å‡½æ•°: é»˜è®¤æ˜¯ä½¿ç”¨çš„éå…¬å¹³é”,å¦‚æœä¼ å…¥è¿›æ¥çš„æ˜¯trueå°±ä¼šä½¿ç”¨å…¬å¹³é”,å¦åˆ™å°±ä¼šä½¿ç”¨éå…¬å¹³é”.\n\n  ```\n   /**\n   * Creates an instance of {@code ReentrantLock}.\n   * This is equivalent to using {@code ReentrantLock(false)}.\n   */\n  public ReentrantLock() {\n      sync = new NonfairSync();\n  }\n  \n  /**\n   * Creates an instance of {@code ReentrantLock} with the\n   * given fairness policy.\n   *\n   * @param fair {@code true} if this lock should use a fair ordering policy\n   */\n  public ReentrantLock(boolean fair) {\n      sync = fair ? new FairSync() : new NonfairSync();\n  }\n  ```\n\n- lock æ–¹æ³•: lockæ–¹æ³•æ˜¯åŠ é”çš„æ–¹æ³•\n\n  lockæ–¹æ³•æ˜¯è°ƒç”¨çš„ Sync çš„lockæ–¹æ³•, ç„¶åæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä¸Šé”çš„æ—¶å€™,èµ°çš„Sync,ç„¶åæ ¹æ®FairSync/NonfairSyncå–èµ°å„è‡ªçš„åŠ é”æ–¹æ³•,æ‰€ä»¥è¯´å…¬å¹³é”å’Œéå…¬å¹³é”æ˜¯åŠ é”çš„æ–¹å¼æ˜¯ä¸ä¸€æ ·çš„.\n\néå…¬å¹³é”è·å–é”çš„æ—¶å€™,ä¼šè·å–stateè¿™ä¸ªçŠ¶æ€æ ‡è¯†,ç„¶åå†å»èµ°å¯¹åº”çš„é€»è¾‘,è¿™é‡Œå¤šäº†æ¯”éå…¬å¹³é”å¤šäº†ä¸€ä¸ªä»é˜Ÿåˆ—ä¸­è·å–ä¿¡æ¯å’Œä¸èƒ½è·å–é”çš„çº¿ç¨‹å°±ä¼šè¢«æŒ‚èµ·è¿›å…¥é˜Ÿåˆ—ä¸­æ’é˜Ÿ.\n\n```\npublic void lock() {    sync.lock();}\n\n// Sync \nabstract void lock();\n\n\n    /**\n    * å…¬å¹³é”\n     * Sync object for fair locks\n     */\ntatic final class FairSync extends Sync {\n        private static final long serialVersionUID = -3000897897090466540L;\n\n    \t/* \n    \tacquire(1) è°ƒç”¨åˆ°AQSä¸­,æœ€åè¿˜æ˜¯è°ƒç”¨åˆ°ä¸‹é¢çš„tryAcquireæ–¹æ³•.\n    \té‚£äº›æ²¡æœ‰è·å–åˆ°é”çš„çº¿ç¨‹,å°±ä¼šæŒ‰ç…§é˜Ÿåˆ—çš„æ–¹å¼æ’é˜Ÿ,æ»¡è¶³å…ˆè¿›å…ˆå‡ºçš„æ•ˆæœçš„,ä¹Ÿå°±æ˜¯å…ˆæ¥çš„çº¿ç¨‹å…ˆæ‰§è¡Œ,\n    \tæœç„¶è¿™å°±å¾ˆå…¬å¹³\n    \t**/\n        final void lock() {\n            acquire(1);\n        }\n\n        /**\n         * Fair version of tryAcquire.  Don't grant access unless\n         * recursive call or no waiters or is first.\n         */\n        protected final boolean tryAcquire(int acquires) {\n            final Thread current = Thread.currentThread();\n            int c = getState();\n            if (c == 0) {\n                /**\n                \thasQueuedPredecessors() æ–¹æ³•,å…ˆåˆ¤æ–­å¤´ç»“ç‚¹å’Œå°¾ç»“ç‚¹æ˜¯ä¸ç›¸ç­‰çš„,å› ä¸ºç›¸ç­‰çš„è¯,å°±é‡å¤äº†,å°±æ˜¯åŒä¸€ä¸ª. ç„¶ååœ¨åˆ¤æ–­å¤´ç»“ç‚¹çš„ threadæ˜¯ä¸æ˜¯å½“å‰çº¿ç¨‹,å¦‚æœä¸æ˜¯å½“å‰çš„å‰ç¨‹çš„è¯,é‚£ä¹ˆå°±æ˜¯åœ¨è¿™ä¸ªçº¿ç¨‹é’±é¢è¿˜æœ‰ä¸€ä¸ªç­‰å¾…è·å–é”æ—¶é—´æ›´ä¹…çš„çº¿ç¨‹,äºæ˜¯å°±å…ˆæŠ›å¼ƒè¿™ä¸ªçº¿ç¨‹,å»æ‰§è¡Œé‚£ä¸ªç­‰å¾…æ›´ä¹…çš„çº¿ç¨‹.\n                \t\n                \tcompareAndSetState å°±æ˜¯ç”¨casæ¥è·å–é”çš„ä»£ç ,å¦‚æœè·å–æˆåŠŸçš„è¯,å°±ä¼šèµ°setExclusiveOwnerThreadæ–¹æ³•,è¿™é‡Œsetè¿›å»çš„å€¼æ˜¯åœ¨é‡Šæ”¾é”çš„æ—¶å€™ä¼šç”¨åˆ°.\n                \tæœ€åè¿”å›true,è¯´æ˜è·å–é”æˆåŠŸäº†.\n                */\n                if (!hasQueuedPredecessors() &&\n                    compareAndSetState(0, acquires)) {\n                    setExclusiveOwnerThread(current);\n                    return true;\n                }\n            }\n            /**\n            \tè·å–ä»setExclusiveOwnerThreadé‡Œé¢çš„thread,æ¥åˆ¤æ–­æ˜¯å¦ä¸å½“å‰çº¿ç¨‹ç›¸ç­‰,å¦‚æœç›¸ç­‰çš„è¯,å°±è¯´æ˜é‡å…¥äº†.\n            */\n            else if (current == getExclusiveOwnerThread()) {\n                int nextc = c + acquires;\n                if (nextc < 0)\n                    throw new Error(\"Maximum lock count exceeded\");\n                setState(nextc);\n                return true;\n            }\n            return false;\n        }ä¹‹å‰\n}\n\npublic final boolean hasQueuedPredecessors() {\n        // The correctness of this depends on head being initialized\n        // before tail and on head.next being accurate if the current\n        // thread is first in queue.\n        Node t = tail; // Read fields in reverse initialization order\n        Node h = head;\n        Node s;\n        return h != t &&\n            ((s = h.next) == null || s.thread != Thread.currentThread());\n}\n\n/**\n\téå…¬å¹³é”:\n*/\nstatic final class NonfairSync extends Sync {\n        private static final long serialVersionUID = 7316153563782823691L;\n\n        /**\n         * Performs lock.  Try immediate barge, backing up to normal\n         * acquire on failure.\n         å¯ä»¥çœ‹åˆ°éå…¬å¹³é”æ˜¯æ²¡æœ‰ä»é˜Ÿåˆ—ä¸­è·å–è¯´æ˜ç»“ç‚¹ä¿¡æ¯,è€Œæ˜¯ç›´æ¥è·å–é”çš„.\n         è·å–æˆåŠŸäº†å°±ä¼šèµ° setExclusiveOwnerThread æ–¹æ³•\n         */\n        final void lock() {\n            if (compareAndSetState(0, 1))\n                setExclusiveOwnerThread(Thread.currentThread());\n            else\n                acquire(1);\n        }\n\n        protected final boolean tryAcquire(int acquires) {\n            return nonfairTryAcquire(acquires);\n        }\n}\n\n/**\n\tSyncç±»ä¸­\n\tè¿™æ®µä»£ç çš„é€»è¾‘ä¹Ÿæ˜¯å’Œ å…¬å¹³é”åæ¥çš„å¤„ç†ä¸€æ ·çš„äº†. cå¦‚æœæ˜¯0çš„è¯,å°±ä¼šèµ°è·å–é”çš„ä»£ç ,å¦‚æœä¸æ˜¯0çš„è¯,å°±è¯´æ˜é‡å…¥äº†,æ‰€ä»¥å°±++\n*/\nfinal boolean nonfairTryAcquire(int acquires) {\n            final Thread current = Thread.currentThread();\n            int c = getState();\n            if (c == 0) {\n                if (compareAndSetState(0, acquires)) {\n                    setExclusiveOwnerThread(current);\n                    return true;\n                }\n            }\n            else if (current == getExclusiveOwnerThread()) {\n                int nextc = c + acquires;\n                if (nextc < 0) // overflow\n                    throw new Error(\"Maximum lock count exceeded\");\n                setState(nextc);\n                return true;\n            }\n            return false;\n}\n```\n\nunlockæ–¹æ³•: unlockæ˜¯é‡Šæ”¾é”çš„æ–¹æ³•. å¯ä»¥çœ‹åˆ°é‡Šæ”¾é”æ˜¯èµ°çš„ Syncçš„releaseæ–¹æ³•,æ‰€ä»¥ä¸ç®¡å…¬å¹³é”è¿˜æ˜¯éå…¬å¹³é”èµ·èµ°çš„é‡Šæ”¾é”æ–¹æ³•æ˜¯ä¸ä¸€æ ·çš„.\n\n```\npublic void unlock() {    sync.release(1);}  \n\n/**\n\tSync ä¸­æ–¹æ³•. \n*/\npublic final boolean release(int arg) {\n        // tryRelease()æ–¹æ³•è¿”å›trueçš„è¯,å°±è¯´æ˜é”éƒ½é‡Šæ”¾å®Œäº†.\n        \n        if (tryRelease(arg)) {\n            Node h = head;\n            // æ¢å¤çº¿ç¨‹\n            if (h != null && h.waitStatus != 0)\n                unparkSuccessor(h);\n            return true;\n        }\n        return false;\n}\n\n\nprotected final boolean tryRelease(int releases) {\n            // é‡Šæ”¾é”\n            int c = getState() - releases;\n            // å¦‚æœå½“å‰çº¿ç¨‹ä¸æ˜¯è‡ªå·±çš„è¯,å°±ä¼šæŠ›å‡ºå¼‚å¸¸.è¿™é‡Œå¯ä»¥ç†è§£ä¸º,ç‹¬å é”,è‚¯å®šæ˜¯è‡ªå·±.\n            // ä¹Ÿå°±æ˜¯è¯´,å¦‚æœä¸æ˜¯ç‹¬å é”çš„è¯,å°±ä¼šæŠ›å‡ºå¼‚å¸¸.\n            if (Thread.currentThread() != getExclusiveOwnerThread())\n                throw new IllegalMonitorStateException();\n            boolean free = false;\n            // å¦‚æœä½ è°ƒç”¨äº†ä¸€æ¬¡lockçš„è¯,é‚£ä¹ˆä¼šåŠ ä¸€,æ‰€ä»¥è¿™ä¸ªåœ°æ–¹è¦ç­‰è¿™ä¸ªlockæ–¹æ³•å…¨éƒ¨è¢«é‡Šæ”¾æ‰.\n    \t\t// ä¹Ÿå°±æ˜¯ç”±äºé‡å…¥é”çš„åŸå› .\n            if (c == 0) {\n                free = true;\n                // é‡Šæ”¾å®Œäº†,å°±è®¾ç½®äº†null.  \n                // ç„¶åAbstractOwnableSynchronizerä¸­çš„threadæ ‡è®°ä¹Ÿå°±æ˜¯null,\n                // æ‰€ä»¥ä¸‹ä¸ªçº¿ç¨‹åˆ¤æ–­æ˜¯nullçš„è¯,å°±å¯ä»¥è·å–åˆ°æ‰§è¡Œæƒ,ä¹Ÿå°±æ˜¯è·å–åˆ°é”.\n                setExclusiveOwnerThread(null);\n            }\n            setState(c);\n            return free;\n}\n```\n\n\n\n- isLocked () æ–¹æ³•, åˆ¤æ–­è¿™ä¸ªçº¿ç¨‹æ˜¯ä¸æ˜¯è¢«é”äº†:\n\n  è°ƒç”¨Syncä¸­isLockæ–¹æ³•,å¦‚æœä¸æ˜¯0çš„è¯,å°±è¯´æ˜æ˜¯è¢«é”äº†,å¦‚æœæ˜¯0çš„è¯,å°±è¯´æ˜æ²¡æœ‰è¢«é”.\n\n  ```java\n      /**\n       * Queries if this lock is held by any thread. This method is\n       * designed for use in monitoring of the system state,\n       * not for synchronization control.\n       *\n       * @return {@code true} if any thread holds this lock and\n       *         {@code false} otherwise\n       */\n      public boolean isLocked() {\n          return sync.isLocked();\n      }\n      \n   final boolean isLocked() {\n              return getState() != 0;\n  }\n  ```\n\nhasQueuedThreads() : æ˜¯å¦æœ‰çº¿ç¨‹åœ¨ç­‰å¾…é˜Ÿåˆ—ä¸­\n\nhasQueuedThread(Thread thread) : çº¿ç¨‹æ˜¯å¦åœ¨ç­‰å¾…é˜Ÿåˆ—ä¸­\n\ngetQueueLength() : è·å–é˜Ÿåˆ—ä¸­çº¿ç¨‹ä¸ªæ•°\n\nç­‰è¿™äº›æ–¹æ³•éƒ½æ˜¯æ¯”è¾ƒå¥½ç†è§£çš„,å¯ä»¥è‡ªè¡Œç‚¹è¿›å»ä»”ç»†çœ‹ä¸‹.\n\n#### æ€»ç»“\n\n```\n Sync  /  NonfairSync  /  FairSync  è¿™ä¸ªä¸‰ä¸ªç±»å°±æ˜¯ ReetrantLockä¸­çš„ä¸‰ä¸ªç±»,éƒ½æ˜¯å›´ç»•è¿™è¿™ä¸‰ä¸ªç±»åœ¨åšæ–‡ç« .\n\nå…¬å¹³é”å’Œéå…¬å¹³é”çš„è·å–é”æ–¹å¼ä¸ä¸€æ ·,ä½†æ˜¯é‡Šæ”¾æ–¹å¼æ˜¯ä¸€æ ·çš„. å…¬å¹³é”è·å–é”çš„æ—¶å€™,å¦‚æœæœ‰çº¿ç¨‹æŒæœ‰äº†çš„è¯\n```\n","tags":["java","javaçº¿ç¨‹"],"categories":["java","javaçº¿ç¨‹"]},{"title":"PriorityQueueæºç é˜…è¯»è®°å½•","url":"/2021/11/04/java/PriorityQueueæºç é˜…è¯»è®°å½•/","content":"\nPriorityQueue : ä¸­æ–‡æ˜¯ä¼˜å…ˆé˜Ÿåˆ— , é˜Ÿåˆ—çš„ç‰¹ç‚¹å°±æ˜¯æ•°æ® å…ˆè¿›å…ˆå‡º, ä½†æ˜¯è¿™ä¸ªä¼˜å…ˆé˜Ÿåˆ—çš„ç‰¹åˆ«æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ é¦–å…ˆè‚¯å®šæ˜¯æœ‰é˜Ÿåˆ—çš„åŸºæœ¬ç‰¹ç‚¹ï¼Œä¹Ÿå°±æ˜¯æœ‰å…ˆè¿›å…ˆå‡ºã€‚ å¦‚æœæ˜¯å…ˆè¿›å…ˆå‡ºçš„è¯,é‚£ä¹ˆå°±å’Œæ™®é€šçš„æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿä¼˜å…ˆäºŒå­—åˆæ˜¯ä½“ç°åœ¨ä»€ä¹ˆåœ°æ–¹å‘¢ï¼Ÿ ä¼˜å…ˆçº§é˜Ÿåˆ—çš„å…ƒç´ æŒ‰ç…§å…¶è‡ªç„¶é¡ºåºè¿›è¡Œæ’åº, æˆ–è€…æ ¹æ® æ„é€ é˜Ÿåˆ—æ—¶æä¾›çš„ Comparator è¿›è¡Œæ’åº.\n\n------\n\n#### ç»“æ„\n\n ç»“æ„å°±æ˜¯ PriorityQueueè¿™ä¸ªç±»çš„ å…¨å±€å˜é‡å‚æ•°, å› ä¸ºè¿™äº›å‚æ•°æ˜¯å­˜å‚¨æ•°æ®çš„, æ‰€ä»¥åªè¦ç†è§£äº†è¿™äº›å‚æ•°,å°±æ˜ç™½äº†è¿™ä¸ª PriorityQueueè¿™ä¸ªæ˜¯å¯¹æ•°æ®æ˜¯æ€ä¹ˆæ ·è¿›è¡Œå­˜å‚¨çš„, è¿˜æ˜¯æ¯”è¾ƒå¥½ç†è§£çš„.\n\nè¿™é‡Œå¯ä»¥çœ‹åˆ° priorityQueueçš„æ•°æ®ç»“æ„è¿˜æ˜¯å¾ˆç®€å•çš„, ä¸€çœ¼æ‰«è¿‡å»æ²¡ä»€ä¹ˆéœ€è¦ç‰¹åˆ«çš„ç†è§£\n\n```\n// å­˜å‚¨æ•°æ®çš„æ•°ç»„\ntransient Object[] queue;\n\n// è®°å½• priorityQueueçš„é•¿åº¦\nprivate int size = 0;\n\n// è¿™ä¸ªå°±æ˜¯ä¹‹å‰è¯´æåˆ°çš„  å¯ä»¥æ ¹æ® Comparator è¿›è¡Œæ’åº\nprivate final Comparator<? super E> comparator;\n```\n\n------\n\n#### æ„é€ æ–¹æ³•\n\n priorityQueueçš„æ„é€ æ–¹æ³•ç›¸å¯¹äºå…¶ä»–çš„é›†åˆçš„æ„é€ æ–¹æ³•å¯èƒ½æ˜¯æ¯”è¾ƒå¤šçš„.\n\n\n\n è¿™é‡Œåˆ—ä¸¾å‡ºæ¥, å¯ä»¥çœ‹åˆ°æ„é€ æ–¹æ³•è¿˜æ˜¯æ¯”è¾ƒå¤šçš„.\n\n å¯¹æ„é€ å‡½æ•°çš„åˆå§‹åŒ–èµ‹å€¼ç­‰æ“ä½œè¿˜æ˜¯å¾ˆå¥½ç†è§£çš„,å¹¶æ²¡æœ‰ä»€ä¹ˆç‰¹åˆ«éš¾ç†è§£çš„ã€‚ ä¸»è¦è¿˜æ˜¯å¯¹æ•°ç»„/é•¿åº¦/æˆ–è€…ä¼ å…¥è¿›æ¥çš„æ•°ç»„è¿›è¡Œèµ‹å€¼æ“ä½œ.\n\n```\n// 1   \n// è¿™é‡Œæ˜¯èµ°åˆ° 4 çš„æ„é€ æ–¹æ³•å»äº†\npublic PriorityQueue() {\n    this(DEFAULT_INITIAL_CAPACITY, null);\n}\n\n// 2\n// è¿™é‡Œæ˜¯èµ°åˆ° 4 çš„æ„é€ æ–¹æ³•å»äº†\npublic PriorityQueue(int initialCapacity) {\n        this(initialCapacity, null);\n}\n\n// 3\n// è¿™é‡Œæ˜¯èµ°åˆ° 4 çš„æ„é€ æ–¹æ³•å»äº†\npublic PriorityQueue(Comparator<? super E> comparator) {\n        this(DEFAULT_INITIAL_CAPACITY, comparator);\n}\n\n// 4 \n/**  å¯ä»¥çœ‹åˆ°å‰é¢çš„ä¸‰ä¸ªéƒ½æ˜¯èµ°åˆ°äº†è¿™é‡Œæ¥äº†,\n\t é•¿åº¦å¦‚æœæ˜¯å°äº1çš„è¯,å°±ä¼šæŠ¥é”™.  \n     this.queue çš„æ•°ç»„é•¿åº¦å°±æ˜¯ initialCapacity\n     comparator æ’åºæ–¹æ³•å°±æ˜¯ä¼ å…¥è¿›æ¥çš„\n*/\npublic PriorityQueue(int initialCapacity,\n                         Comparator<? super E> comparator) {\n        // Note: This restriction of at least one is not actually needed,\n        // but continues for 1.5 compatibility\n        if (initialCapacity < 1)\n            throw new IllegalArgumentException();\n        this.queue = new Object[initialCapacity];\n        this.comparator = comparator;\n}\n\n// 5\n/**  å¯¹ä¼ å…¥è¿›æ¥çš„é›†åˆè¿›è¡Œåˆ¤æ–­. åˆ†ä¸º   SortedSet  æˆ–è€…  PriorityQueue  æˆ–è€…å…¶ä»–\n     å¦‚æœæ˜¯ SortedSet çš„è¯, å¯¹ comparator çš„å€¼èµ‹å€¼ä¸º ä¼ å…¥è¿›æ¥é›†åˆçš„æ’åºæ–¹å¼,ç„¶åèµ° initElementsFromCollection() æ–¹æ³•, è¿™é‡Œåº”è¯¥æ˜¯å¯¹é›†åˆè¿›è¡Œèµ‹å€¼æ“ä½œ.\n     å¦‚æœæ˜¯ PriorityQueue , comparator å¤„ç†æ–¹å¼æ˜¯å’Œ SortedSetä¸€æ ·,ç„¶åèµ° initFromPriorityQueue æ–¹æ³•. \n     å¦åˆ™å°±ä¸ä¸Šé¢çš„äºŒç§, comparator å¤ç½®ä¸º null ,èµ° initFromCollection æ–¹æ³•.\n     è¿™é‡Œæ€»ç»“çš„è¯,å°±æ˜¯ä¼ å…¥è¿›æ¥ä¸åŒçš„é›†åˆ,èµ°çš„æ–¹æ³•ä¹Ÿæ˜¯ä¸ä¸€æ ·çš„,è¿™ä¸ªè¿˜æ˜¯å¾ˆå¥½ç†è§£çš„.\n\t\n*/\npublic PriorityQueue(Collection<? extends E> c) {\n        if (c instanceof SortedSet<?>) {\n            SortedSet<? extends E> ss = (SortedSet<? extends E>) c;\n            this.comparator = (Comparator<? super E>) ss.comparator();\n            initElementsFromCollection(ss);\n        }\n        else if (c instanceof PriorityQueue<?>) {\n            PriorityQueue<? extends E> pq = (PriorityQueue<? extends E>) c;\n            this.comparator = (Comparator<? super E>) pq.comparator();\n            initFromPriorityQueue(pq);\n        }\n        else {\n            this.comparator = null;\n            initFromCollection(c);\n        }\n}\n\n// 6  è¿™ä¸ªå¯¹åº”ä¸Šé¢çš„, å¦‚æœæ˜¯ä¼ å…¥è¿›æ¥ PriorityQueue çš„å¤„ç†æ–¹æ³•\npublic PriorityQueue(PriorityQueue<? extends E> c) {\n        this.comparator = (Comparator<? super E>) c.comparator();\n        initFromPriorityQueue(c);\n}\n\n// 7  è¿™ä¸ªä¹Ÿæ˜¯å¯¹åº”ä¸Šé¢çš„ SortedSet å¤„ç†æ–¹æ³•\npublic PriorityQueue(SortedSet<? extends E> c) {\n        this.comparator = (Comparator<? super E>) c.comparator();\n        initElementsFromCollection(c);\n}\n\n----------------------   åä¸½åˆ†å‰²çº¿   --------------------\nä¸Šé¢çš„if else é‡Œé¢æåˆ°çš„èµ°ä¸åŒçš„æ–¹æ³•,è¿˜æ˜¯æœ‰å¿…è¦å–çœ‹çœ‹çš„. \n    \n/**\n  å¯¹ä¼ å…¥è¿›æ¥æ˜¯  PriorityQueue  è¿›è¡Œå¤„ç†, å…ˆåˆ¤æ–­ç¡®è®¤ classæ˜¯PriorityQueue ,æ˜¯çš„è¯,è°ƒç”¨toArray() å°†æ•°ç»„èµ‹å€¼ç»™ queue , å¹¶ä¸”é•¿åº¦ä¹Ÿè¿›è¡Œå¤ç½®ç»™size.\n  å¦åˆ™å°±èµ°  initFromCollection æ–¹æ³•, è¿™ä¸ª if else è¿˜æ˜¯æ¯”è¾ƒä¸¥è°¨çš„.è¿›è¡Œå¤šæ¬¡åˆ¤æ–­å¤„ç†\n*/    \nprivate void initFromPriorityQueue(PriorityQueue<? extends E> c) {\n        if (c.getClass() == PriorityQueue.class) {\n            this.queue = c.toArray();\n            this.size = c.size();\n        } else {\n            initFromCollection(c);\n        }\n}    \n\n/**\n   è¿™ä¸ªå¯¹ä¼ å…¥è¿›æ¥çš„é›†åˆ, å°†å€¼è½¬åŒ–ä¸º æ•°ç»„a (Object []), å¦‚æœ comparatorä¸æ˜¯nullçš„è¯,å°±ä¼šæ ¹æ®comparatoræ¥è¿›è¡Œæ’åº. ä¹Ÿå°±æ˜¯å¯¹aè¿›è¡Œæ’åº,å¹¶ä¸”è¿™ä¸ªçš„å€¼ä¸å¯ä»¥ä¸ºnullçš„,å¦‚æœå‡ºç°äº†nullçš„è¯,å°±ä¼šæœ‰ç©ºæŒ‡é’ˆçš„å¼‚å¸¸å‡ºç°.\n   ç„¶åå°†æ•°ç»„aèµ‹å€¼ç»™queue,é•¿åº¦ä¹Ÿæ˜¯è°ƒç”¨ a.length å¤ç½®ç»™size\n*/\nprivate void initElementsFromCollection(Collection<? extends E> c) {\n        Object[] a = c.toArray();\n        // If c.toArray incorrectly doesn't return Object[], copy it.\n        if (a.getClass() != Object[].class)\n            a = Arrays.copyOf(a, a.length, Object[].class);\n        int len = a.length;\n        if (len == 1 || this.comparator != null)\n            for (int i = 0; i < len; i++)\n                if (a[i] == null)\n                    throw new NullPointerException();\n        this.queue = a;\n        this.size = a.length;\n}\t\n\n/**\n å¯ä»¥çœ‹åˆ°è¿™ä¸ªæ–¹æ³•æ˜¯èµ°äº†  initElementsFromCollection è¿™ä¸ªæ–¹æ³•, ç„¶åå†èµ° headify æ–¹æ³•\n*/\nprivate void initFromCollection(Collection<? extends E> c) {\n        initElementsFromCollection(c);\n        heapify();\n}\n```\n\n------\n\n#### æ–¹æ³•\n\n æ·»åŠ å…ƒç´ æ–¹æ³• ï¼š\n\n\n\n```\npublic boolean add(E e) {\n    return offer(e);\n}\n\n/**\n\tè¿™é‡Œå¯ä»¥çœ‹åˆ°,å¦‚æœå€¼æ˜¯nullçš„è¯,å°±ä¼šæŠ›å‡ºNPEçš„å¼‚å¸¸.\n\tå¦‚æœsizeçš„å¤§å°æ¯” queueæ•°ç»„çš„é•¿åº¦è¿˜å¤§çš„è¯,å°±ä¼šè¿›è¡Œæ‰©å®¹.\n\tç„¶åsizeé•¿åº¦+1,å¦‚ä½•iæ˜¯0çš„è¯,å°±è¯´æ˜æ˜¯ç¬¬ä¸€ä¸ªå…ƒç´ ,ä¸éœ€è¦ä»»ä½•æ‹å¯»å¤„ç†,ç›´æ¥èµ‹å€¼ç»™ç¬¬ä¸€ä¸ªå³å¯.\n\tå¦‚æœä¸æ˜¯ç¬¬ä¸€ä¸ªçš„è¯,å°±ä¼šèµ°siftUpæ–¹æ³•\n*/\npublic boolean offer(E e) {\n        if (e == null)\n            throw new NullPointerException();\n        modCount++;\n        int i = size;\n        if (i >= queue.length)\n            grow(i + 1);\n        size = i + 1;\n        if (i == 0)\n            queue[0] = e;\n        else\n            siftUp(i, e);\n        return true;\n}\n\n/**\n\tå¦‚æœ comparatoræ˜¯nullçš„è¯,å°±èµ°  siftUpUsingComparator æ–¹æ³•.\n\tå¦åˆ™å°±ä¼šèµ° siftUpComparable æ–¹æ³•\n*/\nprivate void siftUp(int k, E x) {\n        if (comparator != null)\n            siftUpUsingComparator(k, x);\n        else\n            siftUpComparable(k, x);\n}\n\n/**\n\tè¿™é‡Œå…ˆåˆ¤æ–­kæ˜¯å¤§äº0çš„,ä¹Ÿå°±æ˜¯ä¸æ˜¯ç¬¬ä¸€ä¸ªçš„æ„æ€.\n\tç„¶åé€šè¿‡ (k - 1) >>> 1 è®¡ç®—å‡ºæ¥ä¸‹æ ‡ä½ç½®,ä¸‹æ ‡æ˜¯parentçš„å€¼,è°ƒç”¨ comparator.compare(x,e)æ¥è¿›è¡Œæ¯”è¾ƒ,å¦‚æœæ˜¯å¤§äº0çš„è¯,å°±ä¸éœ€è¦åšä»»ä½•å¤„ç†ã€‚\n\tå¦åˆ™çš„è¯,å°±ä¼š queue[k] = e ; k = parent; æ¥è¿›è¡Œä¸‹æ ‡æ•°å€¼çš„æ›¿æ¢å¤„ç†.\n\tæœ€åqueue[k] = x çš„å€¼\n*/\nprivate void siftUpUsingComparator(int k, E x) {\n        while (k > 0) {\n            int parent = (k - 1) >>> 1;\n            Object e = queue[parent];\n            if (comparator.compare(x, (E) e) >= 0)\n                break;\n            queue[k] = e;\n            k = parent;\n        }\n        queue[k] = x;\n}\n\n/**\n\tè¿™ä¸ªæ–¹æ³•å…¶å®ä¹Ÿæ˜¯å’Œä¸Šé¢çš„å¤„ç†æ–¹å¼æ˜¯ç±»ä¼¼çš„,é€šè¿‡æ¯”è¾ƒå€¼æ¥è¿›è¡Œå¤„ç†.\n*/\nprivate void siftUpComparable(int k, E x) {\n        Comparable<? super E> key = (Comparable<? super E>) x;\n        while (k > 0) {\n            int parent = (k - 1) >>> 1;\n            Object e = queue[parent];\n            if (key.compareTo((E) e) >= 0)\n                break;\n            queue[k] = e;\n            k = parent;\n        }\n        queue[k] = key;\n}\n\n\n/**\n\tè¿™é‡Œé¡ºè·¯çœ‹ä¸‹ grow æ‰©å®¹æ–¹æ³•å§ã€‚ \n\tè‚¯å®šæ˜¯æ ¹æ® queueçš„é•¿åº¦æ¥è¿›è¡Œæ‰©å®¹,å¦‚æœå€¼å¤ªå°äº†çš„è¯,å°±ä¼šè¿›è¡Œ äºŒå€æ‰©å®¹.  å¦åˆ™çš„è¯,å°±æ˜¯1.5å€æ‰©å®¹.\n\tæœ€åè°ƒç”¨ Arrays.copyOf() æ¥è¿›è¡Œæ‰©å®¹æ•°ç»„æ“ä½œ\n\tè¿™ä¸ªæ‰©å®¹è¿˜æ˜¯æƒ³å¯¹æ¯”è¾ƒç®€å•çš„\n*/\nprivate void grow(int minCapacity) {\n        int oldCapacity = queue.length;\n        // Double size if small; else grow by 50%\n        int newCapacity = oldCapacity + ((oldCapacity < 64) ?\n                                         (oldCapacity + 2) :\n                                         (oldCapacity >> 1));\n        // overflow-conscious code\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        queue = Arrays.copyOf(queue, newCapacity);\n}\n```\n\npeek æ–¹æ³•\n\nè¿™é‡Œå¯ä»¥çœ‹æ¸…æ¥šçš„çœ‹åˆ°ï¼Œå‡ºé˜Ÿåˆ—æ–¹æ³•çš„å€¼,å°±æ˜¯é»˜è®¤çš„ç¬¬ä¸€ä¸ªå˜›ï¼Œè¿™ä¹ˆä¸€çœ¼çœ‹ä¸‹å»å°±æ˜¯å¾ˆæ¸…æ¥šæ˜äº†çš„.\n\n```\npublic E peek() {\n    return (size == 0) ? null : (E) queue[0];\n}\n```\n\nremove æ–¹æ³• :\n\n```\n/**\n\tåˆ é™¤å…ƒç´ çš„æ–¹æ³•ã€‚\n\tindexOf å¦‚æœè¿”å›çš„ä¸æ˜¯-1çš„è¯,å°±è¯´æ˜æ˜¯æœ‰å€¼å¾—,å°±ä¼šèµ°åˆ° removeAt æ–¹æ³•\n*/\npublic boolean remove(Object o) {\n    int i = indexOf(o);\n    if (i == -1)\n        return false;\n    else {\n        removeAt(i);\n        return true;\n    }\n}\n\n/**\n\tindexOf è¿™ä¸ªæ–¹æ³•å°±æ˜¯åˆ¤æ–­åœ¨è¿™ä¸ªé›†åˆé‡Œé¢æœ‰æ²¡æœ‰ o è¿™ä¸ªå€¼, å¦‚æœæœ‰çš„è¯å°±ä¼šè¿”å›å¯¹åº”çš„ä¸‹æ ‡,å¦‚æœä¸å­˜åœ¨çš„è¯,å°±ä¼šè¿”å›-1çš„å€¼\n*/\nprivate int indexOf(Object o) {\n        if (o != null) {\n            for (int i = 0; i < size; i++)\n                if (o.equals(queue[i]))\n                    return i;\n        }\n        return -1;\n}\n\n/**\n\tremoveAt æ–¹æ³•å°±ä¼šå°†ä¼ å…¥è¿›æ¥çš„içš„ä¸‹æ ‡çš„å€¼é‡ç½®ä¸ºnull,è¿™æ˜¯æ»¡è¶³ i == --size çš„æƒ…å†µä¸‹.\n\tç„¶åä¼šå°†è¦åˆ é™¤çš„ä¸‹æ ‡ i å’Œ å¯¹åº”çš„å€¼ moved ä¼ å…¥åˆ° siftDown è¿™ä¸ªæ–¹æ³•ä¸­.\n\tsiftUp()æ˜¯åœ¨å‰é¢æœ‰è®²è§£åˆ°çš„.\n\tè¿™é‡Œè¿˜æ˜¯å¾ˆæ˜æ˜¾çš„çœ‹åˆ°, priorityQueueæ˜¯ä¸€ç›´åœ¨ç»´æŠ¤è¿™æ’åºçš„å…³ç³»ã€‚\n*/\nprivate E removeAt(int i) {\n        // assert i >= 0 && i < size;\n        modCount++;\n        int s = --size;\n        if (s == i) // removed last element\n            queue[i] = null;\n        else {\n            E moved = (E) queue[s];\n            queue[s] = null;\n            siftDown(i, moved);\n            if (queue[i] == moved) {\n                siftUp(i, moved);\n                if (queue[i] != moved)\n                    return moved;\n            }\n        }\n        return null;\n}\n\n/**\n\tæ ¹æ®comparatorèµ°ä¸åŒçš„æ–¹æ³•\n\tå¯ä»¥çœ‹åˆ°èµ°çš„äºŒä¸ªæ–¹æ³•ï¼Œå…¶ä¸­çš„åŒºåˆ«æ˜¯ comparator.compare å’Œ comparator.compareTo è°ƒç”¨çš„apiæ˜¯ä¸ä¸€æ ·çš„\n*/\nprivate void siftDown(int k, E x) {\n        if (comparator != null)\n            siftDownUsingComparator(k, x);\n        else\n            siftDownComparable(k, x);\n}\n\n\nprivate void siftDownUsingComparator(int k, E x) {\n        int half = size >>> 1;\n        while (k < half) {\n            int child = (k << 1) + 1;\n            Object c = queue[child];\n            int right = child + 1;\n            if (right < size &&\n                comparator.compare((E) c, (E) queue[right]) > 0)\n                c = queue[child = right];\n            if (comparator.compare(x, (E) c) <= 0)\n                break;\n            queue[k] = c;\n            k = child;\n        }\n        queue[k] = x;\n}\n\nprivate void siftDownComparable(int k, E x) {\n        Comparable<? super E> key = (Comparable<? super E>)x;\n        int half = size >>> 1;        // loop while a non-leaf\n        while (k < half) {\n            int child = (k << 1) + 1; // assume left child is least\n            Object c = queue[child];\n            int right = child + 1;\n            if (right < size &&\n                ((Comparable<? super E>) c).compareTo((E) queue[right]) > 0)\n                c = queue[child = right];\n            if (key.compareTo((E) c) <= 0)\n                break;\n            queue[k] = c;\n            k = child;\n        }\n        queue[k] = key;\n}\n```\n\n------\n\n#### æ€»ç»“\n\n PriorityQueue çš„å­˜å‚¨æ•°æ®ç»“æ„æ˜¯é‡‡ç”¨ä¸€ä¸ªæ•°æ®æ¥è¿›è¡Œå­˜å‚¨,ä¹Ÿå°±æ˜¯ä¸€ç›´åœ¨æ“ä½œè¿™ä¸ªæ•°ç»„ï¼Œåªæ˜¯æ¯æ¬¡éƒ½å¯¹æ•°æ®è¿›è¡Œäº†ç»´æŠ¤æ’åºçš„å…³ç³»ã€‚\n\n PriorityQueue æ˜¯çº¿ç¨‹ä¸å®‰å…¨çš„é˜Ÿåˆ—ï¼Œè¿™é‡Œè¿˜æ˜¯æä¸€ä¸‹å§,å› ä¸ºæ·»åŠ å…ƒç´ å’Œåˆ é™¤å…ƒç´ çš„æ–¹æ³•éƒ½æ˜¯æ²¡æœ‰è¿›è¡ŒåŠ é”å¤„ç†ï¼Œå½“ç„¶äº†,å¦‚æœä¸ä½¿ç”¨ä½œä¸ºå…¨å±€å˜é‡çš„è¯ï¼Œè‡ªç„¶æ˜¯æ²¡æœ‰ä»»ä½•é—®é¢˜çš„,åœ¨å±€éƒ¨å˜é‡é‡Œé¢.\n","tags":["java","javaé›†åˆ"],"categories":["java","javaé›†åˆ"]},{"title":"springåˆ›å»ºbean_one","url":"/2021/11/04/spring/springåˆ›å»ºbean-one/","content":"\n\n\n#### å‰æ\n\næˆ‘ä»¬åœ¨åˆ›å»º Spring Bean çš„æ—¶å€™ï¼Œæ˜¯å¯ä»¥é€šè¿‡å¾ˆå¤šç§æ–¹å¼æ¥åˆ›å»ºçš„. ä½†æ˜¯è¿™ä¹ˆå¤šç§æ–¹å¼,åˆæ˜¯æ€ä¹ˆåŠ è½½çš„ï¼Ÿæ˜¯ä¸æ˜¯åˆæœ‰é¡ºåºå‘¢ï¼Ÿ æ‰€ä»¥å¯¹ Spring çš„ Bean åˆ›å»ºè¿˜æ˜¯å¾ˆæœ‰å¿…è¦çš„.\n\n#### åˆ›å»ºæ–¹å¼\n\næˆ‘ä»¬å¯ä»¥é€šè¿‡è‡ªå·±åˆ›å»º bd , ç„¶åè°ƒç”¨ registerBeanDefinition æ–¹æ³•ç»™æ³¨å†Œåˆ° Spring ä¸­æ¥.\n\né‚£ä¹ˆåˆ›å»ºbdçš„æ€ä¹ˆåˆ›å»ºçš„å‘¢ï¼Ÿå¯ä»¥çœ‹åˆ°ä¸‹é¢çš„äºŒç§åˆ›å»ºæ–¹å¼.\n\nè¿™æ˜¯é€šè¿‡ bd æ¥çš„.\n\n```java\npublic class BeanDefinitionCreateAndRegister {\n\n\n    public static void main(String[] args) {\n\n        // 1 : é€šè¿‡ BeanDefinitionBuilder æ¥åˆ›å»º bd\n        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(Person.class);\n        beanDefinitionBuilder.addPropertyValue(\"id\",9527).addPropertyValue(\"name\",\"GavinYang\");\n        BeanDefinition beanDefinition = beanDefinitionBuilder.getBeanDefinition();\n\n        // 2 : é€šè¿‡ new GenericBeanDefinition æ¥åˆ›å»º bd.\n        GenericBeanDefinition genericBeanDefinition = new GenericBeanDefinition();\n        genericBeanDefinition.setBeanClass(Person.class);\n        MutablePropertyValues mutablePropertyValues = new MutablePropertyValues();\n        mutablePropertyValues.add(\"id\",1).add(\"name\",\"Peterwong\");\n        genericBeanDefinition.setPropertyValues(mutablePropertyValues);\n\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();\n\n        // è¿™é‡Œæ˜¯ç»™ bd ç»™æ³¨å†Œåˆ° Spring å®¹å™¨é‡Œé¢æ¥.\n        // context.registerBeanDefinition(\"person\",beanDefinition);\n        context.registerBeanDefinition(\"peterwong\",genericBeanDefinition);\n\n        // å¦‚æœè¿™é‡Œä¸è°ƒç”¨ refresh æ˜¯ä¼šæœ‰é”™è¯¯çš„.\n        context.refresh();\n\n        Person person = context.getBean(Person.class);\n        person.say();\n        System.out.println(person.toString());\n\n    }\n\n}\n```\n\né€šè¿‡æˆ‘ä»¬å¸¸ç”¨çš„æ³¨è§£\n\nè¿™é‡Œä¸»è¦æ˜¯ @Import/@Bean/@Component+@ComponentScan æ–¹å¼æ¥æ³¨å…¥å¯¹è±¡åˆ° Spring å®¹å™¨ä¸­æ¥.\n\n```java\n@Import(ImportBeanConfigMain.ImportConfig.class)\n@ComponentScan(basePackages = \"com.iyang.bean.bd\")\npublic class ImportBeanConfigMain {\n    \n\tpublic ImportBeanConfigMain(){\n        System.out.println(\"ImportBeanConfigMain æ— å‚æ•°æ„é€ å‡½æ•°\");\n    }\n\n    \n    public static void main(String[] args) {\n\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();\n        context.register(ImportBeanConfigMain.class);\n        context.refresh();\n\n        ImportConfig importConfig = context.getBean(ImportConfig.class);\n        Person person = context.getBean(Person.class);\n        AnnotConfig annotConfig = context.getBean(AnnotConfig.class);\n        ExternalConfig externalConfig = context.getBean(ExternalConfig.class);\n\n        System.out.println(importConfig);\n        System.out.println(person);\n        System.out.println(annotConfig);\n        System.out.println(externalConfig);\n\n    }\n\n    /**\n     * é€šè¿‡ @Import å¯¼å…¥è¿›æ¥.\n     */\n    public class ImportConfig{\n\n        public void importMe(){\n            System.out.println(\"è¿™æ˜¯å¯¼å…¥è‡ªå·±çš„æ–¹æ³•\");\n        }\n\n        @Override\n        public String toString() {\n            return \"ImportConfig çš„ toString æ–¹æ³•\";\n        }\n\n        public ImportConfig(){\n            System.out.println(\"ImportConfigæ— å‚æ•°æ„é€ å‡½æ•°\");\n        }\n        /**\n         * ä½¿ç”¨ @Bean æ³¨è§£ æ³¨å…¥ Bean è¿›æ¥.\n         * @return\n         */\n        @Bean\n        public Person importPerson(){\n            return new Person(9527,\"GavinYang\");\n        }\n\n    }\n\n    @Component\n    public static class AnnotConfig{\n\n\n        public AnnotConfig(){\n            System.out.println(\"AnnotConfigæ— å‚æ•°æ„é€ å‡½æ•°\");\n        }\n\n        @Override\n        public String toString() {\n            return \"ä½¿ç”¨æ³¨è§£æ¥æ³¨å…¥beanè¿›æ¥.\";\n        }\n    }\n\n}\n\n@Component\nclass ExternalConfig {\n\n    public ExternalConfig(){\n        System.out.println(\"externalConfig æ— å‚æ„é€ å‡½æ•°\");\n    }\n\n    @Override\n    public String toString() {\n        return \"externalConfig æ‰“å° toString() æ–¹æ³•\";\n    }\n}\n\n\n----------------------------------------------\nImportBeanConfigMain æ— å‚æ•°æ„é€ å‡½æ•°    \nexternalConfig æ— å‚æ„é€ å‡½æ•°\nAnnotConfigæ— å‚æ•°æ„é€ å‡½æ•°\nImportConfigæ— å‚æ•°æ„é€ å‡½æ•°\nperson æœ‰å‚æ•°æ„é€ å‡½æ•°\nImportConfig çš„ toString æ–¹æ³•\nPerson{id=9527, name='GavinYang'}\nä½¿ç”¨æ³¨è§£æ¥æ³¨å…¥beanè¿›æ¥.\nexternalConfig æ‰“å° toString() æ–¹æ³•\n    \n// è¿™é‡Œå¯ä»¥çœ‹åˆ°newå‡ºæ¥çš„å¯¹è±¡æ‰“å°é¡ºåº.\n```\n\nå¦‚æœæ˜¯åŸºäºåˆ›å»º bd çš„æ–¹å¼çš„è¯ï¼Œæ˜¯è¯´æ˜ä¸‹æ˜¯å¯ä»¥é€šè¿‡è¿™ç§æ–¹å¼æ¥å°†æˆ‘ä»¬è‡ªå·±åˆ›å»ºçš„å¯¹è±¡ç»™æ³¨å…¥åˆ°Springå®¹å™¨ä¸­æ¥.æˆ‘ä»¬ä¸»è¦æ¥åˆ†æç¬¬äºŒç§,æ˜¯åšäº†ä»€ä¹ˆäº‹æƒ….\n\n#### @Import/@Bean/@Component+@ComponentScan åˆ†æ\n\nåœ¨åˆ†æä¹‹å‰ï¼Œæˆ‘ä»¬çœ‹ä¸‹æˆ‘ä»¬çš„ beanClass æ˜¯æ€ä¹ˆå…ˆæ³¨å†Œåˆ° Springä¸­æ¥çš„,ä¹Ÿå°±æ˜¯åœ¨org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionMapå’Œorg.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionNamesä¸­,å¯ä»¥çœ‹åˆ°ä¸€ä¸ªæ˜¯Mapç±»å‹çš„,ä¸€ä¸ªæ˜¯é›†åˆç±»å‹çš„.\n\næˆ‘ä»¬æŠŠæ–­ç‚¹æ‰“åœ¨ org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition è¿›æ¥çš„æ–¹æ³•ä¸Šå°±å¯ä»¥çœ‹åˆ°,ç„¶åçœ‹å †æ ˆä¿¡æ¯,å°±å¯ä»¥çœ‹åˆ°æ€ä¹ˆä¸€æ­¥ä¸€æ­¥ç»™æ·»åŠ è¿›æ¥çš„.\n\n##### æ³¨å†Œ Spring ä¸­æ¥èµ°çš„æ–¹æ³•\n\nè¿™é‡Œåªç”¨å…³æ³¨æˆ‘ä»¬è‡ªå·±è‡ªå·±å®šä¹‰çš„ï¼ŒSpringå†…éƒ¨çš„å°±ä¸éœ€è¦ç®¡äº†ã€‚\n\n**ImportBeanConfigMain**\n\norg.springframework.context.annotation.AnnotatedBeanDefinitionReader#registerBean(java.lang.Class<?>) â€”-> org.springframework.beans.factory.support.BeanDefinitionReaderUtils#registerBeanDefinition â€”-> org.springframework.context.support.GenericApplicationContext#registerBeanDefinition\n\n**externalConfig**\n\norg.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors â€”->\n\norg.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors â€”â€“> org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions â€”-> org.springframework.context.annotation.ConfigurationClassParser#parse(org.springframework.core.type.AnnotationMetadata, java.lang.String) â€”> org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass â€”->\n\norg.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan â€”> org.springframework.context.annotation.ClassPathBeanDefinitionScanner#registerBeanDefinition\n\n**importBeanConfigMain.AnnotConfig**\n\norg.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors â€”->org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List<org.springframework.beans.factory.config.BeanFactoryPostProcessor>) â€”-> org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry â€”-> org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions â€”> org.springframework.context.annotation.ConfigurationClassParser#parse(org.springframework.core.type.AnnotationMetadata, java.lang.String) â€”> org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass â€”> org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan â€”> org.springframework.context.annotation.ClassPathBeanDefinitionScanner#registerBeanDefinition\n\n**com.iyang.bean.bd.ImportBeanConfigMain$ImportConfig**\n\norg.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors â€”> org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors â€”> org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry â€”-> org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitions â€”> org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#registerBeanDefinitionForImportedConfigurationClass\n\n**importPerson**\n\norg.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors â€”> org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors â€”> org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry â€”> org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitions â€”> org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod\n\nå¯ä»¥çœ‹åˆ°é™¤äº† ImportBeanConfigMain åœ¨æ‰«æçš„æ—¶å€™å°±è¢«æ³¨å†Œåˆ° spring å®¹å™¨é‡Œé¢æ¥ï¼Œåé¢çš„éƒ½æ˜¯èµ°çš„ AbstractApplicationContext#invokeBeanFactoryPostProcessors æ–¹æ³•ç»™æ³¨å†Œåˆ° Spring å®¹å™¨ä¸­æ¥äº†. æ˜¯ä¸æ˜¯åº”è¯¥è¯¦ç»†åˆ†æä¸‹ invokeBeanFactoryPostProcessors æ–¹æ³•åˆ°äº†åšäº†ä»€ä¹ˆæˆ–è€…è¯´ç”¨äº†ä»€ä¹ˆ,å°†æˆ‘ä»¬å®šä¹‰çš„å¯¹è±¡ç»™æ³¨å†Œåˆ° Spring å®¹å™¨ä¸­æ¥äº†å‘¢ï¼Ÿ\n\n##### invokeBeanFactoryPostProcessors æ–¹æ³•è§£æ\n\nä»ä¸Šé¢æ¥çœ‹ï¼Œè¿™ä¸ªæ–¹æ³•å¹¶ä¸æ˜¯æˆ‘ä»¬æƒ³è±¡ä¸­é‚£ä¹ˆç®€å•çš„.\n\norg.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List<org.springframework.beans.factory.config.BeanFactoryPostProcessor>) å§”æ‰˜åˆ°è¿™é‡Œæ¥è¿›è¡Œè§£æçš„,æ‰€ä»¥æˆ‘ä»¬ç›´æ¥æ·±åº¦åˆ†æè¿™ä¸ªæ–¹æ³•å³å¯.\n\nä¸Šé¢å¯ä»¥çœ‹åˆ°éƒ½æ˜¯èµ°çš„ PostProcessorRegistrationDelegate è¿™ä¸ªç±»,ä½†æ˜¯æˆ‘ä»¬å¹¶æ²¡æœ‰åœ¨è¿™ä¸ªæ–¹æ³•ä¸­æ‰¾åˆ°è¿™ä¸ªç±».\n\n```java\npublic static void invokeBeanFactoryPostProcessors(\n      ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {\n\n   // Invoke BeanDefinitionRegistryPostProcessors first, if any.\n   Set<String> processedBeans = new HashSet<>();\n\n   if (beanFactory instanceof BeanDefinitionRegistry) {\n      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;\n      List<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();\n      List<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();\n\n      for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {\n         if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {\n            BeanDefinitionRegistryPostProcessor registryProcessor =\n                  (BeanDefinitionRegistryPostProcessor) postProcessor;\n            registryProcessor.postProcessBeanDefinitionRegistry(registry);\n            registryProcessors.add(registryProcessor);\n         }\n         else {\n            regularPostProcessors.add(postProcessor);\n         }\n      }\n\n      // Do not initialize FactoryBeans here: We need to leave all regular beans\n      // uninitialized to let the bean factory post-processors apply to them!\n      // Separate between BeanDefinitionRegistryPostProcessors that implement\n      // PriorityOrdered, Ordered, and the rest.\n      List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();\n\n      // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.\n      String[] postProcessorNames =\n            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n      for (String ppName : postProcessorNames) {\n         if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n            processedBeans.add(ppName);\n         }\n      }\n      sortPostProcessors(currentRegistryProcessors, beanFactory);\n      registryProcessors.addAll(currentRegistryProcessors);\n// Note : æˆ‘ä»¬æ ¹æ® debug æ˜¯å¯ä»¥è·Ÿè¿›åˆ°è¿™é‡Œçš„, æˆ‘ä»¬ç›´æ¥åœ¨è¿™é‡Œæ‰“ä¸Šæ–­ç‚¹,å†æ¥ä»”ç»†çœ‹çœ‹è¿™ä¸ªæ–¹æ³•åšäº†ä»€ä¹ˆäº‹æƒ….   // currentRegistryProcessors : org.springframework.context.annotation.ConfigurationClassPostProcessor      \n// registry :  DefaultableListFactory \n// èµ°å®Œè¿™ä¸ªæ–¹æ³•,æˆ‘ä»¬çš„beanä¿¡æ¯éƒ½æ³¨å†Œåˆ° Spring çš„ DefaultLitableFactoryä¸­æ¥äº†.      \n      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n      currentRegistryProcessors.clear();\n\n      // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.\n      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n      for (String ppName : postProcessorNames) {\n         if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {\n            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n            processedBeans.add(ppName);\n         }\n      }\n      sortPostProcessors(currentRegistryProcessors, beanFactory);\n      registryProcessors.addAll(currentRegistryProcessors);\n      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n      currentRegistryProcessors.clear();\n\n      // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.\n      boolean reiterate = true;\n      while (reiterate) {\n         reiterate = false;\n         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n         for (String ppName : postProcessorNames) {\n            if (!processedBeans.contains(ppName)) {\n               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n               processedBeans.add(ppName);\n               reiterate = true;\n            }\n         }\n         sortPostProcessors(currentRegistryProcessors, beanFactory);\n         registryProcessors.addAll(currentRegistryProcessors);\n         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n         currentRegistryProcessors.clear();\n      }\n\n      // Now, invoke the postProcessBeanFactory callback of all processors handled so far.\n      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);\n      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);\n   }\n\n   else {\n      // Invoke factory processors registered with the context instance.\n      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);\n   }\n\n   // Do not initialize FactoryBeans here: We need to leave all regular beans\n   // uninitialized to let the bean factory post-processors apply to them!\n   String[] postProcessorNames =\n         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);\n\n   // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,\n   // Ordered, and the rest.\n   List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();\n   List<String> orderedPostProcessorNames = new ArrayList<>();\n   List<String> nonOrderedPostProcessorNames = new ArrayList<>();\n   for (String ppName : postProcessorNames) {\n      if (processedBeans.contains(ppName)) {\n         // skip - already processed in first phase above\n      }\n      else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));\n      }\n      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n         orderedPostProcessorNames.add(ppName);\n      }\n      else {\n         nonOrderedPostProcessorNames.add(ppName);\n      }\n   }\n\n   // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.\n   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\n   // Next, invoke the BeanFactoryPostProcessors that implement Ordered.\n   List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());\n   for (String postProcessorName : orderedPostProcessorNames) {\n      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n   }\n   sortPostProcessors(orderedPostProcessors, beanFactory);\n   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);\n\n   // Finally, invoke all other BeanFactoryPostProcessors.\n   List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());\n   for (String postProcessorName : nonOrderedPostProcessorNames) {\n      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n   }\n   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);\n\n   // Clear cached merged bean definitions since the post-processors might have\n   // modified the original metadata, e.g. replacing placeholders in values...\n   beanFactory.clearMetadataCache();\n}\n```\n\n###### org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions æ–¹æ³•\n\n```java\n/**\n * Build and validate a configuration model based on the registry of\n * {@link Configuration} classes.\n */\npublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n   List<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n   String[] candidateNames = registry.getBeanDefinitionNames();\n\n   for (String beanName : candidateNames) {\n      BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n      if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) {\n         if (logger.isDebugEnabled()) {\n            logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n         }\n      }\n// å¯¹æ˜¯å¦æ»¡è¶³é…ç½®ç±»è¿›è¡Œæ£€æŸ¥, è¿™é‡Œæˆ‘ä»¬çš„beanæ˜¯importBeanConfigMain,æ»¡è¶³æ¡ä»¶çš„,å…·ä½“å¯ä»¥çœ‹ä¸‹é¢è¯¥æ–¹æ³•çš„åˆ†æ.ç„¶åä¼šæ„å»ºä¸€ä¸ª bdHolder,æ·»åŠ åˆ°é›†åˆä¸­æ¥.\n      else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n         configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n      }\n   }\n\n   // Return immediately if no @Configuration classes were found\n   if (configCandidates.isEmpty()) {\n      return;\n   }\n\n   // Sort by previously determined @Order value, if applicable\n// è¿™é‡Œä¼šæ ¹æ® @Order æ¥è¿›è¡Œæ’åºä¸‹.\n// ä» Integer.compare(i1, i2) æ¥åˆ†æï¼Œåº”è¯¥æ˜¯ä»å°åˆ°å¤§çš„æ’åº,ä¹Ÿå°±æ˜¯è¯´,è¶Šå°çš„è¯,ä¼˜å…ˆçº§å°±çº¦é«˜. \n   configCandidates.sort((bd1, bd2) -> {\n      int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n      int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n      return Integer.compare(i1, i2);\n   });\n\n   // Detect any custom bean name generation strategy supplied through the enclosing application context\n   SingletonBeanRegistry sbr = null;\n   if (registry instanceof SingletonBeanRegistry) {\n// æ»¡è¶³ç±»å‹æ¡ä»¶å¼ºè½¬ä¸‹.       \n      sbr = (SingletonBeanRegistry) registry;\n      if (!this.localBeanNameGeneratorSet) {\n// è¿™é‡Œä¸åŒ…å«,æ‰€ä»¥è¿”å›çš„å°±æ˜¯null.\n//org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean)          \n         BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(\n               AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);\n         if (generator != null) {\n            this.componentScanBeanNameGenerator = generator;\n            this.importBeanNameGenerator = generator;\n         }\n      }\n   }\n// ç¡®ä¿environmentä¸æ˜¯null.\n   if (this.environment == null) {\n      this.environment = new StandardEnvironment();\n   }\n\n   // Parse each @Configuration class\n// åˆ›å»ºä¸€ä¸ªè§£æ @Configuration çš„å¯¹è±¡.\n// åœ¨åˆ›å»ºConfigurationClassParserçš„è¿™ä¸ªæœ‰å‚æ„é€ å‡½æ•°é‡Œé¢,æ˜¯å¯ä»¥çœ‹åˆ°åˆnewäº†äºŒä¸ªå¯¹è±¡çš„,ä¸€ä¸ªæ˜¯ComponentScanAnnotationParser,ä¸€ä¸ªæ˜¯ConditionEvaluator.\n// ComponentScanAnnotationParser è¿™ä¸ªä»åå­—ä¸Šçœ‹,å¯ä»¥ç†è§£ä¸º@ComponentScanæ³¨è§£çš„è§£æ.  \n   ConfigurationClassParser parser = new ConfigurationClassParser(\n         this.metadataReaderFactory, this.problemReporter, this.environment,\n         this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n   Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n   Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n   do {\n// org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClassè¿™é‡Œèµ°åˆ°è¿™é‡Œ,ä¸»è¦çœ‹è¿™ä¸ªæ–¹æ³•ä¸­çš„doProcessConfigurationClassæ–¹æ³•.       \n      parser.parse(candidates);\n// è¿™é‡Œå¯¹æˆ‘ä»¬ä¸Šé¢è§£æå‡ºæ¥çš„beanè¿›è¡Œvaliate,å¦‚æœvalidateå¤±è´¥çš„è¯,é‚£ä¹ˆæœ€åæ˜¯ä¼šæŠ›å‡ºä¸€ä¸ªå¼‚å¸¸æ¥çš„.\t       \n      parser.validate();\n\n// è£…æœ‰æˆ‘ä»¬è§£æå‡ºæ¥çš„beanä¿¡æ¯       \n      Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n// ç§»é™¤å·²ç»è§£æè¿‡äº†çš„.       \n      configClasses.removeAll(alreadyParsed);\n\n      // Read the model and create bean definitions based on its content\n//å¦‚æœthis.readeræ˜¯nullçš„è¯,å°±ä¼šnewä¸€ä¸ªConfigurationClassBeanDefinitionReaderå‡ºæ¥.       \n      if (this.reader == null) {\n         this.reader = new ConfigurationClassBeanDefinitionReader(\n               registry, this.sourceExtractor, this.resourceLoader, this.environment,\n               this.importBeanNameGenerator, parser.getImportRegistry());\n      }\n // è¿™é‡Œå¯¹æˆ‘ä»¬è·å–çš„ bean å†è¿›è¡Œä¸€ä¸ª load.      \n      this.reader.loadBeanDefinitions(configClasses);\n// è§£æè¿‡äº†çš„beanæ”¾å…¥åˆ° alreadyParsed ä¸­æ¥.       \n      alreadyParsed.addAll(configClasses);\n\n      candidates.clear();\n// æ‰«æè·å–å‡ºæ¥çš„beanä¸ªæ•°å¤§äº åˆå§‹åŒ–ä¼ å…¥è¿›æ¥çš„ä¸ªæ•°.       \n      if (registry.getBeanDefinitionCount() > candidateNames.length) {\n        // è·å–å‡ºæ–°æ‰«æçš„beanä¿¡æ¯.  \n         String[] newCandidateNames = registry.getBeanDefinitionNames();\n        // æ—§çš„beanä¿¡æ¯  \n         Set<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n        // è¡¨ç¤ºå·²ç»æ³¨å†Œè¿‡äº†çš„  \n         Set<String> alreadyParsedClasses = new HashSet<>();\n       // å°†å¤–é¢çš„ alreadyParsed ä¸­çš„å…ƒç´ çš„ metadataçš„classNameç»™æ”¾å…¥åˆ°alreadyParsedClassesé›†åˆä¸­æ¥.    \n         for (ConfigurationClass configurationClass : alreadyParsed) {\n            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n         }\n // å¯¹newçš„é›†åˆä¸­å…ƒç´ è¿›è¡Œè¿­ä»£         \n         for (String candidateName : newCandidateNames) {\n       // è€çš„é›†åˆä¸­ä¸åŒ…å«      \n            if (!oldCandidateNames.contains(candidateName)) {\n               BeanDefinition bd = registry.getBeanDefinition(candidateName);\n                \n       // alreadyParsedClasses ä¸­ä¸åŒ…å«å¹¶ä¸”æ£€éªŒå‡ºéœ€è¦é…ç½®çš„,æ¯”å¦‚æœ‰ä¸€äº›@Configurationç­‰ç‰¹æ®Šæ³¨è§£ï¼Œè¿™ä¸ªæ–¹æ³•åœ¨ä¹‹å‰æ˜¯æœ‰æåˆ°çš„.         \n               if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&\n                     !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n           // æ»¡è¶³ä¸Šé¢è¿™äº›æ¡ä»¶å°±ä¼šæ”¾å…¥åˆ°candidatesé›†åˆä¸­æ¥.         \n                  candidates.add(new BeanDefinitionHolder(bd, candidateName));\n               }\n            }\n         }\n         candidateNames = newCandidateNames;\n      }\n   }\n// candidates æ˜¯ empty å°±è·³å‡ºwhileå¾ªç¯,å¦åˆ™å°±è®¤ä¸ºè¿˜æœ‰beanéœ€è¦è§£æ.    \n   while (!candidates.isEmpty());\n\n   // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n// org.springframework.context.annotation.ConfigurationClassPostProcessor.importRegistry sbrä¸åŒ…å«importRegistryçš„è¯,å°±ä¼šæ³¨å†Œä¸€ä¸ªè¿›å».   \n   if (sbr != null && !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n      sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n   }\n\n   if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n      // Clear cache in externally provided MetadataReaderFactory; this is a no-op\n      // for a shared cache since it'll be cleared by the ApplicationContext.\n // è¿™é‡Œæ˜¯æ¸…é™¤ç¼“å­˜,ä¹Ÿæ˜¯æ¸…é™¤ä¸€äº›é›†åˆ.      \n      ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n   }\n}\n```\n\n**èµ°å®Œè¿™ä¸ªæ–¹æ³•,å¦‚æœæ˜¯debugæ¨¡å¼çš„è¯,å°±å¯ä»¥åœ¨ registry(ä¹Ÿå°±æ˜¯DefaultListableBeanFactory)çš„ beanDefintionMapå’ŒbeanDefinitionNamesè¿™äºŒä¸ªé›†åˆä¸­æ˜¯å¯ä»¥çœ‹åˆ°æˆ‘ä»¬çš„beanåå­—å·²ç»beanå¯¹åº”çš„classä¿¡æ¯çš„.**\n\n###### org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClassæ–¹æ³•\n\nå¯ä»¥çœ‹åˆ°è¿™ä¸ªæ–¹æ³•å°±æ˜¯å¯¹ configuration ç±»è¿›è¡Œå¤„ç†çš„.\n\n```java\n/**\n * Apply processing and build a complete {@link ConfigurationClass} by reading the\n * annotations, members and methods from the source class. This method can be called\n * multiple times as relevant sources are discovered.\n * @param configClass the configuration class being build\n * @param sourceClass a source class\n * @return the superclass, or {@code null} if none found or previously processed\n */\n@Nullable\nprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)\n      throws IOException {\n\n// åˆ¤æ–­æ˜¯ä¸æ˜¯æœ‰ @Component æ³¨è§£.  \n   if (configClass.getMetadata().isAnnotated(Component.class.getName())) {\n      // Recursively process any member (nested) classes first\n      processMemberClasses(configClass, sourceClass);\n   }\n\n   // Process any @PropertySource annotations\n// æ¥ç€å†å¤„ç† @PropertySources æ³¨è§£. å¯ä»¥çœ‹åˆ°è¿™ä¸ªæ³¨è§£è²Œä¼¼æ˜¯å’Œ Environment æœ‰å…³ç³».   \n   for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n         sourceClass.getMetadata(), PropertySources.class,\n         org.springframework.context.annotation.PropertySource.class)) {\n      if (this.environment instanceof ConfigurableEnvironment) {\n         processPropertySource(propertySource);\n      }\n      else {\n         logger.info(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n               \"]. Reason: Environment must implement ConfigurableEnvironment\");\n      }\n   }\n\n   // Process any @ComponentScan annotations\n// è·å–@ComponentScan æ³¨è§£,æˆ‘ä»¬è¿™é‡Œæ˜¯æœ‰çš„.    \n   Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n         sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n   if (!componentScans.isEmpty() &&\n         !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n      for (AnnotationAttributes componentScan : componentScans) {\n         // The config class is annotated with @ComponentScan -> perform the scan immediately\n          \n// org.springframework.context.annotation.ComponentScanAnnotationParser#parse\n// parse æ–¹æ³•å†…éƒ¨æ˜¯ä½¿ç”¨ ClassPathBeanDefinitionScanner æ‰«æå™¨çš„,å¯¹resourcePattern/includeFilters/excludeFilters/lazyInit æ˜¯å¦æœ‰è¿›è¡Œå¤„ç†.\n// è·å–æ³¨è§£ä¸Šçš„å±æ€§ basePackages/basePackageClassesçš„å€¼,æ·»åŠ ä¸€ä¸ªAbstractTypeHierarchyTraversingFilter,è¿™ä¸ªæ˜¯ExcludeFilter\n//æœ€åæ¥org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScanåšæ‰«ææ“ä½œ.\n//doScanåšäº†ä»€ä¹ˆäº‹æƒ…å‘¢? æ˜¾ç¤ºé€šè¿‡ä¼ å…¥è¿›æ¥çš„åŒ…,è°ƒç”¨findCandidateComponentsè·å–å‡ºbdçš„é›†åˆæ¥,ScopeMetadataè®¾ç½®ä¹Ÿæ˜¯é»˜è®¤çš„,ç”¨beanNameGeneratorç”Ÿæˆbeanå¯¹åº”çš„beanName\n//å¦‚æœbdæ˜¯AbstractBeanDefinition,å†èµ°ä¸€ä¸‹postProcessBeanDefinitionæ–¹æ³•\n//å¦‚æœbdæ˜¯AnnotatedBeanDefinition,ä¼šèµ°AnnotationConfigUtils.processCommonDefinitionAnnotations()æ–¹æ³•,ä¹Ÿæ˜¯å¯¹ä¸€äº›æ³¨è§£çš„å±æ€§è¿›è¡Œè®¾ç½®å€¼æ“ä½œ. èµ°ä¸ªcheckCandidatæ£€æŸ¥æ–¹æ³•,ç¡®ä¿bdå†registryä¸­ä¸å­˜åœ¨çš„,å¦‚æœå­˜åœ¨çš„è¯,é‚£å°±è¯´æ˜æ˜¯å·²ç»æ³¨å†Œè¿‡äº†çš„.     //å¦‚æœæ˜¯ä¸å­˜åœ¨çš„è¯,å°±ä¼šnewä¸€ä¸ªBeanDefinitionHolderæ¥,ç„¶åèµ°registerBeanDefinitionç»™æ³¨å†Œåˆ°Springå®¹å™¨ä¸­æ¥. æœ€åè¿”å›æ‰«æè·å–åˆ°çš„bdHolderé›†åˆæ¥.     \n         Set<BeanDefinitionHolder> scannedBeanDefinitions =\n               this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n         // Check the set of scanned definitions for any further config classes and parse recursively if needed\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();\n            if (bdCand == null) {\n               bdCand = holder.getBeanDefinition();\n            }\n// å¯ä»¥çœ‹åˆ°è¿™é‡Œ, æˆ‘ä»¬åœ¨æœ€åˆè¿›å…¥åˆ°processConfigBeanDefinitionsæ¥çš„æ—¶å€™,å…¶å®å°±å·²ç»æ˜¯è°ƒç”¨äº†è¿™ä¸ªæ–¹æ³•,é‚£ä¹ˆæˆ‘ä»¬è¿™é‡Œæ‰«æè·å–çš„beanåœ¨æ­¤è°ƒç”¨è¿™ä¸ªæ–¹æ³•. ä¹Ÿå°±æ˜¯ç¡®ä¿,æ‰«æè·å–çš„bean,ä¹Ÿæ˜¯æœ‰ä¸€äº›é…ç½®çš„æ³¨è§£å¹¶ä¸”ä¹Ÿæ˜¯éœ€è¦è§£æçš„.           \n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {\n// org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClassè¿™é‡Œæœ€åä¹Ÿæ˜¯èµ°åˆ°è¿™é‡Œäº†.\n// æœ€åˆæˆ‘ä»¬æ˜¯ä»parse.parse() è¿›æ¥çš„,ä¹Ÿæ˜¯èµ°çš„ConfigurationClassParser#processConfigurationClas,è¿™é‡Œåˆèµ°åˆ°äº†è¯¥æ–¹æ³•.\n// ä¹Ÿå°±è¯´æˆ‘ä»¬æ˜¯è°ƒç”¨è¿™ä¸ªæ–¹æ³•,åªè¦æ»¡è¶³æ¡ä»¶çš„è¯,å°±ä¼šä¸€ç›´è°ƒç”¨è¿™ä¸ªæ–¹æ³•,ç›´åˆ°ä¸æ»¡è¶³æ¡ä»¶ä¸ºæ­¢.                \n               parse(bdCand.getBeanClassName(), holder.getBeanName());\n            }\n         }\n      }\n   }\n\n   // Process any @Import annotations\n// è¿™é‡Œæ˜¯å¯¹ @Import æ³¨è§£è¿›è¡Œå¤„ç†. è¯¥æ–¹æ³•æ˜¯æœ‰åˆ©ç”¨ importStack æ¥æ§åˆ¶,\n// å…¶å†…éƒ¨åˆåˆ†ä¸º @ImportSelector/@ImportBeanDefinitionRegistrar/æ— æ³¨è§£è¿™ä¸‰ç§æƒ…å†µ.\n// è·å–å®Œ bean ä¿¡æ¯å,å°±åˆèµ°åˆ°äº†org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClassæ–¹æ³•æ¥.\n// æœ€åimportStack è°ƒç”¨ pop ç»™æ•°æ®ç»™å¼¹å‡ºæ¥.    \n   processImports(configClass, sourceClass, getImports(sourceClass), true);\n\n   // Process any @ImportResource annotations\n// å¯¹@ImportResourceæ˜¯å¦æœ‰è¿›è¡Œåˆ¤æ–­.    \n   AnnotationAttributes importResource =\n         AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n   if (importResource != null) {\n      String[] resources = importResource.getStringArray(\"locations\");\n      Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n      for (String resource : resources) {\n         String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n         configClass.addImportedResource(resolvedResource, readerClass);\n      }\n   }\n\n   // Process individual @Bean methods\n// @Bean æ³¨è§£å¤„ç†.\n//org.springframework.context.annotation.ConfigurationClassParser#retrieveBeanMethodMetadata , \n// è¿™é‡Œå¯¹äºä¸»å…¥å£ç±»è¿›æ¥,æ˜¯æ²¡æœ‰è¿™ä¸ªé…ç½®çš„.    \n   Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n   for (MethodMetadata methodMetadata : beanMethods) {\n      configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n   }\n\n   // Process default methods on interfaces\n// å¯¹æ¥å£çš„è¿›è¡Œå¤„ç†. è¿™é‡Œç›®å‰ä¹Ÿæ˜¯æ²¡æœ‰çš„.    \n   processInterfaces(configClass, sourceClass);\n\n   // Process superclass, if any\n// å…ˆæ˜¯åˆ¤æ–­æ˜¯ä¸æ˜¯æœ‰çˆ¶ç±».    \n   if (sourceClass.getMetadata().hasSuperClass()) {\n// è·å–å‡ºçˆ¶ç±»ä¿¡æ¯       \n      String superclass = sourceClass.getMetadata().getSuperClassName();\n// çˆ¶ç±»ä¸æ˜¯null,ä¸æ˜¯javaå¼€å¤´å¹¶ä¸”knownSuperclassesä¸­ä¸å­˜åœ¨,å°±æ»¡æ»¡è¶³æ¡ä»¶.       \n      if (superclass != null && !superclass.startsWith(\"java\") &&\n            !this.knownSuperclasses.containsKey(superclass)) {\n         this.knownSuperclasses.put(superclass, configClass);\n         // Superclass found, return its annotation metadata and recurse\n         return sourceClass.getSuperClass();\n      }\n   }\n\n   // No superclass -> processing is complete\n   return null;\n}\n```\n\n**è¿™é‡Œå¯ä»¥çœ‹åˆ° doProcessConfigurationClassæ–¹æ³•,æ˜¯ä¼ å…¥è¿›æ¥ä¸»ç±»å…¥å£è¿›è¡Œè§£æ, ç„¶åæ²¡æ»¡è¶³ä¸€ä¸ªæ¡ä»¶çš„bean,éƒ½ä¼šåœ¨èµ°ä¸€éè§£æçš„æ–¹æ³•,ç›´åˆ°éƒ½èµ°åˆ°æ²¡æ»¡è¶³æ¡ä»¶çš„.**\n\n###### org.springframework.context.annotation.ConfigurationClassUtils#checkConfigurationClassCandidateæ–¹æ³•\n\n```java\n/**\n * Check whether the given bean definition is a candidate for a configuration class\n * (or a nested component class declared within a configuration/component class,\n * to be auto-registered as well), and mark it accordingly.\n * @param beanDef the bean definition to check\n * @param metadataReaderFactory the current factory in use by the caller\n * @return whether the candidate qualifies as (any kind of) configuration class\n */\npublic static boolean checkConfigurationClassCandidate(\n      BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) {\n// å…ˆè·å– beanName å‡ºæ¥\n   String className = beanDef.getBeanClassName();\n   if (className == null || beanDef.getFactoryMethodName() != null) {\n      return false;\n   }\n\n   AnnotationMetadata metadata;\n// åˆ¤æ–­ bd æ˜¯ä¸æ˜¯AnnotatedBeanDefinition å¹¶ä¸” ç¡®è®¤ beanNameæ˜¯ä¸æ˜¯ä¸å‰é¢è·å–å‡ºæ¥çš„classsNameæ˜¯ä¸€æ ·çš„.    \n   if (beanDef instanceof AnnotatedBeanDefinition &&\n         className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) {\n      // Can reuse the pre-parsed metadata from the given BeanDefinition...\n// è·å–ç±»ä¸Šçš„æ³¨è§£.æˆ‘ä»¬è¿™é‡Œè·å–å‡ºæ¥çš„æ˜¯ @Import å’Œ @ComponentScan       \n      metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();\n   }\n   else if (beanDef instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) beanDef).hasBeanClass()) {\n      // Check already loaded Class if present...\n      // since we possibly can't even load the class file for this Class.\n      Class<?> beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();\n      if (BeanFactoryPostProcessor.class.isAssignableFrom(beanClass) ||\n            BeanPostProcessor.class.isAssignableFrom(beanClass) ||\n            AopInfrastructureBean.class.isAssignableFrom(beanClass) ||\n            EventListenerFactory.class.isAssignableFrom(beanClass)) {\n         return false;\n      }\n      metadata = AnnotationMetadata.introspect(beanClass);\n   }\n   else {\n      try {\n         MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);\n         metadata = metadataReader.getAnnotationMetadata();\n      }\n      catch (IOException ex) {\n         if (logger.isDebugEnabled()) {\n            logger.debug(\"Could not find class file for introspecting configuration annotations: \" +\n                  className, ex);\n         }\n         return false;\n      }\n   }\n\n // è·å–@Configuration,æˆ‘ä»¬è¿™é‡Œæ²¡æœ‰,æ‰€ä»¥è·å–å‡ºæ¥çš„null.   \n   Map<String, Object> config = metadata.getAnnotationAttributes(Configuration.class.getName());\n   if (config != null && !Boolean.FALSE.equals(config.get(\"proxyBeanMethods\"))) {\n      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);\n   }\n// æ³¨æ„è¿™é‡Œçš„ isConfigurationCandidateæ–¹æ³•,org.springframework.context.annotation.ConfigurationClassUtils#isConfigurationCandidate\n// @Component/@ComponentScan/@Import/@ImportResource,åªè¦æœ‰å…¶ä¸­çš„ä¸€ç§çš„è¯ï¼Œé‚£ä¹ˆè¿”å›çš„å°±æ˜¯true. \n   else if (config != null || isConfigurationCandidate(metadata)) {\n// CONFIGURATION_CLASS_ATTRIBUTE å¯¹åº”çš„å€¼æ˜¯org.springframework.context.annotation.ConfigurationClassPostProcessor.configurationClass       \n      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);\n   }\n   else {\n      return false;\n   }\n\n   // It's a full or lite configuration candidate... Let's determine the order value, if any.\n// è·å– order,å¦‚æœæœ‰çš„è¯,å°±ä¼šsetè¿›å».    \n   Integer order = getOrder(metadata);\n   if (order != null) {\n      beanDef.setAttribute(ORDER_ATTRIBUTE, order);\n   }\n\n   return true;\n}\n```\n\n**å¯ä»¥çœ‹åˆ°è¿™ä¸ªæ–¹æ³•æœ€ä¸»çš„å°±æ˜¯å¯¹ä¸€äº›ç±»ä¸Šæ˜¯å¦æœ‰æ³¨è§£è¿›è¡Œåˆ¤æ–­, å¦‚æœæ»¡è¶³ @Configuration/@Component/@ComponentScan/@Import/@ImportResource,é‚£ä¹ˆè¿”å›çš„å°±æ˜¯ä¼štrue,åŒæ—¶ä¹Ÿä¼šsetä¸€ä¸ªCONFIGURATION_CLASS_ATTRIBUTEå±æ€§åˆ°bdé‡Œé¢æ¥.**\n\n#### getBeanæ–¹æ³•åˆ†æ\n\n getBean ä¸ä»…ä»…æ˜¯è·å–beançš„æ•ˆæœ,æ›´æ˜¯åˆ›å»ºbeançš„ï¼Œå¯ä»¥çœ‹åˆ°getBeanæœ€åèµ°åˆ°äº†createBeanæ–¹æ³•æ¥.\n\n org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons : è¿™é‡Œæˆ‘ä»¬ç›´æ¥å®šä½åˆ°è¿™ä¸ªæ–¹æ³•,æ¥çœ‹ä¸‹æ˜¯æ€ä¹ˆè°ƒç”¨çš„,è°ƒç”¨ä¹‹å‰/å®ä¾‹åŒ–beanç­‰è¿‡ç¨‹,åˆåšäº†ä»€ä¹ˆäº‹æƒ…ï¼Ÿ\n\n##### preInstantiateSingletons æ–¹æ³•\n\n```java\n@Override\npublic void preInstantiateSingletons() throws BeansException {\n   if (logger.isTraceEnabled()) {\n      logger.trace(\"Pre-instantiating singletons in \" + this);\n   }\n\n   // Iterate over a copy to allow for init methods which in turn register new bean definitions.\n   // While this may not be part of the regular factory bootstrap, it does otherwise work fine.\n// ä» beanDefinitionNames ä¸­è·å–å‡º beanNameçš„é›†åˆ.\n// è¿™é‡Œè·å–å‡ºæ¥çš„ beanNameList ä¸ä»…ä»…æœ‰Springå†…éƒ¨çš„,è¿˜æœ‰æˆ‘ä»¬è‡ªå·±çš„.    \n   List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);\n\n   // Trigger initialization of all non-lazy singleton beans...\n   for (String beanName : beanNames) {\n      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n// bdä¸æ˜¯æŠ½è±¡çš„,æ˜¯å•åˆ—çš„,ä¸æ˜¯èµ–åŠ è½½çš„,å°±è¿›å…¥åˆ°è¿™é‡Œæ¥.       \n      if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {\n    // åˆ¤æ–­æ˜¯ä¸æ˜¯ FactoryBean      \n         if (isFactoryBean(beanName)) {\n            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);\n            if (bean instanceof FactoryBean) {\n               final FactoryBean<?> factory = (FactoryBean<?>) bean;\n               boolean isEagerInit;\n               if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {\n                  isEagerInit = AccessController.doPrivileged((PrivilegedAction<Boolean>)\n                              ((SmartFactoryBean<?>) factory)::isEagerInit,\n                        getAccessControlContext());\n               }\n               else {\n                  isEagerInit = (factory instanceof SmartFactoryBean &&\n                        ((SmartFactoryBean<?>) factory).isEagerInit());\n               }\n               if (isEagerInit) {\n                  getBean(beanName);\n               }\n            }\n         }\n         else {\n      // å¦‚æœä¸æ˜¯ FactroyBeançš„è¯,å°±ç›´æ¥èµ° getBeanæ–¹æ³•.       \n            getBean(beanName);\n         }\n      }\n   }\n\n   // Trigger post-initialization callback for all applicable beans...\n// æ ¹æ® beanNames æ¥è¿›è¡Œè¿­ä»£.    \n   for (String beanName : beanNames) {\n   // æ ¹æ® beanName æ¥è·å–å¯¹è±¡.    \n// org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean)       \n      Object singletonInstance = getSingleton(beanName);\n  // æ»¡è¶³æ˜¯ SmartInitializingSingleton æ¥å£çš„å­ç±». æœ€åå°±éƒ½ä¼šè°ƒç”¨ afterSingletonsInstantiated æ–¹æ³•, è¿™ä¸ªä¹Ÿç®—æ˜¯beanè‡ªèº«å®ç°SmartInitializingSingletonæ¥å£æ¥åšçš„ä¸€ç§æ‰©å±•.  \n      if (singletonInstance instanceof SmartInitializingSingleton) {\n         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;\n         if (System.getSecurityManager() != null) {\n            AccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n               smartSingleton.afterSingletonsInstantiated();\n               return null;\n            }, getAccessControlContext());\n         }\n         else {\n            smartSingleton.afterSingletonsInstantiated();\n         }\n      }\n   }\n}\n```\n\nå¯ä»¥çœ‹åˆ° preInstanitateSingletonsæ–¹æ³•ï¼Œæ ¹æ®beanDefinitionNamesä¸­æ³¨å†Œè¿‡çš„beanNameé›†åˆ,è°ƒç”¨getBeanæ–¹æ³•æ¥åˆ›å»ºè¿™ä¸ªbean. å½“åˆ›å»ºå®Œæ‰€æœ‰çš„beanå,åˆ¤æ–­æ˜¯ä¸æ˜¯æœ‰å®ç° SmartInitializingSingleton æ¥å£çš„bean,å¦‚æœæœ‰çš„è¯, å°±ä¼šè°ƒç”¨è¿™ä¸ªbean çš„afterSingletonsInstantiatedæ–¹æ³•.\n\n###### doGetBean() æ–¹æ³•\n\n```java\n/**\n * Return an instance, which may be shared or independent, of the specified bean.\n * @param name the name of the bean to retrieve\n * @param requiredType the required type of the bean to retrieve\n * @param args arguments to use when creating a bean instance using explicit arguments\n * (only applied when creating a new instance as opposed to retrieving an existing one)\n * @param typeCheckOnly whether the instance is obtained for a type check,\n * not for actual use\n * @return an instance of the bean\n * @throws BeansException if the bean could not be created\n */\n@SuppressWarnings(\"unchecked\")\nprotected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,\n      @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {\n// è·å–beanName\n   final String beanName = transformedBeanName(name);\n   Object bean;\n\n   // Eagerly check singleton cache for manually registered singletons.\n //   è¿™é‡Œæ˜¯åˆ¤æ–­æ˜¯ä¸æ˜¯æ‰‹åŠ¨ç»™æ·»åŠ åˆ°å•ä¾‹æ± é‡Œé¢å»çš„.\n   Object sharedInstance = getSingleton(beanName);\n   if (sharedInstance != null && args == null) {\n      if (logger.isTraceEnabled()) {\n         if (isSingletonCurrentlyInCreation(beanName)) {\n            logger.trace(\"Returning eagerly cached instance of singleton bean '\" + beanName +\n                  \"' that is not fully initialized yet - a consequence of a circular reference\");\n         }\n         else {\n            logger.trace(\"Returning cached instance of singleton bean '\" + beanName + \"'\");\n         }\n      }\n// å¦‚æœæ˜¯ä»å•ä¾‹æ± é‡Œé¢è·å–å‡ºæ¥çš„,å°±èµ°è¿™ä¸ªæ–¹æ³•.    \n      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n   }\n\n   else {\n      // Fail if we're already creating this bean instance:\n      // We're assumably within a circular reference.\n  // åˆ¤æ–­è¿™ä¸ªbeanå½“å‰æ˜¯ä¸æ˜¯å·²ç»åœ¨æ³¨å†Œäº†,å¦‚æœæ˜¯çš„è¯,å°±ä¼šæŠ›å‡ºå¼‚å¸¸æ¥.  \n//org.springframework.beans.factory.support.AbstractBeanFactory#prototypesCurrentlyInCreation,åˆ©ç”¨ThreadLocalæ¥è®°å½•å€¼,å¦‚æœbeanNameæ˜¯ç›¸åŒçš„è¯å°±ä¼šè¿”å›ture,å¦åˆ™å°±è¿”å›flase,è¿™é‡Œè¿”å›çš„æ˜¯false.       \n      if (isPrototypeCurrentlyInCreation(beanName)) {\n         throw new BeanCurrentlyInCreationException(beanName);\n      }\n\n      // Check if bean definition exists in this factory.\n //  org.springframework.beans.factory.support.AbstractBeanFactory#getParentBeanFactoryè·å–çˆ¶å·¥å‚,è¿™é‡Œè¿”å›çš„æ˜¯null,ä¹Ÿå°±æ˜¯è¯´æ˜¯æ²¡æœ‰çš„.æ‰€ä»¥ä¸‹é¢çš„ifæ¡ä»¶ä¹Ÿå°±ä¸ä¼šè¿›å».     \n      BeanFactory parentBeanFactory = getParentBeanFactory();\n      if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n         // Not found -> check parent.\n         String nameToLookup = originalBeanName(name);\n         if (parentBeanFactory instanceof AbstractBeanFactory) {\n            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n                  nameToLookup, requiredType, args, typeCheckOnly);\n         }\n         else if (args != null) {\n            // Delegation to parent with explicit args.\n            return (T) parentBeanFactory.getBean(nameToLookup, args);\n         }\n         else if (requiredType != null) {\n            // No args -> delegate to standard getBean method.\n            return parentBeanFactory.getBean(nameToLookup, requiredType);\n         }\n         else {\n            return (T) parentBeanFactory.getBean(nameToLookup);\n         }\n      }\n\n// typeCheckOnly åœ¨æ­¤å¤„çš„å€¼æ˜¯ false.\n//org.springframework.beans.factory.support.AbstractBeanFactory#alreadyCreated,åˆ©ç”¨Seté›†åˆæ¥æ ‡è®°æ˜¯å¦åˆ›å»º,å¯ä»¥çœ‹åˆ°å¾€alreadyCreatedä¸­æ·»åŠ å…ƒç´ è¿›å»çš„æ—¶å€™,è¿˜ä½¿ç”¨äº†synchronizedæ¥åŠ é”åˆ¤æ–­å¹¶ä¸”ä½¿ç”¨äº†åŒé‡if,å¯ä»¥çœ‹åˆ°æˆ‘ä»¬åœ¨æ¥è§¦å•ä¾‹æ¨¡å¼çš„æ—¶å€™ï¼Œä¹Ÿæ˜¯æœ‰ä½¿ç”¨  synchronized + åŒé‡ifçš„.      \n      if (!typeCheckOnly) {\n         markBeanAsCreated(beanName);\n      }\n\n      try {\n// è·å–å‡º bd æ¥,org.springframework.beans.factory.support.AbstractBeanFactory#mergedBeanDefinitions,ä»è¿™ä¸ªConcurrentHashMapä¸­è·å–å‡ºæ¥,ä¹Ÿå°±æ˜¯è¯´è¿™ä¸ªmergedBeanDefinitions Map ä¸­,keyå°±æ˜¯beanName,valueå°±æ˜¯å¯¹åº”çš„bd.          \n         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n          \n// å¯¹ bd è¿›è¡Œæ£€æŸ¥,å¦‚æœæ˜¯æŠ½è±¡çš„è¯,å°±ä¼šæŠ›å‡ºå¼‚å¸¸æ¥.          \n         checkMergedBeanDefinition(mbd, beanName, args);\n\n         // Guarantee initialization of beans that the current bean depends on.\n // è·å– @DependsOn æ³¨è§£.å¹¶ä¸”å¯¹ @Dependsè¿›è¡Œå¤„ç†.         \n         String[] dependsOn = mbd.getDependsOn();\n         if (dependsOn != null) {\n            for (String dep : dependsOn) {\n               if (isDependent(beanName, dep)) {\n                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        \"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\");\n               }\n               registerDependentBean(dep, beanName);\n               try {\n                  getBean(dep);\n               }\n               catch (NoSuchBeanDefinitionException ex) {\n                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        \"'\" + beanName + \"' depends on missing bean '\" + dep + \"'\", ex);\n               }\n            }\n         }\n\n         // Create bean instance.\n // ç¡®ä¿ bd æ˜¯å•ä¾‹çš„.     \n         if (mbd.isSingleton()) {\n            sharedInstance = getSingleton(beanName, () -> {\n               try {\n                  return createBean(beanName, mbd, args);\n               }\n               catch (BeansException ex) {\n                  // Explicitly remove instance from singleton cache: It might have been put there\n                  // eagerly by the creation process, to allow for circular reference resolution.\n                  // Also remove any beans that received a temporary reference to the bean.\n                  destroySingleton(beanName);\n                  throw ex;\n               }\n            });\n             \n// è·å–beanå®ä¾‹             \n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n         }\n// è¿™é‡Œæ˜¯å®ä¾‹åŒ–ä¸€ä¸ª å¤šåˆ—çš„ bean\n         else if (mbd.isPrototype()) {\n            // It's a prototype -> create a new instance.\n            Object prototypeInstance = null;\n            try {\n               beforePrototypeCreation(beanName);\n               prototypeInstance = createBean(beanName, mbd, args);\n            }\n            finally {\n               afterPrototypeCreation(beanName);\n            }\n            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n         }\n\n         else {\n// è¿™é‡Œæ“ä½œçš„,ä¸ä»…å•åˆ—ä¹Ÿä¸æ˜¯å¤šåˆ—.\n            String scopeName = mbd.getScope();\n            final Scope scope = this.scopes.get(scopeName);\n            if (scope == null) {\n               throw new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\");\n            }\n            try {\n               Object scopedInstance = scope.get(beanName, () -> {\n                  beforePrototypeCreation(beanName);\n                  try {\n                     return createBean(beanName, mbd, args);\n                  }\n                  finally {\n                     afterPrototypeCreation(beanName);\n                  }\n               });\n               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n            }\n            catch (IllegalStateException ex) {\n               throw new BeanCreationException(beanName,\n                     \"Scope '\" + scopeName + \"' is not active for the current thread; consider \" +\n                     \"defining a scoped proxy for this bean if you intend to refer to it from a singleton\",\n                     ex);\n            }\n         }\n      }\n      catch (BeansException ex) {\n         cleanupAfterBeanCreationFailure(beanName);\n         throw ex;\n      }\n   }\n\n   // Check if required type matches the type of the actual bean instance.\n // ä¸æ»¡è¶³æ¡ä»¶,æ‰€ä»¥æ²¡è¿›å…¥åˆ°è¿™é‡Œ.   \n   if (requiredType != null && !requiredType.isInstance(bean)) {\n      try {\n         T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);\n         if (convertedBean == null) {\n            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n         }\n         return convertedBean;\n      }\n      catch (TypeMismatchException ex) {\n         if (logger.isTraceEnabled()) {\n            logger.trace(\"Failed to convert bean '\" + name + \"' to required type '\" +\n                  ClassUtils.getQualifiedName(requiredType) + \"'\", ex);\n         }\n         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n      }\n   }\n\n// ç›´æ¥è¿”å›äº† bean ä¿¡æ¯.    \n   return (T) bean;\n}\n```\n\ndoGetBeanæ–¹æ³• : å¯ä»¥çœ‹åˆ°è¯¥æ–¹æ³•ä¸»è¦æ˜¯å¯¹ bean åˆ†ä¸ºä¸‰ç§ç±»å‹æ¥è¿›è¡Œåˆå§‹åŒ– , åˆ†åˆ«æ˜¯ mbd.isSingleton/mbd.isPrototype()/éå‰äºŒè€… è¿™ä¸‰ç§æƒ…å†µ. åœ¨åˆ†è¿™ä¸‰ç§æƒ…å†µä¹‹å‰,è¿˜å¯¹@DependsOn æ³¨è§£æ¥è¿›è¡Œåˆ†æ,ä¹Ÿå°±è¯´å½“ä½ åˆå§‹åŒ–è¿™ä¸ªbeançš„æ—¶å€™,å¦‚æœå®ƒä¾èµ–äº†ä¸€ä¸ªå®å¤–çš„bean,å°±ä¼šå…ˆå»åˆå§‹åŒ–å®å¤–ä¸€ä¸ªbean,ä¹Ÿå°±æ˜¯è°ƒç”¨äº† getBean æ–¹æ³•, è€ŒgetBeanæ–¹æ³•å°±æ˜¯èµ°çš„ doGetBean() â€”> createBean() ä¹Ÿå°±æ˜¯èµ°åˆ°äº†è‡ªèº«è¿™é‡Œ,æ˜¯ä¸€ç§é€’å½’è°ƒç”¨.\n\nç„¶åæˆ‘ä»¬è¿™é‡Œæ˜¯å•ä¾‹çš„,è‡ªç„¶å°±å¾€ä¸‹èµ°äº† createBean æ–¹æ³•.\n\n###### createBean() æ–¹æ³•\n\nä»åå­—æ¥çœ‹,è¿˜æ˜¯å¯ä»¥å¾ˆå¾ˆé—²çš„æ„Ÿå—åˆ°,æ˜¯åˆ›å»ºbeançš„æ–¹æ³•.\n\n```java\n/**\n * Central method of this class: creates a bean instance,\n * populates the bean instance, applies post-processors, etc.\n * @see #doCreateBean\n */\n@Override\nprotected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n      throws BeanCreationException {\n\n   if (logger.isTraceEnabled()) {\n      logger.trace(\"Creating instance of bean '\" + beanName + \"'\");\n   }\n   RootBeanDefinition mbdToUse = mbd;\n\n   // Make sure bean class is actually resolved at this point, and\n   // clone the bean definition in case of a dynamically resolved Class\n   // which cannot be stored in the shared merged bean definition.\n// ç¡®å®šbeançš„class, å¦‚æœbdæœ‰beanClassçš„ä¿¡æ¯,å°±ä¼šç›´æ¥è¿”å›.    \n   Class<?> resolvedClass = resolveBeanClass(mbd, beanName);\n//å¦‚æœè¿™é‡Œä»bdè·å–å‡ºæ¥çš„classæ˜¯æœ‰å€¼çš„,ç„¶åbdæ˜¯æ²¡æœ‰beanCalss,è·å–å‡ºæ¥çš„beanClassNameä¹Ÿæ˜¯nullçš„è¯,é‚£ä¹ˆè¿™é‡Œå°±ä¼šé‡æ–°æ¥æ„å»ºå‡ºä¸€ä¸ªbd,å¹¶ä¸”è®¾ç½®ä¸Š beanClassä¿¡æ¯.    \n   if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {\n      mbdToUse = new RootBeanDefinition(mbd);\n      mbdToUse.setBeanClass(resolvedClass);\n   }\n\n   // Prepare method overrides.\n// å‡†å¤‡é‡å†™çš„æ–¹æ³•ä¿¡æ¯,å…ˆåˆ¤æ–­æ˜¯ä¸æ˜¯æœ‰é‡å†™çš„æ–¹æ³•,    \n   try {\n      mbdToUse.prepareMethodOverrides();\n   }\n   catch (BeanDefinitionValidationException ex) {\n      throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),\n            beanName, \"Validation of method overrides failed\", ex);\n   }\n\n   try {\n// è¿™æ˜¯ Spring ç³»ç»Ÿé»˜è®¤çš„åç½®å¤„ç†å™¨,æ˜¯æœ‰å…­ä¸ªçš„.       \n// ApplicationContextAwareProcessor ,  ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor , PostProcessorRegistrationDelegate$BeanPostProcessorCheck , CommonAnnotationBeanPostProcessor ,  AutowiredAnnotationBeanPostProcessor ,  ApplicationListenerDetector ,        \n       \n      // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.\n// Apply before-instantiation post-processors, resolving whether there is a before-instantiation shortcut for the specified bean. å¯ä»¥çœ‹åˆ°è¿™é‡Œæœ‰ä¸ªåº”ç”¨å®ä¾‹åŒ–å‰çš„å¤„ç†å™¨,\n//org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation,å¯ä»¥çœ‹åˆ°è¿™ä¸ªæ–¹æ³•é‡Œé¢,æ»¡è¶³æ¡ä»¶çš„è¯,ä¼šè°ƒç”¨applyBeanPostProcessorsBeforeInstantiation() / applyBeanPostProcessorsAfterInitialization() è¿™äºŒä¸ªæ–¹æ³•çš„.\n// èµ°å®Œ applyBeanPostProcessorsBeforeInstantiation æ–¹æ³•,å¦‚æœå‰ç½®å¤„ç†å™¨èƒ½å¤Ÿè¿”å›beanå›æ¥å¹¶ä¸”ä¸æ˜¯nullçš„è¯,å°±ä¼šç»§ç»­èµ°applyBeanPostProcessorsAfterInitializationæ–¹æ³•.\n// æˆ‘ä»¬è¿™é‡Œè¿”å›çš„ bean æ˜¯null,å¦‚æœä¸æ˜¯nullçš„è¯,å°±ä¼šç›´æ¥è¿”å›çš„.       \n      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);\n      if (bean != null) {\n         return bean;\n      }\n   }\n   catch (Throwable ex) {\n      throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,\n            \"BeanPostProcessor before instantiation of bean failed\", ex);\n   }\n\n// ä¸Šé¢çš„å‰ç½®å¤„ç†å™¨applyBeanPostProcessorsBeforeInstantiationè¿”å›çš„beanæ˜¯nullçš„è¯,å°±ä¼šæ¥ç€è¿™ä¸ªä¸‹é¢ç»§ç»­å¾€ä¸‹èµ°.  äºæ˜¯å°±æœ‰äº†èµ° doCreateBean æ–¹æ³•.   \n   try {\n      Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"Finished creating instance of bean '\" + beanName + \"'\");\n      }\n // è¿”å› bean å¯¹è±¡å›å».      \n      return beanInstance;\n   }\n   catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {\n      // A previously detected exception with proper bean creation context already,\n      // or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.\n      throw ex;\n   }\n   catch (Throwable ex) {\n      throw new BeanCreationException(\n            mbdToUse.getResourceDescription(), beanName, \"Unexpected exception during bean creation\", ex);\n   }\n}\n```\n\ncreateBean æ–¹æ³• : å¯ä»¥çœ‹åˆ°createBeanåœ¨åˆ›å»ºä¹‹å‰èµ°äº†å‰ç½®å¤„ç†å™¨,å¦‚æœå‰ç½®å¤„ç†å™¨è¿”å›çš„beanä¸æ˜¯null,é‚£ä¹ˆä¹Ÿå°±æ²¡æœ‰ä¸‹é¢çš„doCreateBeanä»€ä¹ˆäº‹æƒ…äº†. å¦‚æœè¿”å›çš„beanæ˜¯nullçš„è¯,é‚£ä¹ˆå°±ä¼šèµ°åˆ°ä¸‹é¢çš„doCreateBeanæ–¹æ³•,å¯ä»¥ç†è§£ä¸ºè¿™ä¸ªæ–¹æ³•æ‰æ˜¯çœŸæ­£è°ƒç”¨åå°„å»è·å– bean å¯¹è±¡å®ä¾‹çš„æ–¹æ³• , å¹¶ä¸”å…¶è¿”å›å€¼ beanInstance æ˜¯ç›´æ¥è¿”å›è¿”å›å»äº†,ä¹Ÿæ²¡æœ‰åšä»€ä¹ˆå…¶ä»–çš„å¤„ç†.\n\n###### doCreateBean() æ–¹æ³•\n\nå¯ä»¥æ„Ÿè§‰åˆ° doCreateBean å°±æ˜¯çœŸæ­£å®ä¾‹åŒ–beançš„æ–¹æ³•, æ˜¯ä¸æ˜¯Spring åŠ ä¸Šäº† do å¼€å¤´çš„æ–¹æ³•,æ‰æ˜¯çœŸæ­£å¹²æ´»çš„.\n\n```java\n/**\n * Actually create the specified bean. Pre-creation processing has already happened\n * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks.\n * <p>Differentiates between default bean instantiation, use of a\n * factory method, and autowiring a constructor.\n * @param beanName the name of the bean\n * @param mbd the merged bean definition for the bean\n * @param args explicit arguments to use for constructor or factory method invocation\n * @return a new instance of the bean\n * @throws BeanCreationException if the bean could not be created\n * @see #instantiateBean\n * @see #instantiateUsingFactoryMethod\n * @see #autowireConstructor\n */\nprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)\n      throws BeanCreationException {\n\n   // Instantiate the bean.\n   BeanWrapper instanceWrapper = null;\n// ç¡®å®šæ˜¯å•ä¾‹,    \n   if (mbd.isSingleton()) {\n// ä»org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#factoryBeanInstanceCacheç¼“å­˜ä¸­removeæ‰.       \n      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n   }\n   if (instanceWrapper == null) {\n // åˆ›å»º bean çš„å®ä¾‹å¯¹è±¡.\n // å…ˆæ ¹æ® bd è·å–å‡º beanClass,æ ¹æ®beanClassè·å–å‡ºå¦‚æœæ˜¯nullå¹¶ä¸”ä¸æ˜¯publicå¹¶ä¸”æ— å‚æ•°æ„é€ å‡½æ•°ä¸æ˜¯publicçš„è¯,å°±ä¼šæŠ›å‡ºä¸€ä¸ªBeanCreationExceptionå¼‚å¸¸æ¥. \n// ä»bdè·å–å‡ºå®ä¾‹æä¾›è€…ä¿¡æ¯,è¿™é‡Œè·å–å‡ºæ¥çš„æ˜¯Null,æ‰€ä»¥ä¹Ÿå°±ä¸ä¼šå¾€ä¸‹èµ°.\n// è·å– mbd.getFactoryMethodName() æ“ä½œ\n// ç”¨å˜é‡resolved/autowireNecessaryå¸ƒå°”ç±»å‹çš„æ¥æ§åˆ¶ä¸€äº›æµç¨‹,  ç”¨ä¼ å…¥è¿›æ¥çš„argså‚æ•°æ¥å†³å®šæ˜¯èµ°æ— å‚æ„é€ å‡½æ•°è¿˜æ˜¯åœ¨æœ‰å‚æ„é€ å‡½æ•°,å¦‚æœargsæ˜¯nullçš„è¯,å°±èµ°æ— å‚æ•°æ„é€ å‡½æ•°.\n// org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#determineConstructorsFromBeanPostProcessors, è¯¥æ–¹æ³•æ˜¯è·å–å‡ºå…¨éƒ¨çš„ åç½®å¤„ç†å™¨,å¦‚æœåç½®å¤„ç†å™¨æ˜¯ç»§æ‰¿äº†SmartInstantiationAwareBeanPostProcessorçš„è¯,å°±ä¼šèµ°åˆ°åç½®å¤„ç†å™¨çš„determineCandidateConstructorsæ–¹æ³•æ¥,  æ ¹æ® Constructor<?>[] ctors = ibp.determineCandidateConstructors(beanClass, beanName) å¯ä»¥çœ‹åˆ°,æœ€åè¿”å›çš„æ˜¯ä¸€ä¸ªæ„é€ æ–¹æ³•,å¯ä»¥çœ‹åˆ°org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#determineCandidateConstructorsè¿™ä¸ªåœ°æ–¹æ¥. è¿™é‡Œç›®æµ‹æ˜¯å¯¹@Autowiredæ³¨è§£æ³¨å…¥çš„å¯¹è±¡è¿›è¡Œæ“ä½œ.\n//æœ€å,çœ‹åˆ°è¿™ä¸ªæ–¹æ³•:org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#instantiateBean   ---->   org.springframework.beans.factory.support.SimpleInstantiationStrategy#instantiate(org.springframework.beans.factory.support.RootBeanDefinition, java.lang.String, org.springframework.beans.factory.BeanFactory) èµ°åˆ°è¿™é‡Œ, å…ˆåˆ¤æ–­æ²¡æœ‰é‡å†™çš„æ–¹æ³•,æ¥ç€åˆ¤æ–­å¦‚æœæ˜¯æ¥å£çš„è¯,å°±ä¼šæŠ›å‡ºå¼‚å¸¸æ¥,ç”¨constructorToUse = clazz.getDeclaredConstructor();è·å–å‡ºæ„é€ æ–¹æ³•,æœ€åç”¨BeanUtils.instantiateClass(constructorToUse)æ¥å®ä¾‹åŒ–å¯¹è±¡,å¯ä»¥çœ‹åˆ°è¿™è¡Œä»£ç èµ°å®Œ,æˆ‘ä»¬åœ¨æ— å‚æ„é€ å‡½æ•°ä¸­çš„è¾“å‡ºè¯­å¥å°±å¯ä»¥æ‰“å°å‡ºæ¥äº†.  å°†æˆ‘ä»¬å®ä¾‹åŒ–å‡ºæ¥çš„å¯¹è±¡beanInstanceç”¨BeanWrapperImplåŒ…è£…ä¸‹,æ‰€ä»¥è¿™é‡Œæœ€åè¿”å›çš„å°±æ˜¯   BeanWrapperImpl , æ˜¯å¯¹æˆ‘ä»¬çš„ç›®æ ‡å¯¹è±¡è¿›è¡Œä¸€å±‚åŒ…è£…è¿‡äº†çš„.     \n      instanceWrapper = createBeanInstance(beanName, mbd, args);\n   }\n    \n// ä»åŒ…è£…äº†beanInstanceçš„BeanWrapperImplä¸­è·å–å‡ºæ¥beanå’ŒbeanTypeæ¥,    \n   final Object bean = instanceWrapper.getWrappedInstance();\n   Class<?> beanType = instanceWrapper.getWrappedClass();\n    \n// èµ‹å€¼beanTypeç»™mbd.resolvedTargetType    \n   if (beanType != NullBean.class) {\n      mbd.resolvedTargetType = beanType;\n   }\n\n   // Allow post-processors to modify the merged bean definition.\n   synchronized (mbd.postProcessingLock) {\n      if (!mbd.postProcessed) {\n         try {\n // è¿™é‡Œåèµ°äº†ä¸€ä¸ªè°ƒç”¨åç½®å¤„ç†å™¨çš„æ–¹æ³•,æ˜¯MergedBeanDefinitionPostProcessoræ¥å£çš„å­ç±»,å°±ä¼šè°ƒç”¨åˆ°åç½®å¤„ç†å™¨çš„postProcessMergedBeanDefinitionæ–¹æ³•.ä»åå­—ä¸Šçœ‹,æ˜¯å¯¹bdè¿›è¡Œåˆå¹¶çš„å¤„ç†æ“ä½œ.\t            \n            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n         }\n         catch (Throwable ex) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                  \"Post-processing of merged bean definition failed\", ex);\n         }\n         mbd.postProcessed = true;\n      }\n   }\n\n   // Eagerly cache singletons to be able to resolve circular references\n   // even when triggered by lifecycle interfaces like BeanFactoryAware.\n//  bdæ˜¯å•ä¾‹çš„å¹¶ä¸”æ˜¯å¾ªç¯å¼•ç”¨çš„å¹¶ä¸”å•ä¾‹æ˜¯åˆ›å»ºçš„,å°±æ»¡è¶³è¿™ä¸ªæ¡ä»¶,è¿™é‡Œæ˜¯å¤„ç†å¾ªç¯ä¾èµ–é—®é¢˜?è¿˜æ˜¯ç”¨äºå®ç°BeanFactoryAwareè¿™ç§æ¥é¿å…å¾ªç¯ä¾èµ–?    \n   boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\n         isSingletonCurrentlyInCreation(beanName));\n   if (earlySingletonExposure) {\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"Eagerly caching bean '\" + beanName +\n               \"' to allow for resolving potential circular references\");\n      }\n//  æ·»åŠ åˆ° org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#registeredSingletons ä¸­æ¥.       \n      addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));\n   }\n\n   // Initialize the bean instance.\n   Object exposedObject = bean;\n   try {\n// æ„å»ºbean,è¿™é‡Œèµ°äº† InstantiationAwareBeanPostProcessor æ¥å£çš„å®ç°ç±»çš„åç½®å¤„ç†å™¨,å¦‚æœæ»¡è¶³æ¡ä»¶å°±ä¼šèµ°å¤„ç†å™¨çš„postProcessAfterInstantiationæ–¹æ³•,è¯¥æ–¹æ³•ä¼šè¿”å›ä¸€ä¸ªå¸ƒå°”ç±»å‹çš„å€¼,å¦‚æœæ˜¯falseçš„è¯,å°±ä¼šè·³å‡ºå¾ªç¯æ¥çš„.\n// ä¸‹é¢è¿˜ä¼šèµ°ä¸€ä¸ªInstantiationAwareBeanPostProcessoræ¥å£çš„å­ç±»çš„åç½®å¤„ç†å™¨,æ»¡è¶³æ¡ä»¶å°±ä¼šèµ°åç½®å¤„ç†å™¨çš„postProcessPropertiesæ–¹æ³•,å¦‚æœè·å–å‡ºæ¥çš„PropertyValues pvsToUseæ˜¯nullçš„è¯,ä¼šç»§ç»­èµ°åç½®å¤„ç†å™¨çš„postProcessPropertyValuesæ–¹æ³•.       \n      populateBean(beanName, mbd, instanceWrapper);\n//  è¿™é‡Œè°ƒç”¨æ¯ä¸ªåç½®å¤„ç†å™¨çš„ postProcessBeforeInitialization æ–¹æ³•,\n// org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#invokeInitMethods è¯¥æ–¹æ³•å¯ä»¥çœ‹åˆ°(InitializingBean) bean).afterPropertiesSet();å¯¹äºafterPropertiesSetæ–¹æ³•è¿˜æ˜¯æœ‰ç‚¹ç†Ÿæ‚‰çš„.\n//  æ¥ç€å°±æ˜¯è°ƒç”¨æ¯ä¸ªåç½®å¤„ç†å™¨çš„postProcessAfterInitializationæ–¹æ³•,       \n      exposedObject = initializeBean(beanName, exposedObject, mbd);\n       \n// å¯ä»¥çœ‹åˆ°è¿™äºŒä¸ªæ–¹æ³•éƒ½æ˜¯åœ¨è°ƒç”¨åç½®å¤„ç†å™¨æ¥è¿›è¡Œæ‰©å±•.       \n   }\n   catch (Throwable ex) {\n      if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {\n         throw (BeanCreationException) ex;\n      }\n      else {\n         throw new BeanCreationException(\n               mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex);\n      }\n   }\n\n //  earlySingletonExposure is true.  \n   if (earlySingletonExposure) {\n// ä»å•ä¾‹æ± ä¸­æ ¹æ® beanName æ¥è·å–å¯¹è±¡.       \n      Object earlySingletonReference = getSingleton(beanName, false);\n       \n// è·å–å‡ºæ¥çš„å¯¹è±¡ä¸æ˜¯nullçš„è¯,å°±ä¼šè¿›å…¥åˆ°è¿™é‡Œæ¥.       \n      if (earlySingletonReference != null) {\n         if (exposedObject == bean) {\n            exposedObject = earlySingletonReference;\n         }\n         else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {\n            String[] dependentBeans = getDependentBeans(beanName);\n            Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);\n            for (String dependentBean : dependentBeans) {\n               if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n                  actualDependentBeans.add(dependentBean);\n               }\n            }\n            if (!actualDependentBeans.isEmpty()) {\n               throw new BeanCurrentlyInCreationException(beanName,\n                     \"Bean with name '\" + beanName + \"' has been injected into other beans [\" +\n                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +\n                     \"] in its raw version as part of a circular reference, but has eventually been \" +\n                     \"wrapped. This means that said other beans do not use the final version of the \" +\n                     \"bean. This is often the result of over-eager type matching - consider using \" +\n                     \"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\");\n            }\n         }\n      }\n   }\n\n   // Register bean as disposable.\n   try {\n // å¦‚æœæœ‰å¿…è¦çš„è¯,æ³¨å†Œä»»æ„beanä¿¡æ¯.      \n      registerDisposableBeanIfNecessary(beanName, bean, mbd);\n   }\n   catch (BeanDefinitionValidationException ex) {\n      throw new BeanCreationException(\n            mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex);\n   }\n\n   return exposedObject;\n}\n```\n\ndoCreateBean() æ–¹æ³• : è¯¥æ–¹æ³•æ‰æ˜¯æ­£åœ¨å»èµ°åå°„æ¥å®ä¾‹åŒ–beançš„. å¹¶ä¸”åœ¨å®ä¾‹åŒ–è¿™ä¸ªbeanä¹‹å‰å’Œä¹‹å,éƒ½æ˜¯æœ‰è°ƒç”¨è®¸å¤šåç½®å¤„ç†å™¨çš„,ä¹Ÿå°±æ˜¯è¿™ä¸ªbeanè¿›è¡Œä¸€äº›å¢å¼ºæˆ–è€…å…¶ä»–çš„å¤„ç†. ä»ç°åœ¨æ¥çœ‹,éƒ½æ˜¯Springå†…ç½®çš„å¤„ç†å™¨.æˆ‘ä»¬åé¢å¯ä»¥è·Ÿç€Springé‡Œé¢çš„å†™æ³•,æ¥åšç›¸åŒçš„æ‰©å±•å¤„ç†.\n\n#### æ€»ç»“\n\n å…¶å®å¯ä»¥çœ‹åˆ°,æˆ‘ä»¬é€šè¿‡è¿™ç§æ–¹å¼ç»™æˆ‘ä»¬å®šä¹‰çš„ bean ç»™æ³¨å…¥åˆ° Spring å®¹å™¨ä¸­, å…ˆæ˜¯é€šè¿‡æˆ‘ä»¬å®šä¹‰çš„ @ComponentScan(basePackages = â€œcom.iyang.bean.bdâ€) æ¥æ‰«æï¼Œç„¶åå°†æ‰«æå¾—åˆ°çš„ä¿¡æ¯ç»™æ·»åŠ åˆ°Springçš„ä¿¡æ¯æ± é‡Œé¢,ä¹Ÿå°±æ˜¯æ·»åŠ åˆ°é›†åˆä¸­æ¥äº†. æœ€ååœ¨getBean æ–¹æ³•ä¸­, é€šè¿‡æ‰«æè·å–åˆ°çš„beanNamesé›†åˆè¿›è¡Œè¿­ä»£ï¼Œç„¶åæŒ¨ä¸ªè°ƒç”¨getBean()æ–¹æ³•æ¥å®ä¾‹åŒ–bean, getBean() æ–¹æ³•ä¸­åˆèµ°äº† doGetBean () â€”-> createBean() â€”> doCreateBean() æ–¹æ³•ï¼Œ ç„¶åæ¯ä¸ªæ–¹æ³•æœ‰å„è‡ªè¦åšçš„äº‹æƒ…ï¼Œå¹¶ä¸”ä¹Ÿä¼šèµ°ç›¸åº”çš„åç½®å¤„ç†å™¨.\n\n æœ€åï¼Œè¿™æ˜¯ä¸€ä¸ªæ¯”è¾ƒè¯¦ç»†çš„getBeanåˆ†æï¼Œä½†æ˜¯è¿˜æœ‰æ›´æ·±å…¥çš„ , æ¯”å¦‚ : @Autowired / @DependsOn / å¾ªç¯ä¾èµ–ç­‰æ³¨å…¥ï¼Œéœ€è¦æ‰©å±•æ¥è®².\n","tags":["java","spring"],"categories":["java","spring"]},{"title":"LinkedListæºç é˜…è¯»è®°å½•","url":"/2021/11/04/java/LinkedListæºç é˜…è¯»è®°å½•/","content":"\n\n\nè™½ç„¶ä¸€èˆ¬éƒ½æ˜¯ä½¿ç”¨ArrayListé›†åˆæ¯”ä½¿ç”¨LinkedListé›†åˆè¦å¤š,ä½†æ˜¯è¿™å¹¶ä¸å¦¨ç¢æˆ‘ä»¬å¯¹LinkedListçš„æºç ç ”ç©¶å’Œå­¦ä¹ \n\n### ç»“æ„\n\nLinkedList æ˜¯ä¸€ä¸ªåŒå‘é“¾è¡¨çš„ç»“æ„,è¿™ç‚¹å¯ä»¥ç›´æ¥çœ‹å…¶å†…éƒ¨å†…å°±å¯ä»¥éå¸¸æ˜æ˜¾çš„çœ‹å‡ºæ¥. é™æ€ç§æœ‰çš„å†…éƒ¨ç±»,åªæä¾›ä¸€ä¸ªæ„é€ å‡½æ•°.\n\n```\nprivate static class Node<E> {\n    E item;\n    Node<E> next;\n    Node<E> prev;\n\n    Node(Node<E> prev, E element, Node<E> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n\nç„¶åæˆ‘ä»¬çœ‹ LinkedList è‡ªèº«çš„å˜é‡. size è‚¯å®šæ˜¯è®°å½•è¿™ä¸ªé“¾è¡¨çš„é•¿åº¦,ä¸ç„¶åˆ°æ—¶å€™node.next.nextâ€¦.è·å–é•¿åº¦å°±å¾ˆå¾—ä¸å¿å¤±äº†. ç„¶åè®°å½•äº†ä¸€ä¸ªå¤´èŠ‚ç‚¹å’Œå°¾èŠ‚ç‚¹ï¼Œä¸ªäººè®¤ä¸ºè¿™æ˜¯æ–¹ä¾¿éå†ã€‚ä»å¤´å¼€å§‹éå†å°±ä»firstèŠ‚ç‚¹è·å–,ä»å°¾éƒ¨å¼€å§‹éå†çš„è¯,å°±ä»lastå¼€å§‹è·å–.\n\n```\ntransient int size = 0;\n\n/**\n * Pointer to first node.\n * Invariant: (first == null && last == null) ||\n *            (first.prev == null && first.item != null)\n */\ntransient Node<E> first;\n\n/**\n * Pointer to last node.\n * Invariant: (first == null && last == null) ||\n *            (last.next == null && last.item != null)\n */\ntransient Node<E> last;\n```\n\n------\n\n### æ–¹æ³•\n\n- add æ–¹æ³•\n\n  addæ–¹æ³•è°ƒç”¨ä¸€ä¸ªlinkLastæ–¹æ³•,ç„¶åå°±è¿”å›trueäº†. ä¹Ÿå°±æ˜¯è¯´add(E e)å°±æ˜¯é»˜è®¤ä»å°¾éƒ¨å¼€å§‹æ’å…¥å…ƒç´ è¿›å».\n\n  ```\n  public boolean add(E e) {\n      linkLast(e);\n      return true;\n  }\n  \n      /**\n       * Links e as last element.\n         ç¿»è¯‘ : é“¾æ¥eä½œä¸ºæœ€åä¸€ä¸ªå…ƒç´ ã€‚\n         å…ˆå¯¹lastèµ‹å€¼ç»™ Node<E> l , ç„¶åè°ƒç”¨new Node<>(l,e,null);ä¼ å…¥è¿›å»çš„ä¸Šä¸ªèŠ‚ç‚¹,ä¹Ÿå°±æ˜¯l,ä¸Šæ¬¡ä¿å­˜çš„å°¾éƒ¨èŠ‚ç‚¹,ä¹Ÿå°±æ˜¯ä»å€’æ•°ç¬¬ä¸€å˜ä¸ºäº†å€’æ•°äºŒ,è¿™æ ·ç†è§£ã€‚ç„¶åæ­¤æ—¶çš„newNodeå°±æ˜¯å°¾èŠ‚ç‚¹äº†,ç„¶åèµ‹å€¼ç»™last,å› ä¸ºlastæ¯æ¬¡è®°å½•çš„éƒ½æ˜¯å°¾èŠ‚ç‚¹.\n         if else ä¸­æ˜¯å¯¹ä¹‹å‰çš„å°¾èŠ‚ç‚¹è¿›è¡Œåˆ¤æ–­,å¦‚æœæ˜¯nullçš„è¯,è¯´æ˜æ­¤æ—¶å°±æ˜¯æ·»åŠ çš„ç¬¬ä¸€ä¸ªå…ƒç´ ,firstä¹Ÿèµ‹å€¼ç»™newNode,å¦åˆ™çš„è¯,l.next å’Œ å°¾èŠ‚ç‚¹è¿›è¡Œå…³è”ã€‚\n         size é•¿åº¦åŠ ä¸€\n       */\n  void linkLast(E e) {\n          final Node<E> l = last;\n          final Node<E> newNode = new Node<>(l, e, null);\n          last = newNode;\n          if (l == null)\n              first = newNode;\n          else\n              l.next = newNode;\n          size++;\n          modCount++;\n      }\n  ```\n\næ ¹æ®ä¸‹æ ‡æ·»åŠ  add(int index,E element)\n\n```\n/**\n\t1: æ£€æŸ¥ä¼ å…¥è¿›æ¥çš„ä¸‹æ ‡æ˜¯å¦è¶Šç•Œäº†,å¦‚æœä¸‹æ ‡è¶Šç•Œçš„è¯,å°±ä¼šæŠ›å‡º ä¸‹æ ‡è¶Šç•Œçš„å¼‚å¸¸\n\t2: æ ¹æ®ä¼ å…¥è¿›æ¥çš„ä¸‹æ ‡å€¼,åˆ¤æ–­æ˜¯å¦å’Œ size ç›¸ç­‰,å¦‚æœæ˜¯ç›¸ç­‰çš„è¯,å°±è¯´æ˜æ˜¯å°¾éƒ¨æ’å…¥,å°±ä¸éœ€è¦æŒ¨ä¸ªè¿­ä»£å»è·å–å¯¹åº”çš„ä¸‹æ ‡å€¼å¯¹åº”çš„èŠ‚ç‚¹.æ»¡è¶³æ¡ä»¶,å°±ä¼šè°ƒç”¨ä¸Šé¢è¯´åˆ°çš„ linkLastæ–¹æ³•\n\t3: ä¸æ»¡è¶³æ¡ä»¶2çš„è¯,å°±ä¼šèµ°lineBefore()æ–¹æ³•,å…¶ä¸­ä¹Ÿè°ƒç”¨åˆ°äº†.ä¼ å…¥ä¸‹æ ‡è°ƒç”¨nodeæ–¹æ³•.nodeä¼šè¿”å›å¯¹åº”ä¸‹æ ‡çš„å€¼,æ ¹æ®è¿”å›çš„èŠ‚ç‚¹å’Œå½“å‰çš„å€¼è°ƒç”¨lienkBeforeæ–¹æ³•.\n*/\npublic void add(int index, E element) {\n    checkPositionIndex(index);\n\n    if (index == size)\n        linkLast(element);\n    else\n        linkBefore(element, node(index));\n}\n\nprivate void checkPositionIndex(int index) {\n        if (!isPositionIndex(index))\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\n\n private boolean isPositionIndex(int index) {\n        return index >= 0 && index <= size;\n}\n\n/**\n\tsize >> 1 ; æ˜¯å¯¹ size è¿›è¡Œå»åŠ, æ¯”å¦‚ 6 >> 1 æ˜¯ 3ï¼Œ 5 >> 1 æ˜¯2\n\tå¦‚æœå°äºä¸€åŠçš„è¯,å°±ä¼šä»firstèŠ‚ç‚¹å¼€å§‹éå†,ä¹Ÿå°±æ˜¯ä»å¤´èŠ‚ç‚¹å¼€å§‹éå†,å¦åˆ™å°±æ˜¯ä»å°¾èŠ‚ç‚¹å¼€å§‹éå†.\n\tè¿™ä¸ªæ–¹æ³•å¯ä»¥çœ‹åˆ°,ä»å¤´å¼€å§‹éå†çš„è¯,å°±æ˜¯è°ƒç”¨çš„next,å¦‚æœå°¾éƒ¨éå†çš„è¯,è°ƒç”¨çš„å°±æ˜¯prevã€‚æ‰¾åˆ°å¯¹åº”ä¸‹æ ‡çš„èŠ‚ç‚¹å¹¶ä¸”è¿”å›å›å».\n*/\nNode<E> node(int index) {\n        // assert isElementIndex(index);\n\n        if (index < (size >> 1)) {\n            Node<E> x = first;\n            for (int i = 0; i < index; i++)\n                x = x.next;\n            return x;\n        } else {\n            Node<E> x = last;\n            for (int i = size - 1; i > index; i--)\n                x = x.prev;\n            return x;\n        }\n}\n\n/**\n\tè·å–èŠ‚ç‚¹çš„ä¸Šä¸ªèŠ‚ç‚¹èµ‹å€¼ç»™predï¼Œå…¶å®ç±»ä¼¼äºpredè¿™ç§,éƒ½æ˜¯ç”¨äºå˜é‡æ›¿æ¢åˆ›å»ºå‡ºæ¥çš„.\n\tä¸Šä¸€ä¸ªèŠ‚ç‚¹,å½“å‰å€¼e,succèŠ‚ç‚¹æ¥newä¸€ä¸ªæ–°çš„èŠ‚ç‚¹å‡ºæ¥.\n\tsucc.prev æŒ‡å‘å½“å‰newå‡ºæ¥çš„èŠ‚ç‚¹\n\tå¯¹predåˆ¤æ–­æ˜¯å¦æ˜¯null,å¦‚æœæ˜¯nullçš„è¯,å°±è¯´æ˜æ˜¯ç¬¬ä¸€ä¸ªå€¼,å¦åˆ™å°±æ˜¯èµ‹å€¼ä¸Špredä¸ªèŠ‚ç‚¹çš„next\n\t,size ++ å°±æ˜¯å¯¹é•¿åº¦ ++ \n*/\nvoid linkBefore(E e, Node<E> succ) {\n        // assert succ != null;\n        final Node<E> pred = succ.prev;\n        final Node<E> newNode = new Node<>(pred, e, succ);\n        succ.prev = newNode;\n        if (pred == null)\n            first = newNode;\n        else\n            pred.next = newNode;\n        size++;\n        modCount++;\n    }\n```\n\nå¤´æ’å…¥ å’Œ å°¾æ’å…¥\n\nå¤´æ’å…¥ï¼Œå°†å€¼æ’å…¥åˆ°å¤´éƒ¨\n\n```\npublic void addFirst(E e) {\n    linkFirst(e);\n}\n\n/**\n\tå…ˆå°†first èµ‹å€¼ç»™ f ,  æ ¹æ®ä¼ å…¥è¿›æ¥çš„å€¼e å’Œ ä¸‹ä¸€ä¸ªèŠ‚ç‚¹f(å‰ä¸€ä¸ªå¤´èŠ‚ç‚¹),newä¸€ä¸ªæ–°çš„newNodeèŠ‚ç‚¹å‡ºæ¥,firstæŒ‡å‘newNode.å¦‚æœfæ˜¯nullçš„è¯å°±è¯´æ˜æ˜¯åˆå§‹åŒ–,å¦‚æœä¸æ˜¯nullçš„è¯,fçš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘newNode,åˆšåˆšç¨‹åºnewNodeå‡ºæ¥çš„.å°±å®Œæˆäº†å¤´èŠ‚ç‚¹çš„æ’å…¥\n*/\nprivate void linkFirst(E e) {\n        final Node<E> f = first;\n        final Node<E> newNode = new Node<>(null, e, f);\n        first = newNode;\n        if (f == null)\n            last = newNode;\n        else\n            f.prev = newNode;\n        size++;\n        modCount++;\n    }\n```\n\nå°¾èŠ‚ç‚¹æ’å…¥;ä¸å¤´èŠ‚ç‚¹ç›¸ä¼¼ï¼Œä¹Ÿæ˜¯åˆ©ç”¨å˜é‡lastæ¥å®ç°å°¾éƒ¨æ’å…¥.\n\n```\npublic void addLast(E e) {\n    linkLast(e);\n}\n\nvoid linkLast(E e) {\n        final Node<E> l = last;\n        final Node<E> newNode = new Node<>(l, e, null);\n        last = newNode;\n        if (l == null)\n            first = newNode;\n        else\n            l.next = newNode;\n        size++;\n        modCount++;\n    }\n```\n\n- get æ–¹æ³•,è·å–å€¼æ–¹æ³•\n\n  æ ¹æ®ä¸‹æ ‡æ¥è·å–å‡ºå€¼ ,ç„¶åè°ƒç”¨nodeæ–¹æ³•è·å–å‡ºèŠ‚ç‚¹,node.itemå°±æ˜¯æˆ‘ä»¬éœ€è¦çš„å€¼,ç„¶åå¯¹å…¶è¿›è¡Œè¿”å›å³å¯.\n\n  ```\n  public E get(int index) {\n      checkElementIndex(index);\n      return node(index).item;\n  }\n  \n  // å¦‚æœè¾“å…¥indexæ˜¯å°äº0å’Œå¤§äºsizeçš„è¯,å°±ä¼šçˆ†å‡ºä¸‹æ ‡è¶Šç•Œçš„é”™è¯¯.\n  private void checkElementIndex(int index) {\n          if (!isElementIndex(index))\n              throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n  }\n  ```\n\n\n\ngetFirst / getLast å¯ä»¥çœ‹åˆ°firstå’Œ lastéƒ½æ˜¯ç›´æ¥ä»å®šä¹‰çš„å˜é‡ä¸­è·å–å‡ºå¯¹åº”çš„å€¼\n\n```\npublic E getFirst() {\n    final Node<E> f = first;\n    if (f == null)\n        throw new NoSuchElementException();\n    return f.item;\n}\n\n    public E getLast() {\n        final Node<E> l = last;\n        if (l == null)\n            throw new NoSuchElementException();\n        return l.item;\n    }\n```\n\n peek æ–¹æ³•;ä½¿ç”¨firstèŠ‚ç‚¹,å¦‚æœæ˜¯nullçš„è¯å°±ä¼šè¿”å›nullï¼Œå¦åˆ™å°±æ˜¯f.item. è¿™é‡Œæ˜¯æ²¡æœ‰åˆ é™¤firstå…ƒç´ ,pollæ˜¯å¼¹å‡ºå…ƒç´ å¹¶ä¸”åˆ é™¤.\n\n```\npublic E peek() {\n    final Node<E> f = first;\n    return (f == null) ? null : f.item;\n}\n```\n\n poll æ–¹æ³• : è¿™é‡Œä¸»è¦çœ‹unlinkFirstæ–¹æ³•.\n\n```java\npublic E poll() {\n    final Node<E> f = first;\n    return (f == null) ? null : unlinkFirst(f);\n}\n\n/**\n   å–å‡º f çš„item,èŠ‚ç‚¹å¯¹åº”çš„å€¼å’Œ fçš„nextä¸ªèŠ‚ç‚¹,å¦‚æœä¸‹ä¸ªèŠ‚ç‚¹æ˜¯nullçš„è¯,å°±è¯´æ˜æ˜¯æ²¡æœ‰å€¼çš„,å¦‚æœä¸ä¸ºnullçš„è¯ï¼Œè¯´å°†nextçš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹prevæŒ‡å‘null,å› ä¸ºå¤´èŠ‚ç‚¹çš„prevå’Œå°¾èŠ‚ç‚¹çš„nextéƒ½æ˜¯nullæ¥è¿›è¡ŒåŒºåˆ†ã€‚\n*/\nprivate E unlinkFirst(Node<E> f) {\n        // assert f == first && f != null;\n        final E element = f.item;\n        final Node<E> next = f.next;\n        f.item = null;\n        f.next = null; // help GC\n        first = next;\n        if (next == null)\n            last = null;\n        else\n            next.prev = null;\n        size--;\n        modCount++;\n        return element;\n    }\n```\n\n offer ç­‰æ–¹æ³•éƒ½æ˜¯å†…éƒ¨è°ƒç”¨äº†add / addFirst / addLastç­‰æ–¹æ³•.\n\n- remove æ–¹æ³•\n\n  æ ¹æ®ä¸‹æ ‡è¿›æ¥removeæ–¹æ³•, node(index) ä¹Ÿæ˜¯åœ¨ä¸Šé¢è¿›è¡Œè®²åˆ°çš„,å°±æ˜¯æ ¹æ®ä¸‹æ ‡è·å–å¯¹åº”çš„nodeèŠ‚ç‚¹ä¿¡æ¯.\n\n  ```java\n  public E remove(int index) {\n      checkElementIndex(index);\n      return unlink(node(index));\n  }\n  \n  /**\n  \tè¿™é‡Œè·å–å‡ºèŠ‚ç‚¹çš„ next å’Œ prevæ–¹æ³•.\n  \tè¯¥èŠ‚ç‚¹çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹(prev)çš„nextéœ€è¦æŒ‡å‘æŒ‡å‘è¯¥èŠ‚ç‚¹çš„ä¸‹ä¸ªèŠ‚ç‚¹(next),è¯¥èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å’Œprevçš„æ“ä½œæ˜¯ç›¸åçš„,å› ä¸ºè¿™æ ·çš„è¯,å°±åˆ é™¤äº†è¯¥èŠ‚ç‚¹,å¹¶ä¸”ä¸Šä¸€ä¸ªèŠ‚ç‚¹å’Œä¸‹ä¸€ä¸ªèŠ‚ç‚¹å…³è”èµ·æ¥äº†.\t\n  */\n   E unlink(Node<E> x) {\n          // assert x != null;\n          final E element = x.item;\n          final Node<E> next = x.next;\n          final Node<E> prev = x.prev;\n  \n          if (prev == null) {\n              first = next;\n          } else {\n              prev.next = next;\n              x.prev = null;\n          }\n  \n          if (next == null) {\n              last = prev;\n          } else {\n              next.prev = prev;\n              x.next = null;\n          }\n  \n          x.item = null;\n          size--;\n          modCount++;\n          return element;\n  }\n  ```\n\nremove(Object o) æ ¹æ®å€¼æ¥è¿›è¡Œåˆ é™¤.è¿™ä¸ªå¯ä»¥çœ‹å‡ºæ¥ï¼Œå¦‚æœæœ‰äºŒä¸ªç›¸åŒèŠ‚ç‚¹çš„å€¼,è°ƒç”¨ä¸€æ¬¡è¿™ä¸ªæ–¹æ³•æ˜¯åªå¯ä»¥åˆ é™¤ä¸€ä¸ª,è€Œä¸æ˜¯äºŒä¸ª.\n\n```java\npublic boolean remove(Object o) {\n    if (o == null) {\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (x.item == null) {\n                unlink(x);\n                return true;\n            }\n        }\n    } else {\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (o.equals(x.item)) {\n                unlink(x);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\n------\n\n### æ€»ç»“\n\nå¥½å•¦,ä»Šå¤©çš„çŸ¥è¯†å†…å®¹å°±æ›´æ–°åˆ°è¿™é‡Œ,è™½ç„¶æ–‡å­—æè¿°åˆ°å¾ˆéš¾ç†è§£,ä½†æ˜¯ä¸»è¦å»ç†è§£ Node èŠ‚ç‚¹çš„ åŒå‘æŒ‡å‘,å¹¶ä¸”æ¯æ¬¡æ·»åŠ èŠ‚ç‚¹å’Œåˆ é™¤æ·»åŠ ï¼Œéƒ½æ˜¯é Nodeçš„prevå’Œnextæ¥è¿›è¡ŒæŒ‡å‘. æ‰€ä»¥è¯´LinkedListæ˜¯åˆ é™¤å¿«ï¼ŒæŸ¥è¯¢æ…¢çš„åŸå› ã€‚\n","tags":["java","javaé›†åˆ"],"categories":["java","javaé›†åˆ"]},{"title":"HashMapæºç é˜…è¯»è®°å½•","url":"/2021/11/04/java/HashMapæºç é˜…è¯»è®°å½•/","content":"\nHashMap è¿™ç§Key,Value çš„å­˜å‚¨ç»“æ„,æ˜¯æˆ‘ä»¬åœ¨å†™ä»£ç ä¸­ç»å¸¸ä½¿ç”¨åˆ°çš„.å¯ä»¥è¯´ä½¿ç”¨æ˜¯éå¸¸é¢‘ç¹çš„,ä¸è¿‡ç°åœ¨ä½¿ç”¨JSONObjectä¹Ÿæ˜¯éå¸¸å¤šçš„,äºŒè€…éƒ½æ˜¯å®ç°äº†Mapæ¥å£ã€‚\n\næ‰€ä»¥çœ‹ä¸‹HashMapæºç æ˜¯éå¸¸æœ‰å¿…è¦çš„.\n\n------\n\n#### ç»“æ„\n\nè¿™é‡Œæˆ‘ä»¬è¦çœ‹ä¸‹ HashMapçš„å†…éƒ¨ç±».\n\nè¿™é‡Œçš„ Node èŠ‚ç‚¹å°±æ˜¯ HashMapå­˜æ”¾æ•°æ®çš„ç»“æ„. hash è®¡ç®—å‡ºæ¥çš„å“ˆå¸Œå€¼,keyå°±æ˜¯HashMapä¸­çš„key,valueå°±æ˜¯keyå¯¹åº”çš„valueçš„å€¼. è¿™ä¸ª next å°±æ˜¯ key ä¸ä¸€æ ·,è®¡ç®—å‡ºæ¥çš„hashå´æ˜¯ä¸€æ ·çš„,è¿™æ ·å°±æœ‰äº†hashå†²çª,æ‰€ä»¥å°±å°†èŠ‚ç‚¹å­˜æ”¾åœ¨nexté‡Œé¢äº†,ä»å°¾éƒ¨æ’å…¥è¿›å». java8 å,å¦‚æœnextçš„é•¿åº¦æ˜¯å¤§äº8çš„è¯,å°±ä¼šè½¬åŒ–äº†çº¢é»‘æ ‘æ¥å­˜å‚¨,é‚£æ ·è·å–å€¼çš„é€Ÿåº¦å˜å¿«äº†ã€‚\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;\n    final K key;\n    V value;\n    Node<K,V> next;\n\n    Node(int hash, K key, V value, Node<K,V> next) {\n        this.hash = hash;\n        this.key = key;\n        this.value = value;\n        this.next = next;\n    }\n\n    public final K getKey()        { return key; }\n    public final V getValue()      { return value; }\n    public final String toString() { return key + \"=\" + value; }\n\n    public final int hashCode() {\n        return Objects.hashCode(key) ^ Objects.hashCode(value);\n    }\n\n    public final V setValue(V newValue) {\n        V oldValue = value;\n        value = newValue;\n        return oldValue;\n    }\n\n    public final boolean equals(Object o) {\n        if (o == this)\n            return true;\n        if (o instanceof Map.Entry) {\n            Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n            if (Objects.equals(key, e.getKey()) &&\n                Objects.equals(value, e.getValue()))\n                return true;\n        }\n        return false;\n    }\n}\n```\n\nTreeNode è¿™ä¸ªå†…éƒ¨ç±»å°±æ˜¯è¡¨ç¤ºçº¢é»‘æ ‘çš„. TODO åç»­è¿›è¡Œæ›´æ–°.\n\nå‚æ•°, å¯ä»¥çœ‹åˆ° HashMap æ˜¯ä½¿ç”¨äº†ä¸€ä¸ªæ•°ç»„æ¥è¿›è¡Œå­˜å‚¨ NodeèŠ‚ç‚¹.\n\n```java\ntransient Node<K,V>[] table;\n\n\ntransient int size;\n\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n\nstatic final int MAXIMUM_CAPACITY = 1 << 30;\n\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n```\n\n------\n\n#### æ–¹æ³•\n\n æ„é€ å‡½æ•°\n\n\n\n```java\n/**\n * Constructs an empty <tt>HashMap</tt> with the default initial capacity\n * (16) and the default load factor (0.75).\n \tå½“ä½¿ç”¨æ— å‚æ„é€ å‡½æ•°çš„æ—¶å€™,åªæ˜¯å¯¹ loadFactor è¿›è¡Œäº†èµ‹å€¼æ“ä½œ\n */\npublic HashMap() {\n    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted\n}\n\n// ä¼ é€’ä¸€ä¸ªintç±»å‹çš„å‚æ•°æ—¶å€™,å°±ä¼šè®¡æ¯å¾€ä¸‹è°ƒç”¨æ„é€ å‡½æ•°\npublic HashMap(int initialCapacity) {\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n}\n\n/**\n\tå¯¹å€¼è¿›è¡Œåˆ¤æ–­,æ€•ä½ å¯èƒ½ä¼ å…¥è¿›æ¥ä¸€ä¸ªè´Ÿæ•°æ¥æµ‹è¯•ç©ç©å“ˆå“ˆå“ˆã€‚\n\tæœ€åè°ƒç”¨åˆ°äº†tableSizeForæ–¹æ³•,å¯ä»¥çœ‹åˆ°è¿™ä¸ªæ–¹æ³•æ˜¯å¯¹ä¼ å…¥è¿›æ¥çš„å‚æ•°,è¿›è¡Œä¸€è¿ä¸²çš„ä½è¿ç®—.\n*/\npublic HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        this.threshold = tableSizeFor(initialCapacity);\n}\n\nstatic final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n}\n\n// ä¼ å…¥ Map çš„å®ç°ç±»çš„è¯,å°±æ˜¯å¾€ä¸‹ç»§ç»­è°ƒç”¨ putMapEntriesæ–¹æ³•\npublic HashMap(Map<? extends K, ? extends V> m) {\n        this.loadFactor = DEFAULT_LOAD_FACTOR;\n        putMapEntries(m, false);\n}\n\n/**\n\tä¼ å…¥ m.size()çš„é•¿åº¦,é•¿åº¦å¤§äº0å°±ä¼šèµ°é€»è¾‘ä»£ç .æœ€åå¯ä»¥çœ‹åˆ° è¿­ä»£äº†m,ç„¶åè°ƒç”¨putValæ¥å°†å€¼æ”¾å…¥Mapä¸­\n*/\nfinal void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {\n        int s = m.size();\n        if (s > 0) {\n            if (table == null) { // pre-size\n                float ft = ((float)s / loadFactor) + 1.0F;\n                int t = ((ft < (float)MAXIMUM_CAPACITY) ?\n                         (int)ft : MAXIMUM_CAPACITY);\n                if (t > threshold)\n                    threshold = tableSizeFor(t);\n            }\n            else if (s > threshold)\n                resize();\n            for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n                K key = e.getKey();\n                V value = e.getValue();\n                putVal(hash(key), key, value, false, evict);\n            }\n        }\n}\n```\n\nput æ·»åŠ æ–¹æ³•\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\n// æ ¹æ®ä¼ å…¥è¿›æ¥çš„keyæ¥è®¡ç®—å¯¹åº”çš„hashå€¼\nstatic final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n\n/**\n\tputVal å°±æ˜¯ \n*/\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        // å®šä¹‰ä¸€äº›å˜é‡\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n    \t// table èµ‹å€¼ç»™ tab å¹¶åˆ¤æ–­æ˜¯å¦ç­‰äºnull æˆ–è€… tabçš„é•¿åº¦æ˜¯å¦ç­‰äº0,å¦‚æœæ˜¯çš„è¯ï¼Œå°±ä¼šè°ƒç”¨resizeæ¥è¿›è¡Œæ‰©å®¹\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n    \n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node<K,V> e; K k;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else {\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n}\n\n/**\n\tæ‰©å®¹æ–¹æ³•\n\ttableä½¿ç”¨ oldTabæ¥è¿›è¡Œå­˜å‚¨,æ‹¿å‡ºoldTabçš„é•¿åº¦(å¦‚æœoldTabæ˜¯nullçš„è¯,å¯¹åº”çš„é•¿åº¦å°±æ˜¯ä¸º0).\n\toldThr æ˜¯ è®°å½• threshold ä¹‹å‰çš„å€¼, newCap / newThrå°±æ˜¯éœ€è¦æ‰©å®¹ä½¿ç”¨åˆ°çš„å˜é‡å‘½å.\n\tè¿™é‡Œåˆ†ä¸º \n\t1 : oldCap æ˜¯å¤§äº0çš„ã€‚ å¦‚æœæ¯” MAXIMUM_CAPACITY è¿˜æ˜¯è¦å¤§çš„è¯,å°±è¯´æ˜é‡Œé¢å­˜å‚¨çš„å…ƒç´ æ˜¯å¤ªå¤šäº†,å°±ç›´æ¥è¿”å›oldTab.  è¿˜æœ‰ä¸€ç§å°±æ˜¯ newCapç­‰äºoldCapçš„1.5å€å¹¶ä¸”å°äºMAXIMUM_CAPACITYå’ŒoldCapæ˜¯å¤§äºé»˜è®¤16çš„,å°±ä¼šè¿›è¡Œ1.5å€çš„æ‰©å®¹\n\t2 : oldThr å¤§äº 0, newCap(æ‰©å®¹æ–°é•¿åº¦) å°±æ˜¯ç­‰äº oldTheçš„å€¼.\n\t3 : å¦åˆ™å°±æ˜¯éƒ½ä½¿ç”¨é»˜è®¤çš„å€¼å¤§å°\n*/\nfinal Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap > 0) {\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr << 1; // double threshold\n        }\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        else {               // zero initial threshold signifies using defaults\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;\n    \t\n    \t/**\n    \tä½¿ç”¨æ‰©å®¹åçš„newCapæ¥åˆ›å»ºä¸€ä¸ªæ•°ç»„,oldTabä¸æ˜¯null,ç„¶åå°±éœ€è¦å°†è€çš„å€¼èµ‹å€¼åˆ°æ–°çš„newTabé‡Œé¢æ¥.\n        ä½¿ç”¨ä¸‹æ ‡æ¥è¿›è¡Œè¿­ä»£,è·å–æ¯ä¸ªä¸‹æ ‡çš„NodeèŠ‚ç‚¹çš„å€¼,ç„¶oldTab[j]èµ‹å€¼ç»™eå,ç„¶åå°†oldTab[j]é‡ç½®ä¸ºnull.\n        è¿™é‡Œé¢çš„è¿›è¡ŒNodeå¤åˆ¶æ˜¯æœ‰åˆ†ä¸ºä¸‹é¢å‡ ç§, Nodeçš„nextèŠ‚ç‚¹æ˜¯æ²¡æœ‰å€¼å¾—,nextä¸‹é¢æ˜¯ç”±å€¼,eèŠ‚ç‚¹è½¬åŒ–ä¸ºäº†çº¢é»‘æ ‘.\n        1 : å¦‚æœe.nextæ˜¯null,ä¹Ÿå°±æ˜¯æ²¡æœ‰å€¼,newTab[e.hash & (newCap - 1)] = eæ¥èµ‹å€¼.\n        2 : å¦‚æœeæ˜¯TreeNodeçš„è¯,å°±ä¼šè°ƒç”¨((TreeNode<K,V>)e).split(this, newTab, j, oldCap)æ–¹æ³•.\n        3 : ç„¶åå¯ä»¥çœ‹åˆ° do while å¾ªç¯é‡Œé¢, while é‡Œé¢çš„æ¡ä»¶æ˜¯ e.next != null æ‰ä¼šè¿›å»,ä¹Ÿå°±æ˜¯nextæ˜¯ç”±å€¼å¾—æƒ…å†µä¸‹æ‰ä¼šè¿›å…¥åˆ°è¿™é‡Œé¢æ¥.ç„¶åå¯ä»¥çœ‹åˆ°ä¸€äº›ç³»å–èŠ‚ç‚¹å•Š,èµ‹å€¼ç»™å˜é‡å•Š,ç„¶åèµ‹å€¼ç»™æ–°åˆ›å»ºçš„Nodeæ•°ç»„ä¸‹æ ‡ç„¶åå°†ä¹‹å‰çš„nodeèŠ‚ç‚¹é‡ç½®ä¸ºnullã€‚ è¿™é‡Œå°±éœ€è¦è¯»è€…å¯¹è¿™äº›ä»£ç æ¥æ…¢æ…¢æ¶ˆåŒ–äº†.ä»”ç»†æƒ³çœ‹,å°±æ˜¯å¯¹nodeèŠ‚ç‚¹çš„å–å€¼,èµ‹å€¼,é‡ç½®ç­‰æ“ä½œ.\n    \t*/\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        table = newTab;\n        if (oldTab != null) {\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // preserve order\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n}\n```\n\nget æ–¹æ³•,æ˜¯é€šè¿‡keyæ¥è·å–å‡ºå¯¹åº”çš„value.\n\n```java\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\n// ä¼ å…¥keyæ¥è®¡ç®—å‡ºå“ˆå¸Œå€¼\nstatic final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n\n/**\n\tå¦‚æœ tableä¸æ˜¯Null,å¹¶ä¸”é•¿åº¦æ˜¯å¤§äº0çš„,èƒ½å¤Ÿæ ¹æ® (n-1) & hash å¾—å‡ºæ¥çš„ä¸‹æ ‡æ˜¯åœ¨tabé‡Œé¢èƒ½è·å–åˆ°å€¼å¾—,æ‰ä¼šè¿›å…¥é€»è¾‘ä»£ç ,å¦åˆ™å°±æ˜¯è¿”å›null.\n\tå¦‚æœfirstçš„hashæ˜¯äºä¼ å…¥è¿›æ¥çš„hashç›¸åŒ,æ–Œä¸”ç»™keyçš„å€¼ä¹Ÿæ˜¯ç›¸åŒçš„è¯,å°±ä¼šè¿”å›firstèŠ‚ç‚¹.\n\tæ‹¿nodeçš„nextèŠ‚ç‚¹,å¦‚æœæ˜¯TreeNodeçš„ç±»,å°±ä¼šèµ°TreeNodeå¯¹åº”çš„getTreeNodeæ–¹æ³•(é“¾è¡¨çš„é•¿åº¦å¤§äº8å°±ä¼šè½¬åŒ–ä¸ºçº¢é»‘æ ‘). å¦åˆ™çš„è¯å°±å°±è¿­ä»£è¿™ä¸ªNode,é€€å‡ºçš„æ¡ä»¶å°±æ˜¯ e.next == null,å°±è¯´è¯´æ˜ä¸‹é¢æ²¡æœ‰å¯¹åº”çš„èŠ‚ç‚¹äº†ã€‚\n\tè¿™é‡Œæ‹¿å€¼å¾—é€»è¾‘,è¿˜æ˜¯æ¯”è¾ƒå®¹æ˜“ç†è§£å¾—ã€‚ å…ˆæ ¹æ®è®¡ç®—å‡ºæ¥å¾—hashå€¼,å»æ•°ç»„ä¸­æ˜¯å¦å¯ä»¥è·å–åˆ°å¯¹åº”å¾—å€¼,å¦‚æœæœ‰å°±å…ˆä¼šå¯¹firstè¿›è¡Œåˆ¤æ–­,æ˜¯å¦æ»¡è¶³æ¡ä»¶.å¦‚æœä¸æ»¡è¶³çš„è¯,å°±è¯´æ˜è¿™ä¸ªkeyçš„hashæ˜¯ç”±å†²çªçš„,ä¹Ÿå°±æ˜¯ç”±äºŒä¸ªä¸åŒçš„å€¼,è®¡ç®—å‡ºæ¥ç›¸åŒçš„hashå€¼,è¿™ä¸ªæ—¶å€™å°±ä¼šç”¨é“¾è¡¨(Node)æ¥è¿›è¡Œå­˜å‚¨,å¦‚æœé•¿åº¦æ˜¯å¤§äº8çš„è¯,å°±ä¼šè½¬åŒ–ä¸ºTreeNodeçš„çº¢é»‘æ ‘.\n*/\nfinal Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {\n            if (first.hash == hash && // always check first node\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                return first;\n            if ((e = first.next) != null) {\n                if (first instanceof TreeNode)\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n}\n```\n\nisEmpty æ–¹æ³•,è¿™é‡Œå°±ç›´æ¥ä½¿ç”¨ size == 0 æ¥è¿›è¡Œåˆ¤æ–­,å¦‚æœä½ çš„mapæ˜¯nullçš„è¯,ç›´æ¥è°ƒç”¨è¿™ä¸ªæ–¹æ³•å°±ä¼šå‡ºç°ç©ºæŒ‡é’ˆ.\n\n```java\npublic boolean isEmpty() {\n    return size == 0;\n}\n```\n\n------\n\n#### æ€»ç»“\n\n è¿™é‡Œåªæ˜¯é€‰ç”¨äº† put å’Œ getæ–¹æ³•æ¥è¿›è¡Œè®²è§£,å› ä¸ºè¿™äºŒä¸ªæ˜¯ç»å¸¸è°ƒç”¨çš„,æ‰€ä»¥å¾—æ˜ç™½æ˜¯ä¸€ä¸ªæ€ä¹ˆæ ·å¾—å¤§ä½“æµç¨‹èµ°å‘æ‰è¡Œ.\n","tags":["java","javaé›†åˆ"],"categories":["java","javaé›†åˆ"]},{"title":"ArrayListæºç é˜…è¯»è®°å½•","url":"/2021/11/04/java/ArrayListæºç é˜…è¯»è®°å½•/","content":"\n\n\nArrayList æ˜¯ä»£ç ä¸­ä½¿ç”¨éå¸¸é¢‘ç¹çš„,æ‰€ä»¥çœ‹åº•å±‚çš„ä»£ç æ—¶éå¸¸æœ‰å¿…é¡»çš„.\n\n### ç»“æ„\n\n ArrayList æ˜¯ä¸€ä¸ªç”± Object [] çš„æ•°ç»„æ¥å®ç°çš„\n\n transient Object[] elementData ,è¿™ä¸ªå˜é‡å°±æ˜¯å­˜æ”¾æ•°æ®çš„.\n\n é•¿åº¦æ˜¯ç”¨ int size è¿™ä¸ªå˜é‡æ¥è®°å½•çš„,è€Œä¸æ˜¯ç›´æ¥è°ƒç”¨çš„ æ•°ç»„çš„é•¿åº¦è·å–çš„.\n\n\n\n å¦‚æœArrayList list = new ArrayList(); åªæ˜¯ä»…ä»…newä¸€ä¸ªé›†åˆçš„è¯,æ•°ç»„çš„å¤§å°æ˜¯æ²¡æœ‰åˆå§‹åŒ–ä¸º10çš„,è€Œæ˜¯åœ¨add()ä¸­,è¿›è¡Œåˆ¤æ–­ã€‚ å¦‚æœæ•°ç»„çš„æ˜¯ä¸ºç©ºçš„æ•°ç»„çš„è¯,å°±ä¼šä½¿ç”¨ **DEFAULT_CAPACITY** æ¥è¿›è¡Œåˆå§‹åŒ–ã€‚ä¹Ÿå°±æ˜¯è¦è°ƒç”¨addæ–¹æ³•æ‰è¡Œã€‚\n\n```\nif (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n    return Math.max(DEFAULT_CAPACITY, minCapacity);\n}\n```\n\n### æ–¹æ³•\n\n- å…ˆæ¥ä»‹ç»add()æ–¹æ³• , ä¸Šä»£ç \n\n  add é‡Œé¢æ˜¯èµ°äº†ä¸‰ä¸ªæ–¹æ³•, size æ²¡æœ‰èµ‹å€¼çš„æƒ…å†µä¸‹,å°±æ˜¯0.\n\n  ```\n  public boolean add(E e) {\n      ensureCapacityInternal(size + 1);  // Increments modCount!!\n      elementData[size++] = e;\n      return true;\n  }\n  \n  // ç¡®è®¤å®¹é‡ , æ‰“ä¸ªæ¯”æ–¹æˆ‘ä»¬æ²¡æœ‰å¯¹sizeè¿›è¡Œèµ‹å€¼,é‚£ä¹ˆsize + 1 ä¼ å…¥åˆ°è¿™ä¸ªé‡Œé¢çš„å€¼ä¹Ÿå°±æ˜¯1,é‚£ä¹ˆ elementData å¯¹åº”çš„ä¹Ÿå°±æ˜¯ä¸€ä¸ªç©ºæ•°ç»„\n  private void ensureCapacityInternal(int minCapacity) {\n       ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n  }\n  \n  //  æ»¡è¶³æ˜¯ç©ºæ•°ç»„çš„è¯,å°±ä¼šä½¿ç”¨é»˜è®¤çš„å€¼ 10 äº minCapcacity æ¥è¿›è¡Œå¯¹æ¯”,è¿™é‡Œè¿”å›çš„10\n  private static int calculateCapacity(Object[] elementData, int minCapacity) {\n          if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n              return Math.max(DEFAULT_CAPACITY, minCapacity);\n          }\n          return minCapacity;\n      }\n  \n  //  å¦‚æœ minCapacity  å‡å» æ•°ç»„çš„é•¿åº¦æ˜¯å¤§äº0çš„,å°±ä¼šè°ƒç”¨growæ¥è¿›è¡Œæ‰©å®¹\n  private void ensureExplicitCapacity(int minCapacity) {\n          modCount++;\n  \n          // overflow-conscious code\n          if (minCapacity - elementData.length > 0)\n              grow(minCapacity);\n   }\n  \n  // è¿™é‡Œå¯ä»¥çœ‹åˆ°å…ˆå¯¹æ•°ç»„çš„å€¼è¿›è¡Œ,ç„¶åå¯¹ä¿å­˜å‡ºæ¥çš„å€¼è¿›è¡Œ1.5å€æ‰©å®¹,ä¸ä¼ å…¥è¿›æ¥çš„å€¼è¿›è¡Œå¯¹æ¯”,æ»¡è¶³æ¡ä»¶èµ‹å€¼.è¿™é‡Œå°±è¦çœ‹åˆ° Arrays.copyOf(elementDate,newCapacity); è¿™æ‰æ˜¯çœŸæ­£çš„å¯¹æ•°ç»„è¿›è¡Œæ‰©å®¹çš„æ–¹æ³•,ä¹Ÿå°±æ˜¯ç›´æ¥è°ƒç”¨Arraysçš„API. Arrays.copyOf() é‡Œé¢æœ€åä¹Ÿæ˜¯è°ƒç”¨äº† System.arraycopy()çš„æ–¹æ³•\n  private void grow(int minCapacity) {\n          // overflow-conscious code\n          int oldCapacity = elementData.length;\n          int newCapacity = oldCapacity + (oldCapacity >> 1);\n          if (newCapacity - minCapacity < 0)\n              newCapacity = minCapacity;\n          if (newCapacity - MAX_ARRAY_SIZE > 0)\n              newCapacity = hugeCapacity(minCapacity);\n          // minCapacity is usually close to size, so this is a win:\n          elementData = Arrays.copyOf(elementData, newCapacity);\n      }\n  åˆ°è¿™é‡Œ ensureCapacityInternal æ–¹æ³•ä¹Ÿå°±æ˜¯èµ°å®Œäº†\n  ---------------------------------------------\n  åé¢å°±æ˜¯ä½¿ç”¨ æ•°ç»„ä¸‹æ ‡æ¥è¿›è¡Œèµ‹å€¼å¹¶ä¸”è¿”å›trueã€‚\n  ```\n\n\n\n\n\n- æ ¹æ®ä¸‹æ ‡æ¥æ·»åŠ \n\n  ```\n  public void add(int index, E element) {\n      rangeCheckForAdd(index);\n  \n      ensureCapacityInternal(size + 1);  // Increments modCount!!\n      System.arraycopy(elementData, index, elementData, index + 1,\n                       size - index);\n      elementData[index] = element;\n      size++;\n  }\n  \n  // æ£€æŸ¥ä¸‹æ ‡æ˜¯å¦è¶Šç•Œ , ensureCapacityInternal æ–¹æ³•å’Œä¸Šé¢ä¸€æ ·\n  private void rangeCheckForAdd(int index) {\n          if (index > size || index < 0)\n              throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n  }\n  \n  \n  //  System.arraycopy() ä» elementDate çš„ indexå¤„å¼€å§‹å¤åˆ¶, å¤åˆ¶ç»™åé¢çš„elementDateæ•°ç»„çš„å€¼,ä»index + 1 å¼€å§‹å¤åˆ¶,ä¹Ÿå°±æ˜¯è¯´ index ç›¸å½“äºä¿®æ”¹äº† index + 1, ç„¶åindexä½ç½®å°±æ˜¯æ²¡æœ‰å€¼äº†,æ‰€ä»¥elementDate[index] = elementçš„å€¼,size ++.\n  ```\n\n- setæ–¹æ³• : ä¹Ÿå°±æ˜¯æ ¹æ®ä¸‹æ ‡æ¥å¯¹ä¹…çš„å€¼è¿›è¡Œä¸€ç§æ›¿æ¢,å–å‡ºå¯¹åº”ä¸‹æ ‡çš„å€¼,ç„¶åä¸‹æ ‡å¯¹åº”çš„ä½ç½®èµ‹å€¼ç»™æ–°å€¼,æœ€åè¿”å›æ—§å€¼å›å»å³å¯\n\n  ```\n  // å…ˆæ£€æŸ¥ä¸‹æ ‡æ˜¯å¦è¶Šç•Œ,å¦‚æœè¶Šç•Œå°±ä¼šæŠ›å‡ºå¼‚å¸¸\n  public E set(int index, E element) {\n      rangeCheck(index);\n  \n      E oldValue = elementData(index);\n      elementData[index] = element;\n      return oldValue;\n  }\n  \n  // å–å‡ºå¯¹åº”ä¸‹æ ‡çš„å€¼\n      @SuppressWarnings(\"unchecked\")\n      E elementData(int index) {\n          return (E) elementData[index];\n      }\n  ```\n\n- remove\n\n  æ ¹æ®ä¼ å…¥è¿›æ¥çš„å€¼è¿›è¡Œåˆ é™¤,\n\n  ```\n  // åˆ†ä¸º null å’Œ ä¸æ˜¯ null çš„æƒ…å†µæ¥è¿›è¡Œåˆ é™¤.æ»¡è¶³æ¡ä»¶çš„è¯,æœ€åéƒ½ä¼šè°ƒç”¨åˆ° fastRemoveæ–¹æ³•ä¸­æ¥\n  public boolean remove(Object o) {\n      if (o == null) {\n          for (int index = 0; index < size; index++)\n              if (elementData[index] == null) {\n                  fastRemove(index);\n                  return true;\n              }\n      } else {\n          for (int index = 0; index < size; index++)\n              if (o.equals(elementData[index])) {\n                  fastRemove(index);\n                  return true;\n              }\n      }\n      return false;\n  }\n  \n  //  æ ¹æ®ä¼ å…¥è¿›æ¥çš„ ä¸‹æ ‡æ¥åˆ é™¤æ•°æ®,System.arraycopy è¿™ä¸ªæ–¹æ³•å¹¶ä¸é»˜è®¤,æ ¹æ®ä¸‹æ ‡çš„ä½ç½®æ¥è¿›è¡Œå¤åˆ¶æ•°ç»„ã€‚\n  //  å¯ä»¥çœ‹åˆ°æœ€åæœ‰ä¸€ä¸ª å°†å€¼è®¾ç½®ä¸ºnullçš„æ“ä½œ,ä»æ³¨é‡Šä¸Šçœ‹æ˜¯help GC, å¸®åŠ©GC\n  private void fastRemove(int index) {\n          modCount++;\n          int numMoved = size - index - 1;\n          if (numMoved > 0)\n              System.arraycopy(elementData, index+1, elementData, index,\n                               numMoved);\n          elementData[--size] = null; // clear to let GC do its work\n      }\n  ```\n\n- æ ¹æ®ä¸‹æ ‡åˆ é™¤\n\n  å¯ä»¥çœ‹åˆ°æ ¹æ®ä¸‹æ ‡åˆ é™¤çš„è¯ï¼Œä¼šå…ˆåˆ¤æ–­ä¼ å…¥è¿›æ¥çš„ä¸‹æ ‡æ˜¯å¦æ»¡è¶³æ¡ä»¶,å°±æ˜¯æ²¡æœ‰å‡ºç°è¶Šç•Œçš„æƒ…å†µ.\n\n  ç„¶åå–å‡ºæ—§å€¼,æ¥ä¸‹æ¥çš„ä»£ç å°±æ˜¯éå¸¸çš„ç†Ÿæ‚‰äº†,å°±æ˜¯fastRemove() é‡Œé¢çš„ä»£ç äº†\n\n  ```\n  public E remove(int index) {\n      rangeCheck(index);\n    \n      modCount++;\n      E oldValue = elementData(index);\n    \n      int numMoved = size - index - 1;\n      if (numMoved > 0)\n          System.arraycopy(elementData, index+1, elementData, index,\n                           numMoved);\n      elementData[--size] = null; // clear to let GC do its work\n    \n      return oldValue;\n  }\n  ```\n\n------\n\n### æ€»ç»“\n\nå¤§è‡´å°±æ˜¯çœ‹ ArrayList æ˜¯å¦‚ä½•æ·»åŠ æ•°æ®çš„,å¯¹æ•°æ®æ˜¯æ€ä¹ˆä¿å­˜çš„,æ˜¯å¦‚ä½•åˆ é™¤æ•°æ®çš„,æ˜¯æ€ä¹ˆæ ·è¿›è¡Œæ‰©å®¹çš„,å¤§è‡´å¼„æ˜ç™½è¿™äº›å°±æ˜¯å¯¹ArrayListæœ‰ä¸€ä¸ªå¤§è‡´çš„äº†è§£\n","tags":["java","javaé›†åˆ"],"categories":["java","javaé›†åˆ"]},{"title":"ArrayDequeæºç é˜…è¯»è®°å½•","url":"/2021/11/04/java/ArrayDequeæºç é˜…è¯»è®°å½•/","content":"\nArrayDeque åœ¨æˆ‘ç›®å‰åšçš„é¡¹ç›®ä¸­,ä½¿ç”¨æ˜¯æ¯”è¾ƒå°‘çš„,åŸºæœ¬éƒ½æ²¡æœ‰åœ°æ–¹ç”¨åˆ°ã€‚å¯èƒ½æ˜¯æˆ‘å¤ªlowäº†,ä¹Ÿå¯èƒ½æ˜¯ä¸šåŠ¡æ²¡æœ‰ä¸€å®šè¦ç”¨åˆ°é˜Ÿåˆ—çš„æƒ…å†µ. ä½†æ˜¯è¿™ä¸å½±å“æˆ‘ä»¬å¯¹å…¶è¿›è¡Œæºç é˜…è¯»ã€‚\n\n### ç»“æ„\n\nç»“æ„è¿˜æ˜¯å¯ä»¥çœ‹åˆ°, ä½¿ç”¨ä¸€ä¸ªObjectçš„æ•°ç»„, äºŒä¸ªintç±»å‹çš„å˜é‡æ¥è®°å½•å¤´å’Œå°¾(ä»å•è¯çš„æ„æ€)\n\n```\ntransient Object[] elements; // non-private to simplify nested class access\n\ntransient int head;\n\ntransient int tail;\n```\n\n### æ–¹æ³•\n\n- æ„é€ å‡½æ•°\n\n  æ— å‚æ„é€ å‡½æ•°. å¯ä»¥çœ‹åˆ°æ— å‚æ„é€ å‡½æ•°,é»˜è®¤æ˜¯å¯¹æ•°æ®è¿›è¡Œåˆå§‹åŒ–å¤§å°ä¸º16çš„æ“ä½œ.\n\n  ```\n  public ArrayDeque() {\n      elements = new Object[16];\n  }\n  ```\n\n  \n\n  æœ‰å‚æ„é€ å‡½æ•°\n\n  ```\n  /**ä¼ é€’intç±»å‹çš„æ„é€ å‡½æ•°,æœ€åæ˜¯è°ƒç”¨åˆ°äº†calculateSizeæ–¹æ³•è¿”å›å€¼æ¥åˆå§‹åŒ–æ•°ç»„å¤§å° */\n  public ArrayDeque(int numElements) {\n      allocateElements(numElements);\n  }\n  \n  private void allocateElements(int numElements) {\n          elements = new Object[calculateSize(numElements)];\n  }\n  \n  /** è·å–å˜é‡MIN_INITIAL_CAPACITYçš„å€¼,å¦‚æœä¼ å…¥è¿›æ¥çš„å€¼æ˜¯å¤§äºè¿™ä¸ªå€¼,å°±ä¼šè¿›è¡Œä¸‹é¢çš„è¿ç®—æ“ä½œ,ç„¶åè¿”å›è¿™ä¸ªå€¼å‡ºå».   */\n  private static int calculateSize(int numElements) {\n          int initialCapacity = MIN_INITIAL_CAPACITY;\n          // Find the best power of two to hold elements.\n          // Tests \"<=\" because arrays aren't kept full.\n          if (numElements >= initialCapacity) {\n              initialCapacity = numElements;\n              initialCapacity |= (initialCapacity >>>  1);\n              initialCapacity |= (initialCapacity >>>  2);\n              initialCapacity |= (initialCapacity >>>  4);\n              initialCapacity |= (initialCapacity >>>  8);\n              initialCapacity |= (initialCapacity >>> 16);\n              initialCapacity++;\n  \n              if (initialCapacity < 0)   // Too many elements, must back off\n                  initialCapacity >>>= 1;// Good luck allocating 2 ^ 30 elements\n          }\n          return initialCapacity;\n  }\n  \n  \n  \n  /**\n     ä¼ é€’é›†åˆçš„æ„é€ å‡½æ•°\n     ä½¿ç”¨ä¼ é€’è¿›æ¥çš„é›†åˆçš„é•¿åº¦æ¥åˆå§‹åŒ–æ•°ç»„çš„é•¿åº¦.\n     ç„¶åè°ƒç”¨addAllæ–¹æ³•,è¿™é‡Œè¯´æ˜ä¸‹ addAll æ˜¯åœ¨å…¶ AbstractCollection é‡Œé¢,ä¹Ÿå°±æ˜¯å­ç±»è°ƒç”¨çˆ¶ç±»çš„æ–¹æ³•.ç„¶åaddæ–¹æ³•æ˜¯åœ¨ArrayDequeé‡Œé¢è°ƒç”¨\n  */\n  public ArrayDeque(Collection<? extends E> c) {\n          allocateElements(c.size());\n          addAll(c);\n  }\n  \n  \n  private void allocateElements(int numElements) {\n          elements = new Object[calculateSize(numElements)];\n  }\n  \n  /** è¿™é‡Œå¯ä»¥çœ‹åˆ°,å®šä¹‰ç»™å˜é‡,è¿­ä»£é›†åˆc,ä¾æ¬¡è°ƒç”¨addæ–¹æ³•,å¦‚æœaddæ–¹æ³•è¿”å›çš„æ˜¯true,å˜é‡modifiedå°±ä¼šå˜ä¸ºtrue.æœ€åaddAllå°±ä¼šè¿”å›å˜é‡modifiedå›å». */\n  public boolean addAll(Collection<? extends E> c) {\n          boolean modified = false;\n          for (E e : c)\n              if (add(e))\n                  modified = true;\n          return modified;\n  }\n  \n  // å¾€ä¸‹è°ƒç”¨\n  public boolean add(E e) {\n          addLast(e);\n          return true;\n  }\n  \n  /**\n  \tè¿™é‡Œçš„å€¼æ˜¯ä¸èƒ½ä¼ å…¥nullè¿›æ¥çš„,å¦åˆ™çš„è¯å°±ä¼šæŠ¥NPEçš„å¼‚å¸¸.\n  \tç„¶åä½¿ç”¨ä¸‹æ ‡tailç›´æ¥æ’å…¥åˆ°æœ€å,if é‡Œé¢æ˜¯å¯¹ tail çš„å€¼è¿›è¡Œæ–°èµ‹å€¼æ“ä½œ,å¦‚æœæ»¡è¶³æ¡ä»¶å°±ä¼šè°ƒç”¨doubleCapacityæ–¹æ³•,ç›®æµ‹è¿™ä¸ªæ–¹æ³•å°±æ˜¯è¿›è¡Œæ‰©å®¹çš„æ–¹æ³•.\n  \tè¿™é‡Œå°±æ˜¯çœ‹ä¸‹  (tail = (tail + 1) & (elements.length - 1)) è¿™ä¸ªèµ‹å€¼æ“ä½œ,å°±æ˜¯ç»™tailè¿›è¡Œæ–°çš„èµ‹å€¼ã€‚\n  */\n  public void addLast(E e) {\n          if (e == null)\n              throw new NullPointerException();\n          elements[tail] = e;\n          if ( (tail = (tail + 1) & (elements.length - 1)) == head)\n              doubleCapacity();\n  }\n  ```\n\n- æ·»åŠ æ–¹æ³•\n\n  add(E e) è¿™é‡Œæ·»åŠ è°ƒç”¨çš„æ–¹æ³•,æˆ‘ä»¬ä¸»è¦çœ‹ä¸‹ doubleCapacity è¿™ä¸ªæ–¹æ³•\n\n  ```\n  public boolean add(E e) {\n      addLast(e);\n      return true;\n  }\n  \n  public void addLast(E e) {\n          if (e == null)\n              throw new NullPointerException();\n          elements[tail] = e;\n          if ( (tail = (tail + 1) & (elements.length - 1)) == head)\n              doubleCapacity();\n  }\n  \n  /**\n  \tè¿™é‡Œå¯¹ head / elementsçš„é•¿åº¦éƒ½è¿›è¡Œå€¼å­˜å‚¨æ“ä½œ, ä¸€ æ˜¯ä¾¿äºåé¢ä½¿ç”¨System.arraycopy æ¥è¿›è¡Œcopyæ•°ç»„çš„å€¼,å¥½ä»å¯¹åº”ä¸‹æ ‡å¼€å§‹å¤åˆ¶å€¼. äºŒæ˜¯ head /  tail ç­‰èµ‹å€¼.\n  \tå¯ä»¥çœ‹åˆ°æ‰©å®¹åçš„çš„å¤§å°,æ¥newäº†ä¸€ä¸ªæ–°çš„æ•°ç»„,åé¢è°ƒç”¨System.arraycopyæ¥è¿›è¡Œå¤åˆ¶.\n  */\n  private void doubleCapacity() {\n          assert head == tail;\n          int p = head;\n          int n = elements.length;\n          int r = n - p; // number of elements to the right of p\n          int newCapacity = n << 1;\n          if (newCapacity < 0)\n              throw new IllegalStateException(\"Sorry, deque too big\");\n          Object[] a = new Object[newCapacity];\n          System.arraycopy(elements, p, a, 0, r);\n          System.arraycopy(elements, 0, a, r, p);\n          elements = a;\n          head = 0;\n          tail = n;\n  }\n  ```\n\n  \n\n  addFirst ä»å¤´éƒ¨æ’å…¥ , å¯ä»¥çœ‹åˆ° ä½¿ç”¨ head = (head - 1) & (elements.length - 1) æ˜¯è®¡ç®—å‡ºå¤´éƒ¨ä¸‹æ ‡çš„ä½ç½®,å¹¶ä¸”å¯¹å€¼è¿›è¡Œè¦†ç›–. å¦‚æœ head ä¸ tail æ˜¯ç›¸ç­‰çš„è¯,å°±ä¼šè°ƒç”¨ doubleCapacityæ¥è¿›è¡Œæ‰©å®¹\n\n  ```\n  public void addFirst(E e) {\n      if (e == null)\n          throw new NullPointerException();\n      elements[head = (head - 1) & (elements.length - 1)] = e;\n      if (head == tail)\n          doubleCapacity();\n  }\n  ```\n\naddLast å°¾éƒ¨æ’å…¥, è¿™ä¸ªæ–¹æ³•ä¸Šé¢éƒ½æ˜¯æœ‰æåˆ°çš„ã€‚\n\n```\npublic void addLast(E e) {\n    if (e == null)\n        throw new NullPointerException();\n    elements[tail] = e;\n    if ( (tail = (tail + 1) & (elements.length - 1)) == head)\n        doubleCapacity();\n}\n```\n\n\n\n```\nofferLast / offerFirst  å†…éƒ¨éƒ½æ˜¯åˆ†åˆ«è°ƒç”¨åˆ°äº† addLast / addFirst æ–¹æ³•\n```\n\n push æ–¹æ³•ä¹Ÿæ˜¯è°ƒç”¨çš„ addFirst æ–¹æ³•\n\n- get è·å–å€¼æ–¹æ³•\n\n  getFirst / getLast æ–¹æ³•\n\n  ```\n  /** ä»headå¯¹åº”çš„æ•°ç»„ä¸­ç›´æ¥è·å–å‡ºå€¼,å¦‚æœå€¼æ˜¯nullçš„è¯,å°±ä¼šæŠ›å‡ºä¸€ä¸ªå¼‚å¸¸,å¦åˆ™å°±ä¼šè¿”å›*/\n  public E getFirst() {\n      @SuppressWarnings(\"unchecked\")\n      E result = (E) elements[head];\n      if (result == null)\n          throw new NoSuchElementException();\n      return result;\n  }\n  \n  /**\n  \t(tail - 1) & (elements.length - 1) å¾—å‡ºå°¾éƒ¨å…ƒç´ çš„ä¸‹æ ‡ä½ç½®,ç„¶åç”¨æ•°ç»„ä¸‹æ ‡è¿”å›å¯¹åº”çš„å€¼.\n  */\n  public E getLast() {\n          @SuppressWarnings(\"unchecked\")\n          E result = (E) elements[(tail - 1) & (elements.length - 1)];\n          if (result == null)\n              throw new NoSuchElementException();\n          return result;\n      }\n  ```\n\npeekFirst / peekLast ä¸­çš„æ“ä½œ,æ˜¯ä¸ getFirst / getLast æ˜¯ä¸€æ ·çš„\n\npeek æ–¹æ³•é‡Œé¢æ˜¯èµ°çš„ peekFirst æ–¹æ³•\n\n- remove æ–¹æ³•\n\n  removeFirst æ–¹æ³•, èµ°çš„æ˜¯ pollFirst æ–¹æ³•\n\n  removeLast æ–¹æ³•\n\n  ```\n  public E removeFirst() {\n      E x = pollFirst();\n      if (x == null)\n          throw new NoSuchElementException();\n      return x;\n  }\n  \n  /**\n   å¤´èŠ‚ç‚¹ head ä½¿ç”¨å˜é‡ h æ¥è®°å½•, ç›´æ¥elements[h]ä¸‹æ ‡æ¥è·å–å€¼,å¦‚æœå€¼æ˜¯nullçš„è¯,å°±æ‰§è¡Œè¿”å›(è¿™é‡Œç›´æ¥è¿”å›çš„é€»è¾‘å¤„ç†æ˜¯,åˆå§‹åŒ–ä¸€ä¸ªé›†åˆ,ä½†æ˜¯æ²¡ä»»ä½•å€¼,å°±è°ƒç”¨removeFirstæ–¹æ³•,è¿™ä¸ªæ—¶å€™æ•°ç»„é‡Œé¢æ˜¯æ²¡æœ‰å€¼çš„,äºæ˜¯å°±ç›´æ¥è¿”å›å³å¯).\n   å¦‚æœä¸æ˜¯nullçš„è¯,å°±ä¼šèµ°ä¸‹é¢çš„,å°†hçš„ä¸‹æ ‡å€¼è®¾ç½®ä¸ºnull,ä¹Ÿå°±æ˜¯è¿›è¡Œåˆ é™¤,ç„¶åé‡æ–°è®¡ç®—å‡º head çš„å€¼.\n  */\n  public E pollFirst() {\n          int h = head;\n          @SuppressWarnings(\"unchecked\")\n          E result = (E) elements[h];\n          // Element is null if deque empty\n          if (result == null)\n              return null;\n          elements[h] = null;     // Must null out slot\n          head = (h + 1) & (elements.length - 1);\n          return result;\n  }\n  \n  \n  public E removeLast() {\n          E x = pollLast();\n          if (x == null)\n              throw new NoSuchElementException();\n          return x;\n  }\n  \n  /**\n  \tå…ˆè®¡ç®—å‡ºå°¾èŠ‚ç‚¹çš„ä¸‹æ ‡,ç„¶åç”¨å€¼resultæ¥è¿›è¡Œè®°å½•.å¦‚æœæ˜¯nullçš„è¯,å°±ç›´æ¥æ–¹æ³•(è¿™é‡Œæƒ³æ³•å’Œä¸Šé¢ä¸€æ ·).å°†tçš„ä¸‹æ ‡çš„å€¼é‡ç½®ä¸ºnullè¿›è¡Œåˆ é™¤,ç„¶åtailçš„å€¼å°±æ˜¯ç­‰tçš„å€¼.\n  */\n  public E pollLast() {\n          int t = (tail - 1) & (elements.length - 1);\n          @SuppressWarnings(\"unchecked\")\n          E result = (E) elements[t];\n          if (result == null)\n              return null;\n          elements[t] = null;\n          tail = t;\n          return result;\n  }\n  ```\n\nremove æ–¹æ³•æ˜¯ç›´æ¥è°ƒç”¨çš„ removeFirst æ–¹æ³•.\n\n- removeFirstOccurrence / removeLastOccurrence TODO åç»­æ›´æ–°\n\n------\n\n### æ€»ç»“\n\nArrayDeque é˜Ÿåˆ—ï¼Œ é˜Ÿåˆ—çš„ç‰¹æ€§å°±æ˜¯å¯¹æ•°æ®æ˜¯å…ˆè¿›å…ˆå‡ºã€‚ è€Œæ ˆçš„ç‰¹æ€§æ˜¯å…ˆè¿›åå‡º(æ¯”å¦‚æªæ‰“å‡ºå»çš„å­å¼¹).\n\nè¿™é‡Œçš„ç†è§£å°±æ˜¯, ä½¿ç”¨äºŒä¸ªå˜é‡ï¼Œç„¶åæ¯æ¬¡è¿›è¡Œ add / get / remove éƒ½æ˜¯åˆ©ç”¨è¿™äºŒä¸ªå˜é‡æ¥è¿›è¡Œ æ·»åŠ  / åˆ é™¤ / è·å–ç­‰æ“ä½œ.\n","tags":["java","javaé›†åˆ"],"categories":["java","javaé›†åˆ"]},{"title":"Javaåå°„å­¦ä¹ ","url":"/2021/11/03/java/Javaåå°„å­¦ä¹ /","content":"\n\n\n#### é¢˜è®°\n\n æœ€è¿‘åœ¨çœ‹Springæºç çš„æ—¶å€™, å¯ä»¥çœ‹åˆ°åœ¨åŠ è½½ç±»ç­‰çš„æ—¶å€™,éƒ½æ˜¯å¤§é‡ä½¿ç”¨çš„åå°„ã€‚ä¼°æ‘¸ç€MyBatisè¿™ç§æ¡†æ¶,å…¶å†…éƒ¨ä¹Ÿæ˜¯ä¼šå¤§é‡çš„ä½¿ç”¨åå°„ã€‚æ‰€ä»¥çœ‹å¾—å‡ºæ¥åå°„åœ¨ç¬¬ä¸‰æ–¹çš„æ¡†æ¶ä¸­ä½¿ç”¨æ˜¯éå¸¸å¤šçš„,äºæ˜¯è¯´å­¦ä¹ åå°„æŠ€æœ¯æ˜¯å¾ˆæœ‰å¿…è¦çš„ï¼Œä¸è®ºæ˜¯ä½ å†™ä»£ç é€ è½®å­è¿˜æ˜¯å»ç†è§£ç¬¬ä¸‰æ–¹æ¡†æ¶çš„åº•å±‚å®ç°.\n\n è¯ä¸å¤šbb,ç›´æ¥ä¸Šä»£ç çœ‹çœ‹æ˜¯ä¸ªä»€ä¹ˆæ“ä½œ.\n\n#### æ–¹æ³•\n\næˆ‘ä»¬è¿™é‡Œå†™ä¸€ä¸ªç®€å•çš„pojoç±»,ä¹Ÿå°±æ˜¯æˆ‘ä»¬ç»å¸¸ä½¿ç”¨çš„.\n\n```\npublic class User {\n\n    private Integer id;\n    private String name;\n\tpublic String age;\n    public User(){\n    }\n    public User(Integer id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public void say(){\n        System.out.println(\"Userè¯´\");\n    }\n}\n```\n\nç„¶åæ¥ç€åœ¨å†™ä¸€ä¸ªå¯åŠ¨çš„Mainç±»\n\n```\npublic class UserClazzMain {\n    public static void main(String[] args) {\n        User u = new User();\n        // è·å–ç±»çš„æ‰€æœ‰çš„æ„é€ æ–¹æ³•\n        Constructor<?>[] constructors = u.getClass().getConstructors();\n        System.out.println(Arrays.asList(constructors).toString());\n        // æ ¹æ®ä¼ å…¥è¿›å»çš„å‚æ•°ç±»å‹,è·å–å‡ºç±»çš„æ„é€ æ–¹æ³•.\n        Constructor<? extends User> constructor = u.getClass().getConstructor(Integer.class, String.class);\n    }\n}\n// æ‰“å°ç»“æœ:[public com.iyang.bootbasicio.pojo.User(), public com.iyang.bootbasicio.pojo.User(java.lang.Integer,java.lang.String)],\n//å¯ä»¥çœ‹åˆ°è¿™æ˜¯ä¸€ä¸ªè·å–ç±»çš„æ„é€ æ–¹æ³•çš„.\n```\n\nè°ƒç”¨åå°„è·å–æ–¹æ³•:\n\n```\npublic class UserClazzMain {\n    public static void main(String[] args) throws Exception {\n        User u = new User();\n        // å¯ä»¥çœ‹åˆ°è·å–å‡ºæ¥çš„å…¨éƒ¨æ–¹æ³•,ä¸ä»…ä»…åŒ…å«æˆ‘ä»¬å†™çš„,è¿˜æœ‰Objectä¸­çš„notifyç­‰æ–¹æ³•.\n        Method[] methods = u.getClass().getMethods();\n        System.out.println(Arrays.asList(methods).toString());\n        // æ ¹æ®æ–¹æ³•çš„åå­—æ¥è¿‡å»æˆ‘ä»¬ç‰¹å®šçš„æ–¹æ³•.\n        Method method = u.getClass().getMethod(\"say\");\n        System.out.println(method.toString());\n        \n        //getDeclaredMethodsæ–¹æ³•ä»…ä»…åªè·å–é™¤äº†æˆ‘ä»¬è¿™ä¸ªç±»é‡Œé¢çš„æ–¹æ³•,å¹¶æ²¡æœ‰è·å–å…¨éƒ¨çš„æ–¹æ³•(ä¹Ÿå°±æ˜¯ä¸åŒ…æ‹¬Objectçš„).\n        Method[] declaredMethods = u.getClass().getDeclaredMethods();\n        System.out.println(Arrays.asList(declaredMethods).toString());\n        // è¿™é‡Œä¾ç„¶æ˜¯è·å–æˆ‘ä»¬è‡ªå·±å†™çš„æ–¹æ³•\n        Method say = u.getClass().getDeclaredMethod(\"say\");\n        System.out.println(say.toString());\n        \n        // è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥è°ƒç”¨äº†userçš„sayæ–¹æ³•\n        Method say = u.getClass().getDeclaredMethod(\"say\");\n        say.invoke(u);\n    }\n}\n[public void com.iyang.bootbasicio.pojo.User.setId(java.lang.Integer), public void com.iyang.bootbasicio.pojo.User.say(), public java.lang.String com.iyang.bootbasicio.pojo.User.getName(), public void com.iyang.bootbasicio.pojo.User.setName(java.lang.String), public java.lang.Integer com.iyang.bootbasicio.pojo.User.getId(), public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException, public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException, public final void java.lang.Object.wait() throws java.lang.InterruptedException, public boolean java.lang.Object.equals(java.lang.Object), public java.lang.String java.lang.Object.toString(), public native int java.lang.Object.hashCode(), public final native java.lang.Class java.lang.Object.getClass(), public final native void java.lang.Object.notify(), public final native void java.lang.Object.notifyAll()]\n----------------------------\npublic void com.iyang.bootbasicio.pojo.User.say()\n```\n\nè°ƒç”¨è·å–å­—æ®µï¼š\n\n```\npublic class UserClazzMain {\n    public static void main(String[] args) throws Exception {\n        User u = new User();\n        //è·å–å…¨éƒ¨çš„å­—æ®µ,æ˜¯publicä¿®é¥°çš„å­—æ®µ,privateä¿®é¥°çš„æ˜¯è·å–ä¸åˆ°çš„.\n        Field[] fields = u.getClass().getFields();\n        System.out.println(Arrays.asList(fields).toString());\n        //è·å–å­—æ®µ,ç§æœ‰çš„ä¸èƒ½è·å–,ä¼šæŠ›å‡ºå¼‚å¸¸,åªèƒ½è·å–publicä¿®é¥°çš„å­—æ®µ.\n        Field field = u.getClass().getField(\"age\");\n        System.out.println(field.toString());\n        \n        // è·å–å…¨éƒ¨çš„å­—æ®µ,privateä¿®é¥°çš„ä¹Ÿæ˜¯å¯ä»¥è·å–å‡ºæ¥çš„\n        Field[] declaredFields = u.getClass().getDeclaredFields();\n        System.out.println(Arrays.asList(declaredFields).toString());\n\n        // æ ¹æ®å­—æ®µçš„åå­—è·å–å­—æ®µ,ä¸ç®¡ä»€ä¹ˆä¿®é¥°çš„,éƒ½æ˜¯å¯ä»¥è·å–å‡ºæ¥çš„.\n        Field name = u.getClass().getDeclaredField(\"name\");\n        System.out.println(name.toString());\n       }\n }\n```\n\nè·å–æ³¨è§£:\n\næˆ‘ä»¬å…ˆå®šä¹‰äºŒä¸ªæ³¨è§£, ç„¶åè®°å¾—åŠ åœ¨Userç±»ä¸Š. GavinYang å’Œ PeterWong è¿™äºŒä¸ªæ³¨è§£æ˜¯å¯ä»¥åŠ åœ¨ç±»ä¸Šçš„, GavinYangFiledAnnoæ˜¯åŠ åœ¨å­—æ®µä¸Šé¢çš„.\n\n```\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE})\npublic @interface GavinYang {\n\n    String lwf() default \"lwf\";\n\n}\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE})\npublic @interface PeterWong {\n\n    String name() default \"peterWong\";\n\n}\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.FIELD})\npublic @interface GavinYangFiledAnno {\n    String desc() default \"\";\n}\n    // ä»ç»“æœæ¥çœ‹,è·å–æ³¨è§£è¿˜æ˜¯è›®é¡ºåˆ©çš„\n    public static void main(String[] args) throws Exception {\n        User u = new User();\n        // è·å–è¿™ä¸ªç±»ä¸Šé¢çš„æ³¨è§£\n        Annotation[] annotations = u.getClass().getAnnotations();\n        System.out.println(Arrays.asList(annotations).toString());\n        // æ ¹æ®æ³¨è§£åå­—è·å–,å¯ä»¥çœ‹åˆ°è¿”å›çš„ä¹Ÿç›´æ¥æ˜¯æ³¨è§£çš„Obejctäº†\n        GavinYang gavinYang = u.getClass().getAnnotation(GavinYang.class);\n        System.out.println(gavinYang.toString());\n        \n        // è·å–å­—æ®µä¸Šé¢ä½¿ç”¨çš„æ³¨è§£.\n        Field field = u.getClass().getDeclaredField(\"name\");\n        Annotation[] fieldAnnotations = field.getAnnotations();\n        System.out.println(Arrays.asList(fieldAnnotations).toString());\n        }\n      }\n      \n[@com.iyang.bootbasicio.pojo.GavinYang(lwf=baoyang), @com.iyang.bootbasicio.pojo.PeterWong(name=gavinyang)]\n@com.iyang.bootbasicio.pojo.GavinYang(lwf=baoyang)     \n[@com.iyang.bootbasicio.pojo.GavinYangFiledAnno(desc=ç§’å•Š)]\n```\n\n#### å°ç«™ä¸€ä¸‹\n\nUserService æ— å‚æ„é€ æ–¹æ³• Userè¯´ä½¿ç”¨ä¾èµ–æ³¨å…¥å®Œæˆä¸€ä¸ªç®€å•çš„æ³¨å…¥\n\nè®¤ä¸€ä¸‹Springå†™ä¸€ä¸ªå·®ä¸å¤šçš„æ³¨å…¥æ³¨è§£. åœ¨å†™ä¸€ä¸ªè™šå‡çš„ UserService,å½“ç„¶äº†,æˆ‘ä»¬è¿™é‡Œå…ˆä¸ä½¿ç”¨æ‰«æ,å°±ä½¿ç”¨ç®€å•çš„UserServcieå»æ“ä½œå³å¯.\n\n```\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.FIELD})\npublic @interface GavinYangAutowired {\n\n    String alias() default \"\";\n\n}\npublic class UserService {\n\n    @GavinYangAutowired\n    private User user;\n\n    public UserService(){\n        System.out.println(\"UserService æ— å‚æ„é€ æ–¹æ³•\");\n    }\n\n    public void hello(){\n        user.say();\n    }\n\n}\n```\n\nUserClassMain ç±»æ¥å¯åŠ¨å‘è½¦ , è¿™é‡Œçœ‹ç»“æœæ˜¯å¯ä»¥æˆåŠŸçš„å¯åŠ¨ UserService å¹¶ä¸”ä¹Ÿæ˜¯ç”¨helloæ–¹æ³•æ¥è°ƒç”¨userçš„say,éƒ½æ˜¯æˆåŠŸ. ä½†æ˜¯çœŸå®çš„æ¡†æ¶å¤æ‚ç¨‹åº¦ä¸æ˜¯è¿™å‡ è¡Œå°±å¯ä»¥okäº†çš„. è¿™åªæ˜¯ä¸€ä¸ªç®€å•æ˜“å­¦çš„demo.\n\n```\npublic class UserClazzMain {\n\n    public static void main(String[] args) throws Exception {\n        UserService u  = new UserService();\n        Field[] fields = u.getClass().getDeclaredFields();\n        for(Field f : fields){\n            GavinYangAutowired autowired = f.getDeclaredAnnotation(GavinYangAutowired.class);\n            if(autowired != null){\n                Class<?> fType = f.getType();\n                Constructor<?> typeConstructor = fType.getConstructor();\n                Object instance = typeConstructor.newInstance();\n\n                f.setAccessible(true);\n                f.set(u,instance);\n            }\n        }\n\n        u.hello();\n    }\n}\n\n// UserService æ— å‚æ„é€ æ–¹æ³•\n// Userè¯´\n```\n\n#### æ€»ç»“\n\nå¯ä»¥çœ‹åˆ°åå°„çš„åŠŸèƒ½è¿˜æ˜¯è›®å¼ºå¤§çš„, ä½†æ˜¯é¡¹ç›®é‡Œé¢ä¸€èˆ¬æ˜¯CRUD,ç›®å‰ä¹Ÿæ²¡æœ‰ä»€ä¹ˆç‰¹åˆ«çš„åœ°æ–¹çœ‹åˆ°ä½¿ç”¨åå°„çš„æƒ…å†µæ¯”è¾ƒå¤š.å°±æ˜¯æœ€è¿‘ä¸€ç›´çœ‹Springæºç ä¸­,æ˜¯å¯ä»¥çœ‹åˆ°æœ‰å¤§é‡ä½¿ç”¨åå°„çš„æƒ…å†µ.\n","tags":["Javaåå°„","java"],"categories":["javaåå°„","java"]}]