[{"title":"mybatis与springboot整合阅读","url":"/2021/11/04/mybatis/mybatis与springboot整合阅读/","content":"\n#### 前提\n\n MyBatis 与 SpringBoot 整合操作. 在这次整合的过程中,再次明白自己毫无疑问的是一个比较手残的同学了.\n\n 这里我们是基于 sql 语句写在 xml 里面进行整合的操作.\n\n#### 入门\n\n 这里说下创建一个 入门 项目的大致流程.\n\n 先创建一个 SpringBoot 项目 , 引入依赖 : https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/pom.xml\n\n 创建 MyBatis 的配置文件信息 : https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/resources/mybatis-config.xml\n\n 创建查询的 sql 语句，也就是我们的 mapper 文件 : https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-boot-hello/src/main/resources/mapper\n\n application.properties : https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/resources/application.properties\n\n 扫描 mapper 接口 : @MapperScan(basePackages = {“com.iyang.mybatis.springboot.hello.mapper”}) https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/java/com/iyang/mybatis/springboot/hello/MybatisSpringBootHelloApplication.java\n\n这里是没有引入 web 依赖的 , 直接启动 main 方法 , 然后就可以看到我们查询出来的结果了.\n\n如果你熟悉 SpringBoot 源码的话，就会晓得有一个自动装配的操作.\n\n如果不熟悉的话，那么就只能通过 @MapperScan(basePackages = {“com.iyang.mybatis.springboot.hello.mapper”}) 去看 , 这样有些是依赖自动装配（spring.factories） 中的配置加载的, 所以这里建议在看之前，如果是有一点 SpringBoot 扩展的知识了解是很好的。如果没有怎么办呢？没有就来看我接下来的内容。\n\n其实这个地方你仔细想下，在 MyBatis 与 Spring 整合的时候，通过 xml 的方式给 MyBatis 的bean 已经 mybatis-spring 中自己写的扫描类，最后将扫描出来的 bd 在还没初始化之前，将bd 的beanClass 替换为我们的代理类.\n\n那么，SpringBoot 与 MyBatis 整合的时候，最后要做的事情是不是也是将 MyBatis 的信息注入到 SpringBoot 来呢？只不过，SpringBoot 就不像 Spring 一样了，还将 bean 的信息配置到 xml 文件中.\n\n于是，接下来跟我的阅读&分析来一步一步的往下看.\n\n#### 方法分析\n\n **关注点一** : 这里我们点入到 org.mybatis.spring.annotation.MapperScan 注解里面来，可以看到有一个 @Import(MapperScannerRegistrar.class) , 于是我们顺手跟进来 : org.mybatis.spring.annotation.MapperScannerRegistrar , 从名字上来，这个类就做了一个扫描mapper并且将mapper注入到Spring容器中来的事情.\n\n **关注点二** : 我们从引入进来的依赖来看, mybatis-spring-boot-starter-2.1.2.jar 跟进到 这个包来，可以看到这个包也是引入一些进来. mybatis/mybatis-spring/spring-boot-starter-jdbc 这三个依赖我们应该不是很陌生的，mybatis-spring-boot-autoconfigure主要来看这个。 spring.factories 的作用大家可以去了解下，SpringBoot很多 EnableAutoConfiguration 的配置都是放入在这个里面的，在启动的时候，会去一层一层的去读取 spring.factories 文件的内容。 这里我们主要来看 : org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration 这个类皆可.\n\n MyBatis 在 properties 中的配置文件读取 : org.mybatis.spring.boot.autoconfigure.MybatisProperties\n\n可以看到该类上是有: @ConfigurationProperties(prefix = MybatisProperties.MYBATIS_PREFIX)\n\n于是我们一下子就多了二个关注点, 这里我们可以采用之前的 笨方法， 当你对整合流程执行不是很熟悉的话，可以在这二个关注点的重写方法上都打算断点，看下其执行顺序是怎么执行的. 弄清楚了执行流程,就可以跟着流程来一步一步的分析. 从我们打上 debug 开始，往下的执行流程就是一步一步来的，那么就跟着我们debug 的方法来一步一步的分析.\n\norg.mybatis.spring.annotation.MapperScannerRegistrar#registerBeanDefinitions() —> org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#MybatisAutoConfiguration —> org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#afterPropertiesSet —-> org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionFactory —> org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionTemplate() —->\n\n**org.mybatis.spring.annotation.MapperScannerRegistrar#registerBeanDefinitions() 方法** :\n\n```\n/**\n * {@inheritDoc}\n */\n@Override\npublic void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n/***\n*  这里是获取出了注解里面属性的值. \n*/   \n  AnnotationAttributes mapperScanAttrs = \n  AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));\n\n// 能获取到有注解,不是null,就会走到下面的代码中来.    \n  if (mapperScanAttrs != null) {\n    registerBeanDefinitions(importingClassMetadata, mapperScanAttrs, registry,\n        generateBaseBeanName(importingClassMetadata, 0));\n  }\n}\n\n/**\n* \n*/\n  void registerBeanDefinitions(AnnotationMetadata annoMeta, AnnotationAttributes annoAttrs,\n      BeanDefinitionRegistry registry, String beanName) {\n\n// 利用 BeanDefinitionBuilder 构造者,传入了一个 MapperScannerConfigurer.class\n// 这里的 builder里面是有一个 bd 的,里面的beanClass就是 MapperScannerConfigurer      \n    BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);\n    builder.addPropertyValue(\"processPropertyPlaceHolders\", true);\n\n// 这里获取 @MapperScan 注解的属性, 如果属性是有值的话,就会设置到 builder 中来. \n    Class<? extends Annotation> annotationClass = annoAttrs.getClass(\"annotationClass\");\n    if (!Annotation.class.equals(annotationClass)) {\n      builder.addPropertyValue(\"annotationClass\", annotationClass);\n    }\n\n    Class<?> markerInterface = annoAttrs.getClass(\"markerInterface\");\n    if (!Class.class.equals(markerInterface)) {\n      builder.addPropertyValue(\"markerInterface\", markerInterface);\n    }\n\n    Class<? extends BeanNameGenerator> generatorClass = annoAttrs.getClass(\"nameGenerator\");\n    if (!BeanNameGenerator.class.equals(generatorClass)) {\n      builder.addPropertyValue(\"nameGenerator\", BeanUtils.instantiateClass(generatorClass));\n    }\n\n    Class<? extends MapperFactoryBean> mapperFactoryBeanClass = annoAttrs.getClass(\"factoryBean\");\n    if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) {\n      builder.addPropertyValue(\"mapperFactoryBeanClass\", mapperFactoryBeanClass);\n    }\n\n    String sqlSessionTemplateRef = annoAttrs.getString(\"sqlSessionTemplateRef\");\n    if (StringUtils.hasText(sqlSessionTemplateRef)) {\n      builder.addPropertyValue(\"sqlSessionTemplateBeanName\", annoAttrs.getString(\"sqlSessionTemplateRef\"));\n    }\n\n    String sqlSessionFactoryRef = annoAttrs.getString(\"sqlSessionFactoryRef\");\n    if (StringUtils.hasText(sqlSessionFactoryRef)) {\n      builder.addPropertyValue(\"sqlSessionFactoryBeanName\", annoAttrs.getString(\"sqlSessionFactoryRef\"));\n    }\n\n\n// 下面是根据 value/basePackages/basePackageClasses 来获取包的信息,\n// 这里也就说, 我们可以跟着这三个属性来配置包信息.      \n    List<String> basePackages = new ArrayList<>();\n    basePackages.addAll(\n        Arrays.stream(annoAttrs.getStringArray(\"value\")).filter(StringUtils::hasText).collect(Collectors.toList()));\n\n    basePackages.addAll(Arrays.stream(annoAttrs.getStringArray(\"basePackages\")).filter(StringUtils::hasText)\n        .collect(Collectors.toList()));\n\n    basePackages.addAll(Arrays.stream(annoAttrs.getClassArray(\"basePackageClasses\")).map(ClassUtils::getPackageName)\n        .collect(Collectors.toList()));\n\n// 如果没有获取到包的信息,那就根据注解所在的路径来获取默认的路径.      \n    if (basePackages.isEmpty()) {\n      basePackages.add(getDefaultBasePackage(annoMeta));\n    }\n// 如果有lazyInitialization属性的值,就设置到 builder 中来. \n    String lazyInitialization = annoAttrs.getString(\"lazyInitialization\");\n    if (StringUtils.hasText(lazyInitialization)) {\n      builder.addPropertyValue(\"lazyInitialization\", lazyInitialization);\n    }\n// 添加包的属性\n    builder.addPropertyValue(\"basePackage\", StringUtils.collectionToCommaDelimitedString(basePackages));\n\n//  getBeanDefinition() 在返回 bd 之前，会走一个 validate 方法.\n// org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition\n// 走这个方法来将 bd 给注入到 Spring 容器中来.\n// 这里注入进去的 beanName 的值是 :  com.iyang.mybatis.springboot.hello.MybatisSpringBootHelloApplication#MapperScannerRegistrar#0\n// 注入进去的 bd 的 beanClass : class org.mybatis.spring.mapper.MapperScannerConfigurer \n    registry.registerBeanDefinition(beanName, builder.getBeanDefinition());\n\n  }\n```\n\n**这里可以总结下 registerBeanDefinitions 方法，该方法就是将 @MapperScan 的注解属性的值给到 : BeanDefinitionBuilder builder, 该builder 里面有bd,bd的beanClass是MapperScannerConfigurer，最后将MapperScannerConfigurer注入到 Spring 容器中来.**\n\n------\n\n**MyBatisAutoConfiguration() 有参构造函数**\n\n这里我们在 MybatisAutoConfiguration 构造函数上打上断点, 可以根据 断点来分析，走完👆面的方法，然后我们点击走到下一个断点来，就会走到 这个 有参构造函数.\n\n如果好奇的话，可以跟踪debug 的堆栈信息，是怎么走到这步来的. 走到这个方法来 : finishBeanFactoryInitialization(beanFactory) 这是最初的入口.\n\n```\npublic MybatisAutoConfiguration(MybatisProperties properties, ObjectProvider<Interceptor[]> interceptorsProvider,\n    ObjectProvider<TypeHandler[]> typeHandlersProvider, ObjectProvider<LanguageDriver[]> languageDriversProvider,\n    ResourceLoader resourceLoader, ObjectProvider<DatabaseIdProvider> databaseIdProvider,\n    ObjectProvider<List<ConfigurationCustomizer>> configurationCustomizersProvider) {\n// 这里都是赋值    \n  this.properties = properties;\n  this.interceptors = interceptorsProvider.getIfAvailable();\n  this.typeHandlers = typeHandlersProvider.getIfAvailable();\n  this.languageDrivers = languageDriversProvider.getIfAvailable();\n  this.resourceLoader = resourceLoader;\n  this.databaseIdProvider = databaseIdProvider.getIfAvailable();\n  this.configurationCustomizers = configurationCustomizersProvider.getIfAvailable();\n}\n```\n\n**org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#afterPropertiesSet()方法**\n\n这里可以看到是对配置文件是否存在进行检验.\n\n```\n@Override\npublic void afterPropertiesSet() {\n  checkConfigFileExists();\n}\n\n// 检验配置文件是否存在\n  private void checkConfigFileExists() {\n    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {\n      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());\n      Assert.state(resource.exists(),\n          \"Cannot find config location: \" + resource + \" (please add config file or check your Mybatis configuration)\");\n    }\n  }\n```\n\n**org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionFactory 方法**\n\n```\n// 这里说下 @ConditionalOnMissingBean 的作用,当bean不存在的时候，则实例化这个bean.\n// 这里会传入 dataSource 进来.\n@Bean\n@ConditionalOnMissingBean\npublic SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {\n// 创建 sqlSessionBean 对象.    \n  SqlSessionFactoryBean factory = new SqlSessionFactoryBean();\n// 设置 dataSource & SpringBootVFS.class      \n  factory.setDataSource(dataSource);\n  factory.setVfs(SpringBootVFS.class);\n// 获取到 MyBatis 的配置文件属性,如果有的话,就会设置到 configLocation属性来.    \n  if (StringUtils.hasText(this.properties.getConfigLocation())) {\n    factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));\n  }\n    \n// 这里从 properties 中获取 configuration,没有值就会是null.    \n  applyConfiguration(factory);\n  if (this.properties.getConfigurationProperties() != null) {\n    factory.setConfigurationProperties(this.properties.getConfigurationProperties());\n  }\n\n// 如果有插件,就会设置插件.    \n  if (!ObjectUtils.isEmpty(this.interceptors)) {\n    factory.setPlugins(this.interceptors);\n  }\n  if (this.databaseIdProvider != null) {\n    factory.setDatabaseIdProvider(this.databaseIdProvider);\n  }\n// 包的名别设置    \n  if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {\n    factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());\n  }\n  if (this.properties.getTypeAliasesSuperType() != null) {\n    factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());\n  }\n  if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {\n    factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());\n  }\n  if (!ObjectUtils.isEmpty(this.typeHandlers)) {\n    factory.setTypeHandlers(this.typeHandlers);\n  }\n  if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {\n    factory.setMapperLocations(this.properties.resolveMapperLocations());\n  }\n// 这里都是配置属性的设置.    \n\n// 获取 propert 字段属性的名字.    \n  Set<String> factoryPropertyNames = Stream\n      .of(new BeanWrapperImpl(SqlSessionFactoryBean.class).getPropertyDescriptors()).map(PropertyDescriptor::getName)\n      .collect(Collectors.toSet());\n  Class<? extends LanguageDriver> defaultLanguageDriver = this.properties.getDefaultScriptingLanguageDriver();\n  if (factoryPropertyNames.contains(\"scriptingLanguageDrivers\") && !ObjectUtils.isEmpty(this.languageDrivers)) {\n    // Need to mybatis-spring 2.0.2+\n    factory.setScriptingLanguageDrivers(this.languageDrivers);\n    if (defaultLanguageDriver == null && this.languageDrivers.length == 1) {\n      defaultLanguageDriver = this.languageDrivers[0].getClass();\n    }\n  }\n// 设置默认的脚本语言解析器. 这里没有,设置的是默认的null.    \n  if (factoryPropertyNames.contains(\"defaultScriptingLanguageDriver\")) {\n    // Need to mybatis-spring 2.0.2+\n    factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);\n  }\n// org.mybatis.spring.SqlSessionFactoryBean#getObject,这里走到了 SqlSessionBean.\n// 这个SqlSessionFactoryBean是在有之前 mybatis和Spring 整合分析有提过到的,可以参考getObject方法: https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello    \n// 这里会走 org.mybatis.spring.SqlSessionFactoryBean#getObject 的 afterPropertiesSet 方法来创建一个 SqlSessionFactory , 这里返回的 SqlSessionFactory 就注入到 Spring 容器中来.    \n  return factory.getObject();\n}\n```\n\n**所以这个方法 ： 先是new了一个SqlSessionFactoryBean对象，如果你仔细看的话，你会发现这个对象在之前 mybatis-spring 整合的时候，我们通过 xml 配置文件配置进来的，并且同时通过标签给赋值了datasource等信息， 而这里是通过代码，if等判断，来对 SqlSessionFactoryBean 的属性进行set值的. 最后也是创建出一个 SqlSessionFactory 给注入到 Spring 容器中来.**\n\n------\n\n**org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionTemplate 方法**\n\n```\n@Bean\n@ConditionalOnMissingBean\npublic SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {\n// 这里根据 executorType 是否有值来判断要走的构造函数方法.    \n  ExecutorType executorType = this.properties.getExecutorType();\n  if (executorType != null) {\n    return new SqlSessionTemplate(sqlSessionFactory, executorType);\n  } else {\n// 这里默认的获取是 SIMPLE 这个 ExecutorType.      \n    return new SqlSessionTemplate(sqlSessionFactory);\n  }\n}\n\n// org.mybatis.spring.SqlSessionTemplate#SqlSessionTemplate(org.apache.ibatis.session.SqlSessionFactory, org.apache.ibatis.session.ExecutorType, org.springframework.dao.support.PersistenceExceptionTranslator),最后可以跟进到这个方法中来.\n\n  public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,\n      PersistenceExceptionTranslator exceptionTranslator) {\n// 对sqlSessionFactory 和 executorType 进行校验\n    notNull(sqlSessionFactory, \"Property 'sqlSessionFactory' is required\");\n    notNull(executorType, \"Property 'executorType' is required\");\n\n    this.sqlSessionFactory = sqlSessionFactory;\n    this.executorType = executorType;\n    this.exceptionTranslator = exceptionTranslator;\n// 这里通过 JDK 的代码来生成了一个 sqlSessionProxy 代理的对象.      \n    this.sqlSessionProxy = (SqlSession) newProxyInstance(SqlSessionFactory.class.getClassLoader(),\n        new Class[] { SqlSession.class }, new SqlSessionInterceptor());\n  }\n```\n\n该方法是将 SqlSessionTemplate 给注入到 Spring 容器中啦.\n\n#### 疑惑点\n\n 大家有没有疑惑我们定义的 mapper 接口 好像从这个流程分析下来，并没有提到 ，那么是在上面时候被注入到 Spring 容器中来的呢？\n\n registerBeanDefinitions() 这个方法 , 注入了MapperScannerConfigurer 到 Spring 容器中来了，可以回顾下之前 mybatis 整合 Spring 的时候，我们是通过 xml 配置了这个对象注入到 spring 容器中来的。 那么注入进来的,回调到 org.mybatis.spring.mapper.MapperScannerConfigurer#postProcessBeanDefinitionRegistry 这个方法的时候，就会将扫描并且将我们的mapper接口文件，给注入到 Spring 容器中来的. 然后扫描的包，是根据@MapperScan 解析注解的时候，是有对扫描的包进行解析的.\n\n#### 总结\n\n 其实 SpringBoot 整合 MyBatis , 我们从二个切入点来分析是怎么整合进来的.\n​ 一是 @MapperScan 注解中的 @Import(MapperScannerRegistrar.class) 将 MapperScannerRegistrar 给导入到 Spring 容器中来, 然后MapperSacnnerRegistrar 来讲 org.mybatis.spring.mapper.MapperScannerConfigurer 给注入到 Spring中来，替换了我们之前用 Spring 整合 Mybatis 的时候，通过xml配置文件整合进来.\n\n 二是利用 SpringBoot 提供的 spring-boot-autoconfigure + spring.factories() 来 配置自动注入, 这里注入了 MybatisAutoConfiguration 配置类. 然后注入进来的 MyBatis 配置类做了什么事情呢？ 可以看到这个类中是有做: 注入了 SqlSessionFactory. SqlSessionFactory 又是怎么注入进来的呢？ 可以看到 org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionFactory 方法是有先创建一个 org.mybatis.spring.SqlSessionFactoryBean 的， 看到 SqlSessionFactoryBean 这个对象，我们就不难想起 Spring + Mybatis 里面的 beans.xml 是将该对象注入到 Spring 容器中来. 这里是直接new的，然后将一些配置属性并满足条件,给set到 SqlSessionFactoryBean 中来，最后调用 org.mybatis.spring.SqlSessionFactoryBean#getObject 方法来获取 SqlSessionFactory.\n\nspring.factories 文件内容\n\n```\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\\\norg.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration\n```\n\n最后从写的案例里面看, MyBatis 整合 SpringBoot 其实都是在 mybatis —> MyBatis + Spring 等一步一步推导上来的，所以这里不难理解，好的技术都是在有需要和时间的沉淀下一步一步成长起来的.\n","tags":["java框架","mybatis"],"categories":["java框架","mybatis"]},{"title":"mybatis与spring整合阅读","url":"/2021/11/04/mybatis/mybatis与spring整合阅读/","content":"\n\n\n#### 题记\n\n MyBatis 与 Spring 整合操作. 在我们入门学习 SSM 等东西的时候，就发现了任何东西，最后都是逃不过与Spring整合起来的道路. 然后这里看完 MyBatis 整合完 Spring 之后，那么之后一些其他的第三方，比如axon/redis/apollo/shiro 等这些东西，如果要整合 Spring 的时候，是不是也是相似的整合方式呢？\n\n 这个需要我们看完 MyBatis 与 Spring 之后，探究其整合的操作.\n\n#### 入门\n\n 分几个步骤，操作一把即可,带你回到哪个 SM 时代，不过这回是没有了 tomcat 的.\n\n 先放上一个完成的整合地址 : https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello 如果不要看下面流程的,一步跳过即可.\n\n1. 先创建一个 maven 项目，引入依赖. 依赖参考地址 : https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/pom.xml\n2. db配置 : https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/src/main/resources/db.properties\n3. MyBatis配置: https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src/main/resources/mybatis\n4. Spring 配置: https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/src/main/resources/spring-beans.xml\n5. 最后,来份我们熟悉的 https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src/main/resources/sql mapper.xml 文件.\n6. 不忘记再来一份代码 : https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src 这些直接跑测试类即可.\n\n跟着这上面的几个步骤，就可以搭建完一个项目. 然后喊上我们的 永哥， 打上传说中的 debug , 疯狂的调试看每步干了什么事.\n\n这个的时候，可以跑下测试类，是ok的.\n\n#### 分析\n\n 这里我们首先想到的是我们引入的依赖,是不是有个 mybatis-spring 的依赖. 从这个依赖，可以很明显的看出来，就是通过这个依赖，将 MyBatis 和 Spring 整合起来的。\n\n 然后再想想，我们除了这个依赖的话，还再哪里有使用到一些 Spring 和 MyBatis 的东西呢？ 然后看到 spring-beans.xml 这个xml配置, 可以看到 org.mybatis.spring.SqlSessionFactoryBean 给注入到 bean 里面来了.org.mybatis.spring.mapper.MapperScannerConfigurer也是给注入到 bean 里面来了. 并且二者都有通过来进行属性设置值操作.\n\n 那么,我们就基于这二个类的源码开始阅读.\n\n **SqlSessionFactoryBean (org.mybatis.spring.SqlSessionFactoryBean)**\n\n这里 SqlSessionFactoryBean 是实现了很多接口,这些接口都是Spring的.\n\nFactoryBean 工厂bean,点进去可以看到,其有方法getObject()/getObjectType等方法获取bean的,然后加上泛型,也就是这里获取的 getObject就是泛型.\n\nInitializingBean: afterPropertiesSet 初始化 bean 的时候，会调用该方法.\n\nApplicationEvent: Spring的事件传播机制，就是使用的这种方式.\n\n```\n/**  可以看到这个类实现了 Spring 这个多接口,那么就有个问题,实现了这么多接口的方法,到底是哪个方法先执行的呢？ 如果你对Spring源码很熟悉的话,是有可能清楚的,但是还是会有点绕的. \n这里我们给 getObject/afterPropertiesSet/onApplicationEvent这三个方法打上断点来进行debug,\ndebug每走的一步,就是执行的先后顺序。如果不是特别熟悉源码的执行顺序,这种笨方法其实也是可以的.\n*\n* 所以这里debug的执行顺序是 : afterPropertiesSet --> getObject  ---> onApplicationEvent\n* 于是我们就跟着这个顺序来阅读.\n* 注意在调用这些方法之前,<property>标签的值都是已经赋值进来了的,是通过反射走的set 方法进来的.\n*/\npublic class SqlSessionFactoryBean\n    implements FactoryBean<SqlSessionFactory>, InitializingBean, ApplicationListener<ApplicationEvent> {}\n\n// 实现FactoryBean 方法,这里是实现了该接口的三个方法. 其实这里的 isSingle是可以不用实现的\n// 因为接口是用 default 来修饰的.\n  /**\n   * 该方法是判断并且再次确认 SqlSessionFactory是不是有了. 如果没有的话,就会调用afterProperties来初始化.\n   * {@inheritDoc}\n   */\n  @Override\n  public SqlSessionFactory getObject() throws Exception {\n    if (this.sqlSessionFactory == null) {\n      afterPropertiesSet();\n    }\n\n    return this.sqlSessionFactory;\n  }\n\n  @Override\n  public Class<? extends SqlSessionFactory> getObjectType() {\n    return this.sqlSessionFactory == null ? SqlSessionFactory.class : this.sqlSessionFactory.getClass();\n  }\n\n  @Override\n  public boolean isSingleton() {\n    return true;\n  }\n\n\n// InitializingBean 实现的方法\n  @Override\n  public void afterPropertiesSet() throws Exception {\n// 先对 dataSource/sqlSessionFactoryBuilder进行非null的判断.\n    notNull(dataSource, \"Property 'dataSource' is required\");\n    notNull(sqlSessionFactoryBuilder, \"Property 'sqlSessionFactoryBuilder' is required\");\n    state((configuration == null && configLocation == null) || !(configuration != null && configLocation != null),\n        \"Property 'configuration' and 'configLocation' can not specified with together\");\n// 这里构建出 一个 sqlSessionFactory工厂来,想想我们最初再看单个MyBatis项目的时候,是不是也有一个获取SqlSessionFactroy的方法,然后从sqlSessionFactory会话中获取出SqlSession来.\n    this.sqlSessionFactory = buildSqlSessionFactory();\n  }\n\n// ApplicationListener实现方法\n  /**\n   * failFast 时ture 并且传过来的 event是 ContextRefreshedEvent的话,就会进来.\n   *  这里目前都是调用get方法,没有很仔细看出其作用.\n   * {@inheritDoc}\n   */\n  @Override\n  public void onApplicationEvent(ApplicationEvent event) {\n    if (failFast && event instanceof ContextRefreshedEvent) {\n      // fail-fast -> check all statements are completed\n      this.sqlSessionFactory.getConfiguration().getMappedStatementNames();\n    }\n  }\n```\n\n**org.mybatis.spring.SqlSessionFactoryBean#buildSqlSessionFactory**\n\n该方法需要单独拿出来说下,因为内容还是比较多的.\n\n```\n/**\n * Build a {@code SqlSessionFactory} instance.\n *\n * The default implementation uses the standard MyBatis {@code XMLConfigBuilder} API to build a\n * {@code SqlSessionFactory} instance based on a Reader. Since 1.3.0, it can be specified a {@link Configuration}\n * instance directly(without config file).\n *\n * @return SqlSessionFactory\n * @throws Exception\n *           if configuration is failed\n */\nprotected SqlSessionFactory buildSqlSessionFactory() throws Exception {\n\n  final Configuration targetConfiguration;\n\n  XMLConfigBuilder xmlConfigBuilder = null;\n    \n // 这里分为configuration/ configLocation / 非前二者(可以理解为默认的).\n // 三种处理方式.   \n  if (this.configuration != null) {\n    targetConfiguration = this.configuration;\n    if (targetConfiguration.getVariables() == null) {\n      targetConfiguration.setVariables(this.configurationProperties);\n    } else if (this.configurationProperties != null) {\n      targetConfiguration.getVariables().putAll(this.configurationProperties);\n    }\n  } else if (this.configLocation != null) {\n// 这里就是我们配置的情况 \n// org.apache.ibatis.builder.xml.XMLConfigBuilder#XMLConfigBuilder(java.io.InputStream, java.lang.String, java.util.Properties),可以看到这个熟悉的操作,也就是我们单个解析 MyBatis的时候有进行分析过的.      \n    xmlConfigBuilder = new XMLConfigBuilder(this.configLocation.getInputStream(), null, this.configurationProperties);\n// 获取出 configuration 配置信息.      \n    targetConfiguration = xmlConfigBuilder.getConfiguration();\n  } else {\n    LOGGER.debug(\n        () -> \"Property 'configuration' or 'configLocation' not specified, using default MyBatis Configuration\");\n    targetConfiguration = new Configuration();\n    Optional.ofNullable(this.configurationProperties).ifPresent(targetConfiguration::setVariables);\n  }\n\n\n// 这里采用 Optional,如果objectFactory不是null的话,就会调用targetConfiguration的 setObjectFactory方法.下面这二个是同理.\n  Optional.ofNullable(this.objectFactory).ifPresent(targetConfiguration::setObjectFactory);\n  Optional.ofNullable(this.objectWrapperFactory).ifPresent(targetConfiguration::setObjectWrapperFactory);\n  Optional.ofNullable(this.vfs).ifPresent(targetConfiguration::setVfsImpl);\n\n// 这里如果有配置typeAliasesPackage这个参数的话,就会对该包下进行扫描,进行一系列的过滤,\n// 如果都满足条件的话,targetConfiguration.getTypeAliasRegistry()::registerAlias就会注册到这里. \n  if (hasLength(this.typeAliasesPackage)) {\n    scanClasses(this.typeAliasesPackage, this.typeAliasesSuperType).stream()\n        .filter(clazz -> !clazz.isAnonymousClass()).filter(clazz -> !clazz.isInterface())\n        .filter(clazz -> !clazz.isMemberClass()).forEach(targetConfiguration.getTypeAliasRegistry()::registerAlias);\n  }\n// 是否有typeAliases这个参数,如果有的话,也是可以看到是注册到上面哪一步的里面来.\n  if (!isEmpty(this.typeAliases)) {\n    Stream.of(this.typeAliases).forEach(typeAlias -> {\n      targetConfiguration.getTypeAliasRegistry().registerAlias(typeAlias);\n      LOGGER.debug(() -> \"Registered type alias: '\" + typeAlias + \"'\");\n    });\n  }\n\n//判断是否有插件,如果有插件的话,也会添加到configuration中来.    \n  if (!isEmpty(this.plugins)) {\n    Stream.of(this.plugins).forEach(plugin -> {\n      targetConfiguration.addInterceptor(plugin);\n      LOGGER.debug(() -> \"Registered plugin: '\" + plugin + \"'\");\n    });\n  }\n\n  if (hasLength(this.typeHandlersPackage)) {\n    scanClasses(this.typeHandlersPackage, TypeHandler.class).stream().filter(clazz -> !clazz.isAnonymousClass())\n        .filter(clazz -> !clazz.isInterface()).filter(clazz -> !Modifier.isAbstract(clazz.getModifiers()))\n        .forEach(targetConfiguration.getTypeHandlerRegistry()::register);\n  }\n\n  if (!isEmpty(this.typeHandlers)) {\n    Stream.of(this.typeHandlers).forEach(typeHandler -> {\n      targetConfiguration.getTypeHandlerRegistry().register(typeHandler);\n      LOGGER.debug(() -> \"Registered type handler: '\" + typeHandler + \"'\");\n    });\n  }\n\n  targetConfiguration.setDefaultEnumTypeHandler(defaultEnumTypeHandler);\n\n  if (!isEmpty(this.scriptingLanguageDrivers)) {\n    Stream.of(this.scriptingLanguageDrivers).forEach(languageDriver -> {\n      targetConfiguration.getLanguageRegistry().register(languageDriver);\n      LOGGER.debug(() -> \"Registered scripting language driver: '\" + languageDriver + \"'\");\n    });\n  }\n  Optional.ofNullable(this.defaultScriptingLanguageDriver)\n      .ifPresent(targetConfiguration::setDefaultScriptingLanguage);\n\n  if (this.databaseIdProvider != null) {// fix #64 set databaseId before parse mapper xmls\n    try {\n      targetConfiguration.setDatabaseId(this.databaseIdProvider.getDatabaseId(this.dataSource));\n    } catch (SQLException e) {\n      throw new NestedIOException(\"Failed getting a databaseId\", e);\n    }\n  }\n\n  Optional.ofNullable(this.cache).ifPresent(targetConfiguration::addCache);\n// 这这之前,都是对一些配置信息的读取,如果有的话,就会进行相应的赋值之类的操作.\n    \n  if (xmlConfigBuilder != null) {\n    try {\n// 最后这里的 parse 解析方法,是和单个 Mybatis的解读是一样的.        \n      xmlConfigBuilder.parse();\n      LOGGER.debug(() -> \"Parsed configuration file: '\" + this.configLocation + \"'\");\n    } catch (Exception ex) {\n      throw new NestedIOException(\"Failed to parse config resource: \" + this.configLocation, ex);\n    } finally {\n      ErrorContext.instance().reset();\n    }\n  }\n\n//这里可以看事务工厂,是使用了mybatis-spring包下的.\n  targetConfiguration.setEnvironment(new Environment(this.environment,\n      this.transactionFactory == null ? new SpringManagedTransactionFactory() : this.transactionFactory,\n      this.dataSource));\n\n// 这里是处理 mapper.xml 文件的配置,如果在这里是有配置的话,那么也是会被解析到的.    \n  if (this.mapperLocations != null) {\n    if (this.mapperLocations.length == 0) {\n      LOGGER.warn(() -> \"Property 'mapperLocations' was specified but matching resources are not found.\");\n    } else {\n      for (Resource mapperLocation : this.mapperLocations) {\n        if (mapperLocation == null) {\n          continue;\n        }\n        try {\n          XMLMapperBuilder xmlMapperBuilder = new XMLMapperBuilder(mapperLocation.getInputStream(),\n              targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());\n          xmlMapperBuilder.parse();\n        } catch (Exception e) {\n          throw new NestedIOException(\"Failed to parse mapping resource: '\" + mapperLocation + \"'\", e);\n        } finally {\n          ErrorContext.instance().reset();\n        }\n        LOGGER.debug(() -> \"Parsed mapper file: '\" + mapperLocation + \"'\");\n      }\n    }\n  } else {\n    LOGGER.debug(() -> \"Property 'mapperLocations' was not specified.\");\n  }\n//org.apache.ibatis.session.defaults.DefaultSqlSessionFactory,最后到这里也是new了一个mybatis包下的默认SqlSessionFactory类.\n  return this.sqlSessionFactoryBuilder.build(targetConfiguration);\n}\n```\n\n可以看到该方法给人感觉, 先是判断一些配置信息是不是有值，如果是有值的话，就会进行相应的处理。最后调用我们在看单个 mybatis 的 parse 解析方法,最后new了一个默认的sqlSessionFactory工厂类出来.\n\n**MapperScannerConfigurer(org.mybatis.spring.mapper.MapperScannerConfigurer)**\n\n接着看,spring-beans.xml 里面的第二个配置.\n\n可以看到该类，也是实现了 spring 的很多接口.\n\nBeanDefinitionRegistryPostProcessor : 注册BeanDefinition到Spring容器中来.\n\nApplicationContextAware : 获取 ApplicationContext\n\nBeanNameAware : 设置 beanName名字.\n\n这里也可以按照上面的笨方法，一次对重写的方法打上断点. 然后开启我们的debug来看看方法的执行顺序.\n\n其执行顺序 : setBeanName —> setApplicationContext —> afterPropertiesSet —> postProcessBeanDefinitionRegistry , 跟着这四个方法执行的顺序来看.\n\n```\npublic class MapperScannerConfigurer\n    implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware { }\n```\n\n赋值给 beanName 值. org.mybatis.spring.mapper.MapperScannerConfigurer#0\n\n```\n@Override\npublic void setBeanName(String name) {\n  this.beanName = name;\n}\n\n\n// 然后这里是给到 ApplicationContext. 这也就说这个类现在有了 ApplicationContext,可以根据context提供的api来进行相应的操作.\n  @Override\n  public void setApplicationContext(ApplicationContext applicationContext) {\n    this.applicationContext = applicationContext;\n  }\n\n// 检验配置包的值不能为null.\n  @Override\n  public void afterPropertiesSet() throws Exception {\n    notNull(this.basePackage, \"Property 'basePackage' is required\");\n  }\n\n\n\n  /**\n   * {@inheritDoc}\n   * 可以感受到这个方法, 在拿到了BeanDefinitionRegistry的情况下,往里面注册bd.\n   * @since 1.0.2\n   */\n  @Override\n  public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {\n    if (this.processPropertyPlaceHolders) {\n      processPropertyPlaceHolders();\n    }\n\n// 这段是创建了一个 ClassPathMapperScanner 对象,然后往里面set属性.      \n    ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);\n    scanner.setAddToConfig(this.addToConfig);\n    scanner.setAnnotationClass(this.annotationClass);\n    scanner.setMarkerInterface(this.markerInterface);\n    scanner.setSqlSessionFactory(this.sqlSessionFactory);\n    scanner.setSqlSessionTemplate(this.sqlSessionTemplate);\n    scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName);\n    scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName);\n    scanner.setResourceLoader(this.applicationContext);\n    scanner.setBeanNameGenerator(this.nameGenerator);\n    scanner.setMapperFactoryBeanClass(this.mapperFactoryBeanClass);\n      \n    if (StringUtils.hasText(lazyInitialization)) {\n      scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));\n    }\n    if (StringUtils.hasText(defaultScope)) {\n      scanner.setDefaultScope(defaultScope);\n    }\n      \n// 对register里的信息进行过滤      \n    scanner.registerFilters();\n// org.springframework.context.annotation.ClassPathBeanDefinitionScanner#scan\n// 这里主要看扫描的方法. 根据,来切割我们写的 basePackage 信息.扫描类的信息,最后还是借用了 org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan 来进行扫描的. //  doScan(basePackages) 是对 xml 进行扫描的.\n// AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); 是对注解进行扫描的.\n// 最后返回注册到 Spring 容器中的 bean 个数\n// 所以如果我们配置了下面的标签,那么在这里都会被扫描到并且注册到Spring容器中.\n//     <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n//        <property name=\"basePackage\" value=\"com.iyang.sm.mapper\" ></property>\n//    </bean>\n// 这里需要注意的是:  org.mybatis.spring.mapper.ClassPathMapperScanner#processBeanDefinitions\n//   definition.setBeanClass(this.mapperFactoryBeanClass);  这里的这行代码,是给bd的beanClass给换成了 MapperFactoryBean.class , \n//  definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName);     // 这句代码,将 beanClassName 给到 db之后, 然后就才用 beanClassName来new一个 MapperFactoryBean 对象来, 所以这里并不是使用无参构造函数.\n// 也许会问,怎么证实没有走无参数构造函数呢 ? 而是去走的 set 方法呢 ? \n// 再不能动源码的情况下, 面对这种情况情况最好的办法就是, 在无参构造函数上打上断点.\n// 如果没走到断点上,那就说明不是走的无参构造函数来初始化的.      \n    scanner.scan(\n        StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));\n  }\n```\n\n所以到这里, 可以看到 MyBatis 与 Spring 整合的过程就已经完成了.\n\n我们这里是主要对 SqlSessionFactoryBean 和 MapperScannerConfigurer 来进行分析的, 可以很明显的感觉到,我们是配置好这二个bean后,就可以使用了. 着重看第二个, org.mybatis.spring.mapper.MapperScannerConfigurer 这个bean,就是做了如何将 MyBatis 的 mapper接口文件给加载到 Spring 中来的. **那么这里我在想, 如果有天我自己开发出一个好用的框架来,要与 Spring 进行整合的话,是不是也这样整合就可以了？**\n\n```\n<!-- 配置sqlSessionFactory，SqlSessionFactoryBean是用来产生sqlSessionFactory的 -->\n<bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n    <!-- 加载mybatis的全局配置文件，放在classpath下的mybatis文件夹中了 -->\n    <property name=\"configLocation\" value=\"mybatis/SqlMapConfig.xml\" />\n    <!-- 加载数据源，使用上面配置好的数据源 -->\n    <property name=\"dataSource\" ref=\"dataSource\" />\n</bean>\n\n<!--  配置扫描 MyBatis 接口的包 -->\n<bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n    <property name=\"basePackage\" value=\"com.iyang.sm.mapper\" ></property>\n</bean>\n```\n\n#### 总结\n\n 可以看到 MyBatis 与 Spring 整合后, 对于解析 MyBatis 的 mapper 配置文件等，都是走的之前单个 mybatis 的逻辑, 是没有什么变化的. 主要的是将 , SqlSessionFactory 和 Mapper.class(接口类) 给注入到 Spring 容器中.然后接口的话, 是怎么使用的代理类来进行实例化完后, 将对象给注入到 Spring 容器中的呢 ？ 这里看 org.mybatis.spring.mapper.MapperScannerConfigurer 做的事情就明白了.\n\n 不过在看 mybatis 与 Spring 整合的时候, 还是建议要有对 BeanDefinitionRegistryPostProcessor / InitializingBean / ApplicationContextAware / BeanNameAware 有一定的了接. 就是有了了解后, 你就会很明显的感受到， mybatis 为什么是实现这个接口，实现这个接口并且重写这个方法，在后面是什么时候被调用的. 意思也就是，你至少得明白点 Spring 对外提供的一些扩展点，才能很好的理解这些东西.\n","tags":["java框架","mybatis"],"categories":["java框架","mybatis"]},{"title":"mybatis工作流程阅读","url":"/2021/11/04/mybatis/mybatis工作流程阅读/","content":"\n\n\n#### MyBatis 的工程流程分析\n\n MyBatis 是我们在学习Java框架，也就是学习完JavaWeb的知识后,要学习到的一个ORM的框架. 我也是学习&使用过后，再次对源码进行阅读的. 所以这篇文章记录 MyBatis 的一个 work flow.\n\n 先放上项目地址 : https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-work-flow\n\n 有兴趣的同学,可以clone下来看看.\n\n#### 案例代码\n\n先放上案列的代码, 然后我们可以挨个的分析.\n\n```\npublic class InitHelloMyBatis {\n\n    public static void main(String[] args) throws IOException {\n        // 读取配置文件.\n        InputStream mybatisInputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\n        // 传入读取配置文件的流,使用SqlSessionFactoryBuilder来\n        // 构建 SqlSessionFactory.\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mybatisInputStream);\n        // 从 SqlSessionFactory 中获取SqlSession会话.\n        SqlSession session = sqlSessionFactory.openSession();\n\n        // 从会话中获取 Mapper.\n        BlogMapper blogMapper = session.getMapper(BlogMapper.class);\n        \n        // 调用查询方法.\n        TbBlog tbBlog = blogMapper.selectBlog(1);\n        System.out.println(tbBlog);\n        \n    }\n\n}\n```\n\n这里说下大致流程 :\n\n- 使用 Resources 来读取 mybatis-config.xml配置文件, 如果该文件不存在或者读取出来 InputStream 是 null 的话,程序就会抛出 IOException 的错误来.\n- 读取配置没有问题,来到 new SqlSessionFactoryBuilder().build(io) 来构建出一个 SqlSessionFactory 来, 这里构建出来的 SqlSessionFactory 肯定是有已经讲配置文件给全部加载进去了的.\n- SqlSessionFactory.openSession() 从 SqlSessionFactory 中获取一次会话, 然后可以从会话中获取出接口(BlogMapper)来,这里是不是有点好奇,明明这就是一个接口,也没有实现类,怎么就可以get出一个接口对象来?获取出接口来,然后就可以调用接口中的方法, 根据id查询出数据来.\n\n可以看到,根据从官网写的一个列子,从表面来看,代码量并不是很多. 所以接下来点去源码,去跟进源码中的每个方法,到底做了些什么事情.\n\n**读取配置文件**\n\n```\nInputStream mybatisInputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\n```\n\norg.apache.ibatis.io.Resources (Class).\n\n可以看到MyBatis源码还写了一个 ClassLoader的包装类，通过ClassLoaderWrapper包装类来讲配置文件转化为InputSream.\n\n如果返回的InputStream是null，就会抛出IOException来.\n\n```\n/**\n * Returns a resource on the classpath as a Stream object\n *\n * @param loader   The classloader used to fetch the resource\n * @param resource The resource to find\n * @return The resource\n * @throws java.io.IOException If the resource cannot be found or read\n */\nprivate static ClassLoaderWrapper classLoaderWrapper = new ClassLoaderWrapper();\n\npublic static InputStream getResourceAsStream(ClassLoader loader, String resource) throws IOException {\n  // 利用 ClasssLoaderWrapper.  \n  InputStream in = classLoaderWrapper.getResourceAsStream(resource, loader);\n  if (in == null) {\n    throw new IOException(\"Could not find resource \" + resource);\n  }\n  return in;\n}\n```\n\n于是我们接着看 ClassLoaderWrapper 是怎么 读取配置文件 & 转化为 InputStream 流的.\n\n```\n// 这里返回的是 ClassLoader的数组,如果对ClassLoader不是很了解的话,可以先去百度了解下.\nClassLoader[] getClassLoaders(ClassLoader classLoader) {\n  return new ClassLoader[]{\n      // 传递进来的 \n      classLoader,\n      // 默认的 ClassLoader\n      defaultClassLoader,\n      // 根据当前线程获取出来的\n      Thread.currentThread().getContextClassLoader(),\n      // 根据当前 Class 获取出来的.\n      getClass().getClassLoader(),\n      // 系统的ClassLoader.\n      systemClassLoader};\n}\n\n\n// 获取到了 classLoader的数组,然后对其进行迭代.\n// 也就是使用 ClassLoader的  getResourceAsStream 方法,来讲 mybatis-config.xml\n// 配置文件转化为 InputStream.\n// 最后如果获取到InputStream都是null的话,那么返回的也就是null了.\n// 根据上面的说法,返回的如果是null的话,就会出 IOException来.\nInputStream getResourceAsStream(String resource, ClassLoader[] classLoader) {\n    for (ClassLoader cl : classLoader) {\n      if (null != cl) {\n\n        // try to find the resource as passed\n        InputStream returnValue = cl.getResourceAsStream(resource);\n\n        // now, some class loaders want this leading \"/\", so we'll add it and try again if we didn't find the resource\n        if (null == returnValue) {\n          returnValue = cl.getResourceAsStream(\"/\" + resource);\n        }\n\n        if (null != returnValue) {\n          return returnValue;\n        }\n      }\n    }\n    return null;\n  }\n```\n\n**至此,MyBatis读取 mybatis-config.xml 配置文件也就是解析完毕,可以看到采用了自己写的 ClassLoaderWrapper来操作的, 传递一种 ClassLoader进来,其默认的&系统&线程的,加一起也是有四种. 最后挨个进来迭代，满足条件的会读取文件转化为InputStream,如果都是null的话,也会返回null.**\n\n------\n\n**获取SqlSessionFactory & 解析配置文件**\n\nnew SqlSessionFactoryBuilder() 也是new了一个 SqlSessionFactoryBuild,个人理解 SqlSessionFactoryBuilder 就是专程用来构建出 SqlSessionFactory 来的,毕竟其后面有一个 build 方法.\n\nProblem ? 这里有个问题,为什么不将 SqlSessionFactoryBuilder 的build 方法,修改为静态的 ? 如果修改为静态的话，那就不用new了,就可以直接 SqlSessionFactoryBuilder.build(mybatisInputStream);\n\n```\nSqlSessionFactory sqlSessionFactory = new                     SqlSessionFactoryBuilder().build(mybatisInputStream);\n```\n\n**SqlSessionFactory**\n\n接着我们来到 SqlSessionFactory 的 build 方法.\n\n这里在 finnaly 中, 可以看到 ErrorContext 利用了 ThreadLocal , 刚好这周出了 ThreadLocal 的视频.\n\n视频地址 : https://www.bilibili.com/video/BV1Ga4y1W72w\n\n有兴趣&乐于学习&分享的,可以共同进步.\n\n```\npublic SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {\n  try {\n    // 利用传入进来的参数,new出来了一个 XMLConfigBuilder.\n    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);\n    return build(parser.parse());\n  } catch (Exception e) {\n    throw ExceptionFactory.wrapException(\"Error building SqlSession.\", e);\n  } finally {\n    // 这里对 ThreadLocal 中进行 remove() 操作   \n    ErrorContext.instance().reset();\n    try {\n      // 关闭流.  \n      inputStream.close();\n    } catch (IOException e) {\n      // Intentionally ignore. Prefer previous error.\n    }\n  }\n}\n```\n\nnew XmlConfigBuilder() 方法:\n\n```\npublic XMLConfigBuilder(InputStream inputStream, String environment, Properties props) {\n  // 先new一个XMLMapperEntityResolver,再new一个XPathParser,然后就走到下面的构造函数.\n  this(new XPathParser(inputStream, true, props, new XMLMapperEntityResolver()), environment, props);\n}\n\n// 最后还是走到这个构造方法中来.\nprivate XMLConfigBuilder(XPathParser parser, String environment, Properties props) {\n  super(new Configuration());\n  ErrorContext.instance().resource(\"SQL Mapper Configuration\");\n  this.configuration.setVariables(props);\n  this.parsed = false;\n  this.environment = environment;\n  this.parser = parser;\n}\n\n\n----------------------------------------\n// new XPathParser代码:\n    \n  public XPathParser(InputStream inputStream, boolean validation, Properties variables, EntityResolver entityResolver) {\n    // 普通的构造方法.\n    // 对 XPathParser的validation/entityResolver/variables/xpath\n    // 的属性进行赋值操作.\n    commonConstructor(validation, variables, entityResolver);\n    this.document = createDocument(new InputSource(inputStream));\n  }    \n\n\n// createDocument 方法\n  private Document createDocument(InputSource inputSource) {\n    // important: this must only be called AFTER common constructor\n    try {\n      // 这里通过debug看,返回的对象是DocumentBuilderFactoryImpl\n      // 也就是其实现类.  \n      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n     // 对 factory 的 features(HashMap) 添加值,   \n      factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n     // 对 factory 的 validating 进行赋值  \n      factory.setValidating(validation);\n\t // 这下面都是对 factory的属性进行赋值操作.\t\n      factory.setNamespaceAware(false);\n      factory.setIgnoringComments(true);\n      factory.setIgnoringElementContentWhitespace(false);\n      factory.setCoalescing(false);\n      factory.setExpandEntityReferences(true);\n\t\t\n      // 可以看到 return new DocumentBuilderImpl\n      // 最后返回的也是其实现类. \n      DocumentBuilder builder = factory.newDocumentBuilder();\n      builder.setEntityResolver(entityResolver);\n      // 设置错误的handler,可以看到ErrorHandler是接口,这里是匿名实现的\n      // 也就是直接new了接口,然后重写其方法.  \n      builder.setErrorHandler(new ErrorHandler() {\n        @Override\n        public void error(SAXParseException exception) throws SAXException {\n          throw exception;\n        }\n\n        @Override\n        public void fatalError(SAXParseException exception) throws SAXException {\n          throw exception;\n        }\n\n        @Override\n        public void warning(SAXParseException exception) throws SAXException {\n          // NOP\n        }\n      });\n      //   DocumentBuilderImpl 的 parse 解析方法\n      return builder.parse(inputSource);\n    } catch (Exception e) {\n      throw new BuilderException(\"Error creating document instance.  Cause: \" + e, e);\n    }\n  }\n\n-------------\n//   builder.parse(inputSource)\n\n    public Document parse(InputSource is) throws SAXException, IOException {\n        if (is == null) {\n            throw new IllegalArgumentException(\n                DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN,\n                \"jaxp-null-input-source\", null));\n        }\n    // fSchemaValidator 是 null ,跳过.\n        if (fSchemaValidator != null) {\n            if (fSchemaValidationManager != null) {\n                fSchemaValidationManager.reset();\n                fUnparsedEntityHandler.reset();\n            }\n            resetSchemaValidator();\n        }\n  // 使用 xml 的相关类对 is 进行解析  \n        domParser.parse(is);\n //  ?   \n        Document doc = domParser.getDocument();\n // ? 这些解析 Document 的地方.....   \n        domParser.dropDocumentReferences();\n        return doc;\n    }    \n\n\n---------------\n// 最后看到 this 构造函数.\n\n  private XMLConfigBuilder(XPathParser parser, String environment, Properties props) {\n    /** new Configuration() 中,TypeAliasRegistry typeAliasRegistry中的 typeAliases,\n    *   在初始化这个对象的时候,就默认设置了一些别名配置.\n    *   初始化的时候,还有对 LanguageDriverRegistry 的 LANGUAGE_DRIVER_MAP 赋值.\n    *  父类 :  BaseBuilder抽象类.\n    *  然后调用super方法,将configuration赋值父类的configuration\n    *  同时将 configuration的typeAliasRegistry和typeHandlerRegistry也赋值\n    *  给当前的这个对象.\n    *   \n    */\n    super(new Configuration());\n    // instance() 方法是往 ThreadLocal里面去set了一个ErrorContext\n    // 最后会在finnaly中进行remove掉.\n    ErrorContext.instance().resource(\"SQL Mapper Configuration\");\n    // 将 props 赋值到 configuration 的 variable 参数.\n    this.configuration.setVariables(props);\n    // 表示还没有被解析\n    this.parsed = false;\n    this.environment = environment;\n    this.parser = parser;\n  }\n```\n\n到这里,就可以看到 this构造方法以及其之前还有new对象的方法,都已经走完了. 这上面的方法,基本都是再为后面的解析xml文件做准备, 并且还有一些初始化数据的赋值操作.\n\n**Note** : 注意这里的 BaseBuilder是抽象类,其实现类是有好几个的. 这种写法,其实是将子类的一些common的方法,写入到 BaseBuilder父类中,然后不同的方法,需要子类自己去重写这个方法实现自己的业务逻辑. 当然一些参数也是可以放在抽象类中.\n\n**build(parser.parse())** : 解析代码.\n\nparser.parse() 方法 :\n\n```\npublic Configuration parse() {\n  // 用 parsed 来控制是否解析过,如果已经解析过了,那就抛出异常.  \n  if (parsed) {\n    throw new BuilderException(\"Each XMLConfigBuilder can only be used once.\");\n  }\n  parsed = true;\n  //   \n  parseConfiguration(parser.evalNode(\"/configuration\"));\n  return configuration;\n}\n\n\n\n---------------------------------\n// parseConfiguration\n// 这里 debug 可以看到 root 是 configuration 的配置文件信息.   \n// 这里可以初步看到实对 我们的配置文件mybatis-config.xml进行解析,并且加载到 configuration中.\n// 后面我们跟着官网文档一步一步的阅读,会有专门对解析配置的源码进行分析.    \n  private void parseConfiguration(XNode root) {\n    try {\n      //issue #117 read properties first\n      //   \n      propertiesElement(root.evalNode(\"properties\"));\n      Properties settings = settingsAsProperties(root.evalNode(\"settings\"));\n      loadCustomVfs(settings);\n      loadCustomLogImpl(settings);\n      typeAliasesElement(root.evalNode(\"typeAliases\"));\n      pluginElement(root.evalNode(\"plugins\"));\n      objectFactoryElement(root.evalNode(\"objectFactory\"));\n      objectWrapperFactoryElement(root.evalNode(\"objectWrapperFactory\"));\n      reflectorFactoryElement(root.evalNode(\"reflectorFactory\"));\n      settingsElement(settings);\n      // read it after objectFactory and objectWrapperFactory issue #631\n      environmentsElement(root.evalNode(\"environments\"));\n      databaseIdProviderElement(root.evalNode(\"databaseIdProvider\"));\n      typeHandlerElement(root.evalNode(\"typeHandlers\"));\n      mapperElement(root.evalNode(\"mappers\"));\n    } catch (Exception e) {\n      throw new BuilderException(\"Error parsing SQL Mapper Configuration. Cause: \" + e, e);\n    }\n  }\n```\n\n**build(parser.parse()) 方法**\n\n这里是对 parser.parse() 调用玩返回的 Configuration 传入到新创建的 DefaultSqlSessionFactory 对象中.\n\n也就是说,我们拿到的 SqlSessionFactory 是 DefaultSqlSessionFactory.\n\n```\npublic SqlSessionFactory build(Configuration config) {\n  return new DefaultSqlSessionFactory(config);\n}\n```\n\n**获取 SqlSession**\n\n```\nSqlSession session = sqlSessionFactory.openSession();\n\n// org.apache.ibatis.session.defaults.DefaultSqlSessionFactory#openSessionFromDataSource\n// 看到这个方法,直接跟进到这个方法来.\n\n  private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {\n    Transaction tx = null;\n    try {\n        \n// 从 configuration中获取出environment来,这里的 getEnvironment对应的是\n// 标签的 <environment>  里面的内容\n// org.apache.ibatis.mapping.Environment\n// 可以看到这个对象,id对应mybatis-config.xml中的environment id\n// datasource 对应  environment > dataSource 字段.\n      final Environment environment = configuration.getEnvironment();\n// 根据    environment 来获取 TransactionFactory,也就是MyBatis的事务工厂.\n// debug 是可以看到  environment 中是有一个JdbcTransactionFactory的,\n// 如果没用的话,就会自己new一个 ManagedTransactionFactory 来.        \n      final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);\n\n// 在 JdbcTransactionFactory 中new出了一个 JdbcTransaction\n// 也就是new了一个JDBC事务.\n// org.apache.ibatis.transaction.jdbc.JdbcTransaction,\n// 可以看到 JdbcTransaction 中有commit / rollback的方法,\n// 也就是说这个地方就是对事务进行操作的地方        \n      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);\n// 这里是获取是执行器,\n// 具体代码: org.apache.ibatis.session.Configuration#newExecutor(org.apache.ibatis.transaction.Transaction, org.apache.ibatis.session.ExecutorType)\n// 这里有 SIMPLE, REUSE, BATCH ,CachingExecutor 还可以在 plugin 中自己定义.\n//executor = (Executor) interceptorChain.pluginAll(executor); 从这行代码可以看到,\n// 其实还是可以自己扩展的.        \n//org.apache.ibatis.plugin.InterceptorChain        \n      final Executor executor = configuration.newExecutor(tx, execType);\n// 最后 new 出了一个默认的 SqlSession 会话.\n// 该会话中存有 configuration / executor 等核心东西.        \n      return new DefaultSqlSession(configuration, executor, autoCommit);\n    } catch (Exception e) {\n      closeTransaction(tx); // may have fetched a connection so lets call close()\n      throw ExceptionFactory.wrapException(\"Error opening session.  Cause: \" + e, e);\n    } finally {\n// 最后还是不忘记对使用过的ThreadLocal 进行remove 操作.        \n      ErrorContext.instance().reset();\n    }\n  }\n```\n\n至此, 可以看到 MyBatis 从SqlSessionFactory中获取出来SqlSession会话, 也可以理解为几个步骤.\n\n首先获取事务工厂, 然后再从事务工厂中获取一个事务来, JdbcTransaction 有兴趣的同学可以看下这个类,里面也是封装了写 commit / rollback等方法. 再接着获取出 执行器(Executor),这里从代码哪里看,执行器还是有几种类型的,也执行自定义. 最后new了一个 DefaultSqlSession 回去.\n\n**session.getMapper(BlogMapper.class);**\n\n接着看,上一步返回的session,是怎么获取到我们写的Mapper接口文件(Mapper这种文件,在解析配置文件的时候,其实就已经解析到MyBatis的configuration里面去了).\n\n```\n@SuppressWarnings(\"unchecked\")\npublic <T> T getMapper(Class<T> type, SqlSession sqlSession) {\n // knownMappers  中 key 是我们定义接口的Class,value是MapperProxyFactory,\n// MapperProxyFactory中的mapperInterface中存放了我们的接口class    \n  final MapperProxyFactory<T> mapperProxyFactory = (MapperProxyFactory<T>) knownMappers.get(type);\n    \n// 如果获取出来的是null,那么MyBatis就认为你传入进来的接口是不存在的,就会抛出异常来.    \n  if (mapperProxyFactory == null) {\n    throw new BindingException(\"Type \" + type + \" is not known to the MapperRegistry.\");\n  }\n  try {\n// 满足条件的话,调用newInstance方法,从方法名字上看,是创建一个instance的实例.      \n    return mapperProxyFactory.newInstance(sqlSession);\n  } catch (Exception e) {\n    throw new BindingException(\"Error getting mapper instance. Cause: \" + e, e);\n  }\n}\n\n-------------------------------------------\n// mapperProxyFactory.newInstance(sqlSession) 代码\n\n    \n  public T newInstance(SqlSession sqlSession) {\n    // new 了一个 MapperProxy对象.\n    final MapperProxy<T> mapperProxy = new MapperProxy<>(sqlSession, mapperInterface, methodCache);\n    return newInstance(mapperProxy);\n  }    \n\n// 最后可以看到使用 Proxy.newProxyInstance方法来创建的一个对象.\n  @SuppressWarnings(\"unchecked\")\n  protected T newInstance(MapperProxy<T> mapperProxy) {\n    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);\n  }\n\n\n\n-------\n// 如果你是debug模式的话,那么你可以看到BlogMapper的对象地址池在 debug 中显示的值.\n// org.apache.ibatis.binding.MapperProxy@ef9296d    \nBlogMapper blogMapper = session.getMapper(BlogMapper.class);\n```\n\n从SqlSession 中获取 BlogMapper我们写的mapper流程, 先从 knownMappers 中根据key获取出来之前加载配置已经加载完毕的信息,如果没用的话,就会抛出没有的异常. 最后使用 Proxy.newProxyIntsance来生成的一个类似接口实现类的代码,不同的是, 在 new MapperProxy 的时候,就已经将接下来需要的信息全部传入进去.\n\n**blogMapper.selectBlog(1) 方法**\n\n竟然 BlogMapper是通过Proxy.newInstance获取出来的,那它是怎么查询的数据库? 又是怎么将字段给映射到 Object一一对应的呢 ?\n\ndebug会走到 MapperProxy的invoke方法来\n\n```\n@Override\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n  try {\n    if (Object.class.equals(method.getDeclaringClass())) {\n      return method.invoke(this, args);\n    } else {\n      return cachedInvoker(method).invoke(proxy, method, args, sqlSession);\n    }\n  } catch (Throwable t) {\n    throw ExceptionUtil.unwrapThrowable(t);\n  }\n}\n\n\n\n------------------\n// 通过 invoke 方法, 走 mapperMethod的execute方法,来到了这里.\n// switch 有 INSERT/UPDATE/DELETE/SELECT/FLUSH,如果这几种没有匹配到的话,就会抛出异常来.    \n  public Object execute(SqlSession sqlSession, Object[] args) {\n    Object result;\n    switch (command.getType()) {\n            \n// 不难看到 INSERT/UPDATE/DELETE都是先调用 convertArgsToSqlCommandParam 方法,\n// 也就是先将参数转化为sql,然后将执行的结果 赋值 给 result 参数.            \n      case INSERT: {\n        Object param = method.convertArgsToSqlCommandParam(args);\n        result = rowCountResult(sqlSession.insert(command.getName(), param));\n        break;\n      }\n      case UPDATE: {\n        Object param = method.convertArgsToSqlCommandParam(args);\n        result = rowCountResult(sqlSession.update(command.getName(), param));\n        break;\n      }\n      case DELETE: {\n        Object param = method.convertArgsToSqlCommandParam(args);\n        result = rowCountResult(sqlSession.delete(command.getName(), param));\n        break;\n      }\n// 如果是 select 语句,可以根据返回值来分类,如果是void&&method.hasResultHandler,就会返回null\n// 多个 / Map类型  /    Cursor 类型   /  最后查询一个        \n      case SELECT:\n        if (method.returnsVoid() && method.hasResultHandler()) {\n          executeWithResultHandler(sqlSession, args);\n          result = null;\n        } else if (method.returnsMany()) {\n          result = executeForMany(sqlSession, args);\n        } else if (method.returnsMap()) {\n          result = executeForMap(sqlSession, args);\n        } else if (method.returnsCursor()) {\n          result = executeForCursor(sqlSession, args);\n        } else {\n          Object param = method.convertArgsToSqlCommandParam(args);\n          result = sqlSession.selectOne(command.getName(), param);\n          if (method.returnsOptional()\n              && (result == null || !method.getReturnType().equals(result.getClass()))) {\n            result = Optional.ofNullable(result);\n          }\n        }\n        break;\n // 刷新会话.           \n      case FLUSH:\n        result = sqlSession.flushStatements();\n        break;\n      default:\n        throw new BindingException(\"Unknown execution method for: \" + command.getName());\n    }\n// 如果result 是 null, 方法返回的修饰符是private并且 返回值不是void的话,就会抛出异常.    \n    if (result == null && method.getReturnType().isPrimitive() && !method.returnsVoid()) {\n      throw new BindingException(\"Mapper method '\" + command.getName()\n          + \" attempted to return null from a method with a primitive return type (\" + method.getReturnType() + \").\");\n    }\n    return result;\n  }\n```\n\n这里可以看到,先是对 INSERT / UPDATE / DELETE / SELECT 进行分类处理, 然后对再分别根据不同的类型进行处理. 都是先有转化为sql,然后将执行结果赋值给result.\n\n至于里面详细的查询执行sql,还有动态sql,每次会话缓存等,后面看到详细的情况再一一说明. 这里只是对MyBatis的基本工作进行了一个梳理. 然后后面再根据基础梳理,再来挨个击碎他们.\n\n至此, MyBatis的入门分析流程是结束的. 理解起来,应该还不是那么难.\n\n#### 总结\n\n根据 com.iyang.mybatis.InitHelloMyBatis , 也就是入门的demo来梳理下流程.\n\n1. 读取配置文件,也就是将配置文件读取,转化为inptStream流.\n2. 利用 SqlSessionFactoryBuilder 来 解析流, 起内部又利用 BaseBuilder(其又很多实现类,这里用的XMLConfigBuilder)也解析xml配置文件. Configuration configuration 该类中是保存着xml配置文件的很多信息. 然后 DefaultSqlSessionFactory 中有configuration字段,也就是属性.\n3. 然后从 DefaultSqlSessionFactory 中获取 SqlSession来, 并且也会是否开启事务(参考:org.apache.ibatis.transaction.jdbc.JdbcTransaction)类,然后获取 Executor,Executor也是有几种种类的,也可以自己自定义,最后返回一个 DefaultSqlSession 来.\n4. 然后从 SqlSession 中获取我们的接口Mapper, 最后也是利用 Proxy.newProxyInstance 来生成的接口,也就是代理(这里打印出地址池或者debug看地址池,就会很明显的看到是代理对象).\n5. 最后走查询的方法, 也就是走到了 MapperProxy 来. 可以看到MapperProxy里面是有sqlSession的,而SqlSession是有 Executor/configuration/autoCommit等信息的, 有了sqlSession,就剩下执行sql和映射sql查询出来的结果来了(这里是 mapperMethod.execute(sqlSession, args) —> org.apache.ibatis.binding.MapperMethod#execute 走到这里来了,这里之后就会分类进行处理,然后映射sql语句).\n6. 至此,一个 MyBatis 的 HelloWorld分析流程是完毕的.\n","tags":["java框架","mybatis"],"categories":["java框架","mybatis"]},{"title":"mybatis中mapper文件阅读","url":"/2021/11/04/mybatis/mybatis中mapper文件阅读/","content":"\n\n\n#### 题记\n\nMyBatis是如何对 Mapper 文件中的sql进行处理呢？ 虽然上篇解析 mybatis-config.xml 是有进行说明的, 但是应该拿出来单独仔细解析下. 因为这个里面涉及到动态sql, 加上mapper文件自身也有很多标签内容,然后MyBatis是怎么读取出这些内容的呢？读取出来后,又是做了怎么样的处理, 然后达到了sql那种执行效果的呢？\n\n意思也就是,Mapper + 动态sql , 内容还是有点多的, 并且也很重要, 是非常有必要拿出来单独的仔细讲解下的.\n\n#### Target\n\n在之前对标签的进行解析的时候,是有对 标签进行一个初步的解析. 然后里面其实是很多内容还没填补很详细,所以特意记录下对 详细操作的. 那么，下文就开始操作吧.\n\n**org.apache.ibatis.builder.xml.XMLMapperBuilder#parse**\n\n主要来看这段解析的代码 :\n\n```\npublic void parse() {\n    \n// 利用 org.apache.ibatis.session.Configuration 的 loadedResources\n// 来判断是不是已经加载过了的.    \n  if (!configuration.isResourceLoaded(resource)) {\n    configurationElement(parser.evalNode(\"/mapper\"));\n// 这里添加到 loadedResources 中来,也就是用来控制是不是已经解析过了的.      \n    configuration.addLoadedResource(resource);\n    bindMapperForNamespace();\n  }\n\n// 这三个方法给我一种好像解析那种没有还没解析完的 ? 这个地方有待完善.    \n  parsePendingResultMaps();\n  parsePendingCacheRefs();\n  parsePendingStatements();\n}\n\n\n// configurationElement 方法,\n// 可以看到这个方法中,很多标签(namespace/parameterMa/resultMap/sql)\n// 还有下面的select/insert/update/delete\n// 这些熟悉的标签\n  private void configurationElement(XNode context) {\n    try {\n      String namespace = context.getStringAttribute(\"namespace\");\n      if (namespace == null || namespace.equals(\"\")) {\n        throw new BuilderException(\"Mapper's namespace cannot be empty\");\n      }\n// 将 namespace 赋值进去,也就是当前正在解析的 namespace.        \n      builderAssistant.setCurrentNamespace(namespace);\n        \n// 这里是对缓存标签进行解析.        \n      cacheRefElement(context.evalNode(\"cache-ref\"));\n      cacheElement(context.evalNode(\"cache\"));\n \n// 解析 parameterMap标签        \n      parameterMapElement(context.evalNodes(\"/mapper/parameterMap\"));\n        \n//         \n      resultMapElements(context.evalNodes(\"/mapper/resultMap\"));\n      sqlElement(context.evalNodes(\"/mapper/sql\"));\n      buildStatementFromContext(context.evalNodes(\"select|insert|update|delete\"));\n    } catch (Exception e) {\n      throw new BuilderException(\"Error parsing Mapper XML. The XML location is '\" + resource + \"'. Cause: \" + e, e);\n    }\n  }\n```\n\n**resultMapElements 方法 :**\n\n```\n// 这里的 list 是 xml 文件中的所有 <resultMap> 标签文件.\nprivate void resultMapElements(List<XNode> list) {\n  for (XNode resultMapNode : list) {\n    try {\n//  有点好奇,该方法返回的 ResultMap 这边好像并没有参数,有点尴尬.\n//  不过是已经存储在 org.apache.ibatis.session.Configuration#resultMaps 中.       \n      resultMapElement(resultMapNode);\n    } catch (IncompleteElementException e) {\n      // ignore, it will be retried\n    }\n  }\n}\n\n----------\n// 最后跟进到这个方法中来.\n  private ResultMap resultMapElement(XNode resultMapNode, List<ResultMapping> additionalResultMappings, Class<?> enclosingType) {\n    ErrorContext.instance().activity(\"processing \" + resultMapNode.getValueBasedIdentifier());\n \n// 获取出 type , 这里我们获取出来的 type 是 TbBlog.    \n    String type = resultMapNode.getStringAttribute(\"type\",\n        resultMapNode.getStringAttribute(\"ofType\",\n            resultMapNode.getStringAttribute(\"resultType\",\n                resultMapNode.getStringAttribute(\"javaType\"))));\n// 先判断 org.apache.ibatis.type.TypeAliasRegistry#typeAliases 中有没有,\n// 如果没有的话,就会自己new一个出来.    \n    Class<?> typeClass = resolveClass(type);\n    if (typeClass == null) {\n// TODO,如果没有话?        \n      typeClass = inheritEnclosingType(resultMapNode, enclosingType);\n    }\n    Discriminator discriminator = null;\n    List<ResultMapping> resultMappings = new ArrayList<>(additionalResultMappings);\n    \n // 获取该 <resultMap> 下的子标签\n// 那么这里也就是获取 <id> 和 <result> 这二个.    \n    List<XNode> resultChildren = resultMapNode.getChildren();\n    for (XNode resultChild : resultChildren) {\n// 分为 constructor / discriminator / 其他 这三类情况        \n      if (\"constructor\".equals(resultChild.getName())) {\n        processConstructorElement(resultChild, typeClass, resultMappings);\n      } else if (\"discriminator\".equals(resultChild.getName())) {\n        discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);\n      } else {\n // 非前二者情况.         \n        List<ResultFlag> flags = new ArrayList<>();\n        if (\"id\".equals(resultChild.getName())) {\n         // 如果标签是id的话,就会给flags添加ResultFlag.ID.\n          flags.add(ResultFlag.ID);\n        }\n  //  将返回回来的 ResultMapping 添加进来.       \n        resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));\n      }\n    }\n// 这里获取的是 <resultMap> 标签的 id 字段.    \n    String id = resultMapNode.getStringAttribute(\"id\",\n            resultMapNode.getValueBasedIdentifier());\n// 这里还可以使用 extends 属性, 不是看到这里, 都好奇还有这种标签.    \n    String extend = resultMapNode.getStringAttribute(\"extends\");\n    Boolean autoMapping = resultMapNode.getBooleanAttribute(\"autoMapping\");\n// 这里 new 了一个 ResultMapResolver 对象.   \n    ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);\n    try {\n// 这里最后就是 new 了一个 ResultMap 对象, 该对象的 id 是 namespace + 方法ID 拼接.\n// 然后将该对象给添加到  org.apache.ibatis.session.Configuration#resultMaps 中来,\n// key 就是其id, 最后就是根据 local / global 来分别进行二种情况检查.        \n      return resultMapResolver.resolve();\n    } catch (IncompleteElementException  e) {\n      configuration.addIncompleteResultMap(resultMapResolver);\n      throw e;\n    }\n  }    \n\n\n//  buildResultMappingFromContext 方法\n// 该方法是对 resultMap 中的字段进行解析.\n  private ResultMapping buildResultMappingFromContext(XNode context, Class<?> resultType, List<ResultFlag> flags) {\n    String property;\n    if (flags.contains(ResultFlag.CONSTRUCTOR)) {\n      property = context.getStringAttribute(\"name\");\n    } else {\n      property = context.getStringAttribute(\"property\");\n    }\n    String column = context.getStringAttribute(\"column\");\n    String javaType = context.getStringAttribute(\"javaType\");\n    String jdbcType = context.getStringAttribute(\"jdbcType\");\n    String nestedSelect = context.getStringAttribute(\"select\");\n    String nestedResultMap = context.getStringAttribute(\"resultMap\", () ->\n      processNestedResultMappings(context, Collections.emptyList(), resultType));\n    String notNullColumn = context.getStringAttribute(\"notNullColumn\");\n    String columnPrefix = context.getStringAttribute(\"columnPrefix\");\n    String typeHandler = context.getStringAttribute(\"typeHandler\");\n    String resultSet = context.getStringAttribute(\"resultSet\");\n    String foreignColumn = context.getStringAttribute(\"foreignColumn\");\n    boolean lazy = \"lazy\".equals(context.getStringAttribute(\"fetchType\", configuration.isLazyLoadingEnabled() ? \"lazy\" : \"eager\"));\n      \n// 获取 javaType , typeHandler , jdbcType 等对象.      \n    Class<?> javaTypeClass = resolveClass(javaType);\n    Class<? extends TypeHandler<?>> typeHandlerClass = resolveClass(typeHandler);\n    JdbcType jdbcTypeEnum = resolveJdbcType(jdbcType);\n// org.apache.ibatis.builder.MapperBuilderAssistant#buildResultMapping(java.lang.Class<?>, java.lang.String, java.lang.String, java.lang.Class<?>, org.apache.ibatis.type.JdbcType, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.Class<? extends org.apache.ibatis.type.TypeHandler<?>>, java.util.List<org.apache.ibatis.mapping.ResultFlag>, java.lang.String, java.lang.String, boolean)\n// 可以看到这里传递进来的参数还是很多的.\n// 最后返回 ResultMapping 对象,也就是说这么多参数&buildResultMapping方法中的参数,\n//都设置到该对象中来了.     \n    return builderAssistant.buildResultMapping(resultType, property, column, javaTypeClass, jdbcTypeEnum, nestedSelect, nestedResultMap, notNullColumn, columnPrefix, typeHandlerClass, flags, resultSet, foreignColumn, lazy);\n  }\n```\n\n**SqlElement 方法**\n\n该方法可以很明显的感受到是对 标签进行解析的.\n\n```\nprivate void sqlElement(List<XNode> list) {\n // configuration 获取出来 dataBaseId是null,跳过此方法  \n  if (configuration.getDatabaseId() != null) {\n    sqlElement(list, configuration.getDatabaseId());\n  }\n//    \n  sqlElement(list, null);\n}\n\n// 有点好奇写代码风格:  sqlElement(list,configuration.getDatabaseId());\n------------------------\n\n//  sqlElement 方法\n  private void sqlElement(List<XNode> list, String requiredDatabaseId) {\n    for (XNode context : list) {\n        \n // 获取 databaseId 和 id 这二个属性的值.       \n      String databaseId = context.getStringAttribute(\"databaseId\");\n      String id = context.getStringAttribute(\"id\");\n //  org.apache.ibatis.builder.MapperBuilderAssistant#applyCurrentNamespace   \n // 该方法最后返回的id的值是: namespace + id       \n      id = builderAssistant.applyCurrentNamespace(id, false);\n//sqlFragments 不包含该id就返回true,也就说该Map是确定是否已经解析过了的.         \n      if (databaseIdMatchesCurrent(id, databaseId, requiredDatabaseId)) {\n// 添加到 org.apache.ibatis.builder.xml.XMLMapperBuilder#sqlFragments 中来.          \n        sqlFragments.put(id, context);\n      }\n    }\n  }\n```\n\n最后 解析后的值,是使用 namespace + id 存放在 org.apache.ibatis.builder.xml.XMLMapperBuilder#sqlFragments 的属性中的.\n\n**buildStatementFromContext() 方法 :**\n\n这里是对 select / insert / update / delete 标签进行解析.\n\n```\nbuildStatementFromContext(context.evalNodes(\"select|insert|update|delete\"));\n\n\n// 可以看到 databaseId 的获取与 sql 标签是一样的操作\nprivate void buildStatementFromContext(List<XNode> list) {\n  if (configuration.getDatabaseId() != null) {\n    buildStatementFromContext(list, configuration.getDatabaseId());\n  }\n  buildStatementFromContext(list, null);\n}\n\n\n// 所以我们可以跟进到这个方法来.\n  private void buildStatementFromContext(List<XNode> list, String requiredDatabaseId) {\n    for (XNode context : list) {\n// 先 new 了一个 XMLStatementBuilder 对象, 紧接着就调用该对象的 解析 方法.        \n      final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);\n      try {\n        statementParser.parseStatementNode();\n      } catch (IncompleteElementException e) {\n        configuration.addIncompleteStatement(statementParser);\n      }\n    }\n  }\n\n\n// 解析方法\n  public void parseStatementNode() {\n    String id = context.getStringAttribute(\"id\");\n    String databaseId = context.getStringAttribute(\"databaseId\");\n// 用 namespace + id 组合为 id\n// org.apache.ibatis.session.Configuration#mappedStatements\n// 接着就是判断在 mappedStatements 中是不是有该id,如果不存在就返回ture,\n// 存在就返回false,这里也就会直接return出去,也就是不会往后面执行了.      \n    if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) {\n      return;\n    }\n// 获取标签名字,  select / insert/ update /delete.\n    String nodeName = context.getNode().getNodeName();\n// 转化为大写的 SELECT      \n    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));\n    boolean isSelect = sqlCommandType == SqlCommandType.SELECT;\n// 是否刷新 cache,也就是select是不刷新的,那么其他的就应该是要刷新的.      \n    boolean flushCache = context.getBooleanAttribute(\"flushCache\", !isSelect);\n// 使用使用 cache,这里应该是一级缓存，默认开启的.      \n    boolean useCache = context.getBooleanAttribute(\"useCache\", isSelect);\n// 结果排序, 如果没有配置的话,默认就是false.      \n    boolean resultOrdered = context.getBooleanAttribute(\"resultOrdered\", false);\n\n    // Include Fragments before parsing\n// 创建了一个 XMLIncludeTransformer 对象,该对象应该是进行转化的.      \n    XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant);\n //  TODO ? 该方法有待更新     \n    includeParser.applyIncludes(context.getNode());\n\n//获取 parameterType 属性,如果有的话,也会获取出该属性对应的 Class.    \n    String parameterType = context.getStringAttribute(\"parameterType\");\n    Class<?> parameterTypeClass = resolveClass(parameterType);\n\n// lang : null,这里是没有设置的.      \n    String lang = context.getStringAttribute(\"lang\");\n    LanguageDriver langDriver = getLanguageDriver(lang);\n\n    // Parse selectKey after includes and remove them.\n// 这里对是否有 selectKey 进行处理.我们这里目前没有使用 selectKey\n    processSelectKeyNodes(id, parameterTypeClass, langDriver);\n\n    // Parse the SQL (pre: <selectKey> and <include> were parsed and removed)\n    KeyGenerator keyGenerator;\n // selectBlog!selectKey     \n    String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;\n// 这里拼接上 namespace :  com.iyang.mybatis.mapper.BlogMapper.selectBlog!selectKey      \n    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, true);\n\n// 这里是判断是否有 主键自动生成. 这里是查询语句,应该是没有的. \n    if (configuration.hasKeyGenerator(keyStatementId)) {\n      keyGenerator = configuration.getKeyGenerator(keyStatementId);\n    } else {\n      keyGenerator = context.getBooleanAttribute(\"useGeneratedKeys\",\n          configuration.isUseGeneratedKeys() && SqlCommandType.INSERT.equals(sqlCommandType))\n          ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;\n    }\n\n// 创建一个 XMLScriptBuilder 对象,使用该对象的parseScriptNode方法来解析\n// org.apache.ibatis.scripting.xmltags.XMLScriptBuilder#parseScriptNode\n// 获取出sql, 有个 isDynamic 参数,来判断是不是动态sql语句.\n// 这里不是动态sql,最后new了一个RawSqlSource.\n// org.apache.ibatis.builder.SqlSourceBuilder#parse,我们的#{id} 替换成 ? 就是在\n// 这里进行替换的.\n// 如果是动态 sql 的话,就会创建出 DynamicSqlSource 该对象来.\n// 可以看到 SqlSource 下面是有 四个实现类的.\n// 这里返回的 SqlSource里面有sql语句的,和返回类型的.      \n    SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);\n \n// 获取属性.      \n    StatementType statementType = StatementType.valueOf(context.getStringAttribute(\"statementType\", StatementType.PREPARED.toString()));\n    Integer fetchSize = context.getIntAttribute(\"fetchSize\");\n    Integer timeout = context.getIntAttribute(\"timeout\");\n    String parameterMap = context.getStringAttribute(\"parameterMap\");\n// 获取返回类型. 获取出来的 resultTypeClass 是 class com.iyang.mybatis.pojo.TbBlog      \n    String resultType = context.getStringAttribute(\"resultType\");\n    Class<?> resultTypeClass = resolveClass(resultType);\n    String resultMap = context.getStringAttribute(\"resultMap\");      \n    String resultSetType = context.getStringAttribute(\"resultSetType\");\n    ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);\n    if (resultSetTypeEnum == null) {\n      resultSetTypeEnum = configuration.getDefaultResultSetType();\n    }\n// 获取属性的值      \n    String keyProperty = context.getStringAttribute(\"keyProperty\");\n    String keyColumn = context.getStringAttribute(\"keyColumn\");\n    String resultSets = context.getStringAttribute(\"resultSets\");\n\n// 创建一个 MappedStatement.Builder 对象出来.\n// 再通过 builder 构建出一个 MappedStatement 对象来.\n// 最后放入到 org.apache.ibatis.session.Configuration#mappedStatements 中来.      \n    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,\n        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,\n        resultSetTypeEnum, flushCache, useCache, resultOrdered,\n        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);\n  }\n\n  private void processSelectKeyNodes(String id, Class<?> parameterTypeClass, LanguageDriver langDriver) {\n    List<XNode> selectKeyNodes = context.evalNodes(\"selectKey\");\n    if (configuration.getDatabaseId() != null) {\n      parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, configuration.getDatabaseId());\n    }\n    parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, null);\n    removeSelectKeyNodes(selectKeyNodes);\n  }\n```\n\n#### 总结\n\n总结下 MyBatis 解析 Mapper的xml 文件流程。 可以感受到,对于Mybatis处理Mapper,对其字段属性都是挨个解析的,还是下了很大的功夫.\n\n先是有一个集合来控制是否已经解析过了,算是一种是否解析的开关配置. 可以看到其先后的解析顺序,\n\nnamespace –> cache-ref –> cache —> mapper/parameterMap —> mapper/resultMap —> mapper/sql —> select/insert/update/detele.\n\n当解析这些标签的时候, 又会对标签里面的属性进行解析. 这里,主要看下我们平常使用到最多的标签, MyBatis 对这些标签解析了后,其后有是怎么利用的呢？可以看到目前MyBatis是存放在一些configuration等类信息里面,那么等到真正去查询sql语句的时候, MyBatis 又是怎么用上的呢？ 这里目前只讲了如何解析.\n\n解析完了，没异常，那就是解析都ok了，剩下的就是看当 MyBatis 去查询的时候, 是怎么利用上这些资源的呢？所以看接下来的更新.\n","tags":["java框架","mybatis"],"categories":["java框架","mybatis"]},{"title":"mybatis本地缓存阅读","url":"/2021/11/04/mybatis/mybatis本地缓存阅读/","content":"\n#### 题记\n\n####  缓存这个知识点在许多地方都有的，利用到好的话，对系统的很多地方查询是有很大的提升的. 可以看到,MyBatis 也是有 cache 的，那MyBatis 是怎么利用这个缓存的呢？ 在 INSERT/UPDATE/DELETE/SELECT中,是不是只有SELECT的时候用到了缓存，如果是 INSERT/UPDATE/DELETE 是否会对缓存有影响？\n\n 可以看结果来分析，然后跟进源码来仔细分析.\n\n MyBatis 是分为 一级缓存 和 二级缓存的. 那么，我们就先从一级缓存开始.\n\n#### 一级缓存\n\n 案例代码 :\n\n 这里我们是打印的查询sql的语句，再第二次再查询的时候，是\n\n```\nInputStream mybatisInputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\n\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mybatisInputStream);\nSqlSession session = sqlSessionFactory.openSession();\nBlogMapper blogMapper = session.getMapper(BlogMapper.class);\nTbBlog tbBlog = blogMapper.selectBlog(1);\nSystem.out.println(blogMapper.selectBlog(1));\nSystem.out.println(tbBlog);\n\n\n// 结果可以看到,第二次并没有再打印出 sql 语句来.\n==>  Preparing: select * from tb_blog where id = ? \n==> Parameters: 1(Integer)\n<==    Columns: id, name\n<==        Row: 1, 6565\n<==      Total: 1\nTbBlog{id=1, name='6565'}\nTbBlog{id=1, name='6565'}\n```\n\n案例二 : 我们再第二次查询之前 加入 一个add 方法\n\n```\nInputStream mybatisInputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\n\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mybatisInputStream);\nSqlSession session = sqlSessionFactory.openSession();\nBlogMapper blogMapper = session.getMapper(BlogMapper.class);\nTbBlog tbBlog = blogMapper.selectBlog(1);\n\nSystem.out.println(blogMapper.addBlog(\"GavinYang\"));\nSystem.out.println(blogMapper.selectBlog(1));\nSystem.out.println(tbBlog);\n\n// 看结果,可以看到当中间穿插一个 insert 的sql语句,那么在第二次查询的时候,就会执行sql语句.\n// 那么也就说，这个时候缓存是失效了.\n==>  Preparing: select * from tb_blog where id = ? \n==> Parameters: 1(Integer)\n<==    Columns: id, name\n<==        Row: 1, 6565\n<==      Total: 1\n==>  Preparing: insert into tb_blog (name) values(?) \n==> Parameters: GavinYang(String)\n<==    Updates: 1\n1\n==>  Preparing: select * from tb_blog where id = ? \n==> Parameters: 1(Integer)\n<==    Columns: id, name\n<==        Row: 1, 6565\n<==      Total: 1\nTbBlog{id=1, name='6565'}\nTbBlog{id=1, name='6565'}\n```\n\n案例三 : 使用二个 SqlSession 案例\n\n可以很明显的看到 , 在第二次的时候还出现了脏数据.\n\n这里也可以看到一级缓存是只在 SqlSession 中存在的,也就是数据库会话内部共享的.\n\n```\nInputStream mybatisInputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mybatisInputStream);\n\nSqlSession openSession1 = sqlSessionFactory.openSession();\nSqlSession openSession2 = sqlSessionFactory.openSession();\nBlogMapper blogMapper1 = openSession1.getMapper(BlogMapper.class);\nBlogMapper blogMapper2 = openSession2.getMapper(BlogMapper.class);\n\nSystem.out.println(\"blogMapper1 读取数据 \" + blogMapper1.selectBlog(1));\nSystem.out.println(\"blogMapper2 读取数据\" + blogMapper2.selectBlog(1));\n\nSystem.out.println(blogMapper1.updateHashCode(\"PeterWong\"));\n\nSystem.out.println(\"blogMapper1 读取数据 \" + blogMapper1.selectBlog(1));\nSystem.out.println(\"blogMapper2 读取数据\" + blogMapper2.selectBlog(1));\n\n// 然后我们可以看到 log 打印出来的内容\n==>  Preparing: select * from tb_blog where id = ? \n==> Parameters: 1(Integer)\n<==    Columns: id, name\n<==        Row: 1, 6565\n<==      Total: 1\nblogMapper1 读取数据 TbBlog{id=1, name='6565'}\nCreated connection 433287555.\nSetting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@19d37183]\n==>  Preparing: select * from tb_blog where id = ? \n==> Parameters: 1(Integer)\n<==    Columns: id, name\n<==        Row: 1, 6565\n<==      Total: 1\nblogMapper2 读取数据TbBlog{id=1, name='6565'}\n==>  Preparing: update tb_blog set name = ? where id = 1; \n==> Parameters: PeterWong(String)\n<==    Updates: 1\n1\n==>  Preparing: select * from tb_blog where id = ? \n==> Parameters: 1(Integer)\n<==    Columns: id, name\n<==        Row: 1, PeterWong\n<==      Total: 1\nblogMapper1 读取数据 TbBlog{id=1, name='PeterWong'}\nblogMapper2 读取数据TbBlog{id=1, name='6565'}\n```\n\n可以看到我们说了三面的这三种情况, 具体的执行流程可以我们可以现在 案例一里面对第二次 query 进行 debug 分析操作. 当我们debug到 org.apache.ibatis.executor.BaseExecutor#query(org.apache.ibatis.mapping.MappedStatement, java.lang.Object, org.apache.ibatis.session.RowBounds, org.apache.ibatis.session.ResultHandler, org.apache.ibatis.cache.CacheKey, org.apache.ibatis.mapping.BoundSql) 的时候，可以看到 org.apache.ibatis.executor.BaseExecutor#localCache 只有一个 缓存的值的 ， 根据 getObject 方法可以跟进到 org.apache.ibatis.cache.impl.PerpetualCache#cache 中来,\n\n传入进来的 key 值是 : -1896651191:1062027004:com.iyang.mybatis.mapper.BlogMapper.selectBlog:0:2147483647:select * from tb_blog where id = ?:1:development 然后从 cache 中获取出值来, 所以这里就没有走 query 的查询语句.\n\n这是命中缓存的情况.\n\n下面我们来看下, 在第二次 query 之前如果执行了一个 add 方法，为什么就命中不了了呢？\n\n这里可以大致猜测下，在执行完 add 方法后，是不是给 cache 给清除掉了，然后再去查询的时候，就查询不到了.\n\n于是我们在 add 方法上进行 debug 查看下 :\n\n最后我们 debug 跟进到这里 : org.apache.ibatis.executor.BaseExecutor#clearLocalCache 就可以发现\n\n这里是有二个 clear 方法，也就是清除方法.\n\nlocalCache.clear() —-> org.apache.ibatis.cache.impl.PerpetualCache#clear 对应的就是这里的清楚方法，直接调用 HashMap 的clear 方法进行清除.\n\n```\nlocalCache.clear();\nlocalOutputParameterCache.clear();\n```\n\n所以这里可以看出在第二次调用 query 之前，如果是有 insert/update/delete 等方法的话，就会去重置这二个地方的缓存的.\n\nMyBatis 的一级缓存的是跟随 SqlSession 的，这里是可以根据简单的案例效果看出来的.\n\n一级缓存只是使用了一个 HashMap , 最后清除缓存的时候，也是调用 HashMap 的clear 方法\n\n最后从案例三可以看出来，当多个 SqlSession 的时候，由于各自有存有各自的缓存，所以是很容易引起脏数据的, 将缓存级别设置为 Statement.\n\n#### 二级缓存\n\n 可以看到一级缓存的话，是局限于 SqlSession . 如果要多个 sqlSession 之间共享缓存的话，就需要开启二级缓存. 开启的话,我们在 MyBatis 配置文件中加上:\n\n```\n<settings>\n    <setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/>\n\n    <!-- 开启二级缓存 -->\n    <setting name=\"cacheEnabled\" value=\"true\"/>\n</settings>\n```\n\n **案例一 : 是否提交事务**\n\n```\npublic static void main(String[] args) throws Exception {\n\n    InputStream mybatisInputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\n    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mybatisInputStream);\n    SqlSession sqlSession1 = sqlSessionFactory.openSession(true);\n    SqlSession sqlSession2 = sqlSessionFactory.openSession(true);\n\n    BlogMapper blogMapper1 = sqlSession1.getMapper(BlogMapper.class);\n    BlogMapper blogMapper2 = sqlSession2.getMapper(BlogMapper.class);\n\n    System.out.println(\"blogMapper1 获取数据\" + blogMapper1.selectBlog(1));\n    \n    // sqlSession1.commit();\n    \n    System.out.println(\"blogMapper2 获取数据\" + blogMapper2.selectBlog(1));\n\n}\n\n//   ----------------   true结果   -----------------------\n\nCreated connection 492079624.\n==>  Preparing: select * from tb_blog where id = ? \n==> Parameters: 1(Integer)\n<==    Columns: id, name\n<==        Row: 1, 6565\n<==      Total: 1\nblogMapper1 获取数据TbBlog{id=1, name='6565'}\nOpening JDBC Connection\n    \nCreated connection 433287555.\n==>  Preparing: select * from tb_blog where id = ? \n==> Parameters: 1(Integer)\n<==    Columns: id, name\n<==        Row: 1, 6565\n<==      Total: 1\nblogMapper2 获取数据TbBlog{id=1, name='6565'}    \n    \n\n// ------------   加上commit()方法结果   ---------------\n\nCreated connection 630074945.\n==>  Preparing: select * from tb_blog where id = ? \n==> Parameters: 1(Integer)\n<==    Columns: id, name\n<==        Row: 1, 6565\n<==      Total: 1\nblogMapper1 获取数据TbBlog{id=1, name='6565'}\nCache Hit Ratio [com.iyang.mybatis.mapper.BlogMapper]: 0.5\nblogMapper2 获取数据TbBlog{id=1, name='6565'}\n```\n\n 从这里看, 是否提交事务可以看出来，是会影响二级缓存的.\n\n**案例二 : 中间穿插更新语句**\n\n```\npublic static void main(String[] args)  throws Exception {\n\n    InputStream mybatisInputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\n    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mybatisInputStream);\n    SqlSession sqlSession1 = sqlSessionFactory.openSession(false);\n    SqlSession sqlSession2 = sqlSessionFactory.openSession(false);\n    SqlSession sqlSession3 = sqlSessionFactory.openSession(false);\n\n    BlogMapper blogMapper1 = sqlSession1.getMapper(BlogMapper.class);\n    BlogMapper blogMapper2 = sqlSession2.getMapper(BlogMapper.class);\n    BlogMapper blogMapper3 = sqlSession3.getMapper(BlogMapper.class);\n\n    System.out.println(\" blogMapper1 查询出来的数据 : \" + blogMapper1.selectBlog(1));\n    sqlSession1.commit();\n\n    System.out.println(\" blogMapper2 查询出来的结果 : \" + blogMapper2.selectBlog(1));\n\n    System.out.println(blogMapper3.updateHashCode(\"GavinYang\"));\n    sqlSession3.commit();\n\n    System.out.println(\" blogMapper2 查询出来的结果 : \" + blogMapper2.selectBlog(1));\n}\n\n//  ------------------  打印结果 ------\n\nCreated connection 630074945.\nSetting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@258e2e41]\n==>  Preparing: select * from tb_blog where id = ? \n==> Parameters: 1(Integer)\n<==    Columns: id, name\n<==        Row: 1, 6565\n<==      Total: 1\n blogMapper1 查询出来的数据 : TbBlog{id=1, name='6565'}\nCache Hit Ratio [com.iyang.mybatis.mapper.BlogMapper]: 0.5\n blogMapper2 查询出来的结果 : TbBlog{id=1, name='6565'}\n\nCreated connection 603443293.\nSetting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@23f7d05d]\n==>  Preparing: update tb_blog set name = ? where id = 1; \n==> Parameters: GavinYang(String)\n<==    Updates: 1\n1\nCommitting JDBC Connection [com.mysql.jdbc.JDBC4Connection@23f7d05d]\nCache Hit Ratio [com.iyang.mybatis.mapper.BlogMapper]: 0.3333333333333333\nOpening JDBC Connection\n    \n    \nCreated connection 707976812.\nSetting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@2a32de6c]\n==>  Preparing: select * from tb_blog where id = ? \n==> Parameters: 1(Integer)\n<==    Columns: id, name\n<==        Row: 1, GavinYang\n<==      Total: 1\n blogMapper2 查询出来的结果 : TbBlog{id=1, name='GavinYang'}\n```\n\n这里是可以看到在更新之后并且 commit 了事务之后，后面紧跟的 sql 是去查询 数据库了的. 所以这里是可以看出来，update等操作是会去 清空对应的缓存的。\n\n这里我们根据 案例一 的情况来分析，在开启了 二级缓存 的时候，是从哪里获取出来的数据的呢？\n\ndebug 跟进来 : org.apache.ibatis.executor.CachingExecutor#query(org.apache.ibatis.mapping.MappedStatement, java.lang.Object, org.apache.ibatis.session.RowBounds, org.apache.ibatis.session.ResultHandler, org.apache.ibatis.cache.CacheKey, org.apache.ibatis.mapping.BoundSql)\n\n```\n@Override\npublic <E> List<E> query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)\n    throws SQLException {\n  Cache cache = ms.getCache();\n  if (cache != null) {\n    flushCacheIfRequired(ms);\n    if (ms.isUseCache() && resultHandler == null) {\n      ensureNoOutParams(ms, boundSql);\n      @SuppressWarnings(\"unchecked\")\n// debug 到这里，可以看到,就已经返回了我们需要的数据.        \n      List<E> list = (List<E>) tcm.getObject(cache, key);\n      if (list == null) {\n        list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n        tcm.putObject(cache, key, list); // issue #578 and #116\n      }\n      return list;\n    }\n  }\n  return delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n}\n```\n\norg.apache.ibatis.executor.CachingExecutor#tcm 调用这个对象的 getObject 方法获取到了我们需要的值, 跟进来又从 org.apache.ibatis.cache.decorators.TransactionalCache 的 getObject 获取出我们的值, 最后从 org.apache.ibatis.cache.decorators.TransactionalCache#delegate 获取出值, 返回回来的.\n\norg.apache.ibatis.cache.decorators.TransactionalCache#getObject\n\n```\n@Override\npublic Object getObject(Object key) {\n  // issue #116\n// 从缓存中获取出值.    \n  Object object = delegate.getObject(key);\n  if (object == null) {\n// 如果获取出来是null,也就是缓存中没有的话,org.apache.ibatis.cache.decorators.TransactionalCache#entriesMissedInCache 就添加到这个集合中来.      \n    entriesMissedInCache.add(key);\n  }\n  // issue #146\n// commit 后需要 clear 的话，就会返回 null.\n// 这里想下这个变量会不会和我门案例二中的 update 操作有关系呢？\n// 这里再 update后再 debug 发现,  delegate 中获取出来的是 null ,也就是确实是获取不到缓存了\n// 和这个参数没关系.    \n  if (clearOnCommit) {\n    return null;\n  } else {\n    return object;\n  }\n}\n```\n\nMyBatis 二级缓存不适应于配置文件中存在多表查询的情况. 一般我们是单表的 cache, 由于 mybatis 的二级缓存是基于 namespace 的, 多表查询语句所在的 namespace 无法感应到其他的 namespace 中的语句对多表中设计修改，就会引发脏数据. 这个时候，可以采用 cache-ref 来做处理，但是这样的话,缓存的颗粒度就变粗了.\n\n执行流程 : 如果开启了二级缓存的话， MyBatis 会先走二级缓存，如果二级缓存没有的话，就会去一级缓存看看，如果都没有的话，就去查询数据库.\n\n二级缓存 : 用 org.apache.ibatis.executor.CachingExecutor 装饰了 org.apache.ibatis.executor.BaseExecutor 的子类, 委托具体职责给 delegate 之前，实现了二级缓存的查询和写入功能.\n\n#### 总结\n\n最后看 一级缓存和二级缓存，都是利用的 HashMap 这种来做到本地缓存， 只是二级缓存的作用范围比起一级缓存的话，是要大的，并且也利用了一些 装饰者 等设计模式来设计二级缓存的.\n\n如果是部署的分布式项目的话，那么还是 得切换到 redis 这种缓存来了， 本地利用 HashMap 这种缓存满足不了的.\n\n文献参考地址 : https://tech.meituan.com/2018/01/19/mybatis-cache.html\n","tags":["java框架","mybatis"],"categories":["java框架","mybatis"]},{"title":"mybatis中config-xml代码阅读","url":"/2021/11/04/mybatis/mybatis中config-xml代码阅读/","content":"\n\n\n#### 题记\n\n对于配置文件的解析, 还是相对比较好理解的, 就是读取配置文件, 然后在代码需要的地方给使用到.\n\n这里,可以扩展下, Spring / SpringBoot 等是怎么读取配置文件呢 ? 并且配置文件还是有 xml / properties/yaml 等格式的 ， 其读取代码是怎么写的 ? 然后基于 阿波罗(携程开源) 的配置中心 , 其实现配置又是怎么实现的呢 ? 然后这里，看了 Mybatis 读取配置文件, 后续再出 Spring 配置文件的时候，如果二者读取配置进行对比, 你个人更倾向使用代码呢 ?\n\n所以,这里就开启读取 Mybatis 是如何解析配置文件的操作.\n\n#### 配置文件\n\n这里的配置文件解读,是根据 MyBatis官网来一步一步的解析阅读. 如果有官网没有涉及到的,发现了也会在后续加上去的. 解析多行代码, 才能理解 何为优秀.\n\n**标签一 : properties**\n\norg.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfiguration —> propertiesElement(root.evalNode(“properties”)) 方法中来.\n\n```\n// 这里传入进来的 XNode 的值,就是我们写的 properties 标签.\n// 可以看到 XNode的属性,name标签的名字,attributes就是key/value属性\n// 比如这里: key 就是 resource , value 就是 ./db.properties.\nprivate void propertiesElement(XNode context) throws Exception {\n  if (context != null) {\n// 这里调用的node.getChildNodes(),如果有点话,会遍历挨个解析,最后封装成为key/value结构.      \n    Properties defaults = context.getChildrenAsProperties();\n// 获取 resource / url 二者的值.      \n    String resource = context.getStringAttribute(\"resource\");\n    String url = context.getStringAttribute(\"url\");\n// 如果二者都是null,就会抛出异常来.      \n    if (resource != null && url != null) {\n      throw new BuilderException(\"The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.\");\n    }\n      \n // 这里先处理resource,再处理url,也就是有可能url会覆盖掉resource的内容.\n // 二者读取的方式不一样,前者是根据 resource开始读,url是根据绝对路径开始读.\n // 最后 defaults 里面放入的全部是 key/value 对应的键值对\n // 也就是db.properties中的 key / value 相对应i起来.     \n    if (resource != null) {\n      defaults.putAll(Resources.getResourceAsProperties(resource));\n    } else if (url != null) {\n      defaults.putAll(Resources.getUrlAsProperties(url));\n    }\n  \n// 这里看的是 xml 里面是不是直接有 porperties 配置.     \n// 如果有的话,就会putAll进去.      \n    Properties vars = configuration.getVariables();\n    if (vars != null) {\n      defaults.putAll(vars);\n    }\n// 最后吧 defaults,也就是properties给放入到 BaseBuilder 和 Confifuration中去.      \n    parser.setVariables(defaults);\n    configuration.setVariables(defaults);\n  }\n}\n\n\n-----------------------------\n//  如何让 Properties vars = configuration.getVariables(); 有值呢 ?\n//  如果只是单个的 MyBatis 项目的话, 就自己手动new一个properties对象\n//  然后key输入自己要覆盖掉的key就可以了\n        Properties dbConfigProperties = new Properties();\n        dbConfigProperties.setProperty(\"jdbc.password\",\"GavinYang\");\n\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mybatisInputStream,dbConfigProperties);\n```\n\n**标签二 : settings**\n\n这是 MyBatis对 settings 的操作.\n\n具体的 settings 中每项配置参考官网链接 : https://mybatis.org/mybatis-3/configuration.html#properties\n\n```\n// 解析 setting ---> 转化为 key /value\nProperties settings = settingsAsProperties(root.evalNode(\"settings\"));\n// \nloadCustomVfs(settings);\nloadCustomLogImpl(settings);\n```\n\nsettingsAsProperties 方法\n\n可以看到, 该方法就是进行加载,转化为key/value键值对类型, 然后对其key检验是否在\n\nConfiguration 中都有 set 方法.\n\nNotes : 为了验证下, 我们加上一个没有的标签, 可以看到下面的异常. 所以我们看到这种异常的时候，是可以去检查下是不是名字什么有问题.\n\n### Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: org.apache.ibatis.builder.BuilderException: The setting nnnnn is not known. Make sure you spelled it correctly (case sensitive).\n\n```\nprivate Properties settingsAsProperties(XNode context) {\n  if (context == null) {\n    return new Properties();\n  }\n // 对 settings 下的 setting 进行解析 并且 转化为 key / value 操作.   \n  Properties props = context.getChildrenAsProperties();\n  // Check that all settings are known to the configuration class\n // 对 Configuration 进行校验, 确认上面的 props 中的key 在 Configuration\n// 中是都有set 方法的,目测是后面反射需要使用到.    \n  MetaClass metaConfig = MetaClass.forClass(Configuration.class, localReflectorFactory);\n  for (Object key : props.keySet()) {\n    if (!metaConfig.hasSetter(String.valueOf(key))) {\n      throw new BuilderException(\"The setting \" + key + \" is not known.  Make sure you spelled it correctly (case sensitive).\");\n    }\n  }\n  return props;\n}\n```\n\nloadCustomVfs(settings) 方法\n\n该方法,主要就是读取 vfsImpl 对用的value,切割下,然后用 classForName 来获取 class,\n\n最后赋值到 configuration 中去. 这里算是对 vfs 的一种自定义的扩展,虽然目前还不太清楚vfs具体作用.\n\n```\nprivate void loadCustomVfs(Properties props) throws ClassNotFoundException {\n  // 获取 vfsImpl 的 value.  \n  String value = props.getProperty(\"vfsImpl\");\n  if (value != null) {\n   // 根据 , 进行切割.   \n    String[] clazzes = value.split(\",\");\n    for (String clazz : clazzes) {\n      if (!clazz.isEmpty()) {\n        @SuppressWarnings(\"unchecked\")\n        // 反射,获取出 Class , 最后赋值到 configuration 中去.  \n        Class<? extends VFS> vfsImpl = (Class<? extends VFS>)Resources.classForName(clazz);\n        configuration.setVfsImpl(vfsImpl);\n      }\n    }\n  }\n}\n```\n\nloadCustomLogImpl(settings) 方法\n\n```\nprivate void loadCustomLogImpl(Properties props) {\n  Class<? extends Log> logImpl = resolveClass(props.getProperty(\"logImpl\"));\n  // 将 log set 到 configuration 中去.  \n  configuration.setLogImpl(logImpl);\n}\n\n-----------------------\n// resolve 最后如果不是 null 的话,\norg.apache.ibatis.type.TypeAliasRegistry#resolveAlias\n\n // 就会走到这里,这里可以看先是在 typeAliases(HashMap) 中判断下,如果存在就直接获取\n// 如果不存在就用 Resources.ClassForName来操作\n// 这里的 HashMap就类似于,记录之前是否已经加载了或者预热.\n// 如果是用来做cache的话, 那就应该最后会在 return 之前继续把值给放入进去.    \n  public <T> Class<T> resolveAlias(String string) {\n    try {\n      if (string == null) {\n        return null;\n      }\n      // issue #748\n      String key = string.toLowerCase(Locale.ENGLISH);\n      Class<T> value;\n      if (typeAliases.containsKey(key)) {\n        value = (Class<T>) typeAliases.get(key);\n      } else {\n        value = (Class<T>) Resources.classForName(string);\n      }\n      return value;\n    } catch (ClassNotFoundException e) {\n      throw new TypeException(\"Could not resolve type alias '\" + string + \"'.  Cause: \" + e, e);\n    }\n  }    \n\n\n------------\n// 如果我们在配置文件中没有定义的话,这里默认是null,也就是说不会set进去.    \n  public void setLogImpl(Class<? extends Log> logImpl) {\n    if (logImpl != null) {\n      this.logImpl = logImpl;\n      LogFactory.useCustomLogging(this.logImpl);\n    }\n  }\n```\n\n**标签三 :**\n\n关于别名的配置.\n\n```\ntypeAliasesElement(root.evalNode(\"typeAliases\"));\nprivate void typeAliasesElement(XNode parent) {\n  if (parent != null) {\n   // 对 typeAliases 下的子标签进行迭代.\n   // 分为是 package 和非 package   \n    for (XNode child : parent.getChildren()) {\n      if (\"package\".equals(child.getName())) {\n       // 获取你输入的包   \n        String typeAliasPackage = child.getStringAttribute(\"name\");\n        configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);\n      } else {\n // <typeAlias type=\"com.iyang.mybatis.pojo.TbBlog\" alias=\"TbBlog\" />\n // 这里就是对这种进行解析的         \n        String alias = child.getStringAttribute(\"alias\");\n        String type = child.getStringAttribute(\"type\");\n        try {\n          Class<?> clazz = Resources.classForName(type);\n   // 如果没写别名,就只传入 clazz.         \n          if (alias == null) {\n            typeAliasRegistry.registerAlias(clazz);\n          } else {\n   // 写了别名,就别名和clazz一起传入进来.           \n            typeAliasRegistry.registerAlias(alias, clazz);\n          }\n        } catch (ClassNotFoundException e) {\n          throw new BuilderException(\"Error registering typeAlias for '\" + alias + \"'. Cause: \" + e, e);\n        }\n      }\n    }\n  }\n}\n\n\n----------------\n// 这里可以看到是根据 packageName 来 register进来的.    \n  public void registerAliases(String packageName, Class<?> superType) {\n    // new 一个解析器工具类\n    ResolverUtil<Class<?>> resolverUtil = new ResolverUtil<>();\n    // 获取包的path,然后获取该包下的文件,如果文件是.class结尾的话\n    // 最后在 ResolverUtil 中matchess是有该包下的全名称.\n    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);\n    // 这里返回的是上一步说的 matches\n    Set<Class<? extends Class<?>>> typeSet = resolverUtil.getClasses();\n    for (Class<?> type : typeSet) {\n      // Ignore inner classes and interfaces (including package-info.java)\n      // Skip also inner classes. See issue #6\n      // 如果不是接口,不是内部类等条件的话,就走  registerAlias 方法\n      if (!type.isAnonymousClass() && !type.isInterface() && !type.isMemberClass()) {\n // 先获取类名字,判断该类上有没有 @Alias 注解,如果有注解的话,就用注解的值作为缩写的.\n // 最后判断是不是null,是null就会抛出异常来.最后将上面获取出来的缩写名字,转化为大写.\n // 如果此时 typeAliases 是已经有了该值的话,就会抛出异常来.否则就放入到typeAliases来\n // private final Map<String, Class<?>> typeAliases = new HashMap<>();\n // 可以看到 typeAliases 是一个HashMap,并且其存储的Key/Value还是蛮明显的.         \n        registerAlias(type);\n      }\n    }\n  }\n```\n\n**标签四**\n\n扩展的 demo 可以参考 MyBatis官网 : https://mybatis.org/mybatis-3/configuration.html\n\n然后看 MyBatis 是如何将插件给利用上的呢 ?\n\n首先在 mybatis-config.xml 中配置好我们自己定义的 plugin\n\n这里以我配置了二个插件\n\n```\n<plugins>\n    <plugin interceptor=\"com.iyang.mybatis.plugins.ExamplePlugin\">\n        <property name=\"name\" value=\"GavinYang\"/>\n        <property name=\"age\" value=\"22\"/>\n        <property name=\"hobby\" value=\"lwf\"/>\n    </plugin>\n\n    <plugin interceptor=\"com.iyang.mybatis.plugins.QuerySqlPlugin\">\n\n        <property name=\"name\" value=\"GavinYang\"/>\n    </plugin>\n</plugins>\n```\n\n// 处理 plugin 的代码\n\n```\nprivate void pluginElement(XNode parent) throws Exception {\n  // 这里传入进来的就是 <plugins>整个标签内容.  \n  if (parent != null) {\n   // 获取 <plugins> 下的 <plugin> 集合,进行迭代处理.   \n    for (XNode child : parent.getChildren()) {\n     // 获取插件的 全限定名字.   \n      String interceptor = child.getStringAttribute(\"interceptor\");\n     // 获取我们定义在 plugin 下的 properties.   \n      Properties properties = child.getChildrenAsProperties();\n// resolveClass是最后注册到typeAliasRegistry来.    \n// 实例化,这里就可以看到我们在定义的Plugin中,无参构造函数打印出来的内容了.        \n      Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).getDeclaredConstructor().newInstance();\n// 将 properties 赋值给  interceptorInstance\n// 也就是放入到 interceptorInstance 来.        \n      interceptorInstance.setProperties(properties);\n// org.apache.ibatis.plugin.InterceptorChain\n// 这是是将interceptorInstance添加到InterceptorChain的interceptors中来.        \n      configuration.addInterceptor(interceptorInstance);\n    }\n  }\n}\n```\n\n可以看到 MyBatis在加载plugin的时候,是利用了反射来new出一个对象来,并且注册到 typeAliasRegistry 中来. 这里主要是解析 plugin 的配置, 后面在执行sql的时候,都是如何使用到这些 plugin 的呢 ? 肯定是有一个从InterceptorChain中获取interceptors来,然后进行处理.\n\n**标签五 : < objectFactory >**\n\nobjectFactory 的处理方式是和 标签四相似的,只是最后在使用场景是有点不同的.\n\n代码上的操作也是类似的.\n\n```\nprivate void objectFactoryElement(XNode context) throws Exception {\n  if (context != null) {\n    String type = context.getStringAttribute(\"type\");\n    Properties properties = context.getChildrenAsProperties();\n    ObjectFactory factory = (ObjectFactory) resolveClass(type).getDeclaredConstructor().newInstance();\n    factory.setProperties(properties);\n    configuration.setObjectFactory(factory);\n  }\n}\n```\n\n**标签五 :**\n\n该标签在 MyBatis 官网是没有demo, 我是根据代码来顺藤摸瓜写的一个.\n\n参考 : org.apache.ibatis.reflection.wrapper.DefaultObjectWrapperFactory 这个源码,来模仿写的一个.\n\n```\nobjectWrapperFactoryElement(root.evalNode(\"objectWrapperFactory\"));\nprivate void objectWrapperFactoryElement(XNode context) throws Exception {\n  if (context != null) {\n   // 获取 配置文件中的type值   \n    String type = context.getStringAttribute(\"type\");\n // 先注册到  typeAliasRegistry 来,然后实例化这个类.\n // 我们在自己定义的类中,写一个无参构造函数,就可以看到我们打印的内容了.     \n    ObjectWrapperFactory factory = (ObjectWrapperFactory) resolveClass(type).getDeclaredConstructor().newInstance();\n// 最后赋值到 confifuration 中来.      \n    configuration.setObjectWrapperFactory(factory);\n  }\n}\n```\n\n**标签六 : < reflectorFactory >**\n\n处理方式和上面类似.\n\n这里我们自己写一个 com.iyang.mybatis.factory.GavinReflectorFactory 来继承DefaultReflectorFactory,在无参数构造函数中打印下内容, 然后debug跟进.\n\n```\nprivate void reflectorFactoryElement(XNode context) throws Exception {\n  if (context != null) {\n    String type = context.getStringAttribute(\"type\");\n    ReflectorFactory factory = (ReflectorFactory) resolveClass(type).getDeclaredConstructor().newInstance();\n    configuration.setReflectorFactory(factory);\n  }\n}\n```\n\n**标签七 :**\n\nenvironments 标签都是放入一些 db 的配置信息等.\n\n```\n<environments default=\"development\">\n    <environment id=\"development\">\n        <!-- 事务 -->\n        <transactionManager type=\"JDBC\"/>\n        \n        <!-- DB 连接配置 -->\n        <dataSource type=\"POOLED\">\n            <property name=\"driver\" value=\"${jdbc.driver}\" />\n            <property name=\"url\" value=\"${jdbc.url}\" />\n            <property name=\"username\" value = \"${jdbc.username}\" />\n            <property name=\"password\" value=\"${jdbc.password}\" />\n        </dataSource>\n    </environment>\n</environments>\nprivate void environmentsElement(XNode context) throws Exception {\n  if (context != null) {\n    if (environment == null) {\n// 获取 default 对应字段的值         \n      environment = context.getStringAttribute(\"default\");\n    }\n// 这里的 getChildren 获取的是 <environments> --> <environment>下的子标签      \n    for (XNode child : context.getChildren()) {\n      String id = child.getStringAttribute(\"id\");\n// 确保 id 和  上一步的environment 的值是相同的,就会返回true.      \n      if (isSpecifiedEnvironment(id)) {\n/**\n*  获取出 transactionManager 对应的标签.\n*  然后根据 JBDC(配置文件中的值),然后从 typeAliasRegistry中获取出来，\n*  调用反射来 实例化 这个对象. \n*  最后还是可以配置 properties,会被set到txFactory中去的.\n*  但是 JdbcTransactionFactory 好像没有重写 setProperties 方法.\n*/          \n        TransactionFactory txFactory = transactionManagerElement(child.evalNode(\"transactionManager\"));\n// 先获取  dataSource 字段\n/**\n*  先获取type的值,然后再获取 properties的标签字段值.\n*  根据我们的配置 : org.apache.ibatis.datasource.pooled.PooledDataSourceFactory,应该会获取出这个对象.该对象其内部是有一个,org.apache.ibatis.datasource.pooled.PooledDataSource的,里面有部分默认值的.\n*最后将  properties 调用 org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory#setProperties方法,\n最后是将 properties 里面的key/value 都设置到 MetaObject metaDataSource = SystemMetaObject.forObject(dataSource);来了.\n*/\n        DataSourceFactory dsFactory = dataSourceElement(child.evalNode(\"dataSource\"));\n// 从  PooledDataSourceFactory 中获取 datasource 属性.         \n        DataSource dataSource = dsFactory.getDataSource();\n// 这里采用链式编程,也就是将id/txFactory/dataSource 都给set到 Environment.Builder来了.         \n        Environment.Builder environmentBuilder = new Environment.Builder(id)\n            .transactionFactory(txFactory)\n            .dataSource(dataSource);\n  //    environmentBuilder.build() 也就是new 了一个 Environment \n  // 最后 赋值到 configuration 中来了.        \n        configuration.setEnvironment(environmentBuilder.build());\n      }\n    }\n  }\n}\n```\n\n解析 environments ,利用 typeAliasRegistry 中已经注册好了的信息,然后根据名字缩写(比如JDBC)这种,来获取class对象, 用 反射来 new 一波对象出来,真是美滋滋. 接着就是解析 事务/JDBC连接配置信息等, 最后将信息保存到 DataSource 中来. 反手再来一波 链式编程 来new对象出来, 最后就是一个 Environment 对象出来,给set 到 configuration 中来.\n\n**标签八**\n\n到这里,可以看到对xml的解析操作. 先解析 标签 的值出来,然后根据值进行分类处理或者根据自己的需求来进行处理.\n\n```\nprivate void typeHandlerElement(XNode parent) {\n  if (parent != null) {\n    for (XNode child : parent.getChildren()) {\n      // 如果子标签是 package   \n      if (\"package\".equals(child.getName())) {\n       // 获取出 name 对应的值.   \n        String typeHandlerPackage = child.getStringAttribute(\"name\");\n      // 注册到   typeHandlerRegistry 中来.  \n        typeHandlerRegistry.register(typeHandlerPackage);\n      } else {\n // 这里获取出三种值来,   javaType/jdbcType/  handler    \n        String javaTypeName = child.getStringAttribute(\"javaType\");\n        String jdbcTypeName = child.getStringAttribute(\"jdbcType\");\n        String handlerTypeName = child.getStringAttribute(\"handler\");\n        Class<?> javaTypeClass = resolveClass(javaTypeName);\n        JdbcType jdbcType = resolveJdbcType(jdbcTypeName);\n        Class<?> typeHandlerClass = resolveClass(handlerTypeName);\n  // 分为  javaTypeClass 是不是 null 的情况       \n        if (javaTypeClass != null) {\n         // 基于 javaTypeClass 是不是 null的情况,再判断 jdbcType 是不是null  \n          if (jdbcType == null) {\n            typeHandlerRegistry.register(javaTypeClass, typeHandlerClass);\n          } else {\n            typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass);\n          }\n        } else {\n// 这是根据   handlerTypeName 注册到 typeHandlerRegistry 中来.           \n          typeHandlerRegistry.register(typeHandlerClass);\n        }\n      }\n    }\n  }\n}\n```\n\n**标签九 :**\n\n该标签是对我们对应的对象,其sql语句存放的地址. 也就是里面放入的是于mapper接口对应的方法,查询的sql语句.\n\n接下来看下 MyBatis 是对 mappers 标签的内容进行了说明解析和处理.\n\n```java\nprivate void mapperElement(XNode parent) throws Exception {\n  if (parent != null) {\n      \n // getChildren 获取的是 mappers 下的 mapper 标签\n    for (XNode child : parent.getChildren()) {\n// 如果配置的是 package.        \n      if (\"package\".equals(child.getName())) {\n        String mapperPackage = child.getStringAttribute(\"name\");\n        configuration.addMappers(mapperPackage);\n      } else {\n// 获取出    resource/url/class 这三类的值.       \n        String resource = child.getStringAttribute(\"resource\");\n        String url = child.getStringAttribute(\"url\");\n        String mapperClass = child.getStringAttribute(\"class\");\n // 对 resource 处理         \n        if (resource != null && url == null && mapperClass == null) {\n          // 将 resource 赋值给 ErrorContext 中  \n          ErrorContext.instance().resource(resource);\n     // 读取文件.       \n          InputStream inputStream = Resources.getResourceAsStream(resource);\n// 使用 XMLMapperBuilder 来对解析xml内容.            \n          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());\n          mapperParser.parse();\n// url 处理            \n        } else if (resource == null && url != null && mapperClass == null) {\n          ErrorContext.instance().resource(url);\n          InputStream inputStream = Resources.getUrlAsStream(url);\n          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());\n          mapperParser.parse();\n// mapperClass 处理            \n        } else if (resource == null && url == null && mapperClass != null) {\n          Class<?> mapperInterface = Resources.classForName(mapperClass);\n          configuration.addMapper(mapperInterface);\n        } else {\n          throw new BuilderException(\"A mapper element may only specify a url, resource or class, but not more than one.\");\n        }\n      }\n    }\n  }\n}\n\n\n\n-----------------------\n// 这里我们跟进 mapperParser.parse() 方法来\n// org.apache.ibatis.builder.xml.XMLMapperBuilder\n  public void parse() {\n  // 判断 configuration 的 loadedResources 是否含有该值,如果不含有的话,就会去解析.  \n    if (!configuration.isResourceLoaded(resource)) {\n// 对mapper 标签进行解析        \n      configurationElement(parser.evalNode(\"/mapper\"));\n      configuration.addLoadedResource(resource);\n      bindMapperForNamespace();\n    }\n\n    parsePendingResultMaps();\n    parsePendingCacheRefs();\n    parsePendingStatements();\n  }    \n\n-----------------------------------\n//   configurationElement 方法\n\n  private void configurationElement(XNode context) {\n    try {\n // 获取 namespace       \n      String namespace = context.getStringAttribute(\"namespace\");\n      if (namespace == null || namespace.equals(\"\")) {\n        throw new BuilderException(\"Mapper's namespace cannot be empty\");\n      }\n//  MapperBuilderAssistant 将 namespace 绑定到该类的参数中来.        \n      builderAssistant.setCurrentNamespace(namespace);\n  \n   // 这里的 cache-ref / cache 都是暂时没有配置的.     \n      cacheRefElement(context.evalNode(\"cache-ref\"));\n      cacheElement(context.evalNode(\"cache\"));\n        \n //  /mapper/parameterMap 也是暂时没有配置的  \n      parameterMapElement(context.evalNodes(\"/mapper/parameterMap\"));\n        \n// resultMap 是对对象字段的映射\n// mapper/sql 是对一些公用的sql进行抽取\n// 二者暂时都没有配置        \n      resultMapElements(context.evalNodes(\"/mapper/resultMap\"));\n      sqlElement(context.evalNodes(\"/mapper/sql\"));\n// 获取 select / insert / update / delete 等 标签.        \n      buildStatementFromContext(context.evalNodes(\"select|insert|update|delete\"));\n    } catch (Exception e) {\n      throw new BuilderException(\"Error parsing Mapper XML. The XML location is '\" + resource + \"'. Cause: \" + e, e);\n    }\n  }    \n\n// 往下跟方法\n  private void buildStatementFromContext(List<XNode> list, String requiredDatabaseId) {\n    for (XNode context : list) {\n      final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);\n      try {\n        statementParser.parseStatementNode();\n      } catch (IncompleteElementException e) {\n        configuration.addIncompleteStatement(statementParser);\n      }\n    }\n  }\n```\n\n","tags":["java框架","mybatis"],"categories":["java框架","mybatis"]},{"title":"SpringBoot动态添加接口","url":"/2021/11/04/spring/SpringBoot动态添加接口/","content":"\n\n\n## 背景\n\n最近看了公司的产品,有一个这样的动态,就是根据input输入的内容,进行动态接口的添加.\n\n比如 我在没有添加之前,访问 http://localhost:8080/test 该地址是404, 于是通过input的输入创建,就相当于动态添加了一个接口,于是就可以访问了.\n\n实现的方式有很多种, 具体的想要的效果肯定是需要根据自己的业务角度来.\n\n## 实现思路\n\n这里是说下个人的实现思路 :\n\n- 方案一 : 先定义好类,然后使用反射根据定义的类,创建好一个对象出来,然后将这个对象给注入到Spring容器中来,这里不仅仅是注入进来这么简单,还是需要经过 MVC(也就是Controller等注解的匹配操作)来实现\n- 方案二 : 基于请求404的拦截来现实. 比如你新添加的接口访问肯定是404,于是我们可以定义一个拦截,然后获取出请求的路径,根据提前定好的一些设置,进行逻辑的处理.\n\n这里肯定还会有很多好的实现思路,并且基于每个框架都是不一样的,这里更多的是基于 SpringBoot框架来实现这个思路的.\n\n## 代码实现\n\n### 基于反射创建bean注入代码实现\n\n定义一个类的模板\n\n```java\npublic String templateValue = \"import org.springframework.web.bind.annotation.GetMapping;\\n\" +\n        \"import org.springframework.web.bind.annotation.RequestMapping;\\n\" +\n        \"import org.springframework.web.bind.annotation.RestController;\\n\" +\n        \"@RestController\\n\" +\n        \"@RequestMapping(\\\"/test\\\")\\n\" +\n        \"public class TestController {\\n\" +\n        \"    @GetMapping(\\\"/test\\\")\\n\" +\n        \"    public String test(){\\n\" +\n        \"        return \\\"测试Test接口\\\";\\n\" +\n        \"    }\\n\" +\n        \"}\";\n```\n\n提供一个接口来反射创建对象并且注入到spring容器中来:\n\n```java\n@GetMapping(\"/create\")\n    public void createTemplate() throws Exception {\n\n        Map<String, byte[]> bytecode = DynamicLoader.compile(\"TestController.java\", templateValue);\n        MemoryClassLoader classLoader = new MemoryClassLoader(bytecode);\n        Class clazz = classLoader.loadClass(\"TestController\");\n        Object object = clazz.newInstance();\n\n        // 注入 bean 容器的代码 : 容器中是存在这个 bean 对象的,但是Controller却没有访问到.\n        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(object.getClass());\n        ConfigurableApplicationContext context = springUtils.getContext();\n        DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) context.getBeanFactory();\n        beanFactory.registerBeanDefinition(\"testController\",builder.getBeanDefinition());\n\n        RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class);\n        Object oj = context.getBean(\"testController\");\n        Map<Method, RequestMappingInfo> methods = MethodIntrospector.selectMethods(oj.getClass(),(MethodIntrospector.MetadataLookup<RequestMappingInfo>) method ->{\n            try{\n                RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(method, RequestMapping.class);\n                RequestMappingInfo.Builder mappping = RequestMappingInfo.paths(requestMapping.path())\n                                  .methods(requestMapping.method())\n                                  .params(requestMapping.params())\n                                  .headers(requestMapping.headers())\n                                  .consumes(requestMapping.consumes())\n                                  .produces(requestMapping.produces())\n                                  .mappingName(requestMapping.name());\n                return mappping.build();\n            } catch (Exception e){\n                e.printStackTrace();\n            }\n            return null;\n        });\n\n        Method rmhmMethod = mappingHandlerMapping.getClass()\n                            .getDeclaredMethod(\"registerHandlerMethod\",new Class[]{Object.class, Method.class, Object.class});\n\n        rmhmMethod.setAccessible(true);\n        methods.forEach((method,mapping) -> {\n            try{\n                rmhmMethod.invoke(mappingHandlerMapping,new Object[]{oj,method,mapping} );\n            }catch (Exception e){\n                e.printStackTrace();\n            }\n        });\n\n    }\n```\n\nSpring工具类\n\n```java\n@Component\npublic class SpringUtils implements ApplicationContextAware {\n\n    private ApplicationContext context;\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        context = applicationContext;\n    }\n\n    public ConfigurableApplicationContext getContext() {\n        return (ConfigurableApplicationContext)context;\n    }\n\n    public void setContext(ApplicationContext context) {\n        this.context = context;\n    }\n}\n```\n\n到此,就可以动态的创建出一个接口来了。\n\n当然了,这里的代码都是写固定在代码里面的,可以提供 template 或者 通过页面定义给添加进来, 然后调用 反射/注入到Spring容器中等操作即可.\n\n### 基于 404 拦截请求\n\n这是 SpringBoot 本来就有的 404 拦截实现, 如果不做什么处理的话,那么进入到这里来的url地址就会是/error,是无法满足实现的.\n\n```java\n@Slf4j\n@RestController\npublic class SelfErrorController implements ErrorController {\n\n    private final static String ERROR_PATH = \"/error\";\n\n    /**\n     * Supports the HTML Error View\n     *\n     * @param request\n     * @return\n     */\n    @RequestMapping(value = ERROR_PATH)\n    public String errorHtml(HttpServletRequest request) {\n        Integer statusCode = (Integer) request.getAttribute(\"javax.servlet.error.status_code\");\n        String requestURI = request.getRequestURI();\n        log.info(\"在SelfErrorController中请求的路径 : {} \" ,requestURI);\n\n        // 拿到路径后就可以执行相应的代码逻辑.\n        String realUrlName = request.getAttribute(\"realName\").toString();\n        log.info(\"在SelfErrorController中真实存在的请求路径是 : --> {} \" , realUrlName);\n\n        if(statusCode == 401){\n            return  \"{ \\\"code\\\": \\\"401\\\"}\";\n        }else if(statusCode == 404){\n            return \"{ \\\"code\\\": \\\"404\\\"}\";\n        }else if(statusCode == 403){\n            return \"{ \\\"code\\\": \\\"403\\\"}\";\n        }else{\n            return \"{ \\\"code\\\": \\\"500\\\"}\";\n        }\n    }\n    @Override\n    public String getErrorPath() {\n        return null;\n    }\n}\n```\n\n因为上面无法满足的前提下,所以我们可以使用拦截来配置原来的路径.\n\n配置类:\n\n```java\n@Configuration\npublic class MyWebAppConfigurer implements WebMvcConfigurer {\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new SelfInterceptor()).addPathPatterns(\"/**\");\n    }\n}\n```\n\n自定义拦截器:\n\n这里可以看到将原有的路径给set字段realName了.\n\n所以在上面的error接口,我们调用这个realName字段就可以获取到了原有的路径.\n\n```java\n@Component\n@Slf4j\npublic class SelfInterceptor implements HandlerInterceptor {\n    \n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,\n                             Object handler) throws Exception {\n        // 前置拦截器\n        log.info(\"前置拦截器调用 : com.iyang.hello.boot.config.SelfInterceptor.preHandle 中来.\" );\n        String requestURI = request.getRequestURI();\n        log.info(\"在preHandle方法中捕捉到的请求路径 : ---> {} \" , requestURI);\n        // handler 是 ResourceHttpRequestHandler\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response,\n                           Object handler, ModelAndView modelAndView) throws Exception {\n        String requestURI = request.getRequestURI();\n        request.setAttribute(\"realName\",requestURI);\n        if(response.getStatus() == 404){\n            log.info(\"状态是404正常操作\");\n        }\n        log.info(\"请求的url路径是 ---> {} \" , requestURI);\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,\n                                Object handler, Exception ex) throws Exception {\n\n    }\n}\n```\n\n## 总结\n\n该技能看到比较有意思,具体的实现和设计思路其实是有很多种的,具体得看项目的业务是不是需要使用.\n\n并且实现的思路并不是只有这一种,肯定是还有很多种的.\n\n适合自己的业务是最好的.\n","tags":["java","springBoot"],"categories":["java","springBoot"]},{"title":"spring的refresh方法阅读","url":"/2021/11/04/spring/spring的refresh方法阅读/","content":"\n\n\n#### 前言\n\n这里是相对上一次再次的阅读和记录,比上次有了更深入的理解.\n\n这里是再次整理的阅读 Spring 的源码, 相对比上次的阅读，我希望这次可以更清晰&更深刻的理解Spring,也不仅仅会从一个案例来进行分析，会结合多方面的知识来进行整理分析.\n\n 这里放上之前阅读的比例 : https://github.com/baoyang23/source-notes/tree/master/java/spring_bean\n\n 该目录下面有 : bean/get/extend 三个主要地方的分析.\n\n 此模块还是讲述 整体的 flow,后面会对单个进行分析&Spring提供怎么样的扩展方式来进行增强扩展等.\n\n案例入门操作的话,可以参考之前的博客.\n\n#### 分析\n\n 这里我们先不忙这其他类型的bean分析, 就对我们作为 config 的 bean 进行分析. 先单个分析容易理解些.\n\n 入口类 :\n\n```java\npublic class InitWorkFlowSpring {\n\n\n    public static void main(String[] args) {\n\n        AnnotationConfigApplicationContext context =\n                new AnnotationConfigApplicationContext(YangBeanScannerConfig.class);\n        YangBeanScannerConfig yangBeanScannerConfig = context.getBean(YangBeanScannerConfig.class);\n        yangBeanScannerConfig.say();\n\n    }\n\n}\n```\n\n 配置类:\n\n```java\n@ComponentScan(basePackages = \"com.iyang.spring\")\n@Description(value = \"This is GavinYang DemoWorld.\")\npublic class YangBeanScannerConfig {\n\n    public YangBeanScannerConfig(){\n        System.out.println(\"配置扫描初始化打印\");\n    }\n\n    public void say(){\n        System.out.println(\"我是从Spring容器中获取出来的\");\n    }\n}\n```\n\n可以看到，当我们启动 main 方法的时候，是可以看到 YangBeanScannerConfig 中构造函数打印的内容和调用say方法打印出来的内容.\n\n基于这个基础上,我们debug一层一层的走进去看,Spring做了什么事情.\n\n先进入到我们new出来的AnnotationConfigApplicationContext中来\n\n调用自身的无参构造函数\n\n调用 register 注册方法\n\n最后调用一个 refresh, refresh 方法中是做了很多事的.\n\n```java\npublic AnnotationConfigApplicationContext(Class<?>... componentClasses) {\n   this();\n   register(componentClasses);\n   refresh();\n}\n```\n\n那么有了入口，我们就根据这些方法来一个一个的分析.\n\n#### this() 方法 —> org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext()\n\n先来看 this 方法做了什么事情.\n\n创建了二个对象，分别是 注解bd读取/类路口db扫描.\n\n比如有意思的是,传入this(AnnotationConfigApplicationContext), 然后返回来的reader/scanner又属于this.也是相互之间各自都持有各自的引用.\n\n```java\npublic AnnotationConfigApplicationContext() {\n   this.reader = new AnnotatedBeanDefinitionReader(this);\n   this.scanner = new ClassPathBeanDefinitionScanner(this);\n}\n```\n\n##### new AnnotatedBeanDefinitionReader\n\n来，看下new一个对象做了什么事情.\n\n```java\npublic AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) {\n// 这里的 getOrCreateEnvironment 方法中,AnnotationConfigApplicationContext是EnvironmentCapable的子类,\n// 所以Environment也是从AnnotationConfigApplicationContext中获取出来的.    \n   this(registry, getOrCreateEnvironment(registry));\n}\n\n--------------\n    \npublic AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {\n // 检验 registry/environment都不能为null.   \n\t\tAssert.notNull(registry, \"BeanDefinitionRegistry must not be null\");\n\t\tAssert.notNull(environment, \"Environment must not be null\");\n\t\tthis.registry = registry;\n// 这里将 registry/environment 给传入构造到 org.springframework.context.annotation.ConditionEvaluator 中来.\n// ConditionEvaluator又借助org.springframework.context.annotation.ConditionEvaluator.ConditionContextImpl#ConditionContextImpl 来存储这些信息,所以这里最后的信息是在ConditionContextImpl中来了.    \n\t\tthis.conditionEvaluator = new ConditionEvaluator(registry, environment, null);\n// org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors(org.springframework.beans.factory.support.BeanDefinitionRegistry, java.lang.Object)\n// 从该方法的名字上看,是对注册注解配置进行处理.    \n\t\tAnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);\n}\n```\n\n###### org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors(org.springframework.beans.factory.support.BeanDefinitionRegistry, java.lang.Object) 分析\n\n这里根据我们的案列，传入进来的source是null.\n\n```java\npublic static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(\n      BeanDefinitionRegistry registry, @Nullable Object source) {\n// 根据 registry 的类型来获取 DefaultListableBeanFactory.\n// 这里的registry属于GenericApplicationContext,调用其getDefaultListableBeanFactory来获取.    \n   DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);\n   if (beanFactory != null) {\n// beanFactory.getDependencyComparator() 返回的是null,满足条件.       \n      if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {\n// 设置 AnnotationAwareOrderComparator 到beanFactory中来          \n         beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);\n      }\n// get方法获取出来的是SimpleAutowireCandidateResolver,       \n      if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {\n// 设置ContextAnnotationAutowireCandidateResolver到beanFactory中来.          \n         beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());\n      }\n   }\n\n   Set<BeanDefinitionHolder> beanDefs = new LinkedHashSet<>(8);\n\n// 可以看到每个都有 internal 来特意表明内部的意思.    \n// org.springframework.context.annotation.internalConfigurationAnnotationProcessor --->  ConfigurationClassPostProcessor\n// org.springframework.context.annotation.internalAutowiredAnnotationProcessor  --> AutowiredAnnotationBeanPostProcessor\n// org.springframework.context.annotation.internalCommonAnnotationProcessor   ---> CommonAnnotationBeanPostProcessor \n// org.springframework.context.annotation.internalPersistenceAnnotationProcessor  ---> PersistenceAnnotationBeanPostProcessor\n// org.springframework.context.event.internalEventListenerProcessor   ---> EventListenerMethodProcessor\n// org.springframework.context.event.internalEventListenerFactory  --- > DefaultEventListenerFactory\n   if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n      RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);\n      def.setSource(source);\n      beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));\n   }\n\n   if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n      RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);\n      def.setSource(source);\n      beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));\n   }\n\n   // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.\n   if (jsr250Present && !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n      RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);\n      def.setSource(source);\n      beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));\n   }\n\n   // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.\n   if (jpaPresent && !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n      RootBeanDefinition def = new RootBeanDefinition();\n      try {\n         def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,\n               AnnotationConfigUtils.class.getClassLoader()));\n      }\n      catch (ClassNotFoundException ex) {\n         throw new IllegalStateException(\n               \"Cannot load optional framework class: \" + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);\n      }\n      def.setSource(source);\n      beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));\n   }\n\n   if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {\n      RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);\n      def.setSource(source);\n      beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));\n   }\n\n   if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {\n      RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);\n      def.setSource(source);\n      beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));\n   }\n\n   return beanDefs;\n}\n```\n\n这里都是先判断这些内部的bean,是不是已经在 registry 中已经存在了,如果没有存在的话，就会利用类信息来构造出一个RootBeanDefinition来,接着就是调用 registerPostProcessor 方法给注册到 registry 中来.\n\n最后返回一个注册过的 bean 的 Set 集合回去.\n\n总结下这里就是为了给spring容器中注册一些内部的 bean 进去. 这些注册进去的bean,都是在后面初始化bean&解析bean等情况有使用到的.\n\n##### new ClassPathBeanDefinitionScanner() 方法\n\n```java\npublic ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters) {\n   this(registry, useDefaultFilters, getOrCreateEnvironment(registry));\n}\n\n-----------------------------------------------------\n// 最后走到 org.springframework.context.annotation.ClassPathBeanDefinitionScanner#ClassPathBeanDefinitionScanner(org.springframework.beans.factory.support.BeanDefinitionRegistry, boolean, org.springframework.core.env.Environment, org.springframework.core.io.ResourceLoader) 构造函数来.    \npublic ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters,\n\t\t\tEnvironment environment, @Nullable ResourceLoader resourceLoader) {\n\n\t\tAssert.notNull(registry, \"BeanDefinitionRegistry must not be null\");\n// 赋值 registry 来.    \n\t\tthis.registry = registry;\n\n\t\tif (useDefaultFilters) {\n// 添加 filter 到 includeFilters 中来.\n// AnnotationTypeFilter(Component.class)\n// AnnotationTypeFilter(((Class<? extends Annotation>) ClassUtils.forName(\"javax.annotation.ManagedBean\", cl)     \n// 等信息进来      \n\t\t\tregisterDefaultFilters();\n\t\t}\n// org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#setEnvironment\n// 设置 enviornment到父类中来.    \n\t\tsetEnvironment(environment);\n// 这里也是这是到父类来了.\n// 返回的resourcePatternResolver是AnnotationConfigApplicationContext.\n// metadataReaderFactory 是 CachingMetadataReaderFactory 对象来.\n// componentsIndex 是 null.    \n\t\tsetResourceLoader(resourceLoader);\n}\n```\n\n该方法可以看到,添加了三个 filter 到 includeFilters 中来.\n\n设置environment / resource 到 其父类org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider 中来.\n\n也就是setXXX方法是调用的父类.\n\n#### register(componentClasses) 方法\n\n```java\n@Override\npublic void register(Class<?>... componentClasses) {\n   //  检验传入进来的 comonpentClasses是一定要有值的. \n   Assert.notEmpty(componentClasses, \"At least one component class must be specified\");\n   this.reader.register(componentClasses);\n}\n\n-------------------------\n// 这里从名字上就可以很容易看出是注册 bean 的    \npublic void register(Class<?>... componentClasses) {\n\t\tfor (Class<?> componentClass : componentClasses) {\n\t\t\tregisterBean(componentClass);\n\t\t}\n\t}\n\n-----------------------------\nprivate <T> void doRegisterBean(Class<T> beanClass, @Nullable String name,\n\t\t\t@Nullable Class<? extends Annotation>[] qualifiers, @Nullable Supplier<T> supplier,\n\t\t\t@Nullable BeanDefinitionCustomizer[] customizers) {\n// new 一个 bd 出来.\n\t\tAnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(beanClass);\n// 这里没有 @Conditional 注解和 metadata 是 null 就会直接返回 false 来.    \n\t\tif (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {\n\t\t\treturn;\n\t\t}\n\n\t\tabd.setInstanceSupplier(supplier);\n \n// 在对象上获取 @Scope 注解,这里没有,所以就不会往下走.\n// 这里返回的 ScopeMetadata应该是默认的,scopeName是singleton,scopedProxyMode是No/1    \n\t\tScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);\n\t\tabd.setScope(scopeMetadata.getScopeName());\n// 获取 beanName 来    \n\t\tString beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));\n\n// 对一些注解的处理.\n// @Lazy , @Primary , @DependsOn , @Role , @Description 如果有这些注解的话,就会进行处理.\n// 根据注解的名字,来调用相应的set方法.    \n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(abd);\n    \n // 这里是对是否有 @Primary / @Lazy /   @Qualifier 注解进行判断.\n\t\tif (qualifiers != null) {\n\t\t\tfor (Class<? extends Annotation> qualifier : qualifiers) {\n\t\t\t\tif (Primary.class == qualifier) {\n\t\t\t\t\tabd.setPrimary(true);\n\t\t\t\t}\n\t\t\t\telse if (Lazy.class == qualifier) {\n\t\t\t\t\tabd.setLazyInit(true);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tabd.addQualifier(new AutowireCandidateQualifier(qualifier));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//这里 BeanDefinitionCustomizer[] customizers 数组如果有值的话,\n// 会调用 customizer 的 customize 方法传入 bd.\n// TODO , 这里由于没有具体的值,也不是很清楚做了什么事情.    \n\t\tif (customizers != null) {\n\t\t\tfor (BeanDefinitionCustomizer customizer : customizers) {\n\t\t\t\tcustomizer.customize(abd);\n\t\t\t}\n\t\t}\n\n// 用 bd 和 bean的名字，创建出一个 bd 的持有者.    \n\t\tBeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);\n// 这里由于传入进来的 scopeMetadata的值是NO,所以就直接返回bdHolder的持有者了.\n// 可以看到返回下面的代码,是满足一个增强类的概念的.    \n\t\tdefinitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); \n// org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition\n//走到beanFactory中的registerBeanDefinition方法来,先是对bd进行校验,然后利用org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionMap+beaName来判断是不是已经包含了该bean\n// 此时如果你是debug的话,你会发现有五个内置的bean已经在该beanDefinitionMap中了.这也是对应了AnnotatedBeanDefinitionReader中处理的内置的bean.\n//如果beanDefinitionMap中没有的话,就分为是不是已经开始创建bean了.\n//如果没有已经开始创建了,就添加到beanDefinitionMap中来,beanName也会添加到beanDefinitionNames,其实这里有个问题, beanDefinitionMap的key集合就已经是beanName集合了,为什么还单独使用一个集合来维护呢？\n// 这样这个bean的信息和bd就放入到 BeanFactory中来了.    \n// 如果有别名的注解或者配置的话,就会走到registry.registerAlias(beanName, alias);来进行别名的注册. \n\t\tBeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);\n\t}\n```\n\n这里可以总结下看到 register 方法就是对我们的配置类进行扫描, 然后对是否有一些注解进行判断等. 最后使用 BeanDefinitionReaderUtils 工具类的方法将 bd 给 注册到 Spring 容器中来, 注意这时候是没有实例化我们的 YangBeanScannerConfig,只是封装成 bd + beanName 给注册到 BeanFactory 的 beanDefinitionMap 中来了.\n\n#### refresh() 方法\n\n 更新方法，可以看到这个方法内部是走了很多方法,其逻辑也是比较绕的. 不过没事，我们一个一个方法的来看.\n\norg.springframework.context.support.AbstractApplicationContext#refresh()\n\n可以看到其内部的每个方法上面都是有一行注释的.\n\n于是我们挨个方法来debug进来分析.\n\n```java\n// 利用 Object 来当锁对象,避免多个线程同时调用到 refresh 方法来.\nprivate final Object startupShutdownMonitor = new Object();\n\n@Override\npublic void refresh() throws BeansException, IllegalStateException {\n   synchronized (this.startupShutdownMonitor) {\n      // Prepare this context for refreshing.\n  \n      prepareRefresh();\n\n      // Tell the subclass to refresh the internal bean factory.\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n      // Prepare the bean factory for use in this context.\n      prepareBeanFactory(beanFactory);\n\n      try {\n         // Allows post-processing of the bean factory in context subclasses.\n         postProcessBeanFactory(beanFactory);\n\n         // Invoke factory processors registered as beans in the context.\n         invokeBeanFactoryPostProcessors(beanFactory);\n\n         // Register bean processors that intercept bean creation.\n         registerBeanPostProcessors(beanFactory);\n\n         // Initialize message source for this context.\n         initMessageSource();\n\n         // Initialize event multicaster for this context.\n         initApplicationEventMulticaster();\n\n         // Initialize other special beans in specific context subclasses.\n         onRefresh();\n\n         // Check for listener beans and register them.\n         registerListeners();\n\n         // Instantiate all remaining (non-lazy-init) singletons.\n         finishBeanFactoryInitialization(beanFactory);\n\n         // Last step: publish corresponding event.\n         finishRefresh();\n      }\n\n      catch (BeansException ex) {\n         if (logger.isWarnEnabled()) {\n            logger.warn(\"Exception encountered during context initialization - \" +\n                  \"cancelling refresh attempt: \" + ex);\n         }\n\n         // Destroy already created singletons to avoid dangling resources.\n         destroyBeans();\n\n         // Reset 'active' flag.\n         cancelRefresh(ex);\n\n         // Propagate exception to caller.\n         throw ex;\n      }\n\n      finally {\n         // Reset common introspection caches in Spring's core, since we\n         // might not ever need metadata for singleton beans anymore...\n         resetCommonCaches();\n      }\n   }\n}\n```\n\n##### prepareRefresh() 方法\n\n从注释来看, 设置startup数据 & 标识active来表示状态,同时也会初始化一些资源.\n\n```java\n/**\n * Prepare this context for refreshing, setting its startup date and\n * active flag as well as performing any initialization of property sources.\n */\nprotected void prepareRefresh() {\n   // Switch to active.\n   this.startupDate = System.currentTimeMillis();\n// 对状态标识的设置.    \n   this.closed.set(false);\n   this.active.set(true);\n\n   if (logger.isDebugEnabled()) {\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"Refreshing \" + this);\n      }\n      else {\n         logger.debug(\"Refreshing \" + getDisplayName());\n      }\n   }\n\n   // Initialize any placeholder property sources in the context environment.\n// 这里暂时没有实现来做事情.    \n   initPropertySources();\n\n   // Validate that all properties marked as required are resolvable:\n   // see ConfigurablePropertyResolver#setRequiredProperties\n// org.springframework.core.env.AbstractEnvironment#validateRequiredProperties\n// 对 org.springframework.core.env.AbstractPropertyResolver#requiredProperties 进行检验,如果检验到有问题的话,就会抛出异常来.\n// 这里是对 properties 进行检验.    \n   getEnvironment().validateRequiredProperties();\n\n   // Store pre-refresh ApplicationListeners...\n// earlyApplicationListeners是null的话,利用applicationListeners来初始化.   \n   if (this.earlyApplicationListeners == null) {\n      this.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);\n   }\n   else {\n// 如果已经存在值了,就对  applicationListeners 清空，然后全部添加applicationListeners来.     \n      // Reset local application listeners to pre-refresh state.\n      this.applicationListeners.clear();\n      this.applicationListeners.addAll(this.earlyApplicationListeners);\n   }\n\n   // Allow for the collection of early ApplicationEvents,\n   // to be published once the multicaster is available...\n   this.earlyApplicationEvents = new LinkedHashSet<>();\n}\n```\n\n可以看到该方法的话,对状态标识进行设置. 接着地 propertySources 资源来进行初始化, 于是就对property来进行检验. 接下来是对 earlyApplicationListeners/earlyApplicationEvents根据条件来初始化操作.\n\n##### obtainFreshBeanFactroy()\n\n```\nprotected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n   refreshBeanFactory();\n   return getBeanFactory();\n}\n\n---------------------------\norg.springframework.context.support.GenericApplicationContext#refreshBeanFactory\n  \n// 看到 compareAndSet 有点cas 的味道.    \nprotected final void refreshBeanFactory() throws IllegalStateException {    \n\t\tif (!this.refreshed.compareAndSet(false, true)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once\");\n\t\t}\n// private String id = ObjectUtils.identityToString(this);\n// 这里获取出来的id在这个类被new或者子类调用父类的super()构造方法的时候,就已经被初始化值了的.    \n\t\tthis.beanFactory.setSerializationId(getId());\n\t}    \n    \n-----------------\norg.springframework.context.support.GenericApplicationContext#getBeanFactory\n\n// 这里就直接返回了 DefaultListableBeanFactory.   \n\t@Override\n\tpublic final ConfigurableListableBeanFactory getBeanFactory() {\n\t\treturn this.beanFactory;\n\t}\n```\n\n该方法 设置了一个 SerializationId 到 beanFactory 中来. 最后也是返回了一个 DefaultListableBeanFactory 来.\n\n##### prepareBeanFactory() 方法\n\n```java\n/**\n * Configure the factory's standard context characteristics,\n * such as the context's ClassLoader and post-processors.\n * @param beanFactory the BeanFactory to configure\n */\nprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n   // Tell the internal bean factory to use the context's class loader etc.\n// org.springframework.core.io.DefaultResourceLoader#getClassLoader   \n// 设置 class 加载器&赋值进去.    \n   beanFactory.setBeanClassLoader(getClassLoader());\n// 将 beanClassLoader放入SpelParserConfiguration中来,SpelExpressionParser中有含有SpelParserConfiguration作为configuration,StandardBeanExpressionResolver属性又含有SpelExpressionParser. 这也就可以理解为beanClassLoader最后是放入到SpelParserConfiguration来.\n   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n    \n// 传入applicationContext和environment到ResourceEditorRegistrar对象来.\n//然后添加到beanFactory中来.    \n   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));\n\n   // Configure the bean factory with context callbacks.\n// 添加ApplicationContextAwareProcessor后置处理器到org.springframework.beans.factory.support.AbstractBeanFactory#beanPostProcessors中来.\n// 在添加后置处理器到Spring容器之前,会判断这个后置处理起是不是InstantiationAwareBeanPostProcessor/DestructionAwareBeanPostProcessor 这二种情况.\n// 最后添加到 beanPostProcessors 中来.    \n   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n// 然后这里忽略了六种情况的接口. 为什么要忽略呢? 看一个地方.\n// org.springframework.context.support.ApplicationContextAwareProcessor#postProcessBeforeInitialization &  org.springframework.context.support.ApplicationContextAwareProcessor#invokeAwareInterfaces 结合这二个方法来看,是已经对这六种情况的接口做了处理的.    \n   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n\n   // BeanFactory interface not registered as resolvable type in a plain factory.\n   // MessageSource registered (and found for autowiring) as a bean.\n// private final Map<Class<?>, Object> resolvableDependencies = new ConcurrentHashMap<>(16);    \n// org.springframework.beans.factory.support.DefaultListableBeanFactory#resolvableDependencies,这里将 BeanFactory.class和beanFactory给添加到 resolvableDependencies中来了,这里可以看到resolvableDependencies的key是一个Class类型.\n   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n   beanFactory.registerResolvableDependency(ResourceLoader.class, this);\n   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n   beanFactory.registerResolvableDependency(ApplicationContext.class, this);\n\n   // Register early post-processor for detecting inner beans as ApplicationListeners.\n// 这里又添加了一个后置处理器.\n// 传入一个 ApplicationContext 给后置处理器,然后添加到BeanFactory中来.\n// org.springframework.beans.factory.support.AbstractBeanFactory#beanPostProcessors,也即是添加到专门存放 后置处理器的集合中来了.    \n   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));\n\n   // Detect a LoadTimeWeaver and prepare for weaving, if found.\n// beanFactory如果有loadTimeWeaver,那么就添加 LoadTimeWeaverAwareProcessor 后置处理器进来   \n   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n      // Set a temporary ClassLoader for type matching.\n      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n   }\n\n   // Register default environment beans.\n// 不包含environment/systemProperties/systemEnvironment，就会添加到org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#singletonObjects中来.    \n   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());\n   }\n   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());\n   }\n   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());\n   }\n}\n```\n\n这里可以看到,prepareBeanFactory 中做了这些事情 : 添加了 beanClassLoader,添加了二个后置处理器,然后注册了四个 BeanFactory/ResourceLoader/ApplicationEventPublisher/ApplicationContext 到DefaultListableBeanFactory#resolvableDependencies中来了.\n\n最后判断beanFactory是不是不包含一些关于环境的bean,如果是的话,那就调用registerSingleton方法给注册进来.\n\n还是可以看到，这里都是在为环境做准备工作.\n\n##### postProcessBeanFactory() 方法\n\n略略略, 该方法暂无实现类来搞事情…..\n\n```java\n/**\n * Modify the application context's internal bean factory after its standard\n * initialization. All bean definitions will have been loaded, but no beans\n * will have been instantiated yet. This allows for registering special\n * BeanPostProcessors etc in certain ApplicationContext implementations.\n * @param beanFactory the bean factory used by the application context\n */\nprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n}\n```\n\n##### invokeBeanFactoryPostProcessors 方法\n\n这些是对beanFactoryPostProcessors进行处理. 是借用了 PostProcessorRegistrationDelegate.\n\n```java\n/**\n * Instantiate and invoke all registered BeanFactoryPostProcessor beans,\n * respecting explicit order if given.\n * <p>Must be called before singleton instantiation.\n */\nprotected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n// getBeanFactoryPostProcessors() 获取出来的是空集合.    \n   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());\n\n   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime\n   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)\n   if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n   }\n}\n```\n\n###### org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List<org.springframework.beans.factory.config.BeanFactoryPostProcessor>)\n\n该方法从代码上来看,还是做了蛮多的事情.\n\n```java\npublic static void invokeBeanFactoryPostProcessors(\n      ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {\n\n   // Invoke BeanDefinitionRegistryPostProcessors first, if any.\n   Set<String> processedBeans = new HashSet<>();\n\n// 这里是满足条件的    \n   if (beanFactory instanceof BeanDefinitionRegistry) {\n      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;\n      List<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();\n      List<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();\n\n// 对 beanFactory的后置处理器进行迭代处理操作.       \n      for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {\n         if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {\n            BeanDefinitionRegistryPostProcessor registryProcessor =\n                  (BeanDefinitionRegistryPostProcessor) postProcessor;\n            registryProcessor.postProcessBeanDefinitionRegistry(registry);\n            registryProcessors.add(registryProcessor);\n         }\n         else {\n            regularPostProcessors.add(postProcessor);\n         }\n      }\n\n      // Do not initialize FactoryBeans here: We need to leave all regular beans\n      // uninitialized to let the bean factory post-processors apply to them!\n      // Separate between BeanDefinitionRegistryPostProcessors that implement\n      // PriorityOrdered, Ordered, and the rest.\n      List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();\n\n      // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.\n// 根据 BeanDefinitionRegistryPostProcessor.class 来获取beanNames数组,\n// org.springframework.context.annotation.internalConfigurationAnnotationProcessor 这里是获取到了一个内置的BeanFactroyPostProcessor.      \n      String[] postProcessorNames =\n            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n      for (String ppName : postProcessorNames) {\n // 判断是不是有PriorityOrdered,         \n         if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n // 这里的getBean就已经对bean进行初始化，是真正的走反射构造函数拿出来的实例对象.\n // getBean需要仔细分析下，因为其内部在 createBean是走了很多后置处理起来进行增强的. \n// ConfigurationClassPostProcessor 给添加进来.             \n            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n// beanName 添加到 processedBeans集合中来了.             \n            processedBeans.add(ppName);\n         }\n      }\n// 对集合进行排序,从beanFactory中获取出dependencyComparator来,如果没有的话,就用OrderComparator.INSTANCE默认的\n      sortPostProcessors(currentRegistryProcessors, beanFactory);\n// 全部添加到 registryProcessors 中来.       \n      registryProcessors.addAll(currentRegistryProcessors);\n// org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry\n//这里是进入到ConfigurationClassPostProcessor中来了,可以看到其接口 BeanDefinitionRegistryPostProcessor,是重写了接口的方法. \n// ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry 做了什么事情呢?\n// 用System.identityHashCode(registry);计算出registryId来,如果在org.springframework.context.annotation.ConfigurationClassPostProcessor#registriesPostProcessed/factoriesPostProcessed(二个集合)中已经包含了的话,就会抛出已经被调用过的异常来.如果没有的话,就会添加到registriesPostProcessed中来\n// 继续看 org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions 方法,\n//先从registry中获取beanNames来,这其中就有Spring内置的和我们自己定义的yangBeanScannerConfig\n//对beanNames迭代处理,接着就用ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)来判断要不要添加到List<BeanDefinitionHolder> configCandidates集合中来,最后是我们定义的beanName给添加进来了.\n// 对configCandidates集合进行排序,\n// 创建一个ConfigurationClassParser对象来解析每个@Configuration注解类.调用其parse和validate方法,解析完后就是一个ConfigurationClass的Set集合,接着就是new了一个ConfigurationClassBeanDefinitionReader对象来,\n// this.reader.loadBeanDefinitions(configClasses); 这行代码有点根据Config去解析bean的意思.    \n// 具体要等到后面深度解析再反过来定位每行代码的意思.\n// 最后再清除下缓存.       \n      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n// 清空 currentRegistryProcessors 集合      \n      currentRegistryProcessors.clear();\n\n      // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.\n      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n      for (String ppName : postProcessorNames) {\n// 如果processedBeans集合中不包含并且type是Ordered.class才满足进来的条件.          \n         if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {\n            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n            processedBeans.add(ppName);\n         }\n      }\n// 所以这里的currentRegistryProcessors集合是空集合.       \n      sortPostProcessors(currentRegistryProcessors, beanFactory);\n      registryProcessors.addAll(currentRegistryProcessors);\n      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n      currentRegistryProcessors.clear();\n\n      // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.\n// 这里用 while 循环来最后解析,判断从getBeanNamesForType获取出来的bean是不是被解析过了的. \n// 也是用 processedBeans 集合来进行控制的. \n      boolean reiterate = true;\n      while (reiterate) {\n         reiterate = false;\n         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n         for (String ppName : postProcessorNames) {\n            if (!processedBeans.contains(ppName)) {\n               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n               processedBeans.add(ppName);\n               reiterate = true;\n            }\n         }\n         sortPostProcessors(currentRegistryProcessors, beanFactory);\n         registryProcessors.addAll(currentRegistryProcessors);\n         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n         currentRegistryProcessors.clear();\n      }\n\n      // Now, invoke the postProcessBeanFactory callback of all processors handled so far.\n// org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanFactory,这里是走到了postProcessBeanFactory回调方法来了.用org.springframework.context.annotation.ConfigurationClassPostProcessor#factoriesPostProcessed集合来控制是否解析过了.用registriesPostProcessed集合来判断上次是否进入到postProcessBeanDefinitionRegistry方法中来. 如果没有的话,就会再走一边processConfigBeanDefinitions,可以看到 postProcessBeanDefinitionRegistry 方法最后也是走到了processConfigBeanDefinitions中来了.\n//org.springframework.context.annotation.ConfigurationClassPostProcessor#enhanceConfigurationClasses 该方法判断是不是需要代理来增强,这里是没有的,所以就直接return掉了.\n// 最后添加一个 ImportAwareBeanPostProcessor 后置处理器进来.       \n      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);\n// 这里的regularPostProcessors 集合是empty.       \n      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);\n   }\n\n   else {\n      // Invoke factory processors registered with the context instance.\n      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);\n   }\n\n   // Do not initialize FactoryBeans here: We need to leave all regular beans\n   // uninitialized to let the bean factory post-processors apply to them!\n // org.springframework.context.annotation.internalConfigurationAnnotationProcessor和org.springframework.context.event.internalEventListenerProcessor这里获取出来的是二个.   \n   String[] postProcessorNames =\n         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);\n\n   // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,\n   // Ordered, and the rest.\n   List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();\n   List<String> orderedPostProcessorNames = new ArrayList<>();\n   List<String> nonOrderedPostProcessorNames = new ArrayList<>();\n   for (String ppName : postProcessorNames) {\n // 这里是对上面已经处理过了的进行过滤处理.      \n      if (processedBeans.contains(ppName)) {\n         // skip - already processed in first phase above\n      }\n       \n// 这里分为 PriorityOrdered&Ordered&非前二者,分这三种情况分别放入到三个不同的集合中.\n      else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));\n      }\n      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n         orderedPostProcessorNames.add(ppName);\n      }\n      else {\n         nonOrderedPostProcessorNames.add(ppName);\n      }\n   }\n\n// 这里是可以看到先是对PriorityOrdered进行处理,再对Ordered处理,最后对非前二者进行处理.    \n   // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.\n   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\n   // Next, invoke the BeanFactoryPostProcessors that implement Ordered.\n   List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());\n   for (String postProcessorName : orderedPostProcessorNames) {\n // 注意这里是调用了getBean方法.      \n      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n   }\n// 排序    \n   sortPostProcessors(orderedPostProcessors, beanFactory);\n   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);\n\n   // Finally, invoke all other BeanFactoryPostProcessors.\n   List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());\n   for (String postProcessorName : nonOrderedPostProcessorNames) {\n // 注意这里也是调用了 getBean 方法的.      \n      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n   }\n// org.springframework.context.event.EventListenerMethodProcessor#postProcessBeanFactory\n// 这里由于只有一个EventListenerMethodProcessor处理器,所以对应起来的走到其postProcessBeanFactory方法中来.\n// 这里也是调用 postProcessBeanFactory 方法的意思,也就是回调方法.    \n   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);\n\n   // Clear cached merged bean definitions since the post-processors might have\n   // modified the original metadata, e.g. replacing placeholders in values...\n// org.springframework.beans.factory.support.DefaultListableBeanFactory#clearMetadataCache\n// 对 一些集合等进行清除.    \n   beanFactory.clearMetadataCache();\n}\n```\n\n至此就可以看到,该方法主要是对BeanDefinitionRegistryPostProcessor.class和BeanFactoryPostProcessor.class来进行处理.\n\nBeanDefinitionRegistryPostProcessor 又是先处理PriorityOrdered,然后会将处理过的放入processedBeans集合中做一个总的记录，再处理非再processedBeans集合记录中的和是Ordered的,最后用while循环来再确认一遍是不是有还没处理的,这个时候控制条件也是通过 processedBeans来控制是不是处理过了的. 这里注意, 实例化是通过调用 getBean方法来实现的,所以你会发现再调用invokeBeanDefinitionRegistryPostProcessors方法之前,都是会有调用getBean方法的.\n\nBeanFactoryPostProcessor 的处理,这里是一次获取出,然后分为 PriorityOrdered/Ordered/非前二者，分别放入三个集合中进行处理,前提是都没再 processedBeans 集合中. 这里可以看到,如果是PriorityOrdered类型的话，那么在分类的时候就已经调用getBean方法来实例化这个对象了，其他二者都是最后迭代遍历的时候调用getBean方法的. 最后都是sortPostProcessors走下排序，然后调用invokeBeanFactoryPostProcessors方法，这个方法的意思，也就是调用 重写的 postProcessBeanFactory 的方法.\n\n##### registerBeanPostProcessors 方法\n\n该方法传入 beanFactory进来,然后直接借助 PostProcessorRegistrationDelegate 来实现.\n\n```java\nprotected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n   PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);\n}\n```\n\n###### registerBeanPostProcessors 方法\n\n从名字上不难理解，注册 Bean的后置处理器进来.\n\n这里传入进来的 beanFactory 是 DefaultListableBeanFactory , applicationContext是AnnotationConfigApplicationContext\n\n```java\npublic static void registerBeanPostProcessors(\n      ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {\n\n// 获取出 BeanPostProcessor 的名字.\n// org.springframework.context.annotation.internalAutowiredAnnotationProcessor\n// org.springframework.context.annotation.internalCommonAnnotationProcessor\n// 这里获取出来的是二个内部的后置处理器,因为我这里并没有扩展,只是简单的进行说明了下,后面会详细分析。\n// 就是这行代码获取的是什么.    \n   String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);\n\n   // Register BeanPostProcessorChecker that logs an info message when\n   // a bean is created during BeanPostProcessor instantiation, i.e. when\n   // a bean is not eligible for getting processed by all BeanPostProcessors.\n // 6   \n   int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;\n// 传入beanFactory和个数,创建出一个检查bean的后置处理器来.\n// org.springframework.context.support.PostProcessorRegistrationDelegate.BeanPostProcessorChecker\n// 有兴趣的同学可以看到该后置处理器重写的方法做了什么事情.\n// 最后添加到 beanFactory 中来.    \n   beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));\n\n   // Separate between BeanPostProcessors that implement PriorityOrdered,\n   // Ordered, and the rest.\n   List<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();\n   List<BeanPostProcessor> internalPostProcessors = new ArrayList<>();\n   List<String> orderedPostProcessorNames = new ArrayList<>();\n   List<String> nonOrderedPostProcessorNames = new ArrayList<>();\n    \n // 对后置处理器进行迭代   \n   for (String ppName : postProcessorNames) {\n      if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n   // 注意这里调用 getBean 方法是已经实例化这个后置处理起了.\n// AutowiredAnnotationBeanPostProcessor\n// CommonAnnotationBeanPostProcessor\n // 这里实例化的是Spring内置的二个         \n         BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n         priorityOrderedPostProcessors.add(pp);\n      // 内部的二个后置处理器都是有实现   MergedBeanDefinitionPostProcessor 的. \n         if (pp instanceof MergedBeanDefinitionPostProcessor) {\n            internalPostProcessors.add(pp);\n         }\n      }\n      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n         orderedPostProcessorNames.add(ppName);\n      }\n      else {\n         nonOrderedPostProcessorNames.add(ppName);\n      }\n   }\n\n   // First, register the BeanPostProcessors that implement PriorityOrdered.\n// 排序    \n   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n// 添加到 org.springframework.beans.factory.support.AbstractBeanFactory#beanPostProcessors,也就是添加到Spring的BanFactory中来.    \n   registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);\n\n   // Next, register the BeanPostProcessors that implement Ordered.\n// 这里是对实现了 Ordered 类型的处理，很显然我这里是没有的.    \n   List<BeanPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());\n   for (String ppName : orderedPostProcessorNames) {\n      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n      orderedPostProcessors.add(pp);\n      if (pp instanceof MergedBeanDefinitionPostProcessor) {\n         internalPostProcessors.add(pp);\n      }\n   }\n   sortPostProcessors(orderedPostProcessors, beanFactory);\n   registerBeanPostProcessors(beanFactory, orderedPostProcessors);\n\n   // Now, register all regular BeanPostProcessors.\n// 最后是对非 PriorityOrdered和Ordered的处理，    \n   List<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());\n   for (String ppName : nonOrderedPostProcessorNames) {\n      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n      nonOrderedPostProcessors.add(pp);\n      if (pp instanceof MergedBeanDefinitionPostProcessor) {\n         internalPostProcessors.add(pp);\n      }\n   }\n   registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);\n\n   // Finally, re-register all internal BeanPostProcessors.\n// 这里可以看到,最后对内部的后置处理器又重新注册了一遍.    \n   sortPostProcessors(internalPostProcessors, beanFactory);\n   registerBeanPostProcessors(beanFactory, internalPostProcessors);\n\n   // Re-register post-processor for detecting inner beans as ApplicationListeners,\n   // moving it to the end of the processor chain (for picking up proxies etc).\n// ApplicationListenerDetector 这里也是对  ApplicationListenerDetector 也是重新注册一遍.   \n   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));\n}\n```\n\n该方法 借助 org.springframework.context.support.PostProcessorRegistrationDelegate#registerBeanPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, org.springframework.context.support.AbstractApplicationContext) 来，获取BeanPostProcessor的后置处理器,也是分为 PriorityOrdered / Ordered/ 前二者都没有，在 PriorityOrdered 分类的时候，就已经调用了 getBean方法来获取出 bean 对象来(这里依然是分为了三个集合来装数据&处理). 然后调用getBean方法后,就调用registerBeanPostProcessors方法，将后置处理器给注册到 Spring 的BeanFactory 中来.\n\n最后还会最内部的 BeanPost后置处理器 & ApplicationListenerDetector 再重新注册一遍.\n\n可能会比较好奇这个后置处理器是干什么用的 ？ 在后面实例化 bean 的时候，就可以看到是有走很多后置处理器的.\n\n所以该方法是对 beanPost的后置处理器进行实例化并且注册到 Spring 的 BeanFactory 中来的.\n\n##### initMessageSource () 方法\n\n初始化 messageSource .\n\n```java\n/**\n * Initialize the MessageSource.\n * Use parent's if none defined in this context.\n */\nprotected void initMessageSource() {\n // 获取出 beanFactory   \n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n// 如果 beanFactory 包含了名字是messageSource的本地bean.    \n   if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {\n  // 从 beanFactory 中获取出来.     \n      this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);\n      // Make MessageSource aware of parent MessageSource.\n// this.parent不是null并且   messageSource是   HierarchicalMessageSource类型 \n      if (this.parent != null && this.messageSource instanceof HierarchicalMessageSource) {\n  // 强转,判断  getParentMessageSource 是不是null,如果是null的话,就调用 getInternalParentMessageSource() 将获取出来的值给set进去.     \n         HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;\n         if (hms.getParentMessageSource() == null) {\n            // Only set parent context as parent MessageSource if no parent MessageSource\n            // registered already.\n            hms.setParentMessageSource(getInternalParentMessageSource());\n         }\n      }\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"Using MessageSource [\" + this.messageSource + \"]\");\n      }\n   }\n   else {\n// 这里是不包含的情况.       \n      // Use empty MessageSource to be able to accept getMessage calls.\n      DelegatingMessageSource dms = new DelegatingMessageSource();\n// getInternalParentMessageSource() 返回的是null       \n      dms.setParentMessageSource(getInternalParentMessageSource());\n      this.messageSource = dms;\n// 注册到 beanFactory 中来       \n      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"No '\" + MESSAGE_SOURCE_BEAN_NAME + \"' bean, using [\" + this.messageSource + \"]\");\n      }\n   }\n}\n```\n\n该方法可以看到是对 messageSource 的初始化进行操作.\n\n##### initApplicationEventMulticaster 方法\n\n这里如果了解过 Spring 的Event 机制的话,是可以比较清晰的感觉到,是对 ApplicationEventMulticaster 的初始化.\n\n```java\n/**\n * Initialize the ApplicationEventMulticaster.\n * Uses SimpleApplicationEventMulticaster if none defined in the context.\n * @see org.springframework.context.event.SimpleApplicationEventMulticaster\n */\nprotected void initApplicationEventMulticaster() {\n  // 获取出 beanFactory 来.  \n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n// 判断 beanFactory 是否包含  applicationEventMulticaster    \n   if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {\n// 如果包含的话，就直接从beanFactroy中获取出来,并且赋值给  applicationEventMulticaster  \n      this.applicationEventMulticaster =\n            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"Using ApplicationEventMulticaster [\" + this.applicationEventMulticaster + \"]\");\n      }\n   }\n   else {\n // 如果不包含的话,传入beanFactory接着就是new一个SimpleApplicationEventMulticaster出来      \n      this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);\n// 然后注册到 beanFactory 中来.      \n      beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"No '\" + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + \"' bean, using \" +\n               \"[\" + this.applicationEventMulticaster.getClass().getSimpleName() + \"]\");\n      }\n   }\n}\n```\n\n这里可以看到, 主要是对 applicationEventMulticaster 的初始化.\n\n如果beanFactory有的话，就从其中拿，如果没有就自己new一个,最后注册到beanFactory中来.\n\n##### onRefresh() 方法\n\n这里是没有做任何事情的，如果是SpringBoot的源码的，这里就是启动tomcat的.\n\n```java\n/**\n * Template method which can be overridden to add context-specific refresh work.\n * Called on initialization of special beans, before instantiation of singletons.\n * <p>This implementation is empty.\n * @throws BeansException in case of errors\n * @see #refresh()\n */\nprotected void onRefresh() throws BeansException {\n   // For subclasses: do nothing by default.\n}\n```\n\n##### registerListeners() 方法\n\n从名字来看,这里是注册监听器的意思.\n\norg.springframework.context.event.AbstractApplicationEventMulticaster.ListenerRetriever#applicationListeners 这里是存放监听器的地方。\n\n```java\n/**\n * Add beans that implement ApplicationListener as listeners.\n * Doesn't affect other listeners, which can be added without being beans.\n */\nprotected void registerListeners() {\n   // Register statically specified listeners first.\n// getApplicationListeners() 获取出来的是空集合.    \n   for (ApplicationListener<?> listener : getApplicationListeners()) {\n      getApplicationEventMulticaster().addApplicationListener(listener);\n   }\n\n   // Do not initialize FactoryBeans here: We need to leave all regular beans\n   // uninitialized to let post-processors apply to them!\n// 根据ApplicationListener来获取出监听器，这也也是没有的.     \n   String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);\n   for (String listenerBeanName : listenerBeanNames) {\n      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);\n   }\n\n   // Publish early application events now that we finally have a multicaster...\n// 这里也是获取早初始的 ApplicationEvent.    \n   Set<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;\n   this.earlyApplicationEvents = null;\n   if (earlyEventsToProcess != null) {\n      for (ApplicationEvent earlyEvent : earlyEventsToProcess) {\n         getApplicationEventMulticaster().multicastEvent(earlyEvent);\n      }\n   }\n}\n```\n\norg.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType) 可以看下这个方法或者后续我们再详细的看，Spring是如何发送event的，以及那些监听器是怎么获取到 event 的.\n\nTODO : 这里后面是有待详细的讲解的.\n\n##### finishBeanFactoryInitialization() 方法\n\n从名字理解上,这里是对 beanFactory的初始化结束.\n\n```java\n/**\n * Finish the initialization of this context's bean factory,\n * initializing all remaining singleton beans.\n */\nprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n   // Initialize conversion service for this context.\n // 如果beanFactroy包含conversionService并且type是ConversionService.class的话，\n   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&\n         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {\n// 就会从beanFactory中获取出对象设置到beanFactory的ConversionService来.       \n      beanFactory.setConversionService(\n            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));\n   }\n\n   // Register a default embedded value resolver if no bean post-processor\n   // (such as a PropertyPlaceholderConfigurer bean) registered any before:\n   // at this point, primarily for resolution in annotation attribute values.\n   if (!beanFactory.hasEmbeddedValueResolver()) {\n//org.springframework.beans.factory.support.AbstractBeanFactory#addEmbeddedValueResolver //添加到org.springframework.beans.factory.support.AbstractBeanFactory#embeddedValueResolvers中来.      \n      beanFactory.addEmbeddedValueResolver(strVal -> getEnvironment().resolvePlaceholders(strVal));\n   }\n\n   // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.\n// 根据  LoadTimeWeaverAware.class 来获取信息.   \n// 很明显这里我们是没有配置的,所以也就是没有的.    \n   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);\n   for (String weaverAwareName : weaverAwareNames) {\n      getBean(weaverAwareName);\n   }\n\n   // Stop using the temporary ClassLoader for type matching.\n   beanFactory.setTempClassLoader(null);\n\n   // Allow for caching all bean definition metadata, not expecting further changes.\n//org.springframework.beans.factory.support.DefaultListableBeanFactory#freezeConfiguration\n// 设置configurationFrozen是true,\n// 将beanDefinitionNames集合转哈为String类型的数组. StringUtils.toStringArray(this.beanDefinitionNames);使用这个方法即可.    \n   beanFactory.freezeConfiguration();\n\n   // Instantiate all remaining (non-lazy-init) singletons.\n   beanFactory.preInstantiateSingletons();\n}\n```\n\n###### preInstantiateSingletons 方法\n\n这里就是对 单例池 里面的对象进行初始化,可以看到是有 getBean 方法的.\n\n```java\n@Override\npublic void preInstantiateSingletons() throws BeansException {\n   if (logger.isTraceEnabled()) {\n      logger.trace(\"Pre-instantiating singletons in \" + this);\n   }\n\n   // Iterate over a copy to allow for init methods which in turn register new bean definitions.\n   // While this may not be part of the regular factory bootstrap, it does otherwise work fine.\n// 这里获取出来的 beanNames 是有6个的,其中五个是包含了内部的\n//org.springframework.context.annotation.internalConfigurationAnnotationProcessor\n//org.springframework.context.annotation.internalAutowiredAnnotationProcessor\n//org.springframework.context.annotation.internalCommonAnnotationProcessor\n//org.springframework.context.event.internalEventListenerProcessor\n//org.springframework.context.event.internalEventListenerFactory\n//yangBeanScannerConfig    \n   List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);\n\n   // Trigger initialization of all non-lazy singleton beans...\n   for (String beanName : beanNames) {\n      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n       \n  // bd 不是抽象的&是单例的&不是赖加载的     \n      if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {\n  // 判断是不是 FactroyBean        \n         if (isFactoryBean(beanName)) {\n            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);\n            if (bean instanceof FactoryBean) {\n               final FactoryBean<?> factory = (FactoryBean<?>) bean;\n               boolean isEagerInit;\n               if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {\n                  isEagerInit = AccessController.doPrivileged((PrivilegedAction<Boolean>)\n                              ((SmartFactoryBean<?>) factory)::isEagerInit,\n                        getAccessControlContext());\n               }\n               else {\n                  isEagerInit = (factory instanceof SmartFactoryBean &&\n                        ((SmartFactoryBean<?>) factory).isEagerInit());\n               }\n               if (isEagerInit) {\n                  getBean(beanName);\n               }\n            }\n         }\n         else {\n    // 这里不是 FactoryBean  \n// 可以看到当我走到yangBeanScannerConfig,我们定义的类的时候,走完这个方法，就可以看到com.iyang.spring.config.YangBeanScannerConfig#YangBeanScannerConfig中打印的语句了,也就是说走完这里，我们定义的bean就已经被Spring被实例化了.             \n            getBean(beanName);\n         }\n      }\n   }\n\n   // Trigger post-initialization callback for all applicable beans...\n// 这里再对 beanNames 进行迭代,如果是 SmartInitializingSingleton 的话，就会再调用    afterSingletonsInstantiated 方法.\n   for (String beanName : beanNames) {\n      Object singletonInstance = getSingleton(beanName);\n      if (singletonInstance instanceof SmartInitializingSingleton) {\n         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;\n         if (System.getSecurityManager() != null) {\n            AccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n               smartSingleton.afterSingletonsInstantiated();\n               return null;\n            }, getAccessControlContext());\n         }\n         else {\n            smartSingleton.afterSingletonsInstantiated();\n         }\n      }\n   }\n}\n```\n\n可以对我们定义的 bean 进行实例化，最后是调用了 getBean 方法， getBean 方法表面看上去是获取，其实如果没有的话，调用的是createBean方法, 也就是会实例化我们的bean。当然它肯定不会很简单的去调用反射就实例化完一个我们的bean,肯定是有一系列的走Spring内置的或者我们自己定义的后置处理器等操作.\n\ngetBean 方法需要后面专门领出来分析，不能简单的过，这里对 Spring 容器进行大致的flow过,所以还是比较轻描淡写的写过去.\n\n##### finishRefresh 方法\n\n中文式的英语 : 结束刷新方法.\n\n显示清除缓存,再是init了LifecycleProcessor,调用其onRefresh()方法,接近就是发送一个ContextRefreshedEvent事件出来.\n\n```java\n/**\n * Finish the refresh of this context, invoking the LifecycleProcessor's\n * onRefresh() method and publishing the\n * {@link org.springframework.context.event.ContextRefreshedEvent}.\n */\nprotected void finishRefresh() {\n   // Clear context-level resource caches (such as ASM metadata from scanning).\n//对org.springframework.core.io.DefaultResourceLoader#resourceCaches进行清除.    \n   clearResourceCaches();\n\n   // Initialize lifecycle processor for this context.\n   initLifecycleProcessor();\n\n   // Propagate refresh to lifecycle processor first.\n//org.springframework.context.support.DefaultLifecycleProcessor\n//org.springframework.context.support.DefaultLifecycleProcessor#startBeans\n    \n   getLifecycleProcessor().onRefresh();\n\n   // Publish the final event.\n// 推送Event,这里的Event是 ContextRefreshedEvent.    \n   publishEvent(new ContextRefreshedEvent(this));\n\n   // Participate in LiveBeansView MBean, if active.\n//org.springframework.context.support.LiveBeansView#registerApplicationContext\n//先根据key:spring.liveBeansView.mbeanDomain获取value,这里获取出来的是null,\n// 所以也就是没有下文了.    \n   LiveBeansView.registerApplicationContext(this);\n}\n```\n\n###### initLifecycleProcessor 方法 ()\n\n```\n/**\n * Initialize the LifecycleProcessor.\n * Uses DefaultLifecycleProcessor if none defined in the context.\n * @see org.springframework.context.support.DefaultLifecycleProcessor\n */\nprotected void initLifecycleProcessor() {\n  // 获取出 beanFactory 来.  \n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n// 判断beanFactory中是否包含lifecycleProcessor    \n   if (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) {\n// 包含的话,就会获取出来,指向this.lifecycleProcessor       \n      this.lifecycleProcessor =\n            beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor.class);\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"Using LifecycleProcessor [\" + this.lifecycleProcessor + \"]\");\n      }\n   }\n   else {\n   // 如果不包含的话，就自己new一个,然后注册到Spring容器中来.    \n      DefaultLifecycleProcessor defaultProcessor = new DefaultLifecycleProcessor();\n      defaultProcessor.setBeanFactory(beanFactory);\n      this.lifecycleProcessor = defaultProcessor;\n      beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, this.lifecycleProcessor);\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"No '\" + LIFECYCLE_PROCESSOR_BEAN_NAME + \"' bean, using \" +\n               \"[\" + this.lifecycleProcessor.getClass().getSimpleName() + \"]\");\n      }\n   }\n}\n```\n\n###### publishEvent 方法\n\n```java\n/**\n * Publish the given event to all listeners.\n * @param event the event to publish (may be an {@link ApplicationEvent}\n * or a payload object to be turned into a {@link PayloadApplicationEvent})\n * @param eventType the resolved event type, if known\n * @since 4.2\n */\nprotected void publishEvent(Object event, @Nullable ResolvableType eventType) {\n   Assert.notNull(event, \"Event must not be null\");\n\n   // Decorate event as an ApplicationEvent if necessary\n   ApplicationEvent applicationEvent;\n    \n// 对传入进来的 event 进行类型的判断.    \n   if (event instanceof ApplicationEvent) {\n      applicationEvent = (ApplicationEvent) event;\n   }\n   else {\n      applicationEvent = new PayloadApplicationEvent<>(this, event);\n      if (eventType == null) {\n         eventType = ((PayloadApplicationEvent<?>) applicationEvent).getResolvableType();\n      }\n   }\n\n   // Multicast right now if possible - or lazily once the multicaster is initialized\n   if (this.earlyApplicationEvents != null) {\n      this.earlyApplicationEvents.add(applicationEvent);\n   }\n   else {\n//org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType)\n//走到了这里来发送event的,       \n      getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);\n   }\n\n   // Publish event via parent context as well...\n// 这里的 parent是null.    \n   if (this.parent != null) {\n      if (this.parent instanceof AbstractApplicationContext) {\n         ((AbstractApplicationContext) this.parent).publishEvent(event, eventType);\n      }\n      else {\n         this.parent.publishEvent(event);\n      }\n   }\n}\n```\n\n这里是发送ContextRefreshedEvent事件出来.\n\n##### resetCommonCaches 方法()\n\n可以看到 finally 代码块中是疯狂的清除各种缓存.\n\n可以大家可以点进去详细的看下，具体就不仔细描述了.\n\n```java\n/**\n * Reset Spring's common reflection metadata caches, in particular the\n * {@link ReflectionUtils}, {@link AnnotationUtils}, {@link ResolvableType}\n * and {@link CachedIntrospectionResults} caches.\n * @since 4.2\n * @see ReflectionUtils#clearCache()\n * @see AnnotationUtils#clearCache()\n * @see ResolvableType#clearCache()\n * @see CachedIntrospectionResults#clearClassLoader(ClassLoader)\n */\nprotected void resetCommonCaches() {\n   ReflectionUtils.clearCache();\n   AnnotationUtils.clearCache();\n   ResolvableType.clearCache();\n   CachedIntrospectionResults.clearClassLoader(getClassLoader());\n}\n```\n\n#### 总结\n\n最后总结下,Spring在加载 bean & 处理内置的一些配置 & 内部处理器的时候,是下了很多的功夫。可以看着这些方法一步一步的分析下去,理解起来，个人感觉这里还不是特别深入的跟进去了代码，只是一个简单的大概描述，更深入的知识需要更加详细的理解等了.\n\n这里只是简单的对这个整个flow来进行描述，还不是特别有详细的那种.\n","tags":["java","spring"],"categories":["java","spring"]},{"title":"spring初始化(三)","url":"/2021/11/04/spring/spring初始化-三/","content":"\n\n\n#### 题记\n\n 前面讲到了这么多的什么BeanPostProcessor,事件什么的. 如果不写几下代码这里怕是很难弄清楚是个怎么回事. 所以只有看到代码跑,就大致可以看到其效果还是很明显的.\n\n#### BeanDefinitionRegistryPostProcessor\n\n 先写一个类简单实现下 BeanDefinitionRegistryPostProcessor 这个接口 :\n\n 运行后的结果是可以很明显的看到我们的打印数据输出结果的.\n\n 程序是怎么运行到这个地方来的呢？\n\norg.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List<org.springframework.beans.factory.config.BeanFactoryPostProcessor>) 走到这个方法的\n\nbeanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class…..),从这个类中获取出来的postProcessorNames,就有包含我们的自己定义的一个.\n\n由于我们自己扩展的这个类,是没有实现 PriorityOrdered/Ordered的,所以就放到最后来处理了.\n\n也就是在这个方法,while (reiterate) { … invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);}\n\n走的这个方法的时候,才会去走到我们定义的类。\n\n那是因为这个地方 Spring是有处理顺序的。 先处理 PriorityOrdered.class , 再处理 Ordered.class , 最后处理既没有PriorityOrdered,也没有Ordered的.\n\n```java\n@Component\npublic class GavinYangRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {\n\n    public GavinYangRegistryPostProcessor(){\n        System.out.println(\"GavinYangRegistryPostProcessor 构造方法执行\");\n    }\n\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n        System.out.println(\"调用到 GavinYangRegistryPostProcessor#postProcessBeanDefinitionRegistry方法\");\n        String[] beanDefinitionNames = registry.getBeanDefinitionNames();\n        String bdNamesString = Arrays.toString(beanDefinitionNames);\n        System.out.println(\"GavinYangRegistryPostProcessor 类中\" + bdNamesString);\n    }\n\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\n    }\n}\n```\n\n#### BeanFactoryPostProcessor\n\n 简单实现一下 BeanFactoryPostProcessor 这个接口来看一下效果.\n\n 先写一个类 : 然后实现一下这个接口 BeanFactoryPostProcessor , 我们这里就获取下beanFactory中的所有beanDefinitionNames的数组, 然后打印出来看下效果. 打印结果也是贴在下面的. 接着我们看下其源码是一个怎么样的走向.\n\n```java\n@Component\npublic class GavinYangBeanFactoryPostProcessor implements BeanFactoryPostProcessor {\n\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n        String[] beanDefinitionNames = beanFactory.getBeanDefinitionNames();\n        System.out.println(Arrays.toString(beanDefinitionNames));\n    }\n}\n\n//[org.springframework.context.annotation.internalConfigurationAnnotationProcessor, org.springframework.context.annotation.internalAutowiredAnnotationProcessor, org.springframework.context.annotation.internalCommonAnnotationProcessor, org.springframework.context.event.internalEventListenerProcessor, org.springframework.context.event.internalEventListenerFactory, yangBeanOne, gavinYangBeanFactoryPostProcessor, yangBeanPostProcessor, gavinYangLifeImpl]\n```\n\n直接看这个类的这个方法，我这里只截取了一部分代码,也就是和 BeanFactoryPostProcessor 有关的代码.\n\n和它没关系的代码,这里就没有去截取了.\n\norg.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List<org.springframework.beans.factory.config.BeanFactoryPostProcessor>) .\n\n看源码看是如何调用到这个方法的,还是比较好理解。先是根据 BeanFactoryPostProcessor.class获取出beanName的集合,然后老规矩进行一些特定的排序,当然我这里什么都没做,也就是最后处理哦。\n\n然后跟到invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);这个方法里面,可以看到它迭代这个集合的元素,当然了,我们只需要关注我们自己定义的哪个就可以了,然后就会走其postProcessBeanFactory方法,也就是走到了我们定义的类的这个方法上来了.\n\nOK啦。大致流程就是这个样子的,还是比较好理解的.\n\n```java\n// Do not initialize FactoryBeans here: We need to leave all regular beans\n// uninitialized to let the bean factory post-processors apply to them!\n// 这个地方获取出来的数组里面的值,就有我们想看到的.\n//org.springframework.context.annotation.internalConfigurationAnnotationProcessor\n//org.springframework.context.event.internalEventListenerProcessor\n//gavinYangBeanFactoryPostProcessor\n//当看到第三个是不是非常的熟悉.没错,这就是我们自己定义的.\nString[] postProcessorNames =\n      beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);\n\n// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,\n// Ordered, and the rest.\nList<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();\nList<String> orderedPostProcessorNames = new ArrayList<>();\nList<String> nonOrderedPostProcessorNames = new ArrayList<>();\n// 然后先经过一轮排序,就可以看到 我们自己定义的就放入到了nonOrderedPostProcessorNames这个集合中,\n//\nfor (String ppName : postProcessorNames) {\n   if (processedBeans.contains(ppName)) {\n      // skip - already processed in first phase above\n   }\n   else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n      priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));\n   }\n   else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n      orderedPostProcessorNames.add(ppName);\n   }\n   else {\n      nonOrderedPostProcessorNames.add(ppName);\n   }\n}\n\n// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.\nsortPostProcessors(priorityOrderedPostProcessors, beanFactory);\ninvokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\n// Next, invoke the BeanFactoryPostProcessors that implement Ordered.\nList<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());\nfor (String postProcessorName : orderedPostProcessorNames) {\n   orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n}\nsortPostProcessors(orderedPostProcessors, beanFactory);\ninvokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);\n\n// Finally, invoke all other BeanFactoryPostProcessors.\nList<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());\nfor (String postProcessorName : nonOrderedPostProcessorNames) {\n   nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n}\n// 然后我们直接看到处理nonOrderedPostProcessors这个集合的方法,\n//因为这个方法也会走到我们自己定义的类中去\n//方法里面对nonOrderedPostProcessors进行迭代,然后一次调用其postProcessBeanFactory方法,同时也传入了beanFactory到里面去.\ninvokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);\n```\n\n#### BeanPostProcessor\n\n我们先写一个 Bean. 然后可以里面写一个属性,方便标识.\n\n```java\n@Service\npublic class YangBeanOne {\n\n    private String name;\n\n    /**\n     * 无参构造函数\n     */\n    public YangBeanOne(){\n\n        System.out.println(\"YangBeanOne无参数构造函数\");\n\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n```\n\n然后我们自定义一个BeanPostProcessor,其实现了BeanPostProcessor接口.\n\n可以看到的是,我们在if中做了beanName的判断,如果是的话,那么我们就会强转,然后给name字段赋值上GavinYang的值.\n\n我们给断点打到 if这里，然后看进来的堆栈信息,发现其是在初始化bean中,然后调用beanPostProcessor的postProcessAfterInitialization的方法才会走到这里,也就是在doCreateBean这个方法里面.\n\n然后这个 YangBeanPostProcessor 是什么时候给添加到 beanFactory中去的呢？\n\norg.springframework.context.support.PostProcessorRegistrationDelegate#registerBeanPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, org.springframework.context.support.AbstractApplicationContext)在这个方法打上断点,然后你会发现其get出来的postProcessorNames数组,就有我们的这个YangBeanPostProcessor，然后走registerBeanPostProcessors方法的时候,就会给添加到beanFactory中去.\n\n```java\n@Component\npublic class YangBeanPostProcessor implements BeanPostProcessor {\n\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        return bean;\n    }\n\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        if(\"yangBeanOne\".equalsIgnoreCase(beanName)){\n            ((YangBeanOne) bean).setName(\"GavinYang\");\n        }\n        return bean;\n    }\n}\n```\n\n启动类 :\n\n这就打印出来的结果就可以看到的是GavinYang,也就是说我们初始化这个bean之后,然后给其name属性赋值上了GavinYang这个值.\n\n```java\npublic class SpringStartMain {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(\"com.iyang.spring\");\n        YangBeanOne yangBeanOne = context.getBean(YangBeanOne.class);\n        System.out.println(yangBeanOne.getName());\n    }\n}\n```\n\n#### Lifecycle 扩展\n\nLifecycle 扩展要比起 BeanPostProcessor要好理解得多,因为你只用去实现这个接口(SmartLifecycle),然后在org.springframework.context.support.AbstractApplicationContext#finishRefresh到这个方法的时候,就会去调用实现这个接口的对用的方法.\n\n这里我们自己写一个类,然后实现 SmartLifecycle 接口即可。\n\n可以看到下面的打印参数.还是很清楚的明白.\n\n```java\n@Component\npublic class GavinYangLifeImpl implements SmartLifecycle {\n\n    public int getPhase() {\n        return Integer.MAX_VALUE;\n    }\n\n    public void start() {\n        System.out.println(\"调用到了GavinYangLifeImpl.start()方法\");\n    }\n\n    public void stop() {\n\n    }\n\n    public boolean isRunning() {\n        return false;\n    }\n}\n\n//YangBeanOne无参数构造函数\n//调用到了GavinYangLifeImpl.start()方法\n//GavinYang\n```\n\n然后我们再看下源码,为什么要实现 SmartLifecycle 这个接口呢？\n\norg.springframework.context.support.DefaultLifecycleProcessor\n\n这里我们先看到 phases ,也就是最底下的代码, 这个集合是有值的情况下先排序,然后再迭代,然后调用到 start()方法, 这个start方法是不是在我们的实现类中可以看到,是不是非常的熟悉感觉.\n\n然后我们在看下,怎么样让这个集合能有值呢？\n\nphases.put(phase, group); 可以看到 put方法这里, autoStartupOnly 是false 或者bean是SmartLifecycle的子类,并且其isAutoStartup方法的是true. 点到SmartLifecycle源码中去看,可以发现这个方法默认是返回的true.\n\n接着在调用getPhase方法, 该方法也就是判断.最最关键的phases集合来了,先从里面get出数据,然后判断数据是不是null,如果是null的话,就先new一个Group出来,然后调用phases的put方法,也就是放入到这个集合中去了\n\n所以这里就是我们为什么要实现 SmartLifecycle 这个接口,就会有启动的效果了的原因.\n\n```java\n// Internal helpers\n// 传入进来的  autoStartupOnly 参数是true.\nprivate void startBeans(boolean autoStartupOnly) {\n   Map<String, Lifecycle> lifecycleBeans = getLifecycleBeans();\n   Map<Integer, LifecycleGroup> phases = new HashMap<>();\n   lifecycleBeans.forEach((beanName, bean) -> {\n      if (!autoStartupOnly || (bean instanceof SmartLifecycle && ((SmartLifecycle) bean).isAutoStartup())) {\n         int phase = getPhase(bean);\n         LifecycleGroup group = phases.get(phase);\n         if (group == null) {\n            group = new LifecycleGroup(phase, this.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);\n            phases.put(phase, group);\n         }\n         group.add(beanName, bean);\n      }\n   });\n   if (!phases.isEmpty()) {\n      List<Integer> keys = new ArrayList<>(phases.keySet());\n      Collections.sort(keys);\n      for (Integer key : keys) {\n         phases.get(key).start();\n      }\n   }\n}\n```\n\n#### 总结\n\n可以看到我们基于接口扩展的,还是很好理解的。 跟着源码中的初始化一些类,看哪个类是怎么写的，然后我们跟着写一个。 前提是,你要弄得明白 Spring 这个执行过程的. 不然你跟着写,不是很明白的话,就可能不是很容易看明白或者看懂你这个效果的.\n","tags":["java","spring"],"categories":["java","spring"]},{"title":"spring初始化(二)","url":"/2021/11/04/spring/spring初始化-二/","content":"\n\n\n#### 题记\n\n 昨天记录了this()和 register() 这二个方法, 这二个方法都是为后面的做铺垫,也就是提前初始化了一些环境和读取class文件. refresh() 这个方法才是最重要的,其中包含的内容是非常多的. 所以这里慢慢进行更新其方法的内容.\n\n#### refresh 方法\n\n这里可以看到的是, refresh()该方法里面,基本都是走了很多方法的. 所以挨个看方法,有些方法是留给子类的,也就是进行扩展的. 从synchronized这个关键字来看,这里只容许一次只有一个线程来执行这个方法.\n\n```java\n@Override\npublic void refresh() throws BeansException, IllegalStateException {\n   synchronized (this.startupShutdownMonitor) {\n      // Prepare this context for refreshing.\n      prepareRefresh();\n\n      // Tell the subclass to refresh the internal bean factory.\n\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n      // Prepare the bean factory for use in this context.\n      /**\n       * org.springframework.beans.factory.support.DefaultListableBeanFactory\n       *\n       */\n      prepareBeanFactory(beanFactory);\n\n      try {\n         // Allows post-processing of the bean factory in context subclasses.\n         postProcessBeanFactory(beanFactory);\n\n         // Invoke factory processors registered as beans in the context.\n         invokeBeanFactoryPostProcessors(beanFactory);\n\n         // Register bean processors that intercept bean creation.\n         registerBeanPostProcessors(beanFactory);\n         // Initialize message source for this context.\n         initMessageSource();\n\n         // Initialize event multicaster for this context.\n         initApplicationEventMulticaster();\n         // Initialize other special beans in specific context subclasses.\n         onRefresh();\n         // Check for listener beans and register them.\n         registerListeners();\n         // Instantiate all remaining (non-lazy-init) singletons.\n         /**\n          */\n         finishBeanFactoryInitialization(beanFactory);\n\n         // Last step: publish corresponding event.\n         finishRefresh();\n      } catch (BeansException ex) {\n         if (logger.isWarnEnabled()) {\n            logger.warn(\"Exception encountered during context initialization - \" +\n                  \"cancelling refresh attempt: \" + ex);\n         }\n         // Destroy already created singletons to avoid dangling resources.\n         destroyBeans();\n         // Reset 'active' flag.\n         cancelRefresh(ex);\n         // Propagate exception to caller.\n         throw ex;\n      } finally {\n         // Reset common introspection caches in Spring's core, since we\n         // might not ever need metadata for singleton beans anymore...\n         resetCommonCaches();\n      }\n   }\n}\n```\n\n#### refresh.prepareRefresh() 方法\n\nprepareRefresh() 方法: 可以看到该方法先是对closed/active参数进行设置,然后对Enviornment进行调用检验方法,接着判断this.earlyApplicationListeners是否有值来操作this.applicationListeners. 最后初始化earlyApplicationEvents这个集合. 这里大概还是进行一些初始化操作.\n\n```java\n/**\n * Prepare this context for refreshing, setting its startup date and\n * active flag as well as performing any initialization of property sources.\n */\nprotected void prepareRefresh() {\n   // Switch to active.\n   this.startupDate = System.currentTimeMillis();\n  // closed设置为false,active设置为true.  \n   this.closed.set(false);\n   this.active.set(true);\n\n   // 根据log级别来进行输出 \n   if (logger.isInfoEnabled()) {\n      logger.info(\"Refreshing \" + this);\n   }\n\n   // Initialize any placeholder property sources in the context environment.\n   // 目前该方法没有调用;目前没有做任何事情. 目测是应该留给子类之类的进行扩展的.\n   initPropertySources();\n\n   // Validate that all properties marked as required are resolvable:\n   // see ConfigurablePropertyResolver#setRequiredProperties\n//先调用getEnvironment()获取this()方法中创建出来的Environment来,然后走validateRequiredProperties方法来进行一些检验,\n//org.springframework.core.env.AbstractPropertyResolver#validateRequiredProperties\n//最后是走到了这个方法,如果this.requiredProperties中是有值的话,那么这里就会抛出一个异常来    \n   getEnvironment().validateRequiredProperties();\n    \n   // Store pre-refresh ApplicationListeners...\n// 这里是对 earlyApplicationListeners 进行判断,如果有值的话,就先会clear掉,然后再addAll\n//如果是没有值的话,就会new一个集合,然后赋值给this.earlyApplicationListeners参数   \n   if (this.earlyApplicationListeners == null) {\n      this.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);\n   }\n   else {\n      // Reset local application listeners to pre-refresh state.\n      this.applicationListeners.clear();\n      this.applicationListeners.addAll(this.earlyApplicationListeners);\n   }\n\n   // Allow for the collection of early ApplicationEvents,\n   // to be published once the multicaster is available...\n// 最后初始化一下 this.earlyApplicationEvents 这个参数\n   this.earlyApplicationEvents = new LinkedHashSet<>();\n}\n```\n\n#### refresh.obtainFreshBeanFactory()方法\n\n这个方法是有方法一个BeanFactory回去的.\n\n该方法对beanFactory进行SerializationId,然后获取BeanFactory,最后返回这个BeanFactory.\n\n```java\n/**\n * Tell the subclass to refresh the internal bean factory.\n *  告诉子类刷新内部Bean工厂\n * @return the fresh BeanFactory instance\n * @see #refreshBeanFactory()\n * @see #getBeanFactory()\n */\nprotected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n//this.refreshed.compareAndSet(false, true)该方法如果返回的是false的话,就会有异常给抛出来\n//不是false的话,接着就是对beanFactory设置SerializationId    \n   refreshBeanFactory();\n// org.springframework.context.support.GenericApplicationContext#getBeanFactory\n//该方法直接返回DefaultListableBeanFactory    \n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n   if (logger.isDebugEnabled()) {\n      logger.debug(\"Bean factory for \" + getDisplayName() + \": \" + beanFactory);\n   }\n//返回获取的beanFactory.    \n   return beanFactory;\n}\n```\n\n#### refresh.prepareBeanFactory() 方法\n\n从这个方法来看,是对BeanFactory的准备.\n\n该方法可以先是对classLoader,expressionResolver,propertyEditorRegistrar添加到beanFactory中去. 然后添加ApplicationContextAwareProcessor(BeanPostProcessor)到BeanFactory,然后忽略到一些接口的注入到beanFactory中去.\n\n设置 BeanFactory , ResourceLoader , ApplicationEventPublisher, ApplicationContext等bean到BeanFactory中去.\n\n最后就是一些environment,systemProperties,systemEnvironment等注入到BeanFactory中去.\n\n```java\n/**\n *\n * Configure the factory's standard context characteristics,\n * such as the context's ClassLoader and post-processors.\n * @param beanFactory the BeanFactory to configure\n */\nprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n   // Tell the internal bean factory to use the context's class loader etc.\n//给beanFactory设置classLoader(加载bean) \n   beanFactory.setBeanClassLoader(getClassLoader());\n//这里根据classLoader来获取解析器,然后set到BeanFactory中去.(解析bean定义的表达式)\n   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n//属性编辑注册器,set到BeanFactory中\n   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));\n\n   // Configure the bean factory with context callbacks.\n//添加ApplicationContextAwareProcessor到BeanFactory中.该类是有实现BeanPostProcessor的\n//BeanPostProcessor是在bean初始化完后,调用BeanPostProcessor进行扩展.\n   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n//忽略掉EnvironmentAware/EmbeddedValueResolverAware....ApplicationContextAware\n//这六个接口的注入(依赖). 因为ApplicationContextAwareProcessor中有做了这些事\n   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n\n   // BeanFactory interface not registered as resolvable type in a plain factory.\n   // MessageSource registered (and found for autowiring) as a bean.\n// BeanFactory,ResourceLoader,ApplicationEventPublisher,ApplicationContext这四个接口\n//对应的bean都set到beanFactory中去.    \n   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n   beanFactory.registerResolvableDependency(ResourceLoader.class, this);\n   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n   beanFactory.registerResolvableDependency(ApplicationContext.class, this);\n\n   // Register early post-processor for detecting inner beans as ApplicationListeners.\n//添加ApplicationListenerDetector(BeanPostProcessor)到beanFactory中去.\n   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));\n\n   // Detect a LoadTimeWeaver and prepare for weaving, if found.\n   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n      // Set a temporary ClassLoader for type matching.\n      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n   }\n\n   // Register default environment beans.\n//如果beanFactory中没有ENVIRONMENT_BEAN_NAME这个bean的话,就注入一个进去\n   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());\n   }\n// SYSTEM_PROPERTIES_BEAN_NAME也是一样,注入到beanFactory中去\n   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());\n   }\n//SYSTEM_ENVIRONMENT_BEAN_NAME同上    \n   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());\n   }\n}\n```\n\n#### refresh.postProcessBeanFactory() 方法\n\n该方法目前在单个 Spring中是没有做任何事情的。 等到看SpringBoot源码的时候,这里就会有代码走进来,是进行根据包来扫描来获取class等信息的. 满足条件的class,就会当为bd给注册到beanFactory中去.\n\n```java\n/**\n * Modify the application context's internal bean factory after its standard\n * initialization. All bean definitions will have been loaded, but no beans\n * will have been instantiated yet. This allows for registering special\n * BeanPostProcessors etc in certain ApplicationContext implementations.\n * @param beanFactory the bean factory used by the application context\n */\nprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n}\n```\n\n#### refresh.invokeBeanFactoryPostProcessors() 方法\n\n可以看到这个方法,借助PostProcessorRegistrationDelegate来对PostProcessor进行处理。\n\n先是对BeanDefinitionRegistryPostProcessor进行从beanFactory中获取出相应的名字数组,然后迭代这个数组,然后处理PriorityOrdered—>Ordered—> 没有,这个顺序,最后还有一个while循环迭代来检查BeanDefinitionRegistryPostProcessor是否都处理完了.\n\n再接着就是处理BeanFactoryPostProcessor,处理方式是和BeanDefinitionRegistryPostProcessor一样的,顺序也是一样的.\n\n最后就是调用beanFactory.clearMetadataCache()清除.\n\n当然,这个里面有些上面 PostProcessor等待阅读SpringBoot的时候给补上来,因为到时候SpringBoot这里会有很多PostProcessor,这里目前是没有的.\n\n```java\n/**\n * Instantiate and invoke all registered BeanFactoryPostProcessor beans,\n * respecting explicit order if given.\n * <p>Must be called before singleton instantiation.\nBeanFactoryPostProcessor: 用来修改Spring容器中已经存在的bean定义.\nBeanDefinitionRegistryPostProcessor: 是BeanFactoryPostProcessor的子类,作用和父类是一样的,不同的是,该使用的是BeanDefinitionRegistry对bean进行处理\n */\nprotected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n//org.springframework.context.support.AbstractApplicationContext#getBeanFactoryPostProcessors,由于这里只是启动了单个Spring,返回的集合是没有值的.\n   List<BeanFactoryPostProcessor> postProcessorsList = getBeanFactoryPostProcessors();\n   //System.out.println(\"postProcessorsList value ---> \" + postProcessorsList);\n   // System.out.println(\"beanFactory  value 111111 ---> \" + beanFactory);\n//借助PostProcessorRegistrationDelegate来处理PostProcessors.\n//对传入postProcessorsList进行迭代,如果PostProcessor是BeanDefinitionRegistryPostProcessor的话,就会强转然后调用postProcessBeanDefinitionRegistry方法(传入参数是beanFacotry),添加到registryProcessors集合中.如果不是的话,就会添加到regularPostProcessors集合中.\n//根据BeanDefinitionRegistryPostProcessor,从beanFactory中获取postProcessorNames,\n//进行迭代,如果是有PriorityOrdered接口的子类的话,就会从beanFactory中根据bean名字,类.class来获取BeanDefinitionRegistryPostProcessor,并且添加到currentRegistryProcessors集合中,ppName(名字的值)也会添加到processedBeans该集合中\n//对currentRegistryProcessors进行排序,全部添加到registryProcessors集合中,invokeBeanDefinitionRegistryPostProcessors()该方法是调用BeanDefinitionRegistryPostProcessors的,调用完了然后清空currentRegistryProcessors这个集合.\n//同样方法获取postProcessorNames,processedBeans集合中不包含并且是Ordered的子类,然后添加到currentRegistryProcessors集合中,ppName也会添加到processedBeans集合中,同样的排序方式,添加到registryProcessors中,再调用invokeBeanDefinitionRegistryPostProcessors()方法,currentRegistryProcessors清空该集合.\n// 也就是到这里,可以看出来,处理的顺序,先是处理PriorityOrdered,再处理Ordered.\n// 然后使用一个while循环,继续获取BeanDefinitionRegistryPostProcessor对应的postProcessorNames,这个地方是为了防止有些没有调用到的,并且是processedBeans集合中不包含的,然后就会放入到currentRegistryProcessors这个集合中,排序currentRegistryProcessors集合,全部添加到registryProcessors中,调用invokeBeanDefinitionRegistryPostProcessors,也就是调用具体的PostProcessors.\n//invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);\n//invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);\n// 之前的二个集合,registryProcessors和regularPostProcessors,在这里还是会继续调用.\n//然后根据BeanFactoryPostProcessor.class获取postProcessorNames数组,与上面的也是同样的方法,\n//对postProcessorNames进行迭代,如果是processedBeans(上面装的名字)如果包含了,就会跳过.\n/** 如果ppName,也就是迭代的值,是有PriorityOrdered的子类的话,就会从走beanFactory.getBean(ppName, BeanFactoryPostProcessor.class)获取出BeanFactoryPostProcessor放入到priorityOrderedPostProcessors集合中.  如果是Ordered的子类,就将名字放入到orderedPostProcessorNames集合中,如果上面三种都不满足的话,就会放入到nonOrderedPostProcessorNames集合中.\n然后先排序priorityOrderedPostProcessors,再走invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);\n接着迭代orderedPostProcessorNames集合,然后从beanFactory中获取BeanFactoryPostProcessor,再就做与priorityOrderedPostProcessors一样的操作.\n最后在做nonOrderedPostProcessors这个集合的,操作是与orderedPostProcessorNames一摸一样的.\n\n最后在调用一个beanFactory的clearMetadataCache方法.\n可以看到这个方法是先对BeanDefinitionRegistryPostProcessor.class进行处理,然后根据顺序PriorityOrdered-->Ordered--->没有, 这样的顺序执行的.\n然后再处理BeanFactoryPostProcessor.class,处理方式是和BeanDefinitionRegistryPostProcessor.class也是一样的,根据顺序来进行处理.\n*/    \n   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, postProcessorsList);\n\n   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime\n   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)\n// 获取beanFactory的tempClassLoader加载,并且beanFactory是包含了loadTimeWeaver这个bean的,\n//就会走if方法,可以看到是添加LoadTimeWeaverAwareProcessor到beanFactory的postProcessor中,\n//然后添加一个ClassLoader到beanFactory中   \n   if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n   }\n}\n```\n\n#### refresh.registerBeanPostProcessors() 方法\n\n仔细看中这个方法,其实和上一个方法走的逻辑好像是有点类似的. 也是借助PostProcessorRegistrationDelegate来完成其逻辑的.\n\n先是从BeanFactory中获取BeanPostProcessor对用的postProcessorNames数组。\n\n然后分为 PriorityOrdered –> Ordered –> 既不是PriorityOrdered ,也不是Ordered –> MergedBeanDefinitionPostProcessor子类, 这样的先后顺序,走registerBeanPostProcessors,这个是将PostProcessros注册到Spring的beanFactory中(Spring容器).\n\n```java\n/**\n * Instantiate and register all BeanPostProcessor beans,\n * respecting explicit order if given.\n * <p>Must be called before any instantiation of application beans.\n */\nprotected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n   PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);\n}\n\n-------------------\n\tpublic static void registerBeanPostProcessors(\n\t\t\tConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {\n\n// 先是根据BeanPostProcessor获取出postProcessorNames数组,这个根据和上面的方法很相似.    \n\t\tString[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class,\n\t\t\t\ttrue, false);\n\n\t\t// Register BeanPostProcessorChecker that logs an info message when\n\t\t// a bean is created during BeanPostProcessor instantiation, i.e. when\n\t\t// a bean is not eligible for getting processed by all BeanPostProcessors.\n//然后从beanFactory中获取出个数 + postProcessorNames数组长度再加上一个1.     \n\t\tint beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;\n//添加一个BeanPostProcessorChecker到beanFactory中.从名字上来,这个PostProcessor应该是进行检查的操作.\n\t\tbeanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));\n\n\t\t// Separate between BeanPostProcessors that implement PriorityOrdered,\n\t\t// Ordered, and the rest.\n\t\tList<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();\n\t\tList<BeanPostProcessor> internalPostProcessors = new ArrayList<>();\n\t\tList<String> orderedPostProcessorNames = new ArrayList<>();\n\t\tList<String> nonOrderedPostProcessorNames = new ArrayList<>();\n\n\t\t// 对 postProcessorNames 进行遍历;同时使用不同类型的集合来存储数据\n//主要是根据是否是PriorityOrdered的子类,是的话就会放入到priorityOrderedPostProcessors集合中,接着在判断是否是MergedBeanDefinitionPostProcessor,如果是的话,就会放入到internalPostProcessors集合中\n//是不是orderd的子类,是的话,就会放入到orderedPostProcessorNames集合中,\n//如果上面二者都不的话,就会放入到nonOrderedPostProcessorNames集合中  \n\t\tfor (String ppName : postProcessorNames) {\n\t\t\tif (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n\t\t\t\tBeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\t\tpriorityOrderedPostProcessors.add(pp);\n\t\t\t\tif (pp instanceof MergedBeanDefinitionPostProcessor) {\n\t\t\t\t\tinternalPostProcessors.add(pp);\n\t\t\t\t}\n\t\t\t} else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n\t\t\t\torderedPostProcessorNames.add(ppName);\n\t\t\t} else {\n\t\t\t\tnonOrderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t}\n\n\t\t// First, register the BeanPostProcessors that implement PriorityOrdered.\n//先处理priorityOrderedPostProcessors这个集合中的数据.先排序,然后调用registerBeanPostPtocessors方法.\n\t\tsortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\t\tregisterBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);\n\n\t\t// Next, register the BeanPostProcessors that implement Ordered.\n//在处理orderedPostProcessorNames集合中的数据,发现如果也是MergedBeanDefinitionPostProcessor或者其子类的话,也就放入到internalPostProcessors集合中,也就是这里先不处理.\n\t\tList<BeanPostProcessor> orderedPostProcessors = new ArrayList<>();\n\t\tfor (String ppName : orderedPostProcessorNames) {\n\t\t\tBeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\torderedPostProcessors.add(pp);\n\t\t\tif (pp instanceof MergedBeanDefinitionPostProcessor) {\n\t\t\t\tinternalPostProcessors.add(pp);\n\t\t\t}\n\t\t}\n//排序,处理上面不是MergedBeanDefinitionPostProcessor的或其子类,并且是 orderedPostProcessorNames集合中的数据\n\t\tsortPostProcessors(orderedPostProcessors, beanFactory);\n\t\tregisterBeanPostProcessors(beanFactory, orderedPostProcessors);\n\n\t\t// Now, register all regular BeanPostProcessors.\n//最后就处理既不是PriorityOrdered,也不是Ordered的,如果也是MergedBeanDefinitionPostProcessor或者其子类的话,这里也会放入到internalPostProcessors集合中 \n\t\tList<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<>();\n\t\tfor (String ppName : nonOrderedPostProcessorNames) {\n\t\t\tBeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\tnonOrderedPostProcessors.add(pp);\n\t\t\tif (pp instanceof MergedBeanDefinitionPostProcessor) {\n\t\t\t\tinternalPostProcessors.add(pp);\n\t\t\t}\n\t\t}\n//这里先处理nonOrderedPostProcessorNames中的数据并且不是 MergedBeanDefinitionPostProcessor的子类.\n\t\tregisterBeanPostProcessors(beanFactory, nonOrderedPostProcessors);\n\n\t\t// Finally, re-register all internal BeanPostProcessors.\n//最后排序下 MergedBeanDefinitionPostProcessor子类的集合,调用registerBeanPostProcessors方法,注册到BeanFactory中去.   \n\t\tsortPostProcessors(internalPostProcessors, beanFactory);\n\t\tregisterBeanPostProcessors(beanFactory, internalPostProcessors);\n\n\t\t// Re-register post-processor for detecting inner beans as ApplicationListeners,\n\t\t// moving it to the end of the processor chain (for picking up proxies etc).\n//最后添加一个ApplicationListenerDetector到beanFactory中去,并且ApplicationListenerDetector是有实现MergedBeanDefinitionPostProcessor接口的.\n\t\tbeanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));\n\t}\n```\n\n#### refersh.initMessageSource() 方法\n\n这个方法主要是对 MESSAGE_SOURCE_BEAN_NAME 是否在beanFactory中进行判断.如果已经在了的话,就会判断是不是HierarchicalMessageSource类型,继续判断其ParentMessageSource是不是null,如果是null的话,就会getInternalParentMessageSource调用初始化获取一些值给赋值进去.\n\n如果beanFactory中没有的话,就会先new一个,然后也会setParentMessageSource值进去,最后注册到beanFactory中去.\n\n```java\n/**\n * Initialize the MessageSource.\n * Use parent's if none defined in this context.\n */\nprotected void initMessageSource() {\n  //先获取BeanFactory.  \n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n// beanFactory中包含MESSAGE_SOURCE_BEAN_NAME\n   if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {\n //获取出出来的bean赋值给this.messageSource      \n      this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);\n      // Make MessageSource aware of parent MessageSource.\n//this.parent不是null并且bean是HierarchicalMessageSource\n      if (this.parent != null && this.messageSource instanceof HierarchicalMessageSource) {\n        //强转  \n         HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;\n  // hms获取出来的parentMessageSource是null情况下,getInternalParentMessageSource()返回的值赋值给hms的ParentMessageSource属性  \n         if (hms.getParentMessageSource() == null) {\n            // Only set parent context as parent MessageSource if no parent MessageSource\n            // registered already.\n            hms.setParentMessageSource(getInternalParentMessageSource());\n         }\n      }\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"Using MessageSource [\" + this.messageSource + \"]\");\n      }\n   }\n// beanFactory中不包含MESSAGE_SOURCE_BEAN_NAME    \n   else {\n      // Use empty MessageSource to be able to accept getMessage calls.\n//自己new一个DelegatingMessageSource,dms    \n      DelegatingMessageSource dms = new DelegatingMessageSource();\n//调用getInternalParentMessageSource()方法的返回值给set进去.  \n      dms.setParentMessageSource(getInternalParentMessageSource());\n      this.messageSource = dms;\n// 注入到 beanFactroy中去       \n      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);\n// 根据log的级别来打印.       \n      if (logger.isDebugEnabled()) {\n         logger.debug(\"Unable to locate MessageSource with name '\" + MESSAGE_SOURCE_BEAN_NAME +\n               \"': using default [\" + this.messageSource + \"]\");\n      }\n   }\n}\n```\n\n#### refresh.initApplicationEventMulticaster() 方法\n\n该方法可以看到也是对APPLICATION_EVENT_MULTICASTER_BEAN_NAME是否在bean的判断，如果有的话,就会get出来,没有的话,就会new一个出来,然后注册到beanFactory中去.\n\n```java\n/**\n * Initialize the ApplicationEventMulticaster.\n * Uses SimpleApplicationEventMulticaster if none defined in the context.\n * @see org.springframework.context.event.SimpleApplicationEventMulticaster\n */\nprotected void initApplicationEventMulticaster() {\n // 先获取beanFactory   \n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n //判断beanFactory是不是有APPLICATION_EVENT_MULTICASTER_BEAN_NAME这个bean,\n //如果是有的话,就会获取出来.然后进行log的级别,判断要不要打印\n   if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {\n      this.applicationEventMulticaster =\n            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"Using ApplicationEventMulticaster [\" + this.applicationEventMulticaster + \"]\");\n      }\n   }\n   else {\n //如果beanFactory是不包含的话,那么久new一个SimpleApplicationEventMulticaster出来,\n //然后注册到beanFactory中去,最后根据log的级别来判断打印\n  \n      this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);\n      beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"Unable to locate ApplicationEventMulticaster with name '\" +\n               APPLICATION_EVENT_MULTICASTER_BEAN_NAME +\n               \"': using default [\" + this.applicationEventMulticaster + \"]\");\n      }\n   }\n}\n```\n\n#### refresh.onRefresh() 方法\n\n该方法时留给子类的。 如果是SpringBoot启动的话,这里就会去new Tomcat,然后启动web相应的环境.\n\n```java\n/**\n * Template method which can be overridden to add context-specific refresh work.\n * Called on initialization of special beans, before instantiation of singletons.\n * <p>This implementation is empty.\n * @throws BeansException in case of errors\n * @see #refresh()\n */\nprotected void onRefresh() throws BeansException {\n   // For subclasses: do nothing by default.\n}\n```\n\n#### refresh.registerListeners() 方法\n\n该方法是先获取 ApplicationListeners,如果是有值的话,就会添加到AbstractApplicationEventMulticaster的ListenerRetriever的applicationListeners集合中去.\n\n根据ApplicationListener.class获取对应的bean信息,然后迭代,最后会添加到AbstractApplicationEventMulticaster的ListenerRetriever的applicationListenerBeans属性中去\n\n最后是对this.earlyApplicationEvents中的事件进行发布\n\n```java\n/**\n * Add beans that implement ApplicationListener as listeners.\n * Doesn't affect other listeners, which can be added without being beans.\n */\nprotected void registerListeners() {\n   // Register statically specified listeners first.\n//getApplicationListeners()获取AbstractApplicationContext中的applicationListeners\n//getApplicationEventMulticaster()方法获取的applicationEventMulticaster,是在\n//initApplicationEventMulticaster方法中有初始化的.    \n//org.springframework.context.event.AbstractApplicationEventMulticaster#addApplicationListener,最后是走到了这里, \n//this.defaultRetriever.applicationListeners.add(listener);最后listener是添加到\n//其内部内ListenerRetriever的applicationListeners参数中去了.    \n   for (ApplicationListener<?> listener : getApplicationListeners()) {\n      getApplicationEventMulticaster().addApplicationListener(listener);\n   }\n\n   // Do not initialize FactoryBeans here: We need to leave all regular beans\n   // uninitialized to let post-processors apply to them!\n//根据ApplicationListener获取相应的beanNames数组,这里可以看到和之前获取PostProcessor是一样的\n   String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);\n//然后迭代, getApplicationListenerBean是走到了\n//org.springframework.context.event.AbstractApplicationEventMulticaster#addApplicationListenerBean,也就是添加到了其内部类ListenerRetriever的applicationListenerBeans属性里面    \n   for (String listenerBeanName : listenerBeanNames) {\n      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);\n   }\n\n   // Publish early application events now that we finally have a multicaster...\n//使用this.earlyApplicationEvents的集合的值,赋值给变量earlyEventsToProcess,\n//然后给this.earlyApplicationEvents重置为null   \n   Set<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;\n   this.earlyApplicationEvents = null;\n //集合不是null并且是有值的话,   \n   if (earlyEventsToProcess != null) {\n      for (ApplicationEvent earlyEvent : earlyEventsToProcess) {\n  //org.springframework.context.event.SimpleApplicationEventMulticaster#invokeListener,这里是走到了这里,可以看到是对这个事件进行发布.\n // 然后会根据ApplicationListener去走onApplicationEvent方法         \n         getApplicationEventMulticaster().multicastEvent(earlyEvent);\n      }\n   }\n}\n```\n\n#### refresh.finishBeanFactoryInitialization() 方法\n\n该方法从名字上来,就是结束beanFactory的初始化,也就是我们前面准备的bd,postProcessor等信息,在这里都会使用到的.\n\n可以看到该方法就是真正的实例化bean的方法。 大致就是getBean往下走,getBean如果是没有的话,就会走createBean,也就是没有就去创建嘛，就是这个意思。然后其创建的条件,是走各种beanPostProcessors来进行扩展bean.\n\nbeanFactory.preInstantiateSingletons() 是需要去阅读很多遍的. 不是一遍或者简单的几遍就ok了的.\n\n```java\n/**\n * Finish the initialization of this context's bean factory,\n * initializing all remaining singleton beans.\n */\nprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n   // Initialize conversion service for this context.\n//如果beanFactory包含CONVERSION_SERVICE_BEAN_NAME,并且该CONVERSION_SERVICE_BEAN_NAME是\n//ConversionService的子类的话,久满足条件,然后先从beanFactory中获取出bean,set给beanFactory中的conversionService属性    \n   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&\n         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {\n      beanFactory.setConversionService(\n            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));\n   }\n\n   // Register a default embedded value resolver if no bean post-processor\n   // (such as a PropertyPlaceholderConfigurer bean) registered any before:\n   // at this point, primarily for resolution in annotation attribute values.\n// beanFactory中没有EmbeddedValueResolver,也就是该方法返回的是false,然后就从environment中获取出来一个给add到beanFactory中去.    \n   if (!beanFactory.hasEmbeddedValueResolver()) {\n      beanFactory.addEmbeddedValueResolver(strVal -> getEnvironment().resolvePlaceholders(strVal));\n   }\n\n   // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.\n//根据LoadTimeWeaverAware获取出对用的names数组\n   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class,\n         false, false);\n\n//然后迭代上面获取出来的数组,挨个调用getBean方法    \n   for (String weaverAwareName : weaverAwareNames) {      \n      getBean(weaverAwareName);\n   }\n\n   // Stop using the temporary ClassLoader for type matching.\n// tempClassLoader,temp的ClassLoader设置为null    \n   beanFactory.setTempClassLoader(null);\n\n   // Allow for caching all bean definition metadata, not expecting further changes.\n//org.springframework.beans.factory.support.DefaultListableBeanFactory#freezeConfiguration,该方法时走的这里. 其中可以看到是给configurationFrozen设置为true,然后beanName的集合转化为数组,并且赋值给this.frozenBeanDefinitionNames这个数组    \n   beanFactory.freezeConfiguration();\n\n   // Instantiate all remaining (non-lazy-init) singletons.\n//这里面初始化bean,简单说一下逻辑. org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String)\n//getBean() ---> doGetBean() --->   createBean() --->  doCreateBean() \n//然后再createBean和doCreateBean()方法之中,会根据条件上面的,获取BeanPostProcessors,然后判断走哦不走其各种BeanPostProceesors提供的方法.满足条件就会走,不满足也就自然不会走了.\n//当然了这个方法的复杂程度是比较高的，是需要好好理解的。不是这个简简单单的几句话,还需要自己去读.\n//起大致打代码走向就是这样,然后其中会走很多调用bean扩展的BeanPostProcessors，还有实现Init...接口后提供的afterS...等方法.    \n   beanFactory.preInstantiateSingletons();\n}\n```\n\n#### \n\n#### refresh.finishRefresh() 方法\n\n可以看到这个方法是清除了资源缓存, 然后 实现Lifecycle接口的子类,这里就会启动其start方法\n\n发送一个ContextRefreshedEvent事件出去\n\n最后将当前的 AbstractApplicationContext 添加到 LiveBeansView的applicationContexts集合中来\n\n```java\n/**\n * Finish the refresh of this context, invoking the LifecycleProcessor's\n * onRefresh() method and publishing the\n * {@link org.springframework.context.event.ContextRefreshedEvent}.\n */\nprotected void finishRefresh() {\n   // Clear context-level resource caches (such as ASM metadata from scanning).\n  //清除资源缓存  \n   clearResourceCaches();\n\n   // Initialize lifecycle processor for this context.\n// 这个方法就会调用实现了 Lifecycle 接口的子类,并且执行其start方法    \n   initLifecycleProcessor();\n\n   // Propagate refresh to lifecycle processor first.\n   getLifecycleProcessor().onRefresh();\n\n   // Publish the final event.\n //发送一个刷新上下文的Event出去   \n   publishEvent(new ContextRefreshedEvent(this));\n\n   // Participate in LiveBeansView MBean, if active.\n//org.springframework.context.support.LiveBeansView#applicationContexts\n//将AbstractApplicationContext添加到liveBean的applicationContexts集合中    \n   LiveBeansView.registerApplicationContext(this);\n}\n```\n\n#### refresh.resetCommonCaches()\n\n可以看到这个方法才是真正的清除各种集合缓存啥的操作. 是在finally代码快中,也就是说是必须要执行的代码\n\n```java\n/**\n * Reset Spring's common reflection metadata caches, in particular the\n * {@link ReflectionUtils}, {@link AnnotationUtils}, {@link ResolvableType}\n * and {@link CachedIntrospectionResults} caches.\n * @since 4.2\n * @see ReflectionUtils#clearCache()\n * @see AnnotationUtils#clearCache()\n * @see ResolvableType#clearCache()\n * @see CachedIntrospectionResults#clearClassLoader(ClassLoader)\n */\nprotected void resetCommonCaches() {\n   ReflectionUtils.clearCache();\n   AnnotationUtils.clearCache();\n   ResolvableType.clearCache();\n   CachedIntrospectionResults.clearClassLoader(getClassLoader());\n}\n```\n\n","tags":["java","spring"],"categories":["java","spring"]},{"title":"spring初始化(一)","url":"/2021/11/04/spring/spring初始化-一/","content":"\n\n\n#### 阅读方法\n\n最简单的阅读方法,就是创建一个maven项目,让引入Spring的依赖. 然后写上一个main方法,来读取包下的内容,然后写一个bean,即可. 这个bean要在你扫描的包下. 于是我们直接在new的地方打上断点跟进去即可.\n\n```java\n<dependencies>\n\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.2.0.RELEASE</version>\n    </dependency>\n\n</dependencies>\npublic class SpringStartMain {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(\"com.iyang.spring\");\n        YangBeanOne yangBeanOne = context.getBean(YangBeanOne.class);\n        System.out.println(yangBeanOne.getClass().toString());\n    }\n}\n```\n\n还有一种就是你去github上clone一个Spring的源码,然后倒入idea,当然你需要gradle环境来构建.然后成功的build一下, 如果成功了的话,就在源码的目录创建一个模块(x项目),然后像上面一样。这样做的好处是,你可以随便修改源码的代码, 你觉得它的哪个地方的代码写到不够好的话,也是可以去修改的.\n\n#### Debug阅读\n\n开始debug进行代码的阅读 :\n\ndebug就会进入到这个构造函数中, 这里我们先对 this() 和 scan(basePackages) 这二个方法进行阅读, refresh()里面涉及到内容比较多(BeanPostprocess,Aware,event等),不是一下子就能看明白的,是需要大量的时间去仔细阅读的.\n\n```java\n/**\n * Create a new AnnotationConfigApplicationContext, scanning for components\n * in the given packages, registering bean definitions for those components,\n * and automatically refreshing the context.\n * @param basePackages the packages to scan for component classes\n */\npublic AnnotationConfigApplicationContext(String... basePackages) {\n   this();\n   scan(basePackages);\n   refresh();\n}\n```\n\nthis () 方法\n\n可以看到this方法,基本是在做一些对环境初始化的操作.\n\n```java\n/**\n * Create a new AnnotationConfigApplicationContext that needs to be populated\n * through {@link #register} calls and then manually {@linkplain #refresh refreshed}.\n 同时还会走到 : org.springframework.context.support.GenericApplicationContext#GenericApplicationContext()这个方法里面来.  this.beanFactory = new DefaultListableBeanFactory(); 可以看到这里是new了一个beanFactory的,也就是我们后面的refresh()方法,可以看到DefaultListableBeanFactroy这个类.\n 再往父类走 : org.springframework.context.support.AbstractApplicationContext#AbstractApplicationContext()就会走到这个类的这个方法来, this.resourcePatternResolver = getResourcePatternResolver(); 这里可以看到是初始化了 resourcePatternResolver.当然了,肯定还有一些new的全局变量的初始化也会进行初始化的.\n \n \n */\npublic AnnotationConfigApplicationContext() {\n   this.reader = new AnnotatedBeanDefinitionReader(this);\n//这个方法对registry,environment和resourceLoader进行赋值,然后根据filter是true,添加了三个filter过滤器.可以看到这个方法虽然带了scanner名字,但是看每个走的方法,好像是没有扫描任何东西,都是对全局参数进行赋值等操作.\n   this.scanner = new ClassPathBeanDefinitionScanner(this);\n}\n\n---------------------------------\n\n\t/**\n\t * Create a new {@code AnnotatedBeanDefinitionReader} for the given registry.\n\t * <p>If the registry is {@link EnvironmentCapable}, e.g. is an {@code ApplicationContext},\n\t * the {@link Environment} will be inherited, otherwise a new\n\t * {@link StandardEnvironment} will be created and used.\n\t * @param registry the {@code BeanFactory} to load bean definitions into,\n\t * in the form of a {@code BeanDefinitionRegistry}\n\t * @see #AnnotatedBeanDefinitionReader(BeanDefinitionRegistry, Environment)\n\t * @see #setEnvironment(Environment)\n这里可以看到传入进来的registry是 this,也就是传入了AnnotationConfigApplicationContext它自己. \n\n可以看到这个方法主要做的事情是,初始化Environment,然后new一个ConditionEvaluator对象,其保存了五个信息. 最后就分别添加五个 Processor到beanFactroy的beanDefinitionMap中来.\n\t */\n\tpublic AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) {\n        // getOrCreateEnvironment()方法,先对registry进行非null的判断,如果是Null的话,就会抛出对应的异常.最后是new StandardEnvironment()了一个对象返回来. registry是满足EnvironmentCapable\n// this()方法:先对传入进来的registry和environemnt进行非null的判断.this.registry = registry; 紧着new了一个ConditionEvaluator对象,其构造函数中,初始化了registry,beanFactory,environment,resourceLoader和classLoader这五个参数,是在内部类ConditionContextImpl中. 最后往beanFactory的beanDefinitionMap中添加了五个值,分别是:\n//org.springframework.context.annotation.internalConfigurationAnnotationProcessor\n//org.springframework.context.annotation.internalAutowiredAnnotationProcessor\n//org.springframework.context.annotation.internalCommonAnnotationProcessor\n//org.springframework.context.event.internalEventListenerProcessor\n//org.springframework.context.event.internalEventListenerFactory  \n//添加完,new AnnotatedBeanDefinitionReader()这个方法就走完了.        \n\t\tthis(registry, getOrCreateEnvironment(registry));\n\t}\n\n----------------------------------\n\t/**\n\t * Create a new {@code ClassPathBeanDefinitionScanner} for the given bean factory.\n\t * @param registry the {@code BeanFactory} to load bean definitions into, in the form\n\t * of a {@code BeanDefinitionRegistry}\n\t */\n\tpublic ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry) {\n\t\tthis(registry, true);\n\t}\n\n// \n\tpublic ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters) {\n//这里也有getOrCreateEnvironment()方法来获取环境,在上一步已经做了,所以这步是直接获取上一步的结果即可.      \n\t\tthis(registry, useDefaultFilters, getOrCreateEnvironment(registry));\n\t}\n\n// 先对传入进来的 registry 进行非null的判断,\n\tpublic ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters,\n\t\t\tEnvironment environment, @Nullable ResourceLoader resourceLoader) {\n\n\t\tAssert.notNull(registry, \"BeanDefinitionRegistry must not be null\");\n\t\tthis.registry = registry;\n\t\t// 这里传入的是ture,也就是会走到这个if里面来.\n\t\tif (useDefaultFilters) {\n//org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#registerDefaultFilters, 往includeFilters 集合中添加Filter,这些添加的filter,点进去看即可.            \n\t\t\tregisterDefaultFilters();\n\t\t}\n// this.environment赋上传入进来的environment值.        \n\t\tsetEnvironment(environment);\n// org.springframework.core.io.support.ResourcePatternUtils#getResourcePatternResolver进行判断,这里由于是ResourcePatternResolver,所以在第一个if就返回了.\n//接着new一个CachingMetadataReaderFactory,传入进去resourceLoader,new这个类的内部也是可以看,就是对参数进行赋值,并没有做其他的什么事情了.      \n//this.componentsIndex = CandidateComponentsIndexLoader.loadIndex(this.resourcePatternResolver.getClassLoader());获取出来的值Null.        \n\t\tsetResourceLoader(resourceLoader);\n\t}\n```\n\nscan(basePackages) 方法\n\n```java\n// 对传入进来的参数进行一个校验.\n//scanner也是上面那步this.scanner = new ClassPathBeanDefinitionScanner(this)给new出来的.\npublic void scan(String... basePackages) {\n   Assert.notEmpty(basePackages, \"At least one base package must be specified\");\n   this.scanner.scan(basePackages);\n}\n\n/**\n* Perform a scan within the specified base packages.\n* @param basePackages the packages to check for annotated classes\n* @return number of beans registered\n*/\npublic int scan(String... basePackages) {\n// org.springframework.beans.factory.support.DefaultListableBeanFactory#getBeanDefinitionCount 走到这步来获取个数,还记得new AnnotatedBeanDefinitionReader(this)这个方法里面添加了五个processor吗?所以这里获取出来的beanCountAtScanStart大小就是5(默认对初始化做任何改动的情况下).\n\tint beanCountAtScanStart = this.registry.getBeanDefinitionCount();\n//从名字上看,这个方法是真正的做扫描的.其实Spring中,scan都算不做事的,doScan才是真的做事的。到后面还有getBean不是做事的,doGetBean才是做事的,createBean也是的. \n//doScan做的事情可以看到,读取包下的类,然后根据filter条件来过滤,满足条件的话,就会封装成ScannedGenericBeanDefinition,最后是一个集合包装的该包下全部满足条件的. 然后就是接着对 sbd进行注解的处理,比如有些打入了Lazy等注解的,都要读取出来,存入bd的信息中.最后再检查一遍db,如果没问题的话,就会根据beanName和bd,new一个BeanDefinitionHolder出来,最后注册到beanFactory中去,也就是放入BeanFactory的beanDeifitionMap中去.    \n\tdoScan(basePackages);\n\t// Register annotation config processors, if necessary.\n\tif (this.includeAnnotationConfig) {\n// 先获取出beanFactory,先调用beanFactory的getDependencyComparator和getAutowireCandidateResolver方法,如果满足条件的话,就会有对应的set方法.然后紧接着就是判断beanFactory中是否包含一些bd,如果是不包含的话,这里就会添加进去. 这里判断的值,再最初new reader()的时候已经有添加到BeanFactory的beanDifitionMap中去.        \n\t\tAnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);\n\t}\n    // 这里返回int参数,但是 this.scanner.scan(basePackages); 好像并没有使用到返回值.\n\treturn (this.registry.getBeanDefinitionCount() - beanCountAtScanStart);\n}\n\n/**\n* Perform a scan within the specified base packages,\n* returning the registered bean definitions.\n* <p>This method does <i>not</i> register an annotation config processor\n* but rather leaves this up to the caller.\n* @param basePackages the packages to check for annotated classes\n* @return set of beans registered if any for tooling registration purposes (never {@code null})\n\t */\nprotected Set<BeanDefinitionHolder> doScan(String... basePackages) {\n    // 先是对传入进来的参数进行检验.\n\tAssert.notEmpty(basePackages, \"At least one base package must be specified\");\n    // 存BeanDefinitionHolder的集合,也是最后要返回的.\n\tSet<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();\n\tfor (String basePackage : basePackages) {\n//根据传入进去的包名字,读取出包名字下的所有文件,然后迭代这些文件,这些文件要有能读的权限,再走isCandidateComponent(metadataReader)这个方法,其中就有使用 excludeFilters和includeFilters,这二个filter来过滤进行一些判断操作. 返回ture,就会往下走,new一个ScannedGenericBeanDefinition,其中beanClass就是这个类的全限定名字.比如这里(com.iyang.spring.bean.YangBeanOne),我们的是这个.\n//这就是这个方法,扫描,然后根据特定filter,如果是满足条件的话,就会new一个sbd,然后放入Set集合中,返回. \n\t\tSet<BeanDefinition> candidates = findCandidateComponents(basePackage);\n        \n\t\tfor (BeanDefinition candidate : candidates) {\n//org.springframework.context.annotation.AnnotationScopeMetadataResolver#resolveScopeMetadata,走的这个方法,因AnnotationConfigUtils.attributesFor(...)方法返回的是null,所以这个里面就仅仅只是new了一个ScopeMetadata对象返回了           \n\t\t\tScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);\n//scope的值是singletone.这不就是我们熟悉的单例嘛.            \n\t\t\tcandidate.setScope(scopeMetadata.getScopeName());\n//获取出这个bean的名字            \n\t\t\tString beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);\n// db是 AbstractBeanDefinition的话,这里肯定是,从AbstractBeanDefinition这个名字上看,是一个抽象的，也就是应该是父类.            \n\t\t\tif (candidate instanceof AbstractBeanDefinition) {\n//beanDefinition.applyDefaults(this.beanDefinitionDefaults)该方法是对一些参数进行赋值操作. \n//                \n\t\t\t\tpostProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);\n\t\t\t}\n// bd是AnnotatedBeanDefinition或者其子类.            \n\t\t\tif (candidate instanceof AnnotatedBeanDefinition) {\n// 该方是对bd的Lazy.calss,Primary.class,DependsOn.class,Role.class,Description.class这些注解进行获取,如果有的话,就会调用bd对应的set方法给值set进去. 当然我们这里的bean没有这些属性.这里可自行加入一些注入,然后debug到这个地方进行看.\n                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);\n\t\t\t\t}\n// 检查registry中是否含有这个beanName,如果没包含的话,就直接返回ture.            \n\t\t\tif (checkCandidate(beanName, candidate)) {\n// 传入bean和beanName, new一个bean的Holder出来,也就是bean的持有者的意思.其实个人觉得这里是对bean进行一层封装,Holder更抽象地理解点.                \n\t\t\t\tBeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);\n//scopeMetadata中获取出getScopedProxyMode,如果是No的话,就直接返回definitionHolder         \n\t\t\t\tdefinitionHolder =\n\t\t\t\t\t\t\tAnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);\n// 添加到最外层的集合中                \n\t\t\t\tbeanDefinitions.add(definitionHolder);\n//org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition,最后走到了这里,该方法会先对传入进来的参数进行非null的判断,如果bd是AbstractBeanDefinition的话,就会强转调用其validate()方法,进行检验. 在从this.beanDefinitionMap中获取,根据beanName,第一次肯定是获取不到的,走到else.else中在判断hasBeanCreationStarted(),这里返回的是flase,也就是走到了else的else中去了,根据beanName和bean存入到this.beanDefinitionMap中,然后beanName添加到beanDefinitionNames集合中.  这就是这步根据beanName和bean放入beanFactory的beanDefinitionMap集合中.               \n\t\t\t\tregisterBeanDefinition(definitionHolder, this.registry);\n\t\t\t}\n\t\t}\n\t}\n\treturn beanDefinitions;\n}\n```\n\n#### 总结\n\n- this() 方法 : 该方法中主要是初始化了 this.reader 和 this.scanner这个参数,当然了,其中还有一些环境等信息 的初始化. this.reader的时候,是有往beanFactroy中添加五个默认要添加的bd,也就是添加到了 BeanFactory的BeanDefitionMap中. this.scanner 也是对一些环境等信息初始化 , 然后下接来的方法就是使用 this.scanner来进扫描 class,然后满足条件的,就封装成bd,注册到beanFactory中去.\n- register() 方法里面调用 this.reader.register(componentClasses); 该方法就是读取包下的class信息,然后满足条件的就封装成bd,同时还会对注解@Lazy等也会读取,如果是有这些注解的话,就会调用bd对应的set方法,给赋值进去,最后将bd给注册到BeanFactory的beanDefitionMap中去即可.\n\n可以看到 this() 方法 和 register()方法,主要是对环境的初始化和根据传入进来的包名来进行扫描获取class信息,满足条件的class信息就会转化为bd,然后注册到beanFactory中去.\n","tags":["java","spring"],"categories":["java","spring"]},{"title":"ThreadLocal源码阅读","url":"/2021/11/04/java/ThreadLocal源码阅读/","content":"\n\n\nThreadLocal 是来这个公司有过使用一次的感受,所以就学习阅读下源码。 其实Thread 这个里面,就有一个 Map(这里是用ThreadLocal内部类中实现的) , 里面的key就是 ThreadLocal, value 就是存储的值,所以一个Thread是有多个 ThreadLocal。\n\n------\n\n#### 参数\n\n参数部分\n\n```\nprivate final int threadLocalHashCode = nextHashCode();\n\n/**\n * The next hash code to be given out. Updated atomically. Starts at\n * zero.\n   AtomicInteger 是一个线程安全的,实现原理是采用了cas.\t\n */\nprivate static AtomicInteger nextHashCode =\n    new AtomicInteger();\n```\n\n#### 方法\n\nset 赋值\n\n```\n/**\n*\t首先获取当前线程.\n\t调用 getMap 方法, 直接调用 t.trheadLocals来获取 ThreadLocalMap。(ThreadLocalMap这里是ThreadLocal内部自己实现的类)\n\t如果map不是null的话,就进行set值,这里可以看到 set 的key是this,也就是ThreadLocal它自己.\n\t否则就是调用createMap方法,走这个方法是可以确认 currentThread中的threadLocals的值是null,所以直接new了一个进行赋值即可.\n*/\npublic void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\n\nThreadLocalMap getMap(Thread t) {\n        return t.threadLocals;\n}\n\nvoid createMap(Thread t, T firstValue) {\n        t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n```\n\n#### Get 方法\n\nget 方法,获取值.\n\n```\n/**\n\t这里可以看到,获取ThreadLocalMap,如果ThreadLocalMap的是null的话,就会走setInitialValue方法。\n\t如果有值的话,就会进行获取值并且返回.\n*/\npublic T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    return setInitialValue();\n}\n\n/**\n\t如果获取出来的ThreadLocalMap 不是null的话,就会进行set,这个时候set进去的值,value就是null了.\n\t如果获取出来是nulld\n*/\nprivate T setInitialValue() {\n        T value = initialValue();\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n        return value;\n}\n\nprotected T initialValue() {\n        return null;\n}\n```\n\n#### remove 方法\n\nremove 方法就是获取map,如果map不是null的话,就调用m.remove(this)，根据当前this来删除.\n\n```\npublic void remove() {\n    ThreadLocalMap m = getMap(Thread.currentThread());\n    if (m != null)\n        m.remove(this);\n}\n```\n\n------\n\n#### 总结\n\nThreadLocal里面的方法也比较少,还是比较好理解的。只要弄清楚ThreadLocal和Thread是怎么在存储的,就很好的理解了。\n\n注意 : 使用ThreadLocal一定要进行remove,否则容易出现内存泄漏，从而导致内存溢出。\n","tags":["java","java线程"],"categories":["java","java线程"]},{"title":"ReentrantLock源码阅读","url":"/2021/11/04/java/ReentrantLock源码阅读/","content":"\n#### 介绍\n\n ReetrantLock 效果是和 synchronized 是一样的,只不过 synchronized 是内置锁,ReetrantLock是语法级别的锁, 相对于而言是比synchronized灵活性高些. 不过从我目前公司写代码角度来看,都是直接使用 synchronized . 但是不妨碍我们来看 ReetrantLock 里面的代码实现.\n\n 使用代码 : 有lock方法就一定要有 unlock方法来释放锁. 一般代码中这样写即可.\n\n```\npublic class ReentrantLockCaseMain {\n\n    private ReentrantLock lock = new ReentrantLock();\n\n\n    public void lockUseCase(){\n\n        lock.lock();\n        try {\n            System.out.println(\"执行业务代码逻辑\");\n        }finally {\n            lock.unlock();\n        }\n\n\n    }\n\n}\n```\n\n#### 代码分析\n\n ReetrantLock 中是没有什么全局参数,相比于集合,就没有那么多全局参数.但是我们要看其里面的内,这里有三个类, Sync , NonfairSync , FairSync. NonfairSync和FairSync 都是有继承 Sync. 可以看到NonfairSync 是非公平锁 , FairSync是公平锁.\n\n Sync 又集成 AQS, 使用独占锁, 重写了 tryRelease 方法.\n\n- 构造函数: 默认是使用的非公平锁,如果传入进来的是true就会使用公平锁,否则就会使用非公平锁.\n\n  ```\n   /**\n   * Creates an instance of {@code ReentrantLock}.\n   * This is equivalent to using {@code ReentrantLock(false)}.\n   */\n  public ReentrantLock() {\n      sync = new NonfairSync();\n  }\n  \n  /**\n   * Creates an instance of {@code ReentrantLock} with the\n   * given fairness policy.\n   *\n   * @param fair {@code true} if this lock should use a fair ordering policy\n   */\n  public ReentrantLock(boolean fair) {\n      sync = fair ? new FairSync() : new NonfairSync();\n  }\n  ```\n\n- lock 方法: lock方法是加锁的方法\n\n  lock方法是调用的 Sync 的lock方法, 然后我们可以看到上锁的时候,走的Sync,然后根据FairSync/NonfairSync取走各自的加锁方法,所以说公平锁和非公平锁是加锁的方式是不一样的.\n\n非公平锁获取锁的时候,会获取state这个状态标识,然后再去走对应的逻辑,这里多了比非公平锁多了一个从队列中获取信息和不能获取锁的线程就会被挂起进入队列中排队.\n\n```\npublic void lock() {    sync.lock();}\n\n// Sync \nabstract void lock();\n\n\n    /**\n    * 公平锁\n     * Sync object for fair locks\n     */\ntatic final class FairSync extends Sync {\n        private static final long serialVersionUID = -3000897897090466540L;\n\n    \t/* \n    \tacquire(1) 调用到AQS中,最后还是调用到下面的tryAcquire方法.\n    \t那些没有获取到锁的线程,就会按照队列的方式排队,满足先进先出的效果的,也就是先来的线程先执行,\n    \t果然这就很公平\n    \t**/\n        final void lock() {\n            acquire(1);\n        }\n\n        /**\n         * Fair version of tryAcquire.  Don't grant access unless\n         * recursive call or no waiters or is first.\n         */\n        protected final boolean tryAcquire(int acquires) {\n            final Thread current = Thread.currentThread();\n            int c = getState();\n            if (c == 0) {\n                /**\n                \thasQueuedPredecessors() 方法,先判断头结点和尾结点是不相等的,因为相等的话,就重复了,就是同一个. 然后在判断头结点的 thread是不是当前线程,如果不是当前的前程的话,那么就是在这个线程钱面还有一个等待获取锁时间更久的线程,于是就先抛弃这个线程,去执行那个等待更久的线程.\n                \t\n                \tcompareAndSetState 就是用cas来获取锁的代码,如果获取成功的话,就会走setExclusiveOwnerThread方法,这里set进去的值是在释放锁的时候会用到.\n                \t最后返回true,说明获取锁成功了.\n                */\n                if (!hasQueuedPredecessors() &&\n                    compareAndSetState(0, acquires)) {\n                    setExclusiveOwnerThread(current);\n                    return true;\n                }\n            }\n            /**\n            \t获取从setExclusiveOwnerThread里面的thread,来判断是否与当前线程相等,如果相等的话,就说明重入了.\n            */\n            else if (current == getExclusiveOwnerThread()) {\n                int nextc = c + acquires;\n                if (nextc < 0)\n                    throw new Error(\"Maximum lock count exceeded\");\n                setState(nextc);\n                return true;\n            }\n            return false;\n        }之前\n}\n\npublic final boolean hasQueuedPredecessors() {\n        // The correctness of this depends on head being initialized\n        // before tail and on head.next being accurate if the current\n        // thread is first in queue.\n        Node t = tail; // Read fields in reverse initialization order\n        Node h = head;\n        Node s;\n        return h != t &&\n            ((s = h.next) == null || s.thread != Thread.currentThread());\n}\n\n/**\n\t非公平锁:\n*/\nstatic final class NonfairSync extends Sync {\n        private static final long serialVersionUID = 7316153563782823691L;\n\n        /**\n         * Performs lock.  Try immediate barge, backing up to normal\n         * acquire on failure.\n         可以看到非公平锁是没有从队列中获取说明结点信息,而是直接获取锁的.\n         获取成功了就会走 setExclusiveOwnerThread 方法\n         */\n        final void lock() {\n            if (compareAndSetState(0, 1))\n                setExclusiveOwnerThread(Thread.currentThread());\n            else\n                acquire(1);\n        }\n\n        protected final boolean tryAcquire(int acquires) {\n            return nonfairTryAcquire(acquires);\n        }\n}\n\n/**\n\tSync类中\n\t这段代码的逻辑也是和 公平锁后来的处理一样的了. c如果是0的话,就会走获取锁的代码,如果不是0的话,就说明重入了,所以就++\n*/\nfinal boolean nonfairTryAcquire(int acquires) {\n            final Thread current = Thread.currentThread();\n            int c = getState();\n            if (c == 0) {\n                if (compareAndSetState(0, acquires)) {\n                    setExclusiveOwnerThread(current);\n                    return true;\n                }\n            }\n            else if (current == getExclusiveOwnerThread()) {\n                int nextc = c + acquires;\n                if (nextc < 0) // overflow\n                    throw new Error(\"Maximum lock count exceeded\");\n                setState(nextc);\n                return true;\n            }\n            return false;\n}\n```\n\nunlock方法: unlock是释放锁的方法. 可以看到释放锁是走的 Sync的release方法,所以不管公平锁还是非公平锁起走的释放锁方法是不一样的.\n\n```\npublic void unlock() {    sync.release(1);}  \n\n/**\n\tSync 中方法. \n*/\npublic final boolean release(int arg) {\n        // tryRelease()方法返回true的话,就说明锁都释放完了.\n        \n        if (tryRelease(arg)) {\n            Node h = head;\n            // 恢复线程\n            if (h != null && h.waitStatus != 0)\n                unparkSuccessor(h);\n            return true;\n        }\n        return false;\n}\n\n\nprotected final boolean tryRelease(int releases) {\n            // 释放锁\n            int c = getState() - releases;\n            // 如果当前线程不是自己的话,就会抛出异常.这里可以理解为,独占锁,肯定是自己.\n            // 也就是说,如果不是独占锁的话,就会抛出异常.\n            if (Thread.currentThread() != getExclusiveOwnerThread())\n                throw new IllegalMonitorStateException();\n            boolean free = false;\n            // 如果你调用了一次lock的话,那么会加一,所以这个地方要等这个lock方法全部被释放掉.\n    \t\t// 也就是由于重入锁的原因.\n            if (c == 0) {\n                free = true;\n                // 释放完了,就设置了null.  \n                // 然后AbstractOwnableSynchronizer中的thread标记也就是null,\n                // 所以下个线程判断是null的话,就可以获取到执行权,也就是获取到锁.\n                setExclusiveOwnerThread(null);\n            }\n            setState(c);\n            return free;\n}\n```\n\n\n\n- isLocked () 方法, 判断这个线程是不是被锁了:\n\n  调用Sync中isLock方法,如果不是0的话,就说明是被锁了,如果是0的话,就说明没有被锁.\n\n  ```java\n      /**\n       * Queries if this lock is held by any thread. This method is\n       * designed for use in monitoring of the system state,\n       * not for synchronization control.\n       *\n       * @return {@code true} if any thread holds this lock and\n       *         {@code false} otherwise\n       */\n      public boolean isLocked() {\n          return sync.isLocked();\n      }\n      \n   final boolean isLocked() {\n              return getState() != 0;\n  }\n  ```\n\nhasQueuedThreads() : 是否有线程在等待队列中\n\nhasQueuedThread(Thread thread) : 线程是否在等待队列中\n\ngetQueueLength() : 获取队列中线程个数\n\n等这些方法都是比较好理解的,可以自行点进去仔细看下.\n\n#### 总结\n\n```\n Sync  /  NonfairSync  /  FairSync  这个三个类就是 ReetrantLock中的三个类,都是围绕这这三个类在做文章.\n\n公平锁和非公平锁的获取锁方式不一样,但是释放方式是一样的. 公平锁获取锁的时候,如果有线程持有了的话\n```\n","tags":["java","java线程"],"categories":["java","java线程"]},{"title":"PriorityQueue源码阅读记录","url":"/2021/11/04/java/PriorityQueue源码阅读记录/","content":"\nPriorityQueue : 中文是优先队列 , 队列的特点就是数据 先进先出, 但是这个优先队列的特别是什么呢？ 首先肯定是有队列的基本特点，也就是有先进先出。 如果是先进先出的话,那么就和普通的有什么区别？优先二字又是体现在什么地方呢？ 优先级队列的元素按照其自然顺序进行排序, 或者根据 构造队列时提供的 Comparator 进行排序.\n\n------\n\n#### 结构\n\n 结构就是 PriorityQueue这个类的 全局变量参数, 因为这些参数是存储数据的, 所以只要理解了这些参数,就明白了这个 PriorityQueue这个是对数据是怎么样进行存储的, 还是比较好理解的.\n\n这里可以看到 priorityQueue的数据结构还是很简单的, 一眼扫过去没什么需要特别的理解\n\n```\n// 存储数据的数组\ntransient Object[] queue;\n\n// 记录 priorityQueue的长度\nprivate int size = 0;\n\n// 这个就是之前说提到的  可以根据 Comparator 进行排序\nprivate final Comparator<? super E> comparator;\n```\n\n------\n\n#### 构造方法\n\n priorityQueue的构造方法相对于其他的集合的构造方法可能是比较多的.\n\n\n\n 这里列举出来, 可以看到构造方法还是比较多的.\n\n 对构造函数的初始化赋值等操作还是很好理解的,并没有什么特别难理解的。 主要还是对数组/长度/或者传入进来的数组进行赋值操作.\n\n```\n// 1   \n// 这里是走到 4 的构造方法去了\npublic PriorityQueue() {\n    this(DEFAULT_INITIAL_CAPACITY, null);\n}\n\n// 2\n// 这里是走到 4 的构造方法去了\npublic PriorityQueue(int initialCapacity) {\n        this(initialCapacity, null);\n}\n\n// 3\n// 这里是走到 4 的构造方法去了\npublic PriorityQueue(Comparator<? super E> comparator) {\n        this(DEFAULT_INITIAL_CAPACITY, comparator);\n}\n\n// 4 \n/**  可以看到前面的三个都是走到了这里来了,\n\t 长度如果是小于1的话,就会报错.  \n     this.queue 的数组长度就是 initialCapacity\n     comparator 排序方法就是传入进来的\n*/\npublic PriorityQueue(int initialCapacity,\n                         Comparator<? super E> comparator) {\n        // Note: This restriction of at least one is not actually needed,\n        // but continues for 1.5 compatibility\n        if (initialCapacity < 1)\n            throw new IllegalArgumentException();\n        this.queue = new Object[initialCapacity];\n        this.comparator = comparator;\n}\n\n// 5\n/**  对传入进来的集合进行判断. 分为   SortedSet  或者  PriorityQueue  或者其他\n     如果是 SortedSet 的话, 对 comparator 的值赋值为 传入进来集合的排序方式,然后走 initElementsFromCollection() 方法, 这里应该是对集合进行赋值操作.\n     如果是 PriorityQueue , comparator 处理方式是和 SortedSet一样,然后走 initFromPriorityQueue 方法. \n     否则就不上面的二种, comparator 复置为 null ,走 initFromCollection 方法.\n     这里总结的话,就是传入进来不同的集合,走的方法也是不一样的,这个还是很好理解的.\n\t\n*/\npublic PriorityQueue(Collection<? extends E> c) {\n        if (c instanceof SortedSet<?>) {\n            SortedSet<? extends E> ss = (SortedSet<? extends E>) c;\n            this.comparator = (Comparator<? super E>) ss.comparator();\n            initElementsFromCollection(ss);\n        }\n        else if (c instanceof PriorityQueue<?>) {\n            PriorityQueue<? extends E> pq = (PriorityQueue<? extends E>) c;\n            this.comparator = (Comparator<? super E>) pq.comparator();\n            initFromPriorityQueue(pq);\n        }\n        else {\n            this.comparator = null;\n            initFromCollection(c);\n        }\n}\n\n// 6  这个对应上面的, 如果是传入进来 PriorityQueue 的处理方法\npublic PriorityQueue(PriorityQueue<? extends E> c) {\n        this.comparator = (Comparator<? super E>) c.comparator();\n        initFromPriorityQueue(c);\n}\n\n// 7  这个也是对应上面的 SortedSet 处理方法\npublic PriorityQueue(SortedSet<? extends E> c) {\n        this.comparator = (Comparator<? super E>) c.comparator();\n        initElementsFromCollection(c);\n}\n\n----------------------   华丽分割线   --------------------\n上面的if else 里面提到的走不同的方法,还是有必要取看看的. \n    \n/**\n  对传入进来是  PriorityQueue  进行处理, 先判断确认 class是PriorityQueue ,是的话,调用toArray() 将数组赋值给 queue , 并且长度也进行复置给size.\n  否则就走  initFromCollection 方法, 这个 if else 还是比较严谨的.进行多次判断处理\n*/    \nprivate void initFromPriorityQueue(PriorityQueue<? extends E> c) {\n        if (c.getClass() == PriorityQueue.class) {\n            this.queue = c.toArray();\n            this.size = c.size();\n        } else {\n            initFromCollection(c);\n        }\n}    \n\n/**\n   这个对传入进来的集合, 将值转化为 数组a (Object []), 如果 comparator不是null的话,就会根据comparator来进行排序. 也就是对a进行排序,并且这个的值不可以为null的,如果出现了null的话,就会有空指针的异常出现.\n   然后将数组a赋值给queue,长度也是调用 a.length 复置给size\n*/\nprivate void initElementsFromCollection(Collection<? extends E> c) {\n        Object[] a = c.toArray();\n        // If c.toArray incorrectly doesn't return Object[], copy it.\n        if (a.getClass() != Object[].class)\n            a = Arrays.copyOf(a, a.length, Object[].class);\n        int len = a.length;\n        if (len == 1 || this.comparator != null)\n            for (int i = 0; i < len; i++)\n                if (a[i] == null)\n                    throw new NullPointerException();\n        this.queue = a;\n        this.size = a.length;\n}\t\n\n/**\n 可以看到这个方法是走了  initElementsFromCollection 这个方法, 然后再走 headify 方法\n*/\nprivate void initFromCollection(Collection<? extends E> c) {\n        initElementsFromCollection(c);\n        heapify();\n}\n```\n\n------\n\n#### 方法\n\n 添加元素方法 ：\n\n\n\n```\npublic boolean add(E e) {\n    return offer(e);\n}\n\n/**\n\t这里可以看到,如果值是null的话,就会抛出NPE的异常.\n\t如果size的大小比 queue数组的长度还大的话,就会进行扩容.\n\t然后size长度+1,如何i是0的话,就说明是第一个元素,不需要任何拍寻处理,直接赋值给第一个即可.\n\t如果不是第一个的话,就会走siftUp方法\n*/\npublic boolean offer(E e) {\n        if (e == null)\n            throw new NullPointerException();\n        modCount++;\n        int i = size;\n        if (i >= queue.length)\n            grow(i + 1);\n        size = i + 1;\n        if (i == 0)\n            queue[0] = e;\n        else\n            siftUp(i, e);\n        return true;\n}\n\n/**\n\t如果 comparator是null的话,就走  siftUpUsingComparator 方法.\n\t否则就会走 siftUpComparable 方法\n*/\nprivate void siftUp(int k, E x) {\n        if (comparator != null)\n            siftUpUsingComparator(k, x);\n        else\n            siftUpComparable(k, x);\n}\n\n/**\n\t这里先判断k是大于0的,也就是不是第一个的意思.\n\t然后通过 (k - 1) >>> 1 计算出来下标位置,下标是parent的值,调用 comparator.compare(x,e)来进行比较,如果是大于0的话,就不需要做任何处理。\n\t否则的话,就会 queue[k] = e ; k = parent; 来进行下标数值的替换处理.\n\t最后queue[k] = x 的值\n*/\nprivate void siftUpUsingComparator(int k, E x) {\n        while (k > 0) {\n            int parent = (k - 1) >>> 1;\n            Object e = queue[parent];\n            if (comparator.compare(x, (E) e) >= 0)\n                break;\n            queue[k] = e;\n            k = parent;\n        }\n        queue[k] = x;\n}\n\n/**\n\t这个方法其实也是和上面的处理方式是类似的,通过比较值来进行处理.\n*/\nprivate void siftUpComparable(int k, E x) {\n        Comparable<? super E> key = (Comparable<? super E>) x;\n        while (k > 0) {\n            int parent = (k - 1) >>> 1;\n            Object e = queue[parent];\n            if (key.compareTo((E) e) >= 0)\n                break;\n            queue[k] = e;\n            k = parent;\n        }\n        queue[k] = key;\n}\n\n\n/**\n\t这里顺路看下 grow 扩容方法吧。 \n\t肯定是根据 queue的长度来进行扩容,如果值太小了的话,就会进行 二倍扩容.  否则的话,就是1.5倍扩容.\n\t最后调用 Arrays.copyOf() 来进行扩容数组操作\n\t这个扩容还是想对比较简单的\n*/\nprivate void grow(int minCapacity) {\n        int oldCapacity = queue.length;\n        // Double size if small; else grow by 50%\n        int newCapacity = oldCapacity + ((oldCapacity < 64) ?\n                                         (oldCapacity + 2) :\n                                         (oldCapacity >> 1));\n        // overflow-conscious code\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        queue = Arrays.copyOf(queue, newCapacity);\n}\n```\n\npeek 方法\n\n这里可以看清楚的看到，出队列方法的值,就是默认的第一个嘛，这么一眼看下去就是很清楚明了的.\n\n```\npublic E peek() {\n    return (size == 0) ? null : (E) queue[0];\n}\n```\n\nremove 方法 :\n\n```\n/**\n\t删除元素的方法。\n\tindexOf 如果返回的不是-1的话,就说明是有值得,就会走到 removeAt 方法\n*/\npublic boolean remove(Object o) {\n    int i = indexOf(o);\n    if (i == -1)\n        return false;\n    else {\n        removeAt(i);\n        return true;\n    }\n}\n\n/**\n\tindexOf 这个方法就是判断在这个集合里面有没有 o 这个值, 如果有的话就会返回对应的下标,如果不存在的话,就会返回-1的值\n*/\nprivate int indexOf(Object o) {\n        if (o != null) {\n            for (int i = 0; i < size; i++)\n                if (o.equals(queue[i]))\n                    return i;\n        }\n        return -1;\n}\n\n/**\n\tremoveAt 方法就会将传入进来的i的下标的值重置为null,这是满足 i == --size 的情况下.\n\t然后会将要删除的下标 i 和 对应的值 moved 传入到 siftDown 这个方法中.\n\tsiftUp()是在前面有讲解到的.\n\t这里还是很明显的看到, priorityQueue是一直在维护这排序的关系。\n*/\nprivate E removeAt(int i) {\n        // assert i >= 0 && i < size;\n        modCount++;\n        int s = --size;\n        if (s == i) // removed last element\n            queue[i] = null;\n        else {\n            E moved = (E) queue[s];\n            queue[s] = null;\n            siftDown(i, moved);\n            if (queue[i] == moved) {\n                siftUp(i, moved);\n                if (queue[i] != moved)\n                    return moved;\n            }\n        }\n        return null;\n}\n\n/**\n\t根据comparator走不同的方法\n\t可以看到走的二个方法，其中的区别是 comparator.compare 和 comparator.compareTo 调用的api是不一样的\n*/\nprivate void siftDown(int k, E x) {\n        if (comparator != null)\n            siftDownUsingComparator(k, x);\n        else\n            siftDownComparable(k, x);\n}\n\n\nprivate void siftDownUsingComparator(int k, E x) {\n        int half = size >>> 1;\n        while (k < half) {\n            int child = (k << 1) + 1;\n            Object c = queue[child];\n            int right = child + 1;\n            if (right < size &&\n                comparator.compare((E) c, (E) queue[right]) > 0)\n                c = queue[child = right];\n            if (comparator.compare(x, (E) c) <= 0)\n                break;\n            queue[k] = c;\n            k = child;\n        }\n        queue[k] = x;\n}\n\nprivate void siftDownComparable(int k, E x) {\n        Comparable<? super E> key = (Comparable<? super E>)x;\n        int half = size >>> 1;        // loop while a non-leaf\n        while (k < half) {\n            int child = (k << 1) + 1; // assume left child is least\n            Object c = queue[child];\n            int right = child + 1;\n            if (right < size &&\n                ((Comparable<? super E>) c).compareTo((E) queue[right]) > 0)\n                c = queue[child = right];\n            if (key.compareTo((E) c) <= 0)\n                break;\n            queue[k] = c;\n            k = child;\n        }\n        queue[k] = key;\n}\n```\n\n------\n\n#### 总结\n\n PriorityQueue 的存储数据结构是采用一个数据来进行存储,也就是一直在操作这个数组，只是每次都对数据进行了维护排序的关系。\n\n PriorityQueue 是线程不安全的队列，这里还是提一下吧,因为添加元素和删除元素的方法都是没有进行加锁处理，当然了,如果不使用作为全局变量的话，自然是没有任何问题的,在局部变量里面.\n","tags":["java","java集合"],"categories":["java","java集合"]},{"title":"spring创建bean_one","url":"/2021/11/04/spring/spring创建bean-one/","content":"\n\n\n#### 前提\n\n我们在创建 Spring Bean 的时候，是可以通过很多种方式来创建的. 但是这么多种方式,又是怎么加载的？是不是又有顺序呢？ 所以对 Spring 的 Bean 创建还是很有必要的.\n\n#### 创建方式\n\n我们可以通过自己创建 bd , 然后调用 registerBeanDefinition 方法给注册到 Spring 中来.\n\n那么创建bd的怎么创建的呢？可以看到下面的二种创建方式.\n\n这是通过 bd 来的.\n\n```java\npublic class BeanDefinitionCreateAndRegister {\n\n\n    public static void main(String[] args) {\n\n        // 1 : 通过 BeanDefinitionBuilder 来创建 bd\n        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(Person.class);\n        beanDefinitionBuilder.addPropertyValue(\"id\",9527).addPropertyValue(\"name\",\"GavinYang\");\n        BeanDefinition beanDefinition = beanDefinitionBuilder.getBeanDefinition();\n\n        // 2 : 通过 new GenericBeanDefinition 来创建 bd.\n        GenericBeanDefinition genericBeanDefinition = new GenericBeanDefinition();\n        genericBeanDefinition.setBeanClass(Person.class);\n        MutablePropertyValues mutablePropertyValues = new MutablePropertyValues();\n        mutablePropertyValues.add(\"id\",1).add(\"name\",\"Peterwong\");\n        genericBeanDefinition.setPropertyValues(mutablePropertyValues);\n\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();\n\n        // 这里是给 bd 给注册到 Spring 容器里面来.\n        // context.registerBeanDefinition(\"person\",beanDefinition);\n        context.registerBeanDefinition(\"peterwong\",genericBeanDefinition);\n\n        // 如果这里不调用 refresh 是会有错误的.\n        context.refresh();\n\n        Person person = context.getBean(Person.class);\n        person.say();\n        System.out.println(person.toString());\n\n    }\n\n}\n```\n\n通过我们常用的注解\n\n这里主要是 @Import/@Bean/@Component+@ComponentScan 方式来注入对象到 Spring 容器中来.\n\n```java\n@Import(ImportBeanConfigMain.ImportConfig.class)\n@ComponentScan(basePackages = \"com.iyang.bean.bd\")\npublic class ImportBeanConfigMain {\n    \n\tpublic ImportBeanConfigMain(){\n        System.out.println(\"ImportBeanConfigMain 无参数构造函数\");\n    }\n\n    \n    public static void main(String[] args) {\n\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();\n        context.register(ImportBeanConfigMain.class);\n        context.refresh();\n\n        ImportConfig importConfig = context.getBean(ImportConfig.class);\n        Person person = context.getBean(Person.class);\n        AnnotConfig annotConfig = context.getBean(AnnotConfig.class);\n        ExternalConfig externalConfig = context.getBean(ExternalConfig.class);\n\n        System.out.println(importConfig);\n        System.out.println(person);\n        System.out.println(annotConfig);\n        System.out.println(externalConfig);\n\n    }\n\n    /**\n     * 通过 @Import 导入进来.\n     */\n    public class ImportConfig{\n\n        public void importMe(){\n            System.out.println(\"这是导入自己的方法\");\n        }\n\n        @Override\n        public String toString() {\n            return \"ImportConfig 的 toString 方法\";\n        }\n\n        public ImportConfig(){\n            System.out.println(\"ImportConfig无参数构造函数\");\n        }\n        /**\n         * 使用 @Bean 注解 注入 Bean 进来.\n         * @return\n         */\n        @Bean\n        public Person importPerson(){\n            return new Person(9527,\"GavinYang\");\n        }\n\n    }\n\n    @Component\n    public static class AnnotConfig{\n\n\n        public AnnotConfig(){\n            System.out.println(\"AnnotConfig无参数构造函数\");\n        }\n\n        @Override\n        public String toString() {\n            return \"使用注解来注入bean进来.\";\n        }\n    }\n\n}\n\n@Component\nclass ExternalConfig {\n\n    public ExternalConfig(){\n        System.out.println(\"externalConfig 无参构造函数\");\n    }\n\n    @Override\n    public String toString() {\n        return \"externalConfig 打印 toString() 方法\";\n    }\n}\n\n\n----------------------------------------------\nImportBeanConfigMain 无参数构造函数    \nexternalConfig 无参构造函数\nAnnotConfig无参数构造函数\nImportConfig无参数构造函数\nperson 有参数构造函数\nImportConfig 的 toString 方法\nPerson{id=9527, name='GavinYang'}\n使用注解来注入bean进来.\nexternalConfig 打印 toString() 方法\n    \n// 这里可以看到new出来的对象打印顺序.\n```\n\n如果是基于创建 bd 的方式的话，是说明下是可以通过这种方式来将我们自己创建的对象给注入到Spring容器中来.我们主要来分析第二种,是做了什么事情.\n\n#### @Import/@Bean/@Component+@ComponentScan 分析\n\n在分析之前，我们看下我们的 beanClass 是怎么先注册到 Spring中来的,也就是在org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionMap和org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionNames中,可以看到一个是Map类型的,一个是集合类型的.\n\n我们把断点打在 org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition 进来的方法上就可以看到,然后看堆栈信息,就可以看到怎么一步一步给添加进来的.\n\n##### 注册 Spring 中来走的方法\n\n这里只用关注我们自己自己定义的，Spring内部的就不需要管了。\n\n**ImportBeanConfigMain**\n\norg.springframework.context.annotation.AnnotatedBeanDefinitionReader#registerBean(java.lang.Class<?>) —-> org.springframework.beans.factory.support.BeanDefinitionReaderUtils#registerBeanDefinition —-> org.springframework.context.support.GenericApplicationContext#registerBeanDefinition\n\n**externalConfig**\n\norg.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors —->\n\norg.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors —–> org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions —-> org.springframework.context.annotation.ConfigurationClassParser#parse(org.springframework.core.type.AnnotationMetadata, java.lang.String) —> org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass —->\n\norg.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan —> org.springframework.context.annotation.ClassPathBeanDefinitionScanner#registerBeanDefinition\n\n**importBeanConfigMain.AnnotConfig**\n\norg.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors —->org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List<org.springframework.beans.factory.config.BeanFactoryPostProcessor>) —-> org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry —-> org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions —> org.springframework.context.annotation.ConfigurationClassParser#parse(org.springframework.core.type.AnnotationMetadata, java.lang.String) —> org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass —> org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan —> org.springframework.context.annotation.ClassPathBeanDefinitionScanner#registerBeanDefinition\n\n**com.iyang.bean.bd.ImportBeanConfigMain$ImportConfig**\n\norg.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors —> org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors —> org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry —-> org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitions —> org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#registerBeanDefinitionForImportedConfigurationClass\n\n**importPerson**\n\norg.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors —> org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors —> org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry —> org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitions —> org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod\n\n可以看到除了 ImportBeanConfigMain 在扫描的时候就被注册到 spring 容器里面来，后面的都是走的 AbstractApplicationContext#invokeBeanFactoryPostProcessors 方法给注册到 Spring 容器中来了. 是不是应该详细分析下 invokeBeanFactoryPostProcessors 方法到了做了什么或者说用了什么,将我们定义的对象给注册到 Spring 容器中来了呢？\n\n##### invokeBeanFactoryPostProcessors 方法解析\n\n从上面来看，这个方法并不是我们想象中那么简单的.\n\norg.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List<org.springframework.beans.factory.config.BeanFactoryPostProcessor>) 委托到这里来进行解析的,所以我们直接深度分析这个方法即可.\n\n上面可以看到都是走的 PostProcessorRegistrationDelegate 这个类,但是我们并没有在这个方法中找到这个类.\n\n```java\npublic static void invokeBeanFactoryPostProcessors(\n      ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {\n\n   // Invoke BeanDefinitionRegistryPostProcessors first, if any.\n   Set<String> processedBeans = new HashSet<>();\n\n   if (beanFactory instanceof BeanDefinitionRegistry) {\n      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;\n      List<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();\n      List<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();\n\n      for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {\n         if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {\n            BeanDefinitionRegistryPostProcessor registryProcessor =\n                  (BeanDefinitionRegistryPostProcessor) postProcessor;\n            registryProcessor.postProcessBeanDefinitionRegistry(registry);\n            registryProcessors.add(registryProcessor);\n         }\n         else {\n            regularPostProcessors.add(postProcessor);\n         }\n      }\n\n      // Do not initialize FactoryBeans here: We need to leave all regular beans\n      // uninitialized to let the bean factory post-processors apply to them!\n      // Separate between BeanDefinitionRegistryPostProcessors that implement\n      // PriorityOrdered, Ordered, and the rest.\n      List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();\n\n      // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.\n      String[] postProcessorNames =\n            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n      for (String ppName : postProcessorNames) {\n         if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n            processedBeans.add(ppName);\n         }\n      }\n      sortPostProcessors(currentRegistryProcessors, beanFactory);\n      registryProcessors.addAll(currentRegistryProcessors);\n// Note : 我们根据 debug 是可以跟进到这里的, 我们直接在这里打上断点,再来仔细看看这个方法做了什么事情.   // currentRegistryProcessors : org.springframework.context.annotation.ConfigurationClassPostProcessor      \n// registry :  DefaultableListFactory \n// 走完这个方法,我们的bean信息都注册到 Spring 的 DefaultLitableFactory中来了.      \n      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n      currentRegistryProcessors.clear();\n\n      // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.\n      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n      for (String ppName : postProcessorNames) {\n         if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {\n            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n            processedBeans.add(ppName);\n         }\n      }\n      sortPostProcessors(currentRegistryProcessors, beanFactory);\n      registryProcessors.addAll(currentRegistryProcessors);\n      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n      currentRegistryProcessors.clear();\n\n      // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.\n      boolean reiterate = true;\n      while (reiterate) {\n         reiterate = false;\n         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n         for (String ppName : postProcessorNames) {\n            if (!processedBeans.contains(ppName)) {\n               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n               processedBeans.add(ppName);\n               reiterate = true;\n            }\n         }\n         sortPostProcessors(currentRegistryProcessors, beanFactory);\n         registryProcessors.addAll(currentRegistryProcessors);\n         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n         currentRegistryProcessors.clear();\n      }\n\n      // Now, invoke the postProcessBeanFactory callback of all processors handled so far.\n      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);\n      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);\n   }\n\n   else {\n      // Invoke factory processors registered with the context instance.\n      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);\n   }\n\n   // Do not initialize FactoryBeans here: We need to leave all regular beans\n   // uninitialized to let the bean factory post-processors apply to them!\n   String[] postProcessorNames =\n         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);\n\n   // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,\n   // Ordered, and the rest.\n   List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();\n   List<String> orderedPostProcessorNames = new ArrayList<>();\n   List<String> nonOrderedPostProcessorNames = new ArrayList<>();\n   for (String ppName : postProcessorNames) {\n      if (processedBeans.contains(ppName)) {\n         // skip - already processed in first phase above\n      }\n      else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));\n      }\n      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n         orderedPostProcessorNames.add(ppName);\n      }\n      else {\n         nonOrderedPostProcessorNames.add(ppName);\n      }\n   }\n\n   // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.\n   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\n   // Next, invoke the BeanFactoryPostProcessors that implement Ordered.\n   List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());\n   for (String postProcessorName : orderedPostProcessorNames) {\n      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n   }\n   sortPostProcessors(orderedPostProcessors, beanFactory);\n   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);\n\n   // Finally, invoke all other BeanFactoryPostProcessors.\n   List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());\n   for (String postProcessorName : nonOrderedPostProcessorNames) {\n      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n   }\n   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);\n\n   // Clear cached merged bean definitions since the post-processors might have\n   // modified the original metadata, e.g. replacing placeholders in values...\n   beanFactory.clearMetadataCache();\n}\n```\n\n###### org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions 方法\n\n```java\n/**\n * Build and validate a configuration model based on the registry of\n * {@link Configuration} classes.\n */\npublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n   List<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n   String[] candidateNames = registry.getBeanDefinitionNames();\n\n   for (String beanName : candidateNames) {\n      BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n      if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) {\n         if (logger.isDebugEnabled()) {\n            logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n         }\n      }\n// 对是否满足配置类进行检查, 这里我们的bean是importBeanConfigMain,满足条件的,具体可以看下面该方法的分析.然后会构建一个 bdHolder,添加到集合中来.\n      else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n         configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n      }\n   }\n\n   // Return immediately if no @Configuration classes were found\n   if (configCandidates.isEmpty()) {\n      return;\n   }\n\n   // Sort by previously determined @Order value, if applicable\n// 这里会根据 @Order 来进行排序下.\n// 从 Integer.compare(i1, i2) 来分析，应该是从小到大的排序,也就是说,越小的话,优先级就约高. \n   configCandidates.sort((bd1, bd2) -> {\n      int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n      int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n      return Integer.compare(i1, i2);\n   });\n\n   // Detect any custom bean name generation strategy supplied through the enclosing application context\n   SingletonBeanRegistry sbr = null;\n   if (registry instanceof SingletonBeanRegistry) {\n// 满足类型条件强转下.       \n      sbr = (SingletonBeanRegistry) registry;\n      if (!this.localBeanNameGeneratorSet) {\n// 这里不包含,所以返回的就是null.\n//org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean)          \n         BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(\n               AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);\n         if (generator != null) {\n            this.componentScanBeanNameGenerator = generator;\n            this.importBeanNameGenerator = generator;\n         }\n      }\n   }\n// 确保environment不是null.\n   if (this.environment == null) {\n      this.environment = new StandardEnvironment();\n   }\n\n   // Parse each @Configuration class\n// 创建一个解析 @Configuration 的对象.\n// 在创建ConfigurationClassParser的这个有参构造函数里面,是可以看到又new了二个对象的,一个是ComponentScanAnnotationParser,一个是ConditionEvaluator.\n// ComponentScanAnnotationParser 这个从名字上看,可以理解为@ComponentScan注解的解析.  \n   ConfigurationClassParser parser = new ConfigurationClassParser(\n         this.metadataReaderFactory, this.problemReporter, this.environment,\n         this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n   Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n   Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n   do {\n// org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass这里走到这里,主要看这个方法中的doProcessConfigurationClass方法.       \n      parser.parse(candidates);\n// 这里对我们上面解析出来的bean进行valiate,如果validate失败的话,那么最后是会抛出一个异常来的.\t       \n      parser.validate();\n\n// 装有我们解析出来的bean信息       \n      Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n// 移除已经解析过了的.       \n      configClasses.removeAll(alreadyParsed);\n\n      // Read the model and create bean definitions based on its content\n//如果this.reader是null的话,就会new一个ConfigurationClassBeanDefinitionReader出来.       \n      if (this.reader == null) {\n         this.reader = new ConfigurationClassBeanDefinitionReader(\n               registry, this.sourceExtractor, this.resourceLoader, this.environment,\n               this.importBeanNameGenerator, parser.getImportRegistry());\n      }\n // 这里对我们获取的 bean 再进行一个 load.      \n      this.reader.loadBeanDefinitions(configClasses);\n// 解析过了的bean放入到 alreadyParsed 中来.       \n      alreadyParsed.addAll(configClasses);\n\n      candidates.clear();\n// 扫描获取出来的bean个数大于 初始化传入进来的个数.       \n      if (registry.getBeanDefinitionCount() > candidateNames.length) {\n        // 获取出新扫描的bean信息.  \n         String[] newCandidateNames = registry.getBeanDefinitionNames();\n        // 旧的bean信息  \n         Set<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n        // 表示已经注册过了的  \n         Set<String> alreadyParsedClasses = new HashSet<>();\n       // 将外面的 alreadyParsed 中的元素的 metadata的className给放入到alreadyParsedClasses集合中来.    \n         for (ConfigurationClass configurationClass : alreadyParsed) {\n            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n         }\n // 对new的集合中元素进行迭代         \n         for (String candidateName : newCandidateNames) {\n       // 老的集合中不包含      \n            if (!oldCandidateNames.contains(candidateName)) {\n               BeanDefinition bd = registry.getBeanDefinition(candidateName);\n                \n       // alreadyParsedClasses 中不包含并且检验出需要配置的,比如有一些@Configuration等特殊注解，这个方法在之前是有提到的.         \n               if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&\n                     !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n           // 满足上面这些条件就会放入到candidates集合中来.         \n                  candidates.add(new BeanDefinitionHolder(bd, candidateName));\n               }\n            }\n         }\n         candidateNames = newCandidateNames;\n      }\n   }\n// candidates 是 empty 就跳出while循环,否则就认为还有bean需要解析.    \n   while (!candidates.isEmpty());\n\n   // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n// org.springframework.context.annotation.ConfigurationClassPostProcessor.importRegistry sbr不包含importRegistry的话,就会注册一个进去.   \n   if (sbr != null && !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n      sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n   }\n\n   if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n      // Clear cache in externally provided MetadataReaderFactory; this is a no-op\n      // for a shared cache since it'll be cleared by the ApplicationContext.\n // 这里是清除缓存,也是清除一些集合.      \n      ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n   }\n}\n```\n\n**走完这个方法,如果是debug模式的话,就可以在 registry(也就是DefaultListableBeanFactory)的 beanDefintionMap和beanDefinitionNames这二个集合中是可以看到我们的bean名字已经bean对应的class信息的.**\n\n###### org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass方法\n\n可以看到这个方法就是对 configuration 类进行处理的.\n\n```java\n/**\n * Apply processing and build a complete {@link ConfigurationClass} by reading the\n * annotations, members and methods from the source class. This method can be called\n * multiple times as relevant sources are discovered.\n * @param configClass the configuration class being build\n * @param sourceClass a source class\n * @return the superclass, or {@code null} if none found or previously processed\n */\n@Nullable\nprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)\n      throws IOException {\n\n// 判断是不是有 @Component 注解.  \n   if (configClass.getMetadata().isAnnotated(Component.class.getName())) {\n      // Recursively process any member (nested) classes first\n      processMemberClasses(configClass, sourceClass);\n   }\n\n   // Process any @PropertySource annotations\n// 接着再处理 @PropertySources 注解. 可以看到这个注解貌似是和 Environment 有关系.   \n   for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n         sourceClass.getMetadata(), PropertySources.class,\n         org.springframework.context.annotation.PropertySource.class)) {\n      if (this.environment instanceof ConfigurableEnvironment) {\n         processPropertySource(propertySource);\n      }\n      else {\n         logger.info(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n               \"]. Reason: Environment must implement ConfigurableEnvironment\");\n      }\n   }\n\n   // Process any @ComponentScan annotations\n// 获取@ComponentScan 注解,我们这里是有的.    \n   Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n         sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n   if (!componentScans.isEmpty() &&\n         !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n      for (AnnotationAttributes componentScan : componentScans) {\n         // The config class is annotated with @ComponentScan -> perform the scan immediately\n          \n// org.springframework.context.annotation.ComponentScanAnnotationParser#parse\n// parse 方法内部是使用 ClassPathBeanDefinitionScanner 扫描器的,对resourcePattern/includeFilters/excludeFilters/lazyInit 是否有进行处理.\n// 获取注解上的属性 basePackages/basePackageClasses的值,添加一个AbstractTypeHierarchyTraversingFilter,这个是ExcludeFilter\n//最后来org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan做扫描操作.\n//doScan做了什么事情呢? 显示通过传入进来的包,调用findCandidateComponents获取出bd的集合来,ScopeMetadata设置也是默认的,用beanNameGenerator生成bean对应的beanName\n//如果bd是AbstractBeanDefinition,再走一下postProcessBeanDefinition方法\n//如果bd是AnnotatedBeanDefinition,会走AnnotationConfigUtils.processCommonDefinitionAnnotations()方法,也是对一些注解的属性进行设置值操作. 走个checkCandidat检查方法,确保bd再registry中不存在的,如果存在的话,那就说明是已经注册过了的.     //如果是不存在的话,就会new一个BeanDefinitionHolder来,然后走registerBeanDefinition给注册到Spring容器中来. 最后返回扫描获取到的bdHolder集合来.     \n         Set<BeanDefinitionHolder> scannedBeanDefinitions =\n               this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n         // Check the set of scanned definitions for any further config classes and parse recursively if needed\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();\n            if (bdCand == null) {\n               bdCand = holder.getBeanDefinition();\n            }\n// 可以看到这里, 我们在最初进入到processConfigBeanDefinitions来的时候,其实就已经是调用了这个方法,那么我们这里扫描获取的bean在此调用这个方法. 也就是确保,扫描获取的bean,也是有一些配置的注解并且也是需要解析的.           \n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {\n// org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass这里最后也是走到这里了.\n// 最初我们是从parse.parse() 进来的,也是走的ConfigurationClassParser#processConfigurationClas,这里又走到了该方法.\n// 也就说我们是调用这个方法,只要满足条件的话,就会一直调用这个方法,直到不满足条件为止.                \n               parse(bdCand.getBeanClassName(), holder.getBeanName());\n            }\n         }\n      }\n   }\n\n   // Process any @Import annotations\n// 这里是对 @Import 注解进行处理. 该方法是有利用 importStack 来控制,\n// 其内部又分为 @ImportSelector/@ImportBeanDefinitionRegistrar/无注解这三种情况.\n// 获取完 bean 信息后,就又走到了org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass方法来.\n// 最后importStack 调用 pop 给数据给弹出来.    \n   processImports(configClass, sourceClass, getImports(sourceClass), true);\n\n   // Process any @ImportResource annotations\n// 对@ImportResource是否有进行判断.    \n   AnnotationAttributes importResource =\n         AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n   if (importResource != null) {\n      String[] resources = importResource.getStringArray(\"locations\");\n      Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n      for (String resource : resources) {\n         String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n         configClass.addImportedResource(resolvedResource, readerClass);\n      }\n   }\n\n   // Process individual @Bean methods\n// @Bean 注解处理.\n//org.springframework.context.annotation.ConfigurationClassParser#retrieveBeanMethodMetadata , \n// 这里对于主入口类进来,是没有这个配置的.    \n   Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n   for (MethodMetadata methodMetadata : beanMethods) {\n      configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n   }\n\n   // Process default methods on interfaces\n// 对接口的进行处理. 这里目前也是没有的.    \n   processInterfaces(configClass, sourceClass);\n\n   // Process superclass, if any\n// 先是判断是不是有父类.    \n   if (sourceClass.getMetadata().hasSuperClass()) {\n// 获取出父类信息       \n      String superclass = sourceClass.getMetadata().getSuperClassName();\n// 父类不是null,不是java开头并且knownSuperclasses中不存在,就满满足条件.       \n      if (superclass != null && !superclass.startsWith(\"java\") &&\n            !this.knownSuperclasses.containsKey(superclass)) {\n         this.knownSuperclasses.put(superclass, configClass);\n         // Superclass found, return its annotation metadata and recurse\n         return sourceClass.getSuperClass();\n      }\n   }\n\n   // No superclass -> processing is complete\n   return null;\n}\n```\n\n**这里可以看到 doProcessConfigurationClass方法,是传入进来主类入口进行解析, 然后没满足一个条件的bean,都会在走一遍解析的方法,直到都走到没满足条件的.**\n\n###### org.springframework.context.annotation.ConfigurationClassUtils#checkConfigurationClassCandidate方法\n\n```java\n/**\n * Check whether the given bean definition is a candidate for a configuration class\n * (or a nested component class declared within a configuration/component class,\n * to be auto-registered as well), and mark it accordingly.\n * @param beanDef the bean definition to check\n * @param metadataReaderFactory the current factory in use by the caller\n * @return whether the candidate qualifies as (any kind of) configuration class\n */\npublic static boolean checkConfigurationClassCandidate(\n      BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) {\n// 先获取 beanName 出来\n   String className = beanDef.getBeanClassName();\n   if (className == null || beanDef.getFactoryMethodName() != null) {\n      return false;\n   }\n\n   AnnotationMetadata metadata;\n// 判断 bd 是不是AnnotatedBeanDefinition 并且 确认 beanName是不是与前面获取出来的classsName是一样的.    \n   if (beanDef instanceof AnnotatedBeanDefinition &&\n         className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) {\n      // Can reuse the pre-parsed metadata from the given BeanDefinition...\n// 获取类上的注解.我们这里获取出来的是 @Import 和 @ComponentScan       \n      metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();\n   }\n   else if (beanDef instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) beanDef).hasBeanClass()) {\n      // Check already loaded Class if present...\n      // since we possibly can't even load the class file for this Class.\n      Class<?> beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();\n      if (BeanFactoryPostProcessor.class.isAssignableFrom(beanClass) ||\n            BeanPostProcessor.class.isAssignableFrom(beanClass) ||\n            AopInfrastructureBean.class.isAssignableFrom(beanClass) ||\n            EventListenerFactory.class.isAssignableFrom(beanClass)) {\n         return false;\n      }\n      metadata = AnnotationMetadata.introspect(beanClass);\n   }\n   else {\n      try {\n         MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);\n         metadata = metadataReader.getAnnotationMetadata();\n      }\n      catch (IOException ex) {\n         if (logger.isDebugEnabled()) {\n            logger.debug(\"Could not find class file for introspecting configuration annotations: \" +\n                  className, ex);\n         }\n         return false;\n      }\n   }\n\n // 获取@Configuration,我们这里没有,所以获取出来的null.   \n   Map<String, Object> config = metadata.getAnnotationAttributes(Configuration.class.getName());\n   if (config != null && !Boolean.FALSE.equals(config.get(\"proxyBeanMethods\"))) {\n      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);\n   }\n// 注意这里的 isConfigurationCandidate方法,org.springframework.context.annotation.ConfigurationClassUtils#isConfigurationCandidate\n// @Component/@ComponentScan/@Import/@ImportResource,只要有其中的一种的话，那么返回的就是true. \n   else if (config != null || isConfigurationCandidate(metadata)) {\n// CONFIGURATION_CLASS_ATTRIBUTE 对应的值是org.springframework.context.annotation.ConfigurationClassPostProcessor.configurationClass       \n      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);\n   }\n   else {\n      return false;\n   }\n\n   // It's a full or lite configuration candidate... Let's determine the order value, if any.\n// 获取 order,如果有的话,就会set进去.    \n   Integer order = getOrder(metadata);\n   if (order != null) {\n      beanDef.setAttribute(ORDER_ATTRIBUTE, order);\n   }\n\n   return true;\n}\n```\n\n**可以看到这个方法最主的就是对一些类上是否有注解进行判断, 如果满足 @Configuration/@Component/@ComponentScan/@Import/@ImportResource,那么返回的就是会true,同时也会set一个CONFIGURATION_CLASS_ATTRIBUTE属性到bd里面来.**\n\n#### getBean方法分析\n\n getBean 不仅仅是获取bean的效果,更是创建bean的，可以看到getBean最后走到了createBean方法来.\n\n org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons : 这里我们直接定位到这个方法,来看下是怎么调用的,调用之前/实例化bean等过程,又做了什么事情？\n\n##### preInstantiateSingletons 方法\n\n```java\n@Override\npublic void preInstantiateSingletons() throws BeansException {\n   if (logger.isTraceEnabled()) {\n      logger.trace(\"Pre-instantiating singletons in \" + this);\n   }\n\n   // Iterate over a copy to allow for init methods which in turn register new bean definitions.\n   // While this may not be part of the regular factory bootstrap, it does otherwise work fine.\n// 从 beanDefinitionNames 中获取出 beanName的集合.\n// 这里获取出来的 beanNameList 不仅仅有Spring内部的,还有我们自己的.    \n   List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);\n\n   // Trigger initialization of all non-lazy singleton beans...\n   for (String beanName : beanNames) {\n      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n// bd不是抽象的,是单列的,不是赖加载的,就进入到这里来.       \n      if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {\n    // 判断是不是 FactoryBean      \n         if (isFactoryBean(beanName)) {\n            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);\n            if (bean instanceof FactoryBean) {\n               final FactoryBean<?> factory = (FactoryBean<?>) bean;\n               boolean isEagerInit;\n               if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {\n                  isEagerInit = AccessController.doPrivileged((PrivilegedAction<Boolean>)\n                              ((SmartFactoryBean<?>) factory)::isEagerInit,\n                        getAccessControlContext());\n               }\n               else {\n                  isEagerInit = (factory instanceof SmartFactoryBean &&\n                        ((SmartFactoryBean<?>) factory).isEagerInit());\n               }\n               if (isEagerInit) {\n                  getBean(beanName);\n               }\n            }\n         }\n         else {\n      // 如果不是 FactroyBean的话,就直接走 getBean方法.       \n            getBean(beanName);\n         }\n      }\n   }\n\n   // Trigger post-initialization callback for all applicable beans...\n// 根据 beanNames 来进行迭代.    \n   for (String beanName : beanNames) {\n   // 根据 beanName 来获取对象.    \n// org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean)       \n      Object singletonInstance = getSingleton(beanName);\n  // 满足是 SmartInitializingSingleton 接口的子类. 最后就都会调用 afterSingletonsInstantiated 方法, 这个也算是bean自身实现SmartInitializingSingleton接口来做的一种扩展.  \n      if (singletonInstance instanceof SmartInitializingSingleton) {\n         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;\n         if (System.getSecurityManager() != null) {\n            AccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n               smartSingleton.afterSingletonsInstantiated();\n               return null;\n            }, getAccessControlContext());\n         }\n         else {\n            smartSingleton.afterSingletonsInstantiated();\n         }\n      }\n   }\n}\n```\n\n可以看到 preInstanitateSingletons方法，根据beanDefinitionNames中注册过的beanName集合,调用getBean方法来创建这个bean. 当创建完所有的bean后,判断是不是有实现 SmartInitializingSingleton 接口的bean,如果有的话, 就会调用这个bean 的afterSingletonsInstantiated方法.\n\n###### doGetBean() 方法\n\n```java\n/**\n * Return an instance, which may be shared or independent, of the specified bean.\n * @param name the name of the bean to retrieve\n * @param requiredType the required type of the bean to retrieve\n * @param args arguments to use when creating a bean instance using explicit arguments\n * (only applied when creating a new instance as opposed to retrieving an existing one)\n * @param typeCheckOnly whether the instance is obtained for a type check,\n * not for actual use\n * @return an instance of the bean\n * @throws BeansException if the bean could not be created\n */\n@SuppressWarnings(\"unchecked\")\nprotected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,\n      @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {\n// 获取beanName\n   final String beanName = transformedBeanName(name);\n   Object bean;\n\n   // Eagerly check singleton cache for manually registered singletons.\n //   这里是判断是不是手动给添加到单例池里面去的.\n   Object sharedInstance = getSingleton(beanName);\n   if (sharedInstance != null && args == null) {\n      if (logger.isTraceEnabled()) {\n         if (isSingletonCurrentlyInCreation(beanName)) {\n            logger.trace(\"Returning eagerly cached instance of singleton bean '\" + beanName +\n                  \"' that is not fully initialized yet - a consequence of a circular reference\");\n         }\n         else {\n            logger.trace(\"Returning cached instance of singleton bean '\" + beanName + \"'\");\n         }\n      }\n// 如果是从单例池里面获取出来的,就走这个方法.    \n      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n   }\n\n   else {\n      // Fail if we're already creating this bean instance:\n      // We're assumably within a circular reference.\n  // 判断这个bean当前是不是已经在注册了,如果是的话,就会抛出异常来.  \n//org.springframework.beans.factory.support.AbstractBeanFactory#prototypesCurrentlyInCreation,利用ThreadLocal来记录值,如果beanName是相同的话就会返回ture,否则就返回flase,这里返回的是false.       \n      if (isPrototypeCurrentlyInCreation(beanName)) {\n         throw new BeanCurrentlyInCreationException(beanName);\n      }\n\n      // Check if bean definition exists in this factory.\n //  org.springframework.beans.factory.support.AbstractBeanFactory#getParentBeanFactory获取父工厂,这里返回的是null,也就是说是没有的.所以下面的if条件也就不会进去.     \n      BeanFactory parentBeanFactory = getParentBeanFactory();\n      if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n         // Not found -> check parent.\n         String nameToLookup = originalBeanName(name);\n         if (parentBeanFactory instanceof AbstractBeanFactory) {\n            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n                  nameToLookup, requiredType, args, typeCheckOnly);\n         }\n         else if (args != null) {\n            // Delegation to parent with explicit args.\n            return (T) parentBeanFactory.getBean(nameToLookup, args);\n         }\n         else if (requiredType != null) {\n            // No args -> delegate to standard getBean method.\n            return parentBeanFactory.getBean(nameToLookup, requiredType);\n         }\n         else {\n            return (T) parentBeanFactory.getBean(nameToLookup);\n         }\n      }\n\n// typeCheckOnly 在此处的值是 false.\n//org.springframework.beans.factory.support.AbstractBeanFactory#alreadyCreated,利用Set集合来标记是否创建,可以看到往alreadyCreated中添加元素进去的时候,还使用了synchronized来加锁判断并且使用了双重if,可以看到我们在接触单例模式的时候，也是有使用  synchronized + 双重if的.      \n      if (!typeCheckOnly) {\n         markBeanAsCreated(beanName);\n      }\n\n      try {\n// 获取出 bd 来,org.springframework.beans.factory.support.AbstractBeanFactory#mergedBeanDefinitions,从这个ConcurrentHashMap中获取出来,也就是说这个mergedBeanDefinitions Map 中,key就是beanName,value就是对应的bd.          \n         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n          \n// 对 bd 进行检查,如果是抽象的话,就会抛出异常来.          \n         checkMergedBeanDefinition(mbd, beanName, args);\n\n         // Guarantee initialization of beans that the current bean depends on.\n // 获取 @DependsOn 注解.并且对 @Depends进行处理.         \n         String[] dependsOn = mbd.getDependsOn();\n         if (dependsOn != null) {\n            for (String dep : dependsOn) {\n               if (isDependent(beanName, dep)) {\n                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        \"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\");\n               }\n               registerDependentBean(dep, beanName);\n               try {\n                  getBean(dep);\n               }\n               catch (NoSuchBeanDefinitionException ex) {\n                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        \"'\" + beanName + \"' depends on missing bean '\" + dep + \"'\", ex);\n               }\n            }\n         }\n\n         // Create bean instance.\n // 确保 bd 是单例的.     \n         if (mbd.isSingleton()) {\n            sharedInstance = getSingleton(beanName, () -> {\n               try {\n                  return createBean(beanName, mbd, args);\n               }\n               catch (BeansException ex) {\n                  // Explicitly remove instance from singleton cache: It might have been put there\n                  // eagerly by the creation process, to allow for circular reference resolution.\n                  // Also remove any beans that received a temporary reference to the bean.\n                  destroySingleton(beanName);\n                  throw ex;\n               }\n            });\n             \n// 获取bean实例             \n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n         }\n// 这里是实例化一个 多列的 bean\n         else if (mbd.isPrototype()) {\n            // It's a prototype -> create a new instance.\n            Object prototypeInstance = null;\n            try {\n               beforePrototypeCreation(beanName);\n               prototypeInstance = createBean(beanName, mbd, args);\n            }\n            finally {\n               afterPrototypeCreation(beanName);\n            }\n            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n         }\n\n         else {\n// 这里操作的,不仅单列也不是多列.\n            String scopeName = mbd.getScope();\n            final Scope scope = this.scopes.get(scopeName);\n            if (scope == null) {\n               throw new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\");\n            }\n            try {\n               Object scopedInstance = scope.get(beanName, () -> {\n                  beforePrototypeCreation(beanName);\n                  try {\n                     return createBean(beanName, mbd, args);\n                  }\n                  finally {\n                     afterPrototypeCreation(beanName);\n                  }\n               });\n               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n            }\n            catch (IllegalStateException ex) {\n               throw new BeanCreationException(beanName,\n                     \"Scope '\" + scopeName + \"' is not active for the current thread; consider \" +\n                     \"defining a scoped proxy for this bean if you intend to refer to it from a singleton\",\n                     ex);\n            }\n         }\n      }\n      catch (BeansException ex) {\n         cleanupAfterBeanCreationFailure(beanName);\n         throw ex;\n      }\n   }\n\n   // Check if required type matches the type of the actual bean instance.\n // 不满足条件,所以没进入到这里.   \n   if (requiredType != null && !requiredType.isInstance(bean)) {\n      try {\n         T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);\n         if (convertedBean == null) {\n            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n         }\n         return convertedBean;\n      }\n      catch (TypeMismatchException ex) {\n         if (logger.isTraceEnabled()) {\n            logger.trace(\"Failed to convert bean '\" + name + \"' to required type '\" +\n                  ClassUtils.getQualifiedName(requiredType) + \"'\", ex);\n         }\n         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n      }\n   }\n\n// 直接返回了 bean 信息.    \n   return (T) bean;\n}\n```\n\ndoGetBean方法 : 可以看到该方法主要是对 bean 分为三种类型来进行初始化 , 分别是 mbd.isSingleton/mbd.isPrototype()/非前二者 这三种情况. 在分这三种情况之前,还对@DependsOn 注解来进行分析,也就说当你初始化这个bean的时候,如果它依赖了一个宁外的bean,就会先去初始化宁外一个bean,也就是调用了 getBean 方法, 而getBean方法就是走的 doGetBean() —> createBean() 也就是走到了自身这里,是一种递归调用.\n\n然后我们这里是单例的,自然就往下走了 createBean 方法.\n\n###### createBean() 方法\n\n从名字来看,还是可以很很闲的感受到,是创建bean的方法.\n\n```java\n/**\n * Central method of this class: creates a bean instance,\n * populates the bean instance, applies post-processors, etc.\n * @see #doCreateBean\n */\n@Override\nprotected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n      throws BeanCreationException {\n\n   if (logger.isTraceEnabled()) {\n      logger.trace(\"Creating instance of bean '\" + beanName + \"'\");\n   }\n   RootBeanDefinition mbdToUse = mbd;\n\n   // Make sure bean class is actually resolved at this point, and\n   // clone the bean definition in case of a dynamically resolved Class\n   // which cannot be stored in the shared merged bean definition.\n// 确定bean的class, 如果bd有beanClass的信息,就会直接返回.    \n   Class<?> resolvedClass = resolveBeanClass(mbd, beanName);\n//如果这里从bd获取出来的class是有值的,然后bd是没有beanCalss,获取出来的beanClassName也是null的话,那么这里就会重新来构建出一个bd,并且设置上 beanClass信息.    \n   if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {\n      mbdToUse = new RootBeanDefinition(mbd);\n      mbdToUse.setBeanClass(resolvedClass);\n   }\n\n   // Prepare method overrides.\n// 准备重写的方法信息,先判断是不是有重写的方法,    \n   try {\n      mbdToUse.prepareMethodOverrides();\n   }\n   catch (BeanDefinitionValidationException ex) {\n      throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),\n            beanName, \"Validation of method overrides failed\", ex);\n   }\n\n   try {\n// 这是 Spring 系统默认的后置处理器,是有六个的.       \n// ApplicationContextAwareProcessor ,  ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor , PostProcessorRegistrationDelegate$BeanPostProcessorCheck , CommonAnnotationBeanPostProcessor ,  AutowiredAnnotationBeanPostProcessor ,  ApplicationListenerDetector ,        \n       \n      // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.\n// Apply before-instantiation post-processors, resolving whether there is a before-instantiation shortcut for the specified bean. 可以看到这里有个应用实例化前的处理器,\n//org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation,可以看到这个方法里面,满足条件的话,会调用applyBeanPostProcessorsBeforeInstantiation() / applyBeanPostProcessorsAfterInitialization() 这二个方法的.\n// 走完 applyBeanPostProcessorsBeforeInstantiation 方法,如果前置处理器能够返回bean回来并且不是null的话,就会继续走applyBeanPostProcessorsAfterInitialization方法.\n// 我们这里返回的 bean 是null,如果不是null的话,就会直接返回的.       \n      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);\n      if (bean != null) {\n         return bean;\n      }\n   }\n   catch (Throwable ex) {\n      throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,\n            \"BeanPostProcessor before instantiation of bean failed\", ex);\n   }\n\n// 上面的前置处理器applyBeanPostProcessorsBeforeInstantiation返回的bean是null的话,就会接着这个下面继续往下走.  于是就有了走 doCreateBean 方法.   \n   try {\n      Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"Finished creating instance of bean '\" + beanName + \"'\");\n      }\n // 返回 bean 对象回去.      \n      return beanInstance;\n   }\n   catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {\n      // A previously detected exception with proper bean creation context already,\n      // or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.\n      throw ex;\n   }\n   catch (Throwable ex) {\n      throw new BeanCreationException(\n            mbdToUse.getResourceDescription(), beanName, \"Unexpected exception during bean creation\", ex);\n   }\n}\n```\n\ncreateBean 方法 : 可以看到createBean在创建之前走了前置处理器,如果前置处理器返回的bean不是null,那么也就没有下面的doCreateBean什么事情了. 如果返回的bean是null的话,那么就会走到下面的doCreateBean方法,可以理解为这个方法才是真正调用反射去获取 bean 对象实例的方法 , 并且其返回值 beanInstance 是直接返回返回去了,也没有做什么其他的处理.\n\n###### doCreateBean() 方法\n\n可以感觉到 doCreateBean 就是真正实例化bean的方法, 是不是Spring 加上了 do 开头的方法,才是真正干活的.\n\n```java\n/**\n * Actually create the specified bean. Pre-creation processing has already happened\n * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks.\n * <p>Differentiates between default bean instantiation, use of a\n * factory method, and autowiring a constructor.\n * @param beanName the name of the bean\n * @param mbd the merged bean definition for the bean\n * @param args explicit arguments to use for constructor or factory method invocation\n * @return a new instance of the bean\n * @throws BeanCreationException if the bean could not be created\n * @see #instantiateBean\n * @see #instantiateUsingFactoryMethod\n * @see #autowireConstructor\n */\nprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)\n      throws BeanCreationException {\n\n   // Instantiate the bean.\n   BeanWrapper instanceWrapper = null;\n// 确定是单例,    \n   if (mbd.isSingleton()) {\n// 从org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#factoryBeanInstanceCache缓存中remove掉.       \n      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n   }\n   if (instanceWrapper == null) {\n // 创建 bean 的实例对象.\n // 先根据 bd 获取出 beanClass,根据beanClass获取出如果是null并且不是public并且无参数构造函数不是public的话,就会抛出一个BeanCreationException异常来. \n// 从bd获取出实例提供者信息,这里获取出来的是Null,所以也就不会往下走.\n// 获取 mbd.getFactoryMethodName() 操作\n// 用变量resolved/autowireNecessary布尔类型的来控制一些流程,  用传入进来的args参数来决定是走无参构造函数还是在有参构造函数,如果args是null的话,就走无参数构造函数.\n// org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#determineConstructorsFromBeanPostProcessors, 该方法是获取出全部的 后置处理器,如果后置处理器是继承了SmartInstantiationAwareBeanPostProcessor的话,就会走到后置处理器的determineCandidateConstructors方法来,  根据 Constructor<?>[] ctors = ibp.determineCandidateConstructors(beanClass, beanName) 可以看到,最后返回的是一个构造方法,可以看到org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#determineCandidateConstructors这个地方来. 这里目测是对@Autowired注解注入的对象进行操作.\n//最后,看到这个方法:org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#instantiateBean   ---->   org.springframework.beans.factory.support.SimpleInstantiationStrategy#instantiate(org.springframework.beans.factory.support.RootBeanDefinition, java.lang.String, org.springframework.beans.factory.BeanFactory) 走到这里, 先判断没有重写的方法,接着判断如果是接口的话,就会抛出异常来,用constructorToUse = clazz.getDeclaredConstructor();获取出构造方法,最后用BeanUtils.instantiateClass(constructorToUse)来实例化对象,可以看到这行代码走完,我们在无参构造函数中的输出语句就可以打印出来了.  将我们实例化出来的对象beanInstance用BeanWrapperImpl包装下,所以这里最后返回的就是   BeanWrapperImpl , 是对我们的目标对象进行一层包装过了的.     \n      instanceWrapper = createBeanInstance(beanName, mbd, args);\n   }\n    \n// 从包装了beanInstance的BeanWrapperImpl中获取出来bean和beanType来,    \n   final Object bean = instanceWrapper.getWrappedInstance();\n   Class<?> beanType = instanceWrapper.getWrappedClass();\n    \n// 赋值beanType给mbd.resolvedTargetType    \n   if (beanType != NullBean.class) {\n      mbd.resolvedTargetType = beanType;\n   }\n\n   // Allow post-processors to modify the merged bean definition.\n   synchronized (mbd.postProcessingLock) {\n      if (!mbd.postProcessed) {\n         try {\n // 这里后走了一个调用后置处理器的方法,是MergedBeanDefinitionPostProcessor接口的子类,就会调用到后置处理器的postProcessMergedBeanDefinition方法.从名字上看,是对bd进行合并的处理操作.\t            \n            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n         }\n         catch (Throwable ex) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                  \"Post-processing of merged bean definition failed\", ex);\n         }\n         mbd.postProcessed = true;\n      }\n   }\n\n   // Eagerly cache singletons to be able to resolve circular references\n   // even when triggered by lifecycle interfaces like BeanFactoryAware.\n//  bd是单例的并且是循环引用的并且单例是创建的,就满足这个条件,这里是处理循环依赖问题?还是用于实现BeanFactoryAware这种来避免循环依赖?    \n   boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\n         isSingletonCurrentlyInCreation(beanName));\n   if (earlySingletonExposure) {\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"Eagerly caching bean '\" + beanName +\n               \"' to allow for resolving potential circular references\");\n      }\n//  添加到 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#registeredSingletons 中来.       \n      addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));\n   }\n\n   // Initialize the bean instance.\n   Object exposedObject = bean;\n   try {\n// 构建bean,这里走了 InstantiationAwareBeanPostProcessor 接口的实现类的后置处理器,如果满足条件就会走处理器的postProcessAfterInstantiation方法,该方法会返回一个布尔类型的值,如果是false的话,就会跳出循环来的.\n// 下面还会走一个InstantiationAwareBeanPostProcessor接口的子类的后置处理器,满足条件就会走后置处理器的postProcessProperties方法,如果获取出来的PropertyValues pvsToUse是null的话,会继续走后置处理器的postProcessPropertyValues方法.       \n      populateBean(beanName, mbd, instanceWrapper);\n//  这里调用每个后置处理器的 postProcessBeforeInitialization 方法,\n// org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#invokeInitMethods 该方法可以看到(InitializingBean) bean).afterPropertiesSet();对于afterPropertiesSet方法还是有点熟悉的.\n//  接着就是调用每个后置处理器的postProcessAfterInitialization方法,       \n      exposedObject = initializeBean(beanName, exposedObject, mbd);\n       \n// 可以看到这二个方法都是在调用后置处理器来进行扩展.       \n   }\n   catch (Throwable ex) {\n      if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {\n         throw (BeanCreationException) ex;\n      }\n      else {\n         throw new BeanCreationException(\n               mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex);\n      }\n   }\n\n //  earlySingletonExposure is true.  \n   if (earlySingletonExposure) {\n// 从单例池中根据 beanName 来获取对象.       \n      Object earlySingletonReference = getSingleton(beanName, false);\n       \n// 获取出来的对象不是null的话,就会进入到这里来.       \n      if (earlySingletonReference != null) {\n         if (exposedObject == bean) {\n            exposedObject = earlySingletonReference;\n         }\n         else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {\n            String[] dependentBeans = getDependentBeans(beanName);\n            Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);\n            for (String dependentBean : dependentBeans) {\n               if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n                  actualDependentBeans.add(dependentBean);\n               }\n            }\n            if (!actualDependentBeans.isEmpty()) {\n               throw new BeanCurrentlyInCreationException(beanName,\n                     \"Bean with name '\" + beanName + \"' has been injected into other beans [\" +\n                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +\n                     \"] in its raw version as part of a circular reference, but has eventually been \" +\n                     \"wrapped. This means that said other beans do not use the final version of the \" +\n                     \"bean. This is often the result of over-eager type matching - consider using \" +\n                     \"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\");\n            }\n         }\n      }\n   }\n\n   // Register bean as disposable.\n   try {\n // 如果有必要的话,注册任意bean信息.      \n      registerDisposableBeanIfNecessary(beanName, bean, mbd);\n   }\n   catch (BeanDefinitionValidationException ex) {\n      throw new BeanCreationException(\n            mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex);\n   }\n\n   return exposedObject;\n}\n```\n\ndoCreateBean() 方法 : 该方法才是正在去走反射来实例化bean的. 并且在实例化这个bean之前和之后,都是有调用许多后置处理器的,也就是这个bean进行一些增强或者其他的处理. 从现在来看,都是Spring内置的处理器.我们后面可以跟着Spring里面的写法,来做相同的扩展处理.\n\n#### 总结\n\n 其实可以看到,我们通过这种方式给我们定义的 bean 给注入到 Spring 容器中, 先是通过我们定义的 @ComponentScan(basePackages = “com.iyang.bean.bd”) 来扫描，然后将扫描得到的信息给添加到Spring的信息池里面,也就是添加到集合中来了. 最后在getBean 方法中, 通过扫描获取到的beanNames集合进行迭代，然后挨个调用getBean()方法来实例化bean, getBean() 方法中又走了 doGetBean () —-> createBean() —> doCreateBean() 方法， 然后每个方法有各自要做的事情，并且也会走相应的后置处理器.\n\n 最后，这是一个比较详细的getBean分析，但是还有更深入的 , 比如 : @Autowired / @DependsOn / 循环依赖等注入，需要扩展来讲.\n","tags":["java","spring"],"categories":["java","spring"]},{"title":"LinkedList源码阅读记录","url":"/2021/11/04/java/LinkedList源码阅读记录/","content":"\n\n\n虽然一般都是使用ArrayList集合比使用LinkedList集合要多,但是这并不妨碍我们对LinkedList的源码研究和学习\n\n### 结构\n\nLinkedList 是一个双向链表的结构,这点可以直接看其内部内就可以非常明显的看出来. 静态私有的内部类,只提供一个构造函数.\n\n```\nprivate static class Node<E> {\n    E item;\n    Node<E> next;\n    Node<E> prev;\n\n    Node(Node<E> prev, E element, Node<E> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n\n然后我们看 LinkedList 自身的变量. size 肯定是记录这个链表的长度,不然到时候node.next.next….获取长度就很得不偿失了. 然后记录了一个头节点和尾节点，个人认为这是方便遍历。从头开始遍历就从first节点获取,从尾部开始遍历的话,就从last开始获取.\n\n```\ntransient int size = 0;\n\n/**\n * Pointer to first node.\n * Invariant: (first == null && last == null) ||\n *            (first.prev == null && first.item != null)\n */\ntransient Node<E> first;\n\n/**\n * Pointer to last node.\n * Invariant: (first == null && last == null) ||\n *            (last.next == null && last.item != null)\n */\ntransient Node<E> last;\n```\n\n------\n\n### 方法\n\n- add 方法\n\n  add方法调用一个linkLast方法,然后就返回true了. 也就是说add(E e)就是默认从尾部开始插入元素进去.\n\n  ```\n  public boolean add(E e) {\n      linkLast(e);\n      return true;\n  }\n  \n      /**\n       * Links e as last element.\n         翻译 : 链接e作为最后一个元素。\n         先对last赋值给 Node<E> l , 然后调用new Node<>(l,e,null);传入进去的上个节点,也就是l,上次保存的尾部节点,也就是从倒数第一变为了倒数二,这样理解。然后此时的newNode就是尾节点了,然后赋值给last,因为last每次记录的都是尾节点.\n         if else 中是对之前的尾节点进行判断,如果是null的话,说明此时就是添加的第一个元素,first也赋值给newNode,否则的话,l.next 和 尾节点进行关联。\n         size 长度加一\n       */\n  void linkLast(E e) {\n          final Node<E> l = last;\n          final Node<E> newNode = new Node<>(l, e, null);\n          last = newNode;\n          if (l == null)\n              first = newNode;\n          else\n              l.next = newNode;\n          size++;\n          modCount++;\n      }\n  ```\n\n根据下标添加 add(int index,E element)\n\n```\n/**\n\t1: 检查传入进来的下标是否越界了,如果下标越界的话,就会抛出 下标越界的异常\n\t2: 根据传入进来的下标值,判断是否和 size 相等,如果是相等的话,就说明是尾部插入,就不需要挨个迭代去获取对应的下标值对应的节点.满足条件,就会调用上面说到的 linkLast方法\n\t3: 不满足条件2的话,就会走lineBefore()方法,其中也调用到了.传入下标调用node方法.node会返回对应下标的值,根据返回的节点和当前的值调用lienkBefore方法.\n*/\npublic void add(int index, E element) {\n    checkPositionIndex(index);\n\n    if (index == size)\n        linkLast(element);\n    else\n        linkBefore(element, node(index));\n}\n\nprivate void checkPositionIndex(int index) {\n        if (!isPositionIndex(index))\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\n\n private boolean isPositionIndex(int index) {\n        return index >= 0 && index <= size;\n}\n\n/**\n\tsize >> 1 ; 是对 size 进行去半, 比如 6 >> 1 是 3， 5 >> 1 是2\n\t如果小于一半的话,就会从first节点开始遍历,也就是从头节点开始遍历,否则就是从尾节点开始遍历.\n\t这个方法可以看到,从头开始遍历的话,就是调用的next,如果尾部遍历的话,调用的就是prev。找到对应下标的节点并且返回回去.\n*/\nNode<E> node(int index) {\n        // assert isElementIndex(index);\n\n        if (index < (size >> 1)) {\n            Node<E> x = first;\n            for (int i = 0; i < index; i++)\n                x = x.next;\n            return x;\n        } else {\n            Node<E> x = last;\n            for (int i = size - 1; i > index; i--)\n                x = x.prev;\n            return x;\n        }\n}\n\n/**\n\t获取节点的上个节点赋值给pred，其实类似于pred这种,都是用于变量替换创建出来的.\n\t上一个节点,当前值e,succ节点来new一个新的节点出来.\n\tsucc.prev 指向当前new出来的节点\n\t对pred判断是否是null,如果是null的话,就说明是第一个值,否则就是赋值上pred个节点的next\n\t,size ++ 就是对长度 ++ \n*/\nvoid linkBefore(E e, Node<E> succ) {\n        // assert succ != null;\n        final Node<E> pred = succ.prev;\n        final Node<E> newNode = new Node<>(pred, e, succ);\n        succ.prev = newNode;\n        if (pred == null)\n            first = newNode;\n        else\n            pred.next = newNode;\n        size++;\n        modCount++;\n    }\n```\n\n头插入 和 尾插入\n\n头插入，将值插入到头部\n\n```\npublic void addFirst(E e) {\n    linkFirst(e);\n}\n\n/**\n\t先将first 赋值给 f ,  根据传入进来的值e 和 下一个节点f(前一个头节点),new一个新的newNode节点出来,first指向newNode.如果f是null的话就说明是初始化,如果不是null的话,f的上一个节点指向newNode,刚刚程序newNode出来的.就完成了头节点的插入\n*/\nprivate void linkFirst(E e) {\n        final Node<E> f = first;\n        final Node<E> newNode = new Node<>(null, e, f);\n        first = newNode;\n        if (f == null)\n            last = newNode;\n        else\n            f.prev = newNode;\n        size++;\n        modCount++;\n    }\n```\n\n尾节点插入;与头节点相似，也是利用变量last来实现尾部插入.\n\n```\npublic void addLast(E e) {\n    linkLast(e);\n}\n\nvoid linkLast(E e) {\n        final Node<E> l = last;\n        final Node<E> newNode = new Node<>(l, e, null);\n        last = newNode;\n        if (l == null)\n            first = newNode;\n        else\n            l.next = newNode;\n        size++;\n        modCount++;\n    }\n```\n\n- get 方法,获取值方法\n\n  根据下标来获取出值 ,然后调用node方法获取出节点,node.item就是我们需要的值,然后对其进行返回即可.\n\n  ```\n  public E get(int index) {\n      checkElementIndex(index);\n      return node(index).item;\n  }\n  \n  // 如果输入index是小于0和大于size的话,就会爆出下标越界的错误.\n  private void checkElementIndex(int index) {\n          if (!isElementIndex(index))\n              throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n  }\n  ```\n\n\n\ngetFirst / getLast 可以看到first和 last都是直接从定义的变量中获取出对应的值\n\n```\npublic E getFirst() {\n    final Node<E> f = first;\n    if (f == null)\n        throw new NoSuchElementException();\n    return f.item;\n}\n\n    public E getLast() {\n        final Node<E> l = last;\n        if (l == null)\n            throw new NoSuchElementException();\n        return l.item;\n    }\n```\n\n peek 方法;使用first节点,如果是null的话就会返回null，否则就是f.item. 这里是没有删除first元素,poll是弹出元素并且删除.\n\n```\npublic E peek() {\n    final Node<E> f = first;\n    return (f == null) ? null : f.item;\n}\n```\n\n poll 方法 : 这里主要看unlinkFirst方法.\n\n```java\npublic E poll() {\n    final Node<E> f = first;\n    return (f == null) ? null : unlinkFirst(f);\n}\n\n/**\n   取出 f 的item,节点对应的值和 f的next个节点,如果下个节点是null的话,就说明是没有值的,如果不为null的话，说将next的上一个节点prev指向null,因为头节点的prev和尾节点的next都是null来进行区分。\n*/\nprivate E unlinkFirst(Node<E> f) {\n        // assert f == first && f != null;\n        final E element = f.item;\n        final Node<E> next = f.next;\n        f.item = null;\n        f.next = null; // help GC\n        first = next;\n        if (next == null)\n            last = null;\n        else\n            next.prev = null;\n        size--;\n        modCount++;\n        return element;\n    }\n```\n\n offer 等方法都是内部调用了add / addFirst / addLast等方法.\n\n- remove 方法\n\n  根据下标进来remove方法, node(index) 也是在上面进行讲到的,就是根据下标获取对应的node节点信息.\n\n  ```java\n  public E remove(int index) {\n      checkElementIndex(index);\n      return unlink(node(index));\n  }\n  \n  /**\n  \t这里获取出节点的 next 和 prev方法.\n  \t该节点的上一个节点(prev)的next需要指向指向该节点的下个节点(next),该节点的下一个节点和prev的操作是相反的,因为这样的话,就删除了该节点,并且上一个节点和下一个节点关联起来了.\t\n  */\n   E unlink(Node<E> x) {\n          // assert x != null;\n          final E element = x.item;\n          final Node<E> next = x.next;\n          final Node<E> prev = x.prev;\n  \n          if (prev == null) {\n              first = next;\n          } else {\n              prev.next = next;\n              x.prev = null;\n          }\n  \n          if (next == null) {\n              last = prev;\n          } else {\n              next.prev = prev;\n              x.next = null;\n          }\n  \n          x.item = null;\n          size--;\n          modCount++;\n          return element;\n  }\n  ```\n\nremove(Object o) 根据值来进行删除.这个可以看出来，如果有二个相同节点的值,调用一次这个方法是只可以删除一个,而不是二个.\n\n```java\npublic boolean remove(Object o) {\n    if (o == null) {\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (x.item == null) {\n                unlink(x);\n                return true;\n            }\n        }\n    } else {\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (o.equals(x.item)) {\n                unlink(x);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\n------\n\n### 总结\n\n好啦,今天的知识内容就更新到这里,虽然文字描述到很难理解,但是主要去理解 Node 节点的 双向指向,并且每次添加节点和删除添加，都是靠Node的prev和next来进行指向. 所以说LinkedList是删除快，查询慢的原因。\n","tags":["java","java集合"],"categories":["java","java集合"]},{"title":"HashMap源码阅读记录","url":"/2021/11/04/java/HashMap源码阅读记录/","content":"\nHashMap 这种Key,Value 的存储结构,是我们在写代码中经常使用到的.可以说使用是非常频繁的,不过现在使用JSONObject也是非常多的,二者都是实现了Map接口。\n\n所以看下HashMap源码是非常有必要的.\n\n------\n\n#### 结构\n\n这里我们要看下 HashMap的内部类.\n\n这里的 Node 节点就是 HashMap存放数据的结构. hash 计算出来的哈希值,key就是HashMap中的key,value就是key对应的value的值. 这个 next 就是 key 不一样,计算出来的hash却是一样的,这样就有了hash冲突,所以就将节点存放在next里面了,从尾部插入进去. java8 后,如果next的长度是大于8的话,就会转化了红黑树来存储,那样获取值的速度变快了。\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;\n    final K key;\n    V value;\n    Node<K,V> next;\n\n    Node(int hash, K key, V value, Node<K,V> next) {\n        this.hash = hash;\n        this.key = key;\n        this.value = value;\n        this.next = next;\n    }\n\n    public final K getKey()        { return key; }\n    public final V getValue()      { return value; }\n    public final String toString() { return key + \"=\" + value; }\n\n    public final int hashCode() {\n        return Objects.hashCode(key) ^ Objects.hashCode(value);\n    }\n\n    public final V setValue(V newValue) {\n        V oldValue = value;\n        value = newValue;\n        return oldValue;\n    }\n\n    public final boolean equals(Object o) {\n        if (o == this)\n            return true;\n        if (o instanceof Map.Entry) {\n            Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n            if (Objects.equals(key, e.getKey()) &&\n                Objects.equals(value, e.getValue()))\n                return true;\n        }\n        return false;\n    }\n}\n```\n\nTreeNode 这个内部类就是表示红黑树的. TODO 后续进行更新.\n\n参数, 可以看到 HashMap 是使用了一个数组来进行存储 Node节点.\n\n```java\ntransient Node<K,V>[] table;\n\n\ntransient int size;\n\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n\nstatic final int MAXIMUM_CAPACITY = 1 << 30;\n\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n```\n\n------\n\n#### 方法\n\n 构造函数\n\n\n\n```java\n/**\n * Constructs an empty <tt>HashMap</tt> with the default initial capacity\n * (16) and the default load factor (0.75).\n \t当使用无参构造函数的时候,只是对 loadFactor 进行了赋值操作\n */\npublic HashMap() {\n    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted\n}\n\n// 传递一个int类型的参数时候,就会计息往下调用构造函数\npublic HashMap(int initialCapacity) {\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n}\n\n/**\n\t对值进行判断,怕你可能传入进来一个负数来测试玩玩哈哈哈。\n\t最后调用到了tableSizeFor方法,可以看到这个方法是对传入进来的参数,进行一连串的位运算.\n*/\npublic HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        this.threshold = tableSizeFor(initialCapacity);\n}\n\nstatic final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n}\n\n// 传入 Map 的实现类的话,就是往下继续调用 putMapEntries方法\npublic HashMap(Map<? extends K, ? extends V> m) {\n        this.loadFactor = DEFAULT_LOAD_FACTOR;\n        putMapEntries(m, false);\n}\n\n/**\n\t传入 m.size()的长度,长度大于0就会走逻辑代码.最后可以看到 迭代了m,然后调用putVal来将值放入Map中\n*/\nfinal void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {\n        int s = m.size();\n        if (s > 0) {\n            if (table == null) { // pre-size\n                float ft = ((float)s / loadFactor) + 1.0F;\n                int t = ((ft < (float)MAXIMUM_CAPACITY) ?\n                         (int)ft : MAXIMUM_CAPACITY);\n                if (t > threshold)\n                    threshold = tableSizeFor(t);\n            }\n            else if (s > threshold)\n                resize();\n            for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n                K key = e.getKey();\n                V value = e.getValue();\n                putVal(hash(key), key, value, false, evict);\n            }\n        }\n}\n```\n\nput 添加方法\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\n// 根据传入进来的key来计算对应的hash值\nstatic final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n\n/**\n\tputVal 就是 \n*/\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        // 定义一些变量\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n    \t// table 赋值给 tab 并判断是否等于null 或者 tab的长度是否等于0,如果是的话，就会调用resize来进行扩容\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n    \n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node<K,V> e; K k;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else {\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n}\n\n/**\n\t扩容方法\n\ttable使用 oldTab来进行存储,拿出oldTab的长度(如果oldTab是null的话,对应的长度就是为0).\n\toldThr 是 记录 threshold 之前的值, newCap / newThr就是需要扩容使用到的变量命名.\n\t这里分为 \n\t1 : oldCap 是大于0的。 如果比 MAXIMUM_CAPACITY 还是要大的话,就说明里面存储的元素是太多了,就直接返回oldTab.  还有一种就是 newCap等于oldCap的1.5倍并且小于MAXIMUM_CAPACITY和oldCap是大于默认16的,就会进行1.5倍的扩容\n\t2 : oldThr 大于 0, newCap(扩容新长度) 就是等于 oldThe的值.\n\t3 : 否则就是都使用默认的值大小\n*/\nfinal Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap > 0) {\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr << 1; // double threshold\n        }\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        else {               // zero initial threshold signifies using defaults\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;\n    \t\n    \t/**\n    \t使用扩容后的newCap来创建一个数组,oldTab不是null,然后就需要将老的值赋值到新的newTab里面来.\n        使用下标来进行迭代,获取每个下标的Node节点的值,然oldTab[j]赋值给e后,然后将oldTab[j]重置为null.\n        这里面的进行Node复制是有分为下面几种, Node的next节点是没有值得,next下面是由值,e节点转化为了红黑树.\n        1 : 如果e.next是null,也就是没有值,newTab[e.hash & (newCap - 1)] = e来赋值.\n        2 : 如果e是TreeNode的话,就会调用((TreeNode<K,V>)e).split(this, newTab, j, oldCap)方法.\n        3 : 然后可以看到 do while 循环里面, while 里面的条件是 e.next != null 才会进去,也就是next是由值得情况下才会进入到这里面来.然后可以看到一些系取节点啊,赋值给变量啊,然后赋值给新创建的Node数组下标然后将之前的node节点重置为null。 这里就需要读者对这些代码来慢慢消化了.仔细想看,就是对node节点的取值,赋值,重置等操作.\n    \t*/\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        table = newTab;\n        if (oldTab != null) {\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // preserve order\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n}\n```\n\nget 方法,是通过key来获取出对应的value.\n\n```java\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\n// 传入key来计算出哈希值\nstatic final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n\n/**\n\t如果 table不是Null,并且长度是大于0的,能够根据 (n-1) & hash 得出来的下标是在tab里面能获取到值得,才会进入逻辑代码,否则就是返回null.\n\t如果first的hash是于传入进来的hash相同,斌且给key的值也是相同的话,就会返回first节点.\n\t拿node的next节点,如果是TreeNode的类,就会走TreeNode对应的getTreeNode方法(链表的长度大于8就会转化为红黑树). 否则的话就就迭代这个Node,退出的条件就是 e.next == null,就说说明下面没有对应的节点了。\n\t这里拿值得逻辑,还是比较容易理解得。 先根据计算出来得hash值,去数组中是否可以获取到对应得值,如果有就先会对first进行判断,是否满足条件.如果不满足的话,就说明这个key的hash是由冲突的,也就是由二个不同的值,计算出来相同的hash值,这个时候就会用链表(Node)来进行存储,如果长度是大于8的话,就会转化为TreeNode的红黑树.\n*/\nfinal Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {\n            if (first.hash == hash && // always check first node\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                return first;\n            if ((e = first.next) != null) {\n                if (first instanceof TreeNode)\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n}\n```\n\nisEmpty 方法,这里就直接使用 size == 0 来进行判断,如果你的map是null的话,直接调用这个方法就会出现空指针.\n\n```java\npublic boolean isEmpty() {\n    return size == 0;\n}\n```\n\n------\n\n#### 总结\n\n 这里只是选用了 put 和 get方法来进行讲解,因为这二个是经常调用的,所以得明白是一个怎么样得大体流程走向才行.\n","tags":["java","java集合"],"categories":["java","java集合"]},{"title":"ArrayList源码阅读记录","url":"/2021/11/04/java/ArrayList源码阅读记录/","content":"\n\n\nArrayList 是代码中使用非常频繁的,所以看底层的代码时非常有必须的.\n\n### 结构\n\n ArrayList 是一个由 Object [] 的数组来实现的\n\n transient Object[] elementData ,这个变量就是存放数据的.\n\n 长度是用 int size 这个变量来记录的,而不是直接调用的 数组的长度获取的.\n\n\n\n 如果ArrayList list = new ArrayList(); 只是仅仅new一个集合的话,数组的大小是没有初始化为10的,而是在add()中,进行判断。 如果数组的是为空的数组的话,就会使用 **DEFAULT_CAPACITY** 来进行初始化。也就是要调用add方法才行。\n\n```\nif (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n    return Math.max(DEFAULT_CAPACITY, minCapacity);\n}\n```\n\n### 方法\n\n- 先来介绍add()方法 , 上代码\n\n  add 里面是走了三个方法, size 没有赋值的情况下,就是0.\n\n  ```\n  public boolean add(E e) {\n      ensureCapacityInternal(size + 1);  // Increments modCount!!\n      elementData[size++] = e;\n      return true;\n  }\n  \n  // 确认容量 , 打个比方我们没有对size进行赋值,那么size + 1 传入到这个里面的值也就是1,那么 elementData 对应的也就是一个空数组\n  private void ensureCapacityInternal(int minCapacity) {\n       ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n  }\n  \n  //  满足是空数组的话,就会使用默认的值 10 于 minCapcacity 来进行对比,这里返回的10\n  private static int calculateCapacity(Object[] elementData, int minCapacity) {\n          if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n              return Math.max(DEFAULT_CAPACITY, minCapacity);\n          }\n          return minCapacity;\n      }\n  \n  //  如果 minCapacity  减去 数组的长度是大于0的,就会调用grow来进行扩容\n  private void ensureExplicitCapacity(int minCapacity) {\n          modCount++;\n  \n          // overflow-conscious code\n          if (minCapacity - elementData.length > 0)\n              grow(minCapacity);\n   }\n  \n  // 这里可以看到先对数组的值进行,然后对保存出来的值进行1.5倍扩容,与传入进来的值进行对比,满足条件赋值.这里就要看到 Arrays.copyOf(elementDate,newCapacity); 这才是真正的对数组进行扩容的方法,也就是直接调用Arrays的API. Arrays.copyOf() 里面最后也是调用了 System.arraycopy()的方法\n  private void grow(int minCapacity) {\n          // overflow-conscious code\n          int oldCapacity = elementData.length;\n          int newCapacity = oldCapacity + (oldCapacity >> 1);\n          if (newCapacity - minCapacity < 0)\n              newCapacity = minCapacity;\n          if (newCapacity - MAX_ARRAY_SIZE > 0)\n              newCapacity = hugeCapacity(minCapacity);\n          // minCapacity is usually close to size, so this is a win:\n          elementData = Arrays.copyOf(elementData, newCapacity);\n      }\n  到这里 ensureCapacityInternal 方法也就是走完了\n  ---------------------------------------------\n  后面就是使用 数组下标来进行赋值并且返回true。\n  ```\n\n\n\n\n\n- 根据下标来添加\n\n  ```\n  public void add(int index, E element) {\n      rangeCheckForAdd(index);\n  \n      ensureCapacityInternal(size + 1);  // Increments modCount!!\n      System.arraycopy(elementData, index, elementData, index + 1,\n                       size - index);\n      elementData[index] = element;\n      size++;\n  }\n  \n  // 检查下标是否越界 , ensureCapacityInternal 方法和上面一样\n  private void rangeCheckForAdd(int index) {\n          if (index > size || index < 0)\n              throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n  }\n  \n  \n  //  System.arraycopy() 从 elementDate 的 index处开始复制, 复制给后面的elementDate数组的值,从index + 1 开始复制,也就是说 index 相当于修改了 index + 1, 然后index位置就是没有值了,所以elementDate[index] = element的值,size ++.\n  ```\n\n- set方法 : 也就是根据下标来对久的值进行一种替换,取出对应下标的值,然后下标对应的位置赋值给新值,最后返回旧值回去即可\n\n  ```\n  // 先检查下标是否越界,如果越界就会抛出异常\n  public E set(int index, E element) {\n      rangeCheck(index);\n  \n      E oldValue = elementData(index);\n      elementData[index] = element;\n      return oldValue;\n  }\n  \n  // 取出对应下标的值\n      @SuppressWarnings(\"unchecked\")\n      E elementData(int index) {\n          return (E) elementData[index];\n      }\n  ```\n\n- remove\n\n  根据传入进来的值进行删除,\n\n  ```\n  // 分为 null 和 不是 null 的情况来进行删除.满足条件的话,最后都会调用到 fastRemove方法中来\n  public boolean remove(Object o) {\n      if (o == null) {\n          for (int index = 0; index < size; index++)\n              if (elementData[index] == null) {\n                  fastRemove(index);\n                  return true;\n              }\n      } else {\n          for (int index = 0; index < size; index++)\n              if (o.equals(elementData[index])) {\n                  fastRemove(index);\n                  return true;\n              }\n      }\n      return false;\n  }\n  \n  //  根据传入进来的 下标来删除数据,System.arraycopy 这个方法并不默认,根据下标的位置来进行复制数组。\n  //  可以看到最后有一个 将值设置为null的操作,从注释上看是help GC, 帮助GC\n  private void fastRemove(int index) {\n          modCount++;\n          int numMoved = size - index - 1;\n          if (numMoved > 0)\n              System.arraycopy(elementData, index+1, elementData, index,\n                               numMoved);\n          elementData[--size] = null; // clear to let GC do its work\n      }\n  ```\n\n- 根据下标删除\n\n  可以看到根据下标删除的话，会先判断传入进来的下标是否满足条件,就是没有出现越界的情况.\n\n  然后取出旧值,接下来的代码就是非常的熟悉了,就是fastRemove() 里面的代码了\n\n  ```\n  public E remove(int index) {\n      rangeCheck(index);\n    \n      modCount++;\n      E oldValue = elementData(index);\n    \n      int numMoved = size - index - 1;\n      if (numMoved > 0)\n          System.arraycopy(elementData, index+1, elementData, index,\n                           numMoved);\n      elementData[--size] = null; // clear to let GC do its work\n    \n      return oldValue;\n  }\n  ```\n\n------\n\n### 总结\n\n大致就是看 ArrayList 是如何添加数据的,对数据是怎么保存的,是如何删除数据的,是怎么样进行扩容的,大致弄明白这些就是对ArrayList有一个大致的了解\n","tags":["java","java集合"],"categories":["java","java集合"]},{"title":"ArrayDeque源码阅读记录","url":"/2021/11/04/java/ArrayDeque源码阅读记录/","content":"\nArrayDeque 在我目前做的项目中,使用是比较少的,基本都没有地方用到。可能是我太low了,也可能是业务没有一定要用到队列的情况. 但是这不影响我们对其进行源码阅读。\n\n### 结构\n\n结构还是可以看到, 使用一个Object的数组, 二个int类型的变量来记录头和尾(从单词的意思)\n\n```\ntransient Object[] elements; // non-private to simplify nested class access\n\ntransient int head;\n\ntransient int tail;\n```\n\n### 方法\n\n- 构造函数\n\n  无参构造函数. 可以看到无参构造函数,默认是对数据进行初始化大小为16的操作.\n\n  ```\n  public ArrayDeque() {\n      elements = new Object[16];\n  }\n  ```\n\n  \n\n  有参构造函数\n\n  ```\n  /**传递int类型的构造函数,最后是调用到了calculateSize方法返回值来初始化数组大小 */\n  public ArrayDeque(int numElements) {\n      allocateElements(numElements);\n  }\n  \n  private void allocateElements(int numElements) {\n          elements = new Object[calculateSize(numElements)];\n  }\n  \n  /** 获取变量MIN_INITIAL_CAPACITY的值,如果传入进来的值是大于这个值,就会进行下面的运算操作,然后返回这个值出去.   */\n  private static int calculateSize(int numElements) {\n          int initialCapacity = MIN_INITIAL_CAPACITY;\n          // Find the best power of two to hold elements.\n          // Tests \"<=\" because arrays aren't kept full.\n          if (numElements >= initialCapacity) {\n              initialCapacity = numElements;\n              initialCapacity |= (initialCapacity >>>  1);\n              initialCapacity |= (initialCapacity >>>  2);\n              initialCapacity |= (initialCapacity >>>  4);\n              initialCapacity |= (initialCapacity >>>  8);\n              initialCapacity |= (initialCapacity >>> 16);\n              initialCapacity++;\n  \n              if (initialCapacity < 0)   // Too many elements, must back off\n                  initialCapacity >>>= 1;// Good luck allocating 2 ^ 30 elements\n          }\n          return initialCapacity;\n  }\n  \n  \n  \n  /**\n     传递集合的构造函数\n     使用传递进来的集合的长度来初始化数组的长度.\n     然后调用addAll方法,这里说明下 addAll 是在其 AbstractCollection 里面,也就是子类调用父类的方法.然后add方法是在ArrayDeque里面调用\n  */\n  public ArrayDeque(Collection<? extends E> c) {\n          allocateElements(c.size());\n          addAll(c);\n  }\n  \n  \n  private void allocateElements(int numElements) {\n          elements = new Object[calculateSize(numElements)];\n  }\n  \n  /** 这里可以看到,定义给变量,迭代集合c,依次调用add方法,如果add方法返回的是true,变量modified就会变为true.最后addAll就会返回变量modified回去. */\n  public boolean addAll(Collection<? extends E> c) {\n          boolean modified = false;\n          for (E e : c)\n              if (add(e))\n                  modified = true;\n          return modified;\n  }\n  \n  // 往下调用\n  public boolean add(E e) {\n          addLast(e);\n          return true;\n  }\n  \n  /**\n  \t这里的值是不能传入null进来的,否则的话就会报NPE的异常.\n  \t然后使用下标tail直接插入到最后,if 里面是对 tail 的值进行新赋值操作,如果满足条件就会调用doubleCapacity方法,目测这个方法就是进行扩容的方法.\n  \t这里就是看下  (tail = (tail + 1) & (elements.length - 1)) 这个赋值操作,就是给tail进行新的赋值。\n  */\n  public void addLast(E e) {\n          if (e == null)\n              throw new NullPointerException();\n          elements[tail] = e;\n          if ( (tail = (tail + 1) & (elements.length - 1)) == head)\n              doubleCapacity();\n  }\n  ```\n\n- 添加方法\n\n  add(E e) 这里添加调用的方法,我们主要看下 doubleCapacity 这个方法\n\n  ```\n  public boolean add(E e) {\n      addLast(e);\n      return true;\n  }\n  \n  public void addLast(E e) {\n          if (e == null)\n              throw new NullPointerException();\n          elements[tail] = e;\n          if ( (tail = (tail + 1) & (elements.length - 1)) == head)\n              doubleCapacity();\n  }\n  \n  /**\n  \t这里对 head / elements的长度都进行值存储操作, 一 是便于后面使用System.arraycopy 来进行copy数组的值,好从对应下标开始复制值. 二是 head /  tail 等赋值.\n  \t可以看到扩容后的的大小,来new了一个新的数组,后面调用System.arraycopy来进行复制.\n  */\n  private void doubleCapacity() {\n          assert head == tail;\n          int p = head;\n          int n = elements.length;\n          int r = n - p; // number of elements to the right of p\n          int newCapacity = n << 1;\n          if (newCapacity < 0)\n              throw new IllegalStateException(\"Sorry, deque too big\");\n          Object[] a = new Object[newCapacity];\n          System.arraycopy(elements, p, a, 0, r);\n          System.arraycopy(elements, 0, a, r, p);\n          elements = a;\n          head = 0;\n          tail = n;\n  }\n  ```\n\n  \n\n  addFirst 从头部插入 , 可以看到 使用 head = (head - 1) & (elements.length - 1) 是计算出头部下标的位置,并且对值进行覆盖. 如果 head 与 tail 是相等的话,就会调用 doubleCapacity来进行扩容\n\n  ```\n  public void addFirst(E e) {\n      if (e == null)\n          throw new NullPointerException();\n      elements[head = (head - 1) & (elements.length - 1)] = e;\n      if (head == tail)\n          doubleCapacity();\n  }\n  ```\n\naddLast 尾部插入, 这个方法上面都是有提到的。\n\n```\npublic void addLast(E e) {\n    if (e == null)\n        throw new NullPointerException();\n    elements[tail] = e;\n    if ( (tail = (tail + 1) & (elements.length - 1)) == head)\n        doubleCapacity();\n}\n```\n\n\n\n```\nofferLast / offerFirst  内部都是分别调用到了 addLast / addFirst 方法\n```\n\n push 方法也是调用的 addFirst 方法\n\n- get 获取值方法\n\n  getFirst / getLast 方法\n\n  ```\n  /** 从head对应的数组中直接获取出值,如果值是null的话,就会抛出一个异常,否则就会返回*/\n  public E getFirst() {\n      @SuppressWarnings(\"unchecked\")\n      E result = (E) elements[head];\n      if (result == null)\n          throw new NoSuchElementException();\n      return result;\n  }\n  \n  /**\n  \t(tail - 1) & (elements.length - 1) 得出尾部元素的下标位置,然后用数组下标返回对应的值.\n  */\n  public E getLast() {\n          @SuppressWarnings(\"unchecked\")\n          E result = (E) elements[(tail - 1) & (elements.length - 1)];\n          if (result == null)\n              throw new NoSuchElementException();\n          return result;\n      }\n  ```\n\npeekFirst / peekLast 中的操作,是与 getFirst / getLast 是一样的\n\npeek 方法里面是走的 peekFirst 方法\n\n- remove 方法\n\n  removeFirst 方法, 走的是 pollFirst 方法\n\n  removeLast 方法\n\n  ```\n  public E removeFirst() {\n      E x = pollFirst();\n      if (x == null)\n          throw new NoSuchElementException();\n      return x;\n  }\n  \n  /**\n   头节点 head 使用变量 h 来记录, 直接elements[h]下标来获取值,如果值是null的话,就执行返回(这里直接返回的逻辑处理是,初始化一个集合,但是没任何值,就调用removeFirst方法,这个时候数组里面是没有值的,于是就直接返回即可).\n   如果不是null的话,就会走下面的,将h的下标值设置为null,也就是进行删除,然后重新计算出 head 的值.\n  */\n  public E pollFirst() {\n          int h = head;\n          @SuppressWarnings(\"unchecked\")\n          E result = (E) elements[h];\n          // Element is null if deque empty\n          if (result == null)\n              return null;\n          elements[h] = null;     // Must null out slot\n          head = (h + 1) & (elements.length - 1);\n          return result;\n  }\n  \n  \n  public E removeLast() {\n          E x = pollLast();\n          if (x == null)\n              throw new NoSuchElementException();\n          return x;\n  }\n  \n  /**\n  \t先计算出尾节点的下标,然后用值result来进行记录.如果是null的话,就直接方法(这里想法和上面一样).将t的下标的值重置为null进行删除,然后tail的值就是等t的值.\n  */\n  public E pollLast() {\n          int t = (tail - 1) & (elements.length - 1);\n          @SuppressWarnings(\"unchecked\")\n          E result = (E) elements[t];\n          if (result == null)\n              return null;\n          elements[t] = null;\n          tail = t;\n          return result;\n  }\n  ```\n\nremove 方法是直接调用的 removeFirst 方法.\n\n- removeFirstOccurrence / removeLastOccurrence TODO 后续更新\n\n------\n\n### 总结\n\nArrayDeque 队列， 队列的特性就是对数据是先进先出。 而栈的特性是先进后出(比如枪打出去的子弹).\n\n这里的理解就是, 使用二个变量，然后每次进行 add / get / remove 都是利用这二个变量来进行 添加 / 删除 / 获取等操作.\n","tags":["java","java集合"],"categories":["java","java集合"]},{"title":"Java反射学习","url":"/2021/11/03/java/Java反射学习/","content":"\n\n\n#### 题记\n\n 最近在看Spring源码的时候, 可以看到在加载类等的时候,都是大量使用的反射。估摸着MyBatis这种框架,其内部也是会大量的使用反射。所以看得出来反射在第三方的框架中使用是非常多的,于是说学习反射技术是很有必要的，不论是你写代码造轮子还是去理解第三方框架的底层实现.\n\n 话不多bb,直接上代码看看是个什么操作.\n\n#### 方法\n\n我们这里写一个简单的pojo类,也就是我们经常使用的.\n\n```\npublic class User {\n\n    private Integer id;\n    private String name;\n\tpublic String age;\n    public User(){\n    }\n    public User(Integer id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public void say(){\n        System.out.println(\"User说\");\n    }\n}\n```\n\n然后接着在写一个启动的Main类\n\n```\npublic class UserClazzMain {\n    public static void main(String[] args) {\n        User u = new User();\n        // 获取类的所有的构造方法\n        Constructor<?>[] constructors = u.getClass().getConstructors();\n        System.out.println(Arrays.asList(constructors).toString());\n        // 根据传入进去的参数类型,获取出类的构造方法.\n        Constructor<? extends User> constructor = u.getClass().getConstructor(Integer.class, String.class);\n    }\n}\n// 打印结果:[public com.iyang.bootbasicio.pojo.User(), public com.iyang.bootbasicio.pojo.User(java.lang.Integer,java.lang.String)],\n//可以看到这是一个获取类的构造方法的.\n```\n\n调用反射获取方法:\n\n```\npublic class UserClazzMain {\n    public static void main(String[] args) throws Exception {\n        User u = new User();\n        // 可以看到获取出来的全部方法,不仅仅包含我们写的,还有Object中的notify等方法.\n        Method[] methods = u.getClass().getMethods();\n        System.out.println(Arrays.asList(methods).toString());\n        // 根据方法的名字来过去我们特定的方法.\n        Method method = u.getClass().getMethod(\"say\");\n        System.out.println(method.toString());\n        \n        //getDeclaredMethods方法仅仅只获取除了我们这个类里面的方法,并没有获取全部的方法(也就是不包括Object的).\n        Method[] declaredMethods = u.getClass().getDeclaredMethods();\n        System.out.println(Arrays.asList(declaredMethods).toString());\n        // 这里依然是获取我们自己写的方法\n        Method say = u.getClass().getDeclaredMethod(\"say\");\n        System.out.println(say.toString());\n        \n        // 这样我们就可以调用了user的say方法\n        Method say = u.getClass().getDeclaredMethod(\"say\");\n        say.invoke(u);\n    }\n}\n[public void com.iyang.bootbasicio.pojo.User.setId(java.lang.Integer), public void com.iyang.bootbasicio.pojo.User.say(), public java.lang.String com.iyang.bootbasicio.pojo.User.getName(), public void com.iyang.bootbasicio.pojo.User.setName(java.lang.String), public java.lang.Integer com.iyang.bootbasicio.pojo.User.getId(), public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException, public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException, public final void java.lang.Object.wait() throws java.lang.InterruptedException, public boolean java.lang.Object.equals(java.lang.Object), public java.lang.String java.lang.Object.toString(), public native int java.lang.Object.hashCode(), public final native java.lang.Class java.lang.Object.getClass(), public final native void java.lang.Object.notify(), public final native void java.lang.Object.notifyAll()]\n----------------------------\npublic void com.iyang.bootbasicio.pojo.User.say()\n```\n\n调用获取字段：\n\n```\npublic class UserClazzMain {\n    public static void main(String[] args) throws Exception {\n        User u = new User();\n        //获取全部的字段,是public修饰的字段,private修饰的是获取不到的.\n        Field[] fields = u.getClass().getFields();\n        System.out.println(Arrays.asList(fields).toString());\n        //获取字段,私有的不能获取,会抛出异常,只能获取public修饰的字段.\n        Field field = u.getClass().getField(\"age\");\n        System.out.println(field.toString());\n        \n        // 获取全部的字段,private修饰的也是可以获取出来的\n        Field[] declaredFields = u.getClass().getDeclaredFields();\n        System.out.println(Arrays.asList(declaredFields).toString());\n\n        // 根据字段的名字获取字段,不管什么修饰的,都是可以获取出来的.\n        Field name = u.getClass().getDeclaredField(\"name\");\n        System.out.println(name.toString());\n       }\n }\n```\n\n获取注解:\n\n我们先定义二个注解, 然后记得加在User类上. GavinYang 和 PeterWong 这二个注解是可以加在类上的, GavinYangFiledAnno是加在字段上面的.\n\n```\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE})\npublic @interface GavinYang {\n\n    String lwf() default \"lwf\";\n\n}\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE})\npublic @interface PeterWong {\n\n    String name() default \"peterWong\";\n\n}\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.FIELD})\npublic @interface GavinYangFiledAnno {\n    String desc() default \"\";\n}\n    // 从结果来看,获取注解还是蛮顺利的\n    public static void main(String[] args) throws Exception {\n        User u = new User();\n        // 获取这个类上面的注解\n        Annotation[] annotations = u.getClass().getAnnotations();\n        System.out.println(Arrays.asList(annotations).toString());\n        // 根据注解名字获取,可以看到返回的也直接是注解的Obejct了\n        GavinYang gavinYang = u.getClass().getAnnotation(GavinYang.class);\n        System.out.println(gavinYang.toString());\n        \n        // 获取字段上面使用的注解.\n        Field field = u.getClass().getDeclaredField(\"name\");\n        Annotation[] fieldAnnotations = field.getAnnotations();\n        System.out.println(Arrays.asList(fieldAnnotations).toString());\n        }\n      }\n      \n[@com.iyang.bootbasicio.pojo.GavinYang(lwf=baoyang), @com.iyang.bootbasicio.pojo.PeterWong(name=gavinyang)]\n@com.iyang.bootbasicio.pojo.GavinYang(lwf=baoyang)     \n[@com.iyang.bootbasicio.pojo.GavinYangFiledAnno(desc=秒啊)]\n```\n\n#### 小站一下\n\nUserService 无参构造方法 User说使用依赖注入完成一个简单的注入\n\n认一下Spring写一个差不多的注入注解. 在写一个虚假的 UserService,当然了,我们这里先不使用扫描,就使用简单的UserServcie去操作即可.\n\n```\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.FIELD})\npublic @interface GavinYangAutowired {\n\n    String alias() default \"\";\n\n}\npublic class UserService {\n\n    @GavinYangAutowired\n    private User user;\n\n    public UserService(){\n        System.out.println(\"UserService 无参构造方法\");\n    }\n\n    public void hello(){\n        user.say();\n    }\n\n}\n```\n\nUserClassMain 类来启动发车 , 这里看结果是可以成功的启动 UserService 并且也是用hello方法来调用user的say,都是成功. 但是真实的框架复杂程度不是这几行就可以ok了的. 这只是一个简单易学的demo.\n\n```\npublic class UserClazzMain {\n\n    public static void main(String[] args) throws Exception {\n        UserService u  = new UserService();\n        Field[] fields = u.getClass().getDeclaredFields();\n        for(Field f : fields){\n            GavinYangAutowired autowired = f.getDeclaredAnnotation(GavinYangAutowired.class);\n            if(autowired != null){\n                Class<?> fType = f.getType();\n                Constructor<?> typeConstructor = fType.getConstructor();\n                Object instance = typeConstructor.newInstance();\n\n                f.setAccessible(true);\n                f.set(u,instance);\n            }\n        }\n\n        u.hello();\n    }\n}\n\n// UserService 无参构造方法\n// User说\n```\n\n#### 总结\n\n可以看到反射的功能还是蛮强大的, 但是项目里面一般是CRUD,目前也没有什么特别的地方看到使用反射的情况比较多.就是最近一直看Spring源码中,是可以看到有大量使用反射的情况.\n","tags":["Java反射","java"],"categories":["java反射","java"]}]