<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"ruy9527.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.13.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script><meta name="description" content="知识笔记"><meta property="og:type" content="website"><meta property="og:title" content="YangBao"><meta property="og:url" content="https://ruy9527.github.io/page/3/index.html"><meta property="og:site_name" content="YangBao"><meta property="og:description" content="知识笔记"><meta property="og:locale" content="en_US"><meta property="article:author" content="YangBao"><meta property="article:tag" content="知识笔记"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://ruy9527.github.io/page/3/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/3/index.html","title":""}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>YangBao</title><script async defer data-website-id="" src=""></script><script defer data-domain="" src=""></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="YangBao" type="application/atom+xml">
</head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">YangBao</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li></ul></nav></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="YangBao" src="/images/touxiang.jpg"><p class="site-author-name" itemprop="name">YangBao</p><div class="site-description" itemprop="description">知识笔记</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">23</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><a href="https://github.com/ruY9527" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ruY9527" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:1411091515@qq.com" title="E-Mail → mailto:1411091515@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/11/04/java/ArrayList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/04/java/ArrayList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">ArrayList源码阅读记录</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-04 00:13:29" itemprop="dateCreated datePublished" datetime="2021-11-04T00:13:29+08:00">2021-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/java%E9%9B%86%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">java集合</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>4.1k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>4 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>ArrayList 是代码中使用非常频繁的,所以看底层的代码时非常有必须的.</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>ArrayList 是一个由 Object [] 的数组来实现的</p><p>transient Object[] elementData ,这个变量就是存放数据的.</p><p>长度是用 int size 这个变量来记录的,而不是直接调用的 数组的长度获取的.</p><p>如果ArrayList list &#x3D; new ArrayList(); 只是仅仅new一个集合的话,数组的大小是没有初始化为10的,而是在add()中,进行判断。 如果数组的是为空的数组的话,就会使用 <strong>DEFAULT_CAPACITY</strong> 来进行初始化。也就是要调用add方法才行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>先来介绍add()方法 , 上代码</p><p>add 里面是走了三个方法, size 没有赋值的情况下,就是0.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 确认容量 , 打个比方我们没有对size进行赋值,那么size + 1 传入到这个里面的值也就是1,那么 elementData 对应的也就是一个空数组</span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">     ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  满足是空数组的话,就会使用默认的值 10 于 minCapcacity 来进行对比,这里返回的10</span><br><span class="line">private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        return minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//  如果 minCapacity  减去 数组的长度是大于0的,就会调用grow来进行扩容</span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        // overflow-conscious code</span><br><span class="line">        if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">// 这里可以看到先对数组的值进行,然后对保存出来的值进行1.5倍扩容,与传入进来的值进行对比,满足条件赋值.这里就要看到 Arrays.copyOf(elementDate,newCapacity); 这才是真正的对数组进行扩容的方法,也就是直接调用Arrays的API. Arrays.copyOf() 里面最后也是调用了 System.arraycopy()的方法</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">        // overflow-conscious code</span><br><span class="line">        int oldCapacity = elementData.length;</span><br><span class="line">        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">        if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        // minCapacity is usually close to size, so this is a win:</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">到这里 ensureCapacityInternal 方法也就是走完了</span><br><span class="line">---------------------------------------------</span><br><span class="line">后面就是使用 数组下标来进行赋值并且返回true。</span><br></pre></td></tr></table></figure></li><li><p>根据下标来添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检查下标是否越界 , ensureCapacityInternal 方法和上面一样</span><br><span class="line">private void rangeCheckForAdd(int index) &#123;</span><br><span class="line">        if (index &gt; size || index &lt; 0)</span><br><span class="line">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//  System.arraycopy() 从 elementDate 的 index处开始复制, 复制给后面的elementDate数组的值,从index + 1 开始复制,也就是说 index 相当于修改了 index + 1, 然后index位置就是没有值了,所以elementDate[index] = element的值,size ++.</span><br></pre></td></tr></table></figure></li><li><p>set方法 : 也就是根据下标来对久的值进行一种替换,取出对应下标的值,然后下标对应的位置赋值给新值,最后返回旧值回去即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 先检查下标是否越界,如果越界就会抛出异常</span><br><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 取出对应下标的值</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    E elementData(int index) &#123;</span><br><span class="line">        return (E) elementData[index];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>remove</p><p>根据传入进来的值进行删除,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 分为 null 和 不是 null 的情况来进行删除.满足条件的话,最后都会调用到 fastRemove方法中来</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (int index = 0; index &lt; size; index++)</span><br><span class="line">            if (elementData[index] == null) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int index = 0; index &lt; size; index++)</span><br><span class="line">            if (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  根据传入进来的 下标来删除数据,System.arraycopy 这个方法并不默认,根据下标的位置来进行复制数组。</span><br><span class="line">//  可以看到最后有一个 将值设置为null的操作,从注释上看是help GC, 帮助GC</span><br><span class="line">private void fastRemove(int index) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        int numMoved = size - index - 1;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>根据下标删除</p><p>可以看到根据下标删除的话，会先判断传入进来的下标是否满足条件,就是没有出现越界的情况.</p><p>然后取出旧值,接下来的代码就是非常的熟悉了,就是fastRemove() 里面的代码了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">  </span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">  </span><br><span class="line">    int numMoved = size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">  </span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大致就是看 ArrayList 是如何添加数据的,对数据是怎么保存的,是如何删除数据的,是怎么样进行扩容的,大致弄明白这些就是对ArrayList有一个大致的了解</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/11/04/java/ArrayDeque%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/04/java/ArrayDeque%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">ArrayDeque源码阅读记录</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-04 00:13:11" itemprop="dateCreated datePublished" datetime="2021-11-04T00:13:11+08:00">2021-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/java%E9%9B%86%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">java集合</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>5.6k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>5 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>ArrayDeque 在我目前做的项目中,使用是比较少的,基本都没有地方用到。可能是我太low了,也可能是业务没有一定要用到队列的情况. 但是这不影响我们对其进行源码阅读。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>结构还是可以看到, 使用一个Object的数组, 二个int类型的变量来记录头和尾(从单词的意思)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">transient Object[] elements; // non-private to simplify nested class access</span><br><span class="line"></span><br><span class="line">transient int head;</span><br><span class="line"></span><br><span class="line">transient int tail;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>构造函数</p><p>无参构造函数. 可以看到无参构造函数,默认是对数据进行初始化大小为16的操作.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ArrayDeque() &#123;</span><br><span class="line">    elements = new Object[16];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有参构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">/**传递int类型的构造函数,最后是调用到了calculateSize方法返回值来初始化数组大小 */</span><br><span class="line">public ArrayDeque(int numElements) &#123;</span><br><span class="line">    allocateElements(numElements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void allocateElements(int numElements) &#123;</span><br><span class="line">        elements = new Object[calculateSize(numElements)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 获取变量MIN_INITIAL_CAPACITY的值,如果传入进来的值是大于这个值,就会进行下面的运算操作,然后返回这个值出去.   */</span><br><span class="line">private static int calculateSize(int numElements) &#123;</span><br><span class="line">        int initialCapacity = MIN_INITIAL_CAPACITY;</span><br><span class="line">        // Find the best power of two to hold elements.</span><br><span class="line">        // Tests &quot;&lt;=&quot; because arrays aren&#x27;t kept full.</span><br><span class="line">        if (numElements &gt;= initialCapacity) &#123;</span><br><span class="line">            initialCapacity = numElements;</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  1);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  2);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  4);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  8);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt; 16);</span><br><span class="line">            initialCapacity++;</span><br><span class="line"></span><br><span class="line">            if (initialCapacity &lt; 0)   // Too many elements, must back off</span><br><span class="line">                initialCapacity &gt;&gt;&gt;= 1;// Good luck allocating 2 ^ 30 elements</span><br><span class="line">        &#125;</span><br><span class="line">        return initialCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">   传递集合的构造函数</span><br><span class="line">   使用传递进来的集合的长度来初始化数组的长度.</span><br><span class="line">   然后调用addAll方法,这里说明下 addAll 是在其 AbstractCollection 里面,也就是子类调用父类的方法.然后add方法是在ArrayDeque里面调用</span><br><span class="line">*/</span><br><span class="line">public ArrayDeque(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        allocateElements(c.size());</span><br><span class="line">        addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void allocateElements(int numElements) &#123;</span><br><span class="line">        elements = new Object[calculateSize(numElements)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 这里可以看到,定义给变量,迭代集合c,依次调用add方法,如果add方法返回的是true,变量modified就会变为true.最后addAll就会返回变量modified回去. */</span><br><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        boolean modified = false;</span><br><span class="line">        for (E e : c)</span><br><span class="line">            if (add(e))</span><br><span class="line">                modified = true;</span><br><span class="line">        return modified;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 往下调用</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        addLast(e);</span><br><span class="line">        return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	这里的值是不能传入null进来的,否则的话就会报NPE的异常.</span><br><span class="line">	然后使用下标tail直接插入到最后,if 里面是对 tail 的值进行新赋值操作,如果满足条件就会调用doubleCapacity方法,目测这个方法就是进行扩容的方法.</span><br><span class="line">	这里就是看下  (tail = (tail + 1) &amp; (elements.length - 1)) 这个赋值操作,就是给tail进行新的赋值。</span><br><span class="line">*/</span><br><span class="line">public void addLast(E e) &#123;</span><br><span class="line">        if (e == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        elements[tail] = e;</span><br><span class="line">        if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)</span><br><span class="line">            doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加方法</p><p>add(E e) 这里添加调用的方法,我们主要看下 doubleCapacity 这个方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void addLast(E e) &#123;</span><br><span class="line">        if (e == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        elements[tail] = e;</span><br><span class="line">        if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)</span><br><span class="line">            doubleCapacity();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	这里对 head / elements的长度都进行值存储操作, 一 是便于后面使用System.arraycopy 来进行copy数组的值,好从对应下标开始复制值. 二是 head /  tail 等赋值.</span><br><span class="line">	可以看到扩容后的的大小,来new了一个新的数组,后面调用System.arraycopy来进行复制.</span><br><span class="line">*/</span><br><span class="line">private void doubleCapacity() &#123;</span><br><span class="line">        assert head == tail;</span><br><span class="line">        int p = head;</span><br><span class="line">        int n = elements.length;</span><br><span class="line">        int r = n - p; // number of elements to the right of p</span><br><span class="line">        int newCapacity = n &lt;&lt; 1;</span><br><span class="line">        if (newCapacity &lt; 0)</span><br><span class="line">            throw new IllegalStateException(&quot;Sorry, deque too big&quot;);</span><br><span class="line">        Object[] a = new Object[newCapacity];</span><br><span class="line">        System.arraycopy(elements, p, a, 0, r);</span><br><span class="line">        System.arraycopy(elements, 0, a, r, p);</span><br><span class="line">        elements = a;</span><br><span class="line">        head = 0;</span><br><span class="line">        tail = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addFirst 从头部插入 , 可以看到 使用 head &#x3D; (head - 1) &amp; (elements.length - 1) 是计算出头部下标的位置,并且对值进行覆盖. 如果 head 与 tail 是相等的话,就会调用 doubleCapacity来进行扩容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void addFirst(E e) &#123;</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    elements[head = (head - 1) &amp; (elements.length - 1)] = e;</span><br><span class="line">    if (head == tail)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>addLast 尾部插入, 这个方法上面都是有提到的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void addLast(E e) &#123;</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    elements[tail] = e;</span><br><span class="line">    if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offerLast / offerFirst  内部都是分别调用到了 addLast / addFirst 方法</span><br></pre></td></tr></table></figure><p>push 方法也是调用的 addFirst 方法</p><ul><li><p>get 获取值方法</p><p>getFirst &#x2F; getLast 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/** 从head对应的数组中直接获取出值,如果值是null的话,就会抛出一个异常,否则就会返回*/</span><br><span class="line">public E getFirst() &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    E result = (E) elements[head];</span><br><span class="line">    if (result == null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	(tail - 1) &amp; (elements.length - 1) 得出尾部元素的下标位置,然后用数组下标返回对应的值.</span><br><span class="line">*/</span><br><span class="line">public E getLast() &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        E result = (E) elements[(tail - 1) &amp; (elements.length - 1)];</span><br><span class="line">        if (result == null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>peekFirst &#x2F; peekLast 中的操作,是与 getFirst &#x2F; getLast 是一样的</p><p>peek 方法里面是走的 peekFirst 方法</p><ul><li><p>remove 方法</p><p>removeFirst 方法, 走的是 pollFirst 方法</p><p>removeLast 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public E removeFirst() &#123;</span><br><span class="line">    E x = pollFirst();</span><br><span class="line">    if (x == null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 头节点 head 使用变量 h 来记录, 直接elements[h]下标来获取值,如果值是null的话,就执行返回(这里直接返回的逻辑处理是,初始化一个集合,但是没任何值,就调用removeFirst方法,这个时候数组里面是没有值的,于是就直接返回即可).</span><br><span class="line"> 如果不是null的话,就会走下面的,将h的下标值设置为null,也就是进行删除,然后重新计算出 head 的值.</span><br><span class="line">*/</span><br><span class="line">public E pollFirst() &#123;</span><br><span class="line">        int h = head;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        E result = (E) elements[h];</span><br><span class="line">        // Element is null if deque empty</span><br><span class="line">        if (result == null)</span><br><span class="line">            return null;</span><br><span class="line">        elements[h] = null;     // Must null out slot</span><br><span class="line">        head = (h + 1) &amp; (elements.length - 1);</span><br><span class="line">        return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public E removeLast() &#123;</span><br><span class="line">        E x = pollLast();</span><br><span class="line">        if (x == null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	先计算出尾节点的下标,然后用值result来进行记录.如果是null的话,就直接方法(这里想法和上面一样).将t的下标的值重置为null进行删除,然后tail的值就是等t的值.</span><br><span class="line">*/</span><br><span class="line">public E pollLast() &#123;</span><br><span class="line">        int t = (tail - 1) &amp; (elements.length - 1);</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        E result = (E) elements[t];</span><br><span class="line">        if (result == null)</span><br><span class="line">            return null;</span><br><span class="line">        elements[t] = null;</span><br><span class="line">        tail = t;</span><br><span class="line">        return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>remove 方法是直接调用的 removeFirst 方法.</p><ul><li>removeFirstOccurrence &#x2F; removeLastOccurrence TODO 后续更新</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ArrayDeque 队列， 队列的特性就是对数据是先进先出。 而栈的特性是先进后出(比如枪打出去的子弹).</p><p>这里的理解就是, 使用二个变量，然后每次进行 add &#x2F; get &#x2F; remove 都是利用这二个变量来进行 添加 &#x2F; 删除 &#x2F; 获取等操作.</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/11/03/java/Java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/03/java/Java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Java反射学习</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-03 23:18:57" itemprop="dateCreated datePublished" datetime="2021-11-03T23:18:57+08:00">2021-11-03</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java%E5%8F%8D%E5%B0%84/" itemprop="url" rel="index"><span itemprop="name">java反射</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>6.3k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>6 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h4 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h4><p>最近在看Spring源码的时候, 可以看到在加载类等的时候,都是大量使用的反射。估摸着MyBatis这种框架,其内部也是会大量的使用反射。所以看得出来反射在第三方的框架中使用是非常多的,于是说学习反射技术是很有必要的，不论是你写代码造轮子还是去理解第三方框架的底层实现.</p><p>话不多bb,直接上代码看看是个什么操作.</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>我们这里写一个简单的pojo类,也就是我们经常使用的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">	public String age;</span><br><span class="line">    public User()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public User(Integer id, String name) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void say()&#123;</span><br><span class="line">        System.out.println(&quot;User说&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后接着在写一个启动的Main类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class UserClazzMain &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User u = new User();</span><br><span class="line">        // 获取类的所有的构造方法</span><br><span class="line">        Constructor&lt;?&gt;[] constructors = u.getClass().getConstructors();</span><br><span class="line">        System.out.println(Arrays.asList(constructors).toString());</span><br><span class="line">        // 根据传入进去的参数类型,获取出类的构造方法.</span><br><span class="line">        Constructor&lt;? extends User&gt; constructor = u.getClass().getConstructor(Integer.class, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 打印结果:[public com.iyang.bootbasicio.pojo.User(), public com.iyang.bootbasicio.pojo.User(java.lang.Integer,java.lang.String)],</span><br><span class="line">//可以看到这是一个获取类的构造方法的.</span><br></pre></td></tr></table></figure><p>调用反射获取方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class UserClazzMain &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        User u = new User();</span><br><span class="line">        // 可以看到获取出来的全部方法,不仅仅包含我们写的,还有Object中的notify等方法.</span><br><span class="line">        Method[] methods = u.getClass().getMethods();</span><br><span class="line">        System.out.println(Arrays.asList(methods).toString());</span><br><span class="line">        // 根据方法的名字来过去我们特定的方法.</span><br><span class="line">        Method method = u.getClass().getMethod(&quot;say&quot;);</span><br><span class="line">        System.out.println(method.toString());</span><br><span class="line">        </span><br><span class="line">        //getDeclaredMethods方法仅仅只获取除了我们这个类里面的方法,并没有获取全部的方法(也就是不包括Object的).</span><br><span class="line">        Method[] declaredMethods = u.getClass().getDeclaredMethods();</span><br><span class="line">        System.out.println(Arrays.asList(declaredMethods).toString());</span><br><span class="line">        // 这里依然是获取我们自己写的方法</span><br><span class="line">        Method say = u.getClass().getDeclaredMethod(&quot;say&quot;);</span><br><span class="line">        System.out.println(say.toString());</span><br><span class="line">        </span><br><span class="line">        // 这样我们就可以调用了user的say方法</span><br><span class="line">        Method say = u.getClass().getDeclaredMethod(&quot;say&quot;);</span><br><span class="line">        say.invoke(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[public void com.iyang.bootbasicio.pojo.User.setId(java.lang.Integer), public void com.iyang.bootbasicio.pojo.User.say(), public java.lang.String com.iyang.bootbasicio.pojo.User.getName(), public void com.iyang.bootbasicio.pojo.User.setName(java.lang.String), public java.lang.Integer com.iyang.bootbasicio.pojo.User.getId(), public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException, public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException, public final void java.lang.Object.wait() throws java.lang.InterruptedException, public boolean java.lang.Object.equals(java.lang.Object), public java.lang.String java.lang.Object.toString(), public native int java.lang.Object.hashCode(), public final native java.lang.Class java.lang.Object.getClass(), public final native void java.lang.Object.notify(), public final native void java.lang.Object.notifyAll()]</span><br><span class="line">----------------------------</span><br><span class="line">public void com.iyang.bootbasicio.pojo.User.say()</span><br></pre></td></tr></table></figure><p>调用获取字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class UserClazzMain &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        User u = new User();</span><br><span class="line">        //获取全部的字段,是public修饰的字段,private修饰的是获取不到的.</span><br><span class="line">        Field[] fields = u.getClass().getFields();</span><br><span class="line">        System.out.println(Arrays.asList(fields).toString());</span><br><span class="line">        //获取字段,私有的不能获取,会抛出异常,只能获取public修饰的字段.</span><br><span class="line">        Field field = u.getClass().getField(&quot;age&quot;);</span><br><span class="line">        System.out.println(field.toString());</span><br><span class="line">        </span><br><span class="line">        // 获取全部的字段,private修饰的也是可以获取出来的</span><br><span class="line">        Field[] declaredFields = u.getClass().getDeclaredFields();</span><br><span class="line">        System.out.println(Arrays.asList(declaredFields).toString());</span><br><span class="line"></span><br><span class="line">        // 根据字段的名字获取字段,不管什么修饰的,都是可以获取出来的.</span><br><span class="line">        Field name = u.getClass().getDeclaredField(&quot;name&quot;);</span><br><span class="line">        System.out.println(name.toString());</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>获取注解:</p><p>我们先定义二个注解, 然后记得加在User类上. GavinYang 和 PeterWong 这二个注解是可以加在类上的, GavinYangFiledAnno是加在字段上面的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">public @interface GavinYang &#123;</span><br><span class="line"></span><br><span class="line">    String lwf() default &quot;lwf&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">public @interface PeterWong &#123;</span><br><span class="line"></span><br><span class="line">    String name() default &quot;peterWong&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.FIELD&#125;)</span><br><span class="line">public @interface GavinYangFiledAnno &#123;</span><br><span class="line">    String desc() default &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">    // 从结果来看,获取注解还是蛮顺利的</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        User u = new User();</span><br><span class="line">        // 获取这个类上面的注解</span><br><span class="line">        Annotation[] annotations = u.getClass().getAnnotations();</span><br><span class="line">        System.out.println(Arrays.asList(annotations).toString());</span><br><span class="line">        // 根据注解名字获取,可以看到返回的也直接是注解的Obejct了</span><br><span class="line">        GavinYang gavinYang = u.getClass().getAnnotation(GavinYang.class);</span><br><span class="line">        System.out.println(gavinYang.toString());</span><br><span class="line">        </span><br><span class="line">        // 获取字段上面使用的注解.</span><br><span class="line">        Field field = u.getClass().getDeclaredField(&quot;name&quot;);</span><br><span class="line">        Annotation[] fieldAnnotations = field.getAnnotations();</span><br><span class="line">        System.out.println(Arrays.asList(fieldAnnotations).toString());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">[@com.iyang.bootbasicio.pojo.GavinYang(lwf=baoyang), @com.iyang.bootbasicio.pojo.PeterWong(name=gavinyang)]</span><br><span class="line">@com.iyang.bootbasicio.pojo.GavinYang(lwf=baoyang)     </span><br><span class="line">[@com.iyang.bootbasicio.pojo.GavinYangFiledAnno(desc=秒啊)]</span><br></pre></td></tr></table></figure><h4 id="小站一下"><a href="#小站一下" class="headerlink" title="小站一下"></a>小站一下</h4><p>UserService 无参构造方法 User说使用依赖注入完成一个简单的注入</p><p>认一下Spring写一个差不多的注入注解. 在写一个虚假的 UserService,当然了,我们这里先不使用扫描,就使用简单的UserServcie去操作即可.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.FIELD&#125;)</span><br><span class="line">public @interface GavinYangAutowired &#123;</span><br><span class="line"></span><br><span class="line">    String alias() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">    @GavinYangAutowired</span><br><span class="line">    private User user;</span><br><span class="line"></span><br><span class="line">    public UserService()&#123;</span><br><span class="line">        System.out.println(&quot;UserService 无参构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void hello()&#123;</span><br><span class="line">        user.say();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserClassMain 类来启动发车 , 这里看结果是可以成功的启动 UserService 并且也是用hello方法来调用user的say,都是成功. 但是真实的框架复杂程度不是这几行就可以ok了的. 这只是一个简单易学的demo.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class UserClazzMain &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        UserService u  = new UserService();</span><br><span class="line">        Field[] fields = u.getClass().getDeclaredFields();</span><br><span class="line">        for(Field f : fields)&#123;</span><br><span class="line">            GavinYangAutowired autowired = f.getDeclaredAnnotation(GavinYangAutowired.class);</span><br><span class="line">            if(autowired != null)&#123;</span><br><span class="line">                Class&lt;?&gt; fType = f.getType();</span><br><span class="line">                Constructor&lt;?&gt; typeConstructor = fType.getConstructor();</span><br><span class="line">                Object instance = typeConstructor.newInstance();</span><br><span class="line"></span><br><span class="line">                f.setAccessible(true);</span><br><span class="line">                f.set(u,instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        u.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UserService 无参构造方法</span><br><span class="line">// User说</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>可以看到反射的功能还是蛮强大的, 但是项目里面一般是CRUD,目前也没有什么特别的地方看到使用反射的情况比较多.就是最近一直看Spring源码中,是可以看到有大量使用反射的情况.</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span></nav></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">YangBao</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>Symbols count total: </span><span title="Symbols count total">307k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>Reading time total &asymp;</span> <span title="Reading time total">4:39</span></span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a></div></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script></body></html>