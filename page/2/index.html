<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"ruy9527.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.13.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script><meta name="description" content="知识笔记"><meta property="og:type" content="website"><meta property="og:title" content="YangBao"><meta property="og:url" content="https://ruy9527.github.io/page/2/index.html"><meta property="og:site_name" content="YangBao"><meta property="og:description" content="知识笔记"><meta property="og:locale" content="en_US"><meta property="article:author" content="YangBao"><meta property="article:tag" content="知识笔记"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://ruy9527.github.io/page/2/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/2/index.html","title":""}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>YangBao</title><script async defer data-website-id="" src=""></script><script defer data-domain="" src=""></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="YangBao" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">YangBao</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li></ul></nav></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="YangBao" src="/images/touxiang.jpg"><p class="site-author-name" itemprop="name">YangBao</p><div class="site-description" itemprop="description">知识笔记</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">23</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><a href="https://github.com/ruY9527" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ruY9527" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:1411091515@qq.com" title="E-Mail → mailto:1411091515@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/11/04/spring/spring%E7%9A%84refresh%E6%96%B9%E6%B3%95%E9%98%85%E8%AF%BB/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/04/spring/spring%E7%9A%84refresh%E6%96%B9%E6%B3%95%E9%98%85%E8%AF%BB/" class="post-title-link" itemprop="url">spring的refresh方法阅读</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-04 00:17:10" itemprop="dateCreated datePublished" datetime="2021-11-04T00:17:10+08:00">2021-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>55k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>50 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这里是相对上一次再次的阅读和记录,比上次有了更深入的理解.</p><p>这里是再次整理的阅读 Spring 的源码, 相对比上次的阅读，我希望这次可以更清晰&amp;更深刻的理解Spring,也不仅仅会从一个案例来进行分析，会结合多方面的知识来进行整理分析.</p><p>这里放上之前阅读的比例 : <a target="_blank" rel="noopener" href="https://github.com/baoyang23/source-notes/tree/master/java/spring_bean">https://github.com/baoyang23/source-notes/tree/master/java/spring_bean</a></p><p>该目录下面有 : bean&#x2F;get&#x2F;extend 三个主要地方的分析.</p><p>此模块还是讲述 整体的 flow,后面会对单个进行分析&amp;Spring提供怎么样的扩展方式来进行增强扩展等.</p><p>案例入门操作的话,可以参考之前的博客.</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>这里我们先不忙这其他类型的bean分析, 就对我们作为 config 的 bean 进行分析. 先单个分析容易理解些.</p><p>入口类 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitWorkFlowSpring</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(YangBeanScannerConfig.class);</span><br><span class="line">        <span class="type">YangBeanScannerConfig</span> <span class="variable">yangBeanScannerConfig</span> <span class="operator">=</span> context.getBean(YangBeanScannerConfig.class);</span><br><span class="line">        yangBeanScannerConfig.say();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.iyang.spring&quot;)</span></span><br><span class="line"><span class="meta">@Description(value = &quot;This is GavinYang DemoWorld.&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YangBeanScannerConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">YangBeanScannerConfig</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;配置扫描初始化打印&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是从Spring容器中获取出来的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当我们启动 main 方法的时候，是可以看到 YangBeanScannerConfig 中构造函数打印的内容和调用say方法打印出来的内容.</p><p>基于这个基础上,我们debug一层一层的走进去看,Spring做了什么事情.</p><p>先进入到我们new出来的AnnotationConfigApplicationContext中来</p><p>调用自身的无参构造函数</p><p>调用 register 注册方法</p><p>最后调用一个 refresh, refresh 方法中是做了很多事的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>();</span><br><span class="line">   register(componentClasses);</span><br><span class="line">   refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么有了入口，我们就根据这些方法来一个一个的分析.</p><h4 id="this-方法-—-gt-org-springframework-context-annotation-AnnotationConfigApplicationContext-AnnotationConfigApplicationContext"><a href="#this-方法-—-gt-org-springframework-context-annotation-AnnotationConfigApplicationContext-AnnotationConfigApplicationContext" class="headerlink" title="this() 方法 —&gt; org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext()"></a>this() 方法 —&gt; org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext()</h4><p>先来看 this 方法做了什么事情.</p><p>创建了二个对象，分别是 注解bd读取&#x2F;类路口db扫描.</p><p>比如有意思的是,传入this(AnnotationConfigApplicationContext), 然后返回来的reader&#x2F;scanner又属于this.也是相互之间各自都持有各自的引用.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line">   <span class="built_in">this</span>.scanner = <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="new-AnnotatedBeanDefinitionReader"><a href="#new-AnnotatedBeanDefinitionReader" class="headerlink" title="new AnnotatedBeanDefinitionReader"></a>new AnnotatedBeanDefinitionReader</h5><p>来，看下new一个对象做了什么事情.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line"><span class="comment">// 这里的 getOrCreateEnvironment 方法中,AnnotationConfigApplicationContext是EnvironmentCapable的子类,</span></span><br><span class="line"><span class="comment">// 所以Environment也是从AnnotationConfigApplicationContext中获取出来的.    </span></span><br><span class="line">   <span class="built_in">this</span>(registry, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry, Environment environment)</span> &#123;</span><br><span class="line"> <span class="comment">// 检验 registry/environment都不能为null.   </span></span><br><span class="line">		Assert.notNull(registry, <span class="string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);</span><br><span class="line">		Assert.notNull(environment, <span class="string">&quot;Environment must not be null&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.registry = registry;</span><br><span class="line"><span class="comment">// 这里将 registry/environment 给传入构造到 org.springframework.context.annotation.ConditionEvaluator 中来.</span></span><br><span class="line"><span class="comment">// ConditionEvaluator又借助org.springframework.context.annotation.ConditionEvaluator.ConditionContextImpl#ConditionContextImpl 来存储这些信息,所以这里最后的信息是在ConditionContextImpl中来了.    </span></span><br><span class="line">		<span class="built_in">this</span>.conditionEvaluator = <span class="keyword">new</span> <span class="title class_">ConditionEvaluator</span>(registry, environment, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors(org.springframework.beans.factory.support.BeanDefinitionRegistry, java.lang.Object)</span></span><br><span class="line"><span class="comment">// 从该方法的名字上看,是对注册注解配置进行处理.    </span></span><br><span class="line">		AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="built_in">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="org-springframework-context-annotation-AnnotationConfigUtils-registerAnnotationConfigProcessors-org-springframework-beans-factory-support-BeanDefinitionRegistry-java-lang-Object-分析"><a href="#org-springframework-context-annotation-AnnotationConfigUtils-registerAnnotationConfigProcessors-org-springframework-beans-factory-support-BeanDefinitionRegistry-java-lang-Object-分析" class="headerlink" title="org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors(org.springframework.beans.factory.support.BeanDefinitionRegistry, java.lang.Object) 分析"></a>org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors(org.springframework.beans.factory.support.BeanDefinitionRegistry, java.lang.Object) 分析</h6><p>这里根据我们的案列，传入进来的source是null.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">registerAnnotationConfigProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">      BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> &#123;</span><br><span class="line"><span class="comment">// 根据 registry 的类型来获取 DefaultListableBeanFactory.</span></span><br><span class="line"><span class="comment">// 这里的registry属于GenericApplicationContext,调用其getDefaultListableBeanFactory来获取.    </span></span><br><span class="line">   <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">   <span class="keyword">if</span> (beanFactory != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// beanFactory.getDependencyComparator() 返回的是null,满足条件.       </span></span><br><span class="line">      <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line"><span class="comment">// 设置 AnnotationAwareOrderComparator 到beanFactory中来          </span></span><br><span class="line">         beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// get方法获取出来的是SimpleAutowireCandidateResolver,       </span></span><br><span class="line">      <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line"><span class="comment">// 设置ContextAnnotationAutowireCandidateResolver到beanFactory中来.          </span></span><br><span class="line">         beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到每个都有 internal 来特意表明内部的意思.    </span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.internalConfigurationAnnotationProcessor ---&gt;  ConfigurationClassPostProcessor</span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.internalAutowiredAnnotationProcessor  --&gt; AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.internalCommonAnnotationProcessor   ---&gt; CommonAnnotationBeanPostProcessor </span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.internalPersistenceAnnotationProcessor  ---&gt; PersistenceAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment">// org.springframework.context.event.internalEventListenerProcessor   ---&gt; EventListenerMethodProcessor</span></span><br><span class="line"><span class="comment">// org.springframework.context.event.internalEventListenerFactory  --- &gt; DefaultEventListenerFactory</span></span><br><span class="line">   <span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">      <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(ConfigurationClassPostProcessor.class);</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">      <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span></span><br><span class="line">   <span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">      <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span></span><br><span class="line">   <span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">      <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class="line">               AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">               <span class="string">&quot;Cannot load optional framework class: &quot;</span> + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">      <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(EventListenerMethodProcessor.class);</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">      <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(DefaultEventListenerFactory.class);</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> beanDefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里都是先判断这些内部的bean,是不是已经在 registry 中已经存在了,如果没有存在的话，就会利用类信息来构造出一个RootBeanDefinition来,接着就是调用 registerPostProcessor 方法给注册到 registry 中来.</p><p>最后返回一个注册过的 bean 的 Set 集合回去.</p><p>总结下这里就是为了给spring容器中注册一些内部的 bean 进去. 这些注册进去的bean,都是在后面初始化bean&amp;解析bean等情况有使用到的.</p><h5 id="new-ClassPathBeanDefinitionScanner-方法"><a href="#new-ClassPathBeanDefinitionScanner-方法" class="headerlink" title="new ClassPathBeanDefinitionScanner() 方法"></a>new ClassPathBeanDefinitionScanner() 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="type">boolean</span> useDefaultFilters)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>(registry, useDefaultFilters, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"><span class="comment">// 最后走到 org.springframework.context.annotation.ClassPathBeanDefinitionScanner#ClassPathBeanDefinitionScanner(org.springframework.beans.factory.support.BeanDefinitionRegistry, boolean, org.springframework.core.env.Environment, org.springframework.core.io.ResourceLoader) 构造函数来.    </span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="type">boolean</span> useDefaultFilters,</span></span><br><span class="line"><span class="params">			Environment environment, <span class="meta">@Nullable</span> ResourceLoader resourceLoader)</span> &#123;</span><br><span class="line"></span><br><span class="line">		Assert.notNull(registry, <span class="string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);</span><br><span class="line"><span class="comment">// 赋值 registry 来.    </span></span><br><span class="line">		<span class="built_in">this</span>.registry = registry;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line"><span class="comment">// 添加 filter 到 includeFilters 中来.</span></span><br><span class="line"><span class="comment">// AnnotationTypeFilter(Component.class)</span></span><br><span class="line"><span class="comment">// AnnotationTypeFilter(((Class&lt;? extends Annotation&gt;) ClassUtils.forName(&quot;javax.annotation.ManagedBean&quot;, cl)     </span></span><br><span class="line"><span class="comment">// 等信息进来      </span></span><br><span class="line">			registerDefaultFilters();</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">// org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#setEnvironment</span></span><br><span class="line"><span class="comment">// 设置 enviornment到父类中来.    </span></span><br><span class="line">		setEnvironment(environment);</span><br><span class="line"><span class="comment">// 这里也是这是到父类来了.</span></span><br><span class="line"><span class="comment">// 返回的resourcePatternResolver是AnnotationConfigApplicationContext.</span></span><br><span class="line"><span class="comment">// metadataReaderFactory 是 CachingMetadataReaderFactory 对象来.</span></span><br><span class="line"><span class="comment">// componentsIndex 是 null.    </span></span><br><span class="line">		setResourceLoader(resourceLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法可以看到,添加了三个 filter 到 includeFilters 中来.</p><p>设置environment &#x2F; resource 到 其父类org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider 中来.</p><p>也就是setXXX方法是调用的父类.</p><h4 id="register-componentClasses-方法"><a href="#register-componentClasses-方法" class="headerlink" title="register(componentClasses) 方法"></a>register(componentClasses) 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">   <span class="comment">//  检验传入进来的 comonpentClasses是一定要有值的. </span></span><br><span class="line">   Assert.notEmpty(componentClasses, <span class="string">&quot;At least one component class must be specified&quot;</span>);</span><br><span class="line">   <span class="built_in">this</span>.reader.register(componentClasses);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------</span><br><span class="line"><span class="comment">// 这里从名字上就可以很容易看出是注册 bean 的    </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (Class&lt;?&gt; componentClass : componentClasses) &#123;</span><br><span class="line">			registerBean(componentClass);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">doRegisterBean</span><span class="params">(Class&lt;T&gt; beanClass, <span class="meta">@Nullable</span> String name,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt;[] qualifiers, <span class="meta">@Nullable</span> Supplier&lt;T&gt; supplier,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> BeanDefinitionCustomizer[] customizers)</span> &#123;</span><br><span class="line"><span class="comment">// new 一个 bd 出来.</span></span><br><span class="line">		<span class="type">AnnotatedGenericBeanDefinition</span> <span class="variable">abd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotatedGenericBeanDefinition</span>(beanClass);</span><br><span class="line"><span class="comment">// 这里没有 @Conditional 注解和 metadata 是 null 就会直接返回 false 来.    </span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		abd.setInstanceSupplier(supplier);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在对象上获取 @Scope 注解,这里没有,所以就不会往下走.</span></span><br><span class="line"><span class="comment">// 这里返回的 ScopeMetadata应该是默认的,scopeName是singleton,scopedProxyMode是No/1    </span></span><br><span class="line">		<span class="type">ScopeMetadata</span> <span class="variable">scopeMetadata</span> <span class="operator">=</span> <span class="built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">		abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line"><span class="comment">// 获取 beanName 来    </span></span><br><span class="line">		<span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> (name != <span class="literal">null</span> ? name : <span class="built_in">this</span>.beanNameGenerator.generateBeanName(abd, <span class="built_in">this</span>.registry));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对一些注解的处理.</span></span><br><span class="line"><span class="comment">// @Lazy , @Primary , @DependsOn , @Role , @Description 如果有这些注解的话,就会进行处理.</span></span><br><span class="line"><span class="comment">// 根据注解的名字,来调用相应的set方法.    </span></span><br><span class="line">		AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 这里是对是否有 @Primary / @Lazy /   @Qualifier 注解进行判断.</span></span><br><span class="line">		<span class="keyword">if</span> (qualifiers != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; qualifier : qualifiers) &#123;</span><br><span class="line">				<span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">					abd.setPrimary(<span class="literal">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">					abd.setLazyInit(<span class="literal">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					abd.addQualifier(<span class="keyword">new</span> <span class="title class_">AutowireCandidateQualifier</span>(qualifier));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//这里 BeanDefinitionCustomizer[] customizers 数组如果有值的话,</span></span><br><span class="line"><span class="comment">// 会调用 customizer 的 customize 方法传入 bd.</span></span><br><span class="line"><span class="comment">// TODO , 这里由于没有具体的值,也不是很清楚做了什么事情.    </span></span><br><span class="line">		<span class="keyword">if</span> (customizers != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">				customizer.customize(abd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 bd 和 bean的名字，创建出一个 bd 的持有者.    </span></span><br><span class="line">		<span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(abd, beanName);</span><br><span class="line"><span class="comment">// 这里由于传入进来的 scopeMetadata的值是NO,所以就直接返回bdHolder的持有者了.</span></span><br><span class="line"><span class="comment">// 可以看到返回下面的代码,是满足一个增强类的概念的.    </span></span><br><span class="line">		definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry); </span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition</span></span><br><span class="line"><span class="comment">//走到beanFactory中的registerBeanDefinition方法来,先是对bd进行校验,然后利用org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionMap+beaName来判断是不是已经包含了该bean</span></span><br><span class="line"><span class="comment">// 此时如果你是debug的话,你会发现有五个内置的bean已经在该beanDefinitionMap中了.这也是对应了AnnotatedBeanDefinitionReader中处理的内置的bean.</span></span><br><span class="line"><span class="comment">//如果beanDefinitionMap中没有的话,就分为是不是已经开始创建bean了.</span></span><br><span class="line"><span class="comment">//如果没有已经开始创建了,就添加到beanDefinitionMap中来,beanName也会添加到beanDefinitionNames,其实这里有个问题, beanDefinitionMap的key集合就已经是beanName集合了,为什么还单独使用一个集合来维护呢？</span></span><br><span class="line"><span class="comment">// 这样这个bean的信息和bd就放入到 BeanFactory中来了.    </span></span><br><span class="line"><span class="comment">// 如果有别名的注解或者配置的话,就会走到registry.registerAlias(beanName, alias);来进行别名的注册. </span></span><br><span class="line">		BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>这里可以总结下看到 register 方法就是对我们的配置类进行扫描, 然后对是否有一些注解进行判断等. 最后使用 BeanDefinitionReaderUtils 工具类的方法将 bd 给 注册到 Spring 容器中来, 注意这时候是没有实例化我们的 YangBeanScannerConfig,只是封装成 bd + beanName 给注册到 BeanFactory 的 beanDefinitionMap 中来了.</p><h4 id="refresh-方法"><a href="#refresh-方法" class="headerlink" title="refresh() 方法"></a>refresh() 方法</h4><p>更新方法，可以看到这个方法内部是走了很多方法,其逻辑也是比较绕的. 不过没事，我们一个一个方法的来看.</p><p>org.springframework.context.support.AbstractApplicationContext#refresh()</p><p>可以看到其内部的每个方法上面都是有一行注释的.</p><p>于是我们挨个方法来debug进来分析.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用 Object 来当锁对象,避免多个线程同时调用到 refresh 方法来.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">startupShutdownMonitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">  </span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">      <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="prepareRefresh-方法"><a href="#prepareRefresh-方法" class="headerlink" title="prepareRefresh() 方法"></a>prepareRefresh() 方法</h5><p>从注释来看, 设置startup数据 &amp; 标识active来表示状态,同时也会初始化一些资源.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prepare this context for refreshing, setting its startup date and</span></span><br><span class="line"><span class="comment"> * active flag as well as performing any initialization of property sources.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// Switch to active.</span></span><br><span class="line">   <span class="built_in">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 对状态标识的设置.    </span></span><br><span class="line">   <span class="built_in">this</span>.closed.set(<span class="literal">false</span>);</span><br><span class="line">   <span class="built_in">this</span>.active.set(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Refreshing &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;Refreshing &quot;</span> + getDisplayName());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize any placeholder property sources in the context environment.</span></span><br><span class="line"><span class="comment">// 这里暂时没有实现来做事情.    </span></span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Validate that all properties marked as required are resolvable:</span></span><br><span class="line">   <span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line"><span class="comment">// org.springframework.core.env.AbstractEnvironment#validateRequiredProperties</span></span><br><span class="line"><span class="comment">// 对 org.springframework.core.env.AbstractPropertyResolver#requiredProperties 进行检验,如果检验到有问题的话,就会抛出异常来.</span></span><br><span class="line"><span class="comment">// 这里是对 properties 进行检验.    </span></span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line"><span class="comment">// earlyApplicationListeners是null的话,利用applicationListeners来初始化.   </span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.earlyApplicationListeners == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.earlyApplicationListeners = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="built_in">this</span>.applicationListeners);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果已经存在值了,就对  applicationListeners 清空，然后全部添加applicationListeners来.     </span></span><br><span class="line">      <span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">      <span class="built_in">this</span>.applicationListeners.clear();</span><br><span class="line">      <span class="built_in">this</span>.applicationListeners.addAll(<span class="built_in">this</span>.earlyApplicationListeners);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">   <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">   <span class="built_in">this</span>.earlyApplicationEvents = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到该方法的话,对状态标识进行设置. 接着地 propertySources 资源来进行初始化, 于是就对property来进行检验. 接下来是对 earlyApplicationListeners&#x2F;earlyApplicationEvents根据条件来初始化操作.</p><h5 id="obtainFreshBeanFactroy"><a href="#obtainFreshBeanFactroy" class="headerlink" title="obtainFreshBeanFactroy()"></a>obtainFreshBeanFactroy()</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line">   refreshBeanFactory();</span><br><span class="line">   return getBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------</span><br><span class="line">org.springframework.context.support.GenericApplicationContext#refreshBeanFactory</span><br><span class="line">  </span><br><span class="line">// 看到 compareAndSet 有点cas 的味道.    </span><br><span class="line">protected final void refreshBeanFactory() throws IllegalStateException &#123;    </span><br><span class="line">		if (!this.refreshed.compareAndSet(false, true)) &#123;</span><br><span class="line">			throw new IllegalStateException(</span><br><span class="line">					&quot;GenericApplicationContext does not support multiple refresh attempts: just call &#x27;refresh&#x27; once&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">// private String id = ObjectUtils.identityToString(this);</span><br><span class="line">// 这里获取出来的id在这个类被new或者子类调用父类的super()构造方法的时候,就已经被初始化值了的.    </span><br><span class="line">		this.beanFactory.setSerializationId(getId());</span><br><span class="line">	&#125;    </span><br><span class="line">    </span><br><span class="line">-----------------</span><br><span class="line">org.springframework.context.support.GenericApplicationContext#getBeanFactory</span><br><span class="line"></span><br><span class="line">// 这里就直接返回了 DefaultListableBeanFactory.   </span><br><span class="line">	@Override</span><br><span class="line">	public final ConfigurableListableBeanFactory getBeanFactory() &#123;</span><br><span class="line">		return this.beanFactory;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>该方法 设置了一个 SerializationId 到 beanFactory 中来. 最后也是返回了一个 DefaultListableBeanFactory 来.</p><h5 id="prepareBeanFactory-方法"><a href="#prepareBeanFactory-方法" class="headerlink" title="prepareBeanFactory() 方法"></a>prepareBeanFactory() 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configure the factory&#x27;s standard context characteristics,</span></span><br><span class="line"><span class="comment"> * such as the context&#x27;s ClassLoader and post-processors.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the BeanFactory to configure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">   <span class="comment">// Tell the internal bean factory to use the context&#x27;s class loader etc.</span></span><br><span class="line"><span class="comment">// org.springframework.core.io.DefaultResourceLoader#getClassLoader   </span></span><br><span class="line"><span class="comment">// 设置 class 加载器&amp;赋值进去.    </span></span><br><span class="line">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line"><span class="comment">// 将 beanClassLoader放入SpelParserConfiguration中来,SpelExpressionParser中有含有SpelParserConfiguration作为configuration,StandardBeanExpressionResolver属性又含有SpelExpressionParser. 这也就可以理解为beanClassLoader最后是放入到SpelParserConfiguration来.</span></span><br><span class="line">   beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> <span class="title class_">StandardBeanExpressionResolver</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 传入applicationContext和environment到ResourceEditorRegistrar对象来.</span></span><br><span class="line"><span class="comment">//然后添加到beanFactory中来.    </span></span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> <span class="title class_">ResourceEditorRegistrar</span>(<span class="built_in">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line"><span class="comment">// 添加ApplicationContextAwareProcessor后置处理器到org.springframework.beans.factory.support.AbstractBeanFactory#beanPostProcessors中来.</span></span><br><span class="line"><span class="comment">// 在添加后置处理器到Spring容器之前,会判断这个后置处理起是不是InstantiationAwareBeanPostProcessor/DestructionAwareBeanPostProcessor 这二种情况.</span></span><br><span class="line"><span class="comment">// 最后添加到 beanPostProcessors 中来.    </span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationContextAwareProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line"><span class="comment">// 然后这里忽略了六种情况的接口. 为什么要忽略呢? 看一个地方.</span></span><br><span class="line"><span class="comment">// org.springframework.context.support.ApplicationContextAwareProcessor#postProcessBeforeInitialization &amp;  org.springframework.context.support.ApplicationContextAwareProcessor#invokeAwareInterfaces 结合这二个方法来看,是已经对这六种情况的接口做了处理的.    </span></span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">   <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line"><span class="comment">// private final Map&lt;Class&lt;?&gt;, Object&gt; resolvableDependencies = new ConcurrentHashMap&lt;&gt;(16);    </span></span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.DefaultListableBeanFactory#resolvableDependencies,这里将 BeanFactory.class和beanFactory给添加到 resolvableDependencies中来了,这里可以看到resolvableDependencies的key是一个Class类型.</span></span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="built_in">this</span>);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="built_in">this</span>);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line"><span class="comment">// 这里又添加了一个后置处理器.</span></span><br><span class="line"><span class="comment">// 传入一个 ApplicationContext 给后置处理器,然后添加到BeanFactory中来.</span></span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.AbstractBeanFactory#beanPostProcessors,也即是添加到专门存放 后置处理器的集合中来了.    </span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line"><span class="comment">// beanFactory如果有loadTimeWeaver,那么就添加 LoadTimeWeaverAwareProcessor 后置处理器进来   </span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">      <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register default environment beans.</span></span><br><span class="line"><span class="comment">// 不包含environment/systemProperties/systemEnvironment，就会添加到org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#singletonObjects中来.    </span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到,prepareBeanFactory 中做了这些事情 : 添加了 beanClassLoader,添加了二个后置处理器,然后注册了四个 BeanFactory&#x2F;ResourceLoader&#x2F;ApplicationEventPublisher&#x2F;ApplicationContext 到DefaultListableBeanFactory#resolvableDependencies中来了.</p><p>最后判断beanFactory是不是不包含一些关于环境的bean,如果是的话,那就调用registerSingleton方法给注册进来.</p><p>还是可以看到，这里都是在为环境做准备工作.</p><h5 id="postProcessBeanFactory-方法"><a href="#postProcessBeanFactory-方法" class="headerlink" title="postProcessBeanFactory() 方法"></a>postProcessBeanFactory() 方法</h5><p>略略略, 该方法暂无实现类来搞事情…..</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Modify the application context&#x27;s internal bean factory after its standard</span></span><br><span class="line"><span class="comment"> * initialization. All bean definitions will have been loaded, but no beans</span></span><br><span class="line"><span class="comment"> * will have been instantiated yet. This allows for registering special</span></span><br><span class="line"><span class="comment"> * BeanPostProcessors etc in certain ApplicationContext implementations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="invokeBeanFactoryPostProcessors-方法"><a href="#invokeBeanFactoryPostProcessors-方法" class="headerlink" title="invokeBeanFactoryPostProcessors 方法"></a>invokeBeanFactoryPostProcessors 方法</h5><p>这些是对beanFactoryPostProcessors进行处理. 是借用了 PostProcessorRegistrationDelegate.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate and invoke all registered BeanFactoryPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before singleton instantiation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line"><span class="comment">// getBeanFactoryPostProcessors() 获取出来的是空集合.    </span></span><br><span class="line">   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">   <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="literal">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="org-springframework-context-support-PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors-org-springframework-beans-factory-config-ConfigurableListableBeanFactory-java-util-List-lt-org-springframework-beans-factory-config-BeanFactoryPostProcessor-gt"><a href="#org-springframework-context-support-PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors-org-springframework-beans-factory-config-ConfigurableListableBeanFactory-java-util-List-lt-org-springframework-beans-factory-config-BeanFactoryPostProcessor-gt" class="headerlink" title="org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;)"></a>org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;)</h6><p>该方法从代码上来看,还是做了蛮多的事情.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">      ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">   Set&lt;String&gt; processedBeans = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是满足条件的    </span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">      <span class="type">BeanDefinitionRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">      List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 beanFactory的后置处理器进行迭代处理操作.       </span></span><br><span class="line">      <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">         <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">            <span class="type">BeanDefinitionRegistryPostProcessor</span> <span class="variable">registryProcessor</span> <span class="operator">=</span></span><br><span class="line">                  (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">            registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">            registryProcessors.add(registryProcessor);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            regularPostProcessors.add(postProcessor);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">      <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">      <span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line">      <span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">      List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line"><span class="comment">// 根据 BeanDefinitionRegistryPostProcessor.class 来获取beanNames数组,</span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.internalConfigurationAnnotationProcessor 这里是获取到了一个内置的BeanFactroyPostProcessor.      </span></span><br><span class="line">      String[] postProcessorNames =</span><br><span class="line">            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"> <span class="comment">// 判断是不是有PriorityOrdered,         </span></span><br><span class="line">         <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line"> <span class="comment">// 这里的getBean就已经对bean进行初始化，是真正的走反射构造函数拿出来的实例对象.</span></span><br><span class="line"> <span class="comment">// getBean需要仔细分析下，因为其内部在 createBean是走了很多后置处理起来进行增强的. </span></span><br><span class="line"><span class="comment">// ConfigurationClassPostProcessor 给添加进来.             </span></span><br><span class="line">            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line"><span class="comment">// beanName 添加到 processedBeans集合中来了.             </span></span><br><span class="line">            processedBeans.add(ppName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 对集合进行排序,从beanFactory中获取出dependencyComparator来,如果没有的话,就用OrderComparator.INSTANCE默认的</span></span><br><span class="line">      sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line"><span class="comment">// 全部添加到 registryProcessors 中来.       </span></span><br><span class="line">      registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line"><span class="comment">// org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry</span></span><br><span class="line"><span class="comment">//这里是进入到ConfigurationClassPostProcessor中来了,可以看到其接口 BeanDefinitionRegistryPostProcessor,是重写了接口的方法. </span></span><br><span class="line"><span class="comment">// ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry 做了什么事情呢?</span></span><br><span class="line"><span class="comment">// 用System.identityHashCode(registry);计算出registryId来,如果在org.springframework.context.annotation.ConfigurationClassPostProcessor#registriesPostProcessed/factoriesPostProcessed(二个集合)中已经包含了的话,就会抛出已经被调用过的异常来.如果没有的话,就会添加到registriesPostProcessed中来</span></span><br><span class="line"><span class="comment">// 继续看 org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions 方法,</span></span><br><span class="line"><span class="comment">//先从registry中获取beanNames来,这其中就有Spring内置的和我们自己定义的yangBeanScannerConfig</span></span><br><span class="line"><span class="comment">//对beanNames迭代处理,接着就用ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)来判断要不要添加到List&lt;BeanDefinitionHolder&gt; configCandidates集合中来,最后是我们定义的beanName给添加进来了.</span></span><br><span class="line"><span class="comment">// 对configCandidates集合进行排序,</span></span><br><span class="line"><span class="comment">// 创建一个ConfigurationClassParser对象来解析每个@Configuration注解类.调用其parse和validate方法,解析完后就是一个ConfigurationClass的Set集合,接着就是new了一个ConfigurationClassBeanDefinitionReader对象来,</span></span><br><span class="line"><span class="comment">// this.reader.loadBeanDefinitions(configClasses); 这行代码有点根据Config去解析bean的意思.    </span></span><br><span class="line"><span class="comment">// 具体要等到后面深度解析再反过来定位每行代码的意思.</span></span><br><span class="line"><span class="comment">// 最后再清除下缓存.       </span></span><br><span class="line">      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line"><span class="comment">// 清空 currentRegistryProcessors 集合      </span></span><br><span class="line">      currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="comment">// 如果processedBeans集合中不包含并且type是Ordered.class才满足进来的条件.          </span></span><br><span class="line">         <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">            processedBeans.add(ppName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 所以这里的currentRegistryProcessors集合是空集合.       </span></span><br><span class="line">      sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">      registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">      currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line"><span class="comment">// 这里用 while 循环来最后解析,判断从getBeanNamesForType获取出来的bean是不是被解析过了的. </span></span><br><span class="line"><span class="comment">// 也是用 processedBeans 集合来进行控制的. </span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">reiterate</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">         reiterate = <span class="literal">false</span>;</span><br><span class="line">         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">         <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">               processedBeans.add(ppName);</span><br><span class="line">               reiterate = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">         registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">         currentRegistryProcessors.clear();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanFactory,这里是走到了postProcessBeanFactory回调方法来了.用org.springframework.context.annotation.ConfigurationClassPostProcessor#factoriesPostProcessed集合来控制是否解析过了.用registriesPostProcessed集合来判断上次是否进入到postProcessBeanDefinitionRegistry方法中来. 如果没有的话,就会再走一边processConfigBeanDefinitions,可以看到 postProcessBeanDefinitionRegistry 方法最后也是走到了processConfigBeanDefinitions中来了.</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.ConfigurationClassPostProcessor#enhanceConfigurationClasses 该方法判断是不是需要代理来增强,这里是没有的,所以就直接return掉了.</span></span><br><span class="line"><span class="comment">// 最后添加一个 ImportAwareBeanPostProcessor 后置处理器进来.       </span></span><br><span class="line">      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line"><span class="comment">// 这里的regularPostProcessors 集合是empty.       </span></span><br><span class="line">      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">   <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line"> <span class="comment">// org.springframework.context.annotation.internalConfigurationAnnotationProcessor和org.springframework.context.event.internalEventListenerProcessor这里获取出来的是二个.   </span></span><br><span class="line">   String[] postProcessorNames =</span><br><span class="line">         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">   <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"> <span class="comment">// 这里是对上面已经处理过了的进行过滤处理.      </span></span><br><span class="line">      <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">         <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">// 这里分为 PriorityOrdered&amp;Ordered&amp;非前二者,分这三种情况分别放入到三个不同的集合中.</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">         orderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是可以看到先是对PriorityOrdered进行处理,再对Ordered处理,最后对非前二者进行处理.    </span></span><br><span class="line">   <span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line"> <span class="comment">// 注意这里是调用了getBean方法.      </span></span><br><span class="line">      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 排序    </span></span><br><span class="line">   sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line"> <span class="comment">// 注意这里也是调用了 getBean 方法的.      </span></span><br><span class="line">      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// org.springframework.context.event.EventListenerMethodProcessor#postProcessBeanFactory</span></span><br><span class="line"><span class="comment">// 这里由于只有一个EventListenerMethodProcessor处理器,所以对应起来的走到其postProcessBeanFactory方法中来.</span></span><br><span class="line"><span class="comment">// 这里也是调用 postProcessBeanFactory 方法的意思,也就是回调方法.    </span></span><br><span class="line">   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">   <span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.DefaultListableBeanFactory#clearMetadataCache</span></span><br><span class="line"><span class="comment">// 对 一些集合等进行清除.    </span></span><br><span class="line">   beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此就可以看到,该方法主要是对BeanDefinitionRegistryPostProcessor.class和BeanFactoryPostProcessor.class来进行处理.</p><p>BeanDefinitionRegistryPostProcessor 又是先处理PriorityOrdered,然后会将处理过的放入processedBeans集合中做一个总的记录，再处理非再processedBeans集合记录中的和是Ordered的,最后用while循环来再确认一遍是不是有还没处理的,这个时候控制条件也是通过 processedBeans来控制是不是处理过了的. 这里注意, 实例化是通过调用 getBean方法来实现的,所以你会发现再调用invokeBeanDefinitionRegistryPostProcessors方法之前,都是会有调用getBean方法的.</p><p>BeanFactoryPostProcessor 的处理,这里是一次获取出,然后分为 PriorityOrdered&#x2F;Ordered&#x2F;非前二者，分别放入三个集合中进行处理,前提是都没再 processedBeans 集合中. 这里可以看到,如果是PriorityOrdered类型的话，那么在分类的时候就已经调用getBean方法来实例化这个对象了，其他二者都是最后迭代遍历的时候调用getBean方法的. 最后都是sortPostProcessors走下排序，然后调用invokeBeanFactoryPostProcessors方法，这个方法的意思，也就是调用 重写的 postProcessBeanFactory 的方法.</p><h5 id="registerBeanPostProcessors-方法"><a href="#registerBeanPostProcessors-方法" class="headerlink" title="registerBeanPostProcessors 方法"></a>registerBeanPostProcessors 方法</h5><p>该方法传入 beanFactory进来,然后直接借助 PostProcessorRegistrationDelegate 来实现.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">   PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="registerBeanPostProcessors-方法-1"><a href="#registerBeanPostProcessors-方法-1" class="headerlink" title="registerBeanPostProcessors 方法"></a>registerBeanPostProcessors 方法</h6><p>从名字上不难理解，注册 Bean的后置处理器进来.</p><p>这里传入进来的 beanFactory 是 DefaultListableBeanFactory , applicationContext是AnnotationConfigApplicationContext</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">      ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取出 BeanPostProcessor 的名字.</span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.internalCommonAnnotationProcessor</span></span><br><span class="line"><span class="comment">// 这里获取出来的是二个内部的后置处理器,因为我这里并没有扩展,只是简单的进行说明了下,后面会详细分析。</span></span><br><span class="line"><span class="comment">// 就是这行代码获取的是什么.    </span></span><br><span class="line">   String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line">   <span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line">   <span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line"> <span class="comment">// 6   </span></span><br><span class="line">   <span class="type">int</span> <span class="variable">beanProcessorTargetCount</span> <span class="operator">=</span> beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line"><span class="comment">// 传入beanFactory和个数,创建出一个检查bean的后置处理器来.</span></span><br><span class="line"><span class="comment">// org.springframework.context.support.PostProcessorRegistrationDelegate.BeanPostProcessorChecker</span></span><br><span class="line"><span class="comment">// 有兴趣的同学可以看到该后置处理器重写的方法做了什么事情.</span></span><br><span class="line"><span class="comment">// 最后添加到 beanFactory 中来.    </span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">BeanPostProcessorChecker</span>(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">   <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">   List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 对后置处理器进行迭代   </span></span><br><span class="line">   <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">      <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">   <span class="comment">// 注意这里调用 getBean 方法是已经实例化这个后置处理起了.</span></span><br><span class="line"><span class="comment">// AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment">// CommonAnnotationBeanPostProcessor</span></span><br><span class="line"> <span class="comment">// 这里实例化的是Spring内置的二个         </span></span><br><span class="line">         <span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">         priorityOrderedPostProcessors.add(pp);</span><br><span class="line">      <span class="comment">// 内部的二个后置处理器都是有实现   MergedBeanDefinitionPostProcessor 的. </span></span><br><span class="line">         <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">         orderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line"><span class="comment">// 排序    </span></span><br><span class="line">   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"><span class="comment">// 添加到 org.springframework.beans.factory.support.AbstractBeanFactory#beanPostProcessors,也就是添加到Spring的BanFactory中来.    </span></span><br><span class="line">   registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line"><span class="comment">// 这里是对实现了 Ordered 类型的处理，很显然我这里是没有的.    </span></span><br><span class="line">   List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">      <span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">      orderedPostProcessors.add(pp);</span><br><span class="line">      <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">         internalPostProcessors.add(pp);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">   registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line"><span class="comment">// 最后是对非 PriorityOrdered和Ordered的处理，    </span></span><br><span class="line">   List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">      <span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">      nonOrderedPostProcessors.add(pp);</span><br><span class="line">      <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">         internalPostProcessors.add(pp);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line"><span class="comment">// 这里可以看到,最后对内部的后置处理器又重新注册了一遍.    </span></span><br><span class="line">   sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">   registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">   <span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line"><span class="comment">// ApplicationListenerDetector 这里也是对  ApplicationListenerDetector 也是重新注册一遍.   </span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法 借助 org.springframework.context.support.PostProcessorRegistrationDelegate#registerBeanPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, org.springframework.context.support.AbstractApplicationContext) 来，获取BeanPostProcessor的后置处理器,也是分为 PriorityOrdered &#x2F; Ordered&#x2F; 前二者都没有，在 PriorityOrdered 分类的时候，就已经调用了 getBean方法来获取出 bean 对象来(这里依然是分为了三个集合来装数据&amp;处理). 然后调用getBean方法后,就调用registerBeanPostProcessors方法，将后置处理器给注册到 Spring 的BeanFactory 中来.</p><p>最后还会最内部的 BeanPost后置处理器 &amp; ApplicationListenerDetector 再重新注册一遍.</p><p>可能会比较好奇这个后置处理器是干什么用的 ？ 在后面实例化 bean 的时候，就可以看到是有走很多后置处理器的.</p><p>所以该方法是对 beanPost的后置处理器进行实例化并且注册到 Spring 的 BeanFactory 中来的.</p><h5 id="initMessageSource-方法"><a href="#initMessageSource-方法" class="headerlink" title="initMessageSource () 方法"></a>initMessageSource () 方法</h5><p>初始化 messageSource .</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the MessageSource.</span></span><br><span class="line"><span class="comment"> * Use parent&#x27;s if none defined in this context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initMessageSource</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// 获取出 beanFactory   </span></span><br><span class="line">   <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line"><span class="comment">// 如果 beanFactory 包含了名字是messageSource的本地bean.    </span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">  <span class="comment">// 从 beanFactory 中获取出来.     </span></span><br><span class="line">      <span class="built_in">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line">      <span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line"><span class="comment">// this.parent不是null并且   messageSource是   HierarchicalMessageSource类型 </span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">  <span class="comment">// 强转,判断  getParentMessageSource 是不是null,如果是null的话,就调用 getInternalParentMessageSource() 将获取出来的值给set进去.     </span></span><br><span class="line">         <span class="type">HierarchicalMessageSource</span> <span class="variable">hms</span> <span class="operator">=</span> (HierarchicalMessageSource) <span class="built_in">this</span>.messageSource;</span><br><span class="line">         <span class="keyword">if</span> (hms.getParentMessageSource() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line">            <span class="comment">// registered already.</span></span><br><span class="line">            hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Using MessageSource [&quot;</span> + <span class="built_in">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 这里是不包含的情况.       </span></span><br><span class="line">      <span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line">      <span class="type">DelegatingMessageSource</span> <span class="variable">dms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegatingMessageSource</span>();</span><br><span class="line"><span class="comment">// getInternalParentMessageSource() 返回的是null       </span></span><br><span class="line">      dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">      <span class="built_in">this</span>.messageSource = dms;</span><br><span class="line"><span class="comment">// 注册到 beanFactory 中来       </span></span><br><span class="line">      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="built_in">this</span>.messageSource);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + MESSAGE_SOURCE_BEAN_NAME + <span class="string">&quot;&#x27; bean, using [&quot;</span> + <span class="built_in">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法可以看到是对 messageSource 的初始化进行操作.</p><h5 id="initApplicationEventMulticaster-方法"><a href="#initApplicationEventMulticaster-方法" class="headerlink" title="initApplicationEventMulticaster 方法"></a>initApplicationEventMulticaster 方法</h5><p>这里如果了解过 Spring 的Event 机制的话,是可以比较清晰的感觉到,是对 ApplicationEventMulticaster 的初始化.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the ApplicationEventMulticaster.</span></span><br><span class="line"><span class="comment"> * Uses SimpleApplicationEventMulticaster if none defined in the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.event.SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initApplicationEventMulticaster</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 获取出 beanFactory 来.  </span></span><br><span class="line">   <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line"><span class="comment">// 判断 beanFactory 是否包含  applicationEventMulticaster    </span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line"><span class="comment">// 如果包含的话，就直接从beanFactroy中获取出来,并且赋值给  applicationEventMulticaster  </span></span><br><span class="line">      <span class="built_in">this</span>.applicationEventMulticaster =</span><br><span class="line">            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Using ApplicationEventMulticaster [&quot;</span> + <span class="built_in">this</span>.applicationEventMulticaster + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// 如果不包含的话,传入beanFactory接着就是new一个SimpleApplicationEventMulticaster出来      </span></span><br><span class="line">      <span class="built_in">this</span>.applicationEventMulticaster = <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>(beanFactory);</span><br><span class="line"><span class="comment">// 然后注册到 beanFactory 中来.      </span></span><br><span class="line">      beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="built_in">this</span>.applicationEventMulticaster);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">&quot;&#x27; bean, using &quot;</span> +</span><br><span class="line">               <span class="string">&quot;[&quot;</span> + <span class="built_in">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到, 主要是对 applicationEventMulticaster 的初始化.</p><p>如果beanFactory有的话，就从其中拿，如果没有就自己new一个,最后注册到beanFactory中来.</p><h5 id="onRefresh-方法"><a href="#onRefresh-方法" class="headerlink" title="onRefresh() 方法"></a>onRefresh() 方法</h5><p>这里是没有做任何事情的，如果是SpringBoot的源码的，这里就是启动tomcat的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Template method which can be overridden to add context-specific refresh work.</span></span><br><span class="line"><span class="comment"> * Called on initialization of special beans, before instantiation of singletons.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation is empty.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refresh()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="registerListeners-方法"><a href="#registerListeners-方法" class="headerlink" title="registerListeners() 方法"></a>registerListeners() 方法</h5><p>从名字来看,这里是注册监听器的意思.</p><p>org.springframework.context.event.AbstractApplicationEventMulticaster.ListenerRetriever#applicationListeners 这里是存放监听器的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add beans that implement ApplicationListener as listeners.</span></span><br><span class="line"><span class="comment"> * Doesn&#x27;t affect other listeners, which can be added without being beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerListeners</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// Register statically specified listeners first.</span></span><br><span class="line"><span class="comment">// getApplicationListeners() 获取出来的是空集合.    </span></span><br><span class="line">   <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">      getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">   <span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line"><span class="comment">// 根据ApplicationListener来获取出监听器，这也也是没有的.     </span></span><br><span class="line">   String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">   <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line"><span class="comment">// 这里也是获取早初始的 ApplicationEvent.    </span></span><br><span class="line">   Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="built_in">this</span>.earlyApplicationEvents;</span><br><span class="line">   <span class="built_in">this</span>.earlyApplicationEvents = <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (earlyEventsToProcess != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">         getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType) 可以看下这个方法或者后续我们再详细的看，Spring是如何发送event的，以及那些监听器是怎么获取到 event 的.</p><p>TODO : 这里后面是有待详细的讲解的.</p><h5 id="finishBeanFactoryInitialization-方法"><a href="#finishBeanFactoryInitialization-方法" class="headerlink" title="finishBeanFactoryInitialization() 方法"></a>finishBeanFactoryInitialization() 方法</h5><p>从名字理解上,这里是对 beanFactory的初始化结束.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the initialization of this context&#x27;s bean factory,</span></span><br><span class="line"><span class="comment"> * initializing all remaining singleton beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">   <span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line"> <span class="comment">// 如果beanFactroy包含conversionService并且type是ConversionService.class的话，</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line"><span class="comment">// 就会从beanFactory中获取出对象设置到beanFactory的ConversionService来.       </span></span><br><span class="line">      beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">   <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">   <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line"><span class="comment">//org.springframework.beans.factory.support.AbstractBeanFactory#addEmbeddedValueResolver //添加到org.springframework.beans.factory.support.AbstractBeanFactory#embeddedValueResolvers中来.      </span></span><br><span class="line">      beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line"><span class="comment">// 根据  LoadTimeWeaverAware.class 来获取信息.   </span></span><br><span class="line"><span class="comment">// 很明显这里我们是没有配置的,所以也就是没有的.    </span></span><br><span class="line">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">   <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">      getBean(weaverAwareName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">   beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line"><span class="comment">//org.springframework.beans.factory.support.DefaultListableBeanFactory#freezeConfiguration</span></span><br><span class="line"><span class="comment">// 设置configurationFrozen是true,</span></span><br><span class="line"><span class="comment">// 将beanDefinitionNames集合转哈为String类型的数组. StringUtils.toStringArray(this.beanDefinitionNames);使用这个方法即可.    </span></span><br><span class="line">   beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">   beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="preInstantiateSingletons-方法"><a href="#preInstantiateSingletons-方法" class="headerlink" title="preInstantiateSingletons 方法"></a>preInstantiateSingletons 方法</h6><p>这里就是对 单例池 里面的对象进行初始化,可以看到是有 getBean 方法的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">   <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line"><span class="comment">// 这里获取出来的 beanNames 是有6个的,其中五个是包含了内部的</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.internalCommonAnnotationProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.event.internalEventListenerProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.event.internalEventListenerFactory</span></span><br><span class="line"><span class="comment">//yangBeanScannerConfig    </span></span><br><span class="line">   List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      <span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">       </span><br><span class="line">  <span class="comment">// bd 不是抽象的&amp;是单例的&amp;不是赖加载的     </span></span><br><span class="line">      <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">  <span class="comment">// 判断是不是 FactroyBean        </span></span><br><span class="line">         <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">               <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">               <span class="type">boolean</span> isEagerInit;</span><br><span class="line">               <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                  isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                              ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                        getAccessControlContext());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                  isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                        ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                  getBean(beanName);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这里不是 FactoryBean  </span></span><br><span class="line"><span class="comment">// 可以看到当我走到yangBeanScannerConfig,我们定义的类的时候,走完这个方法，就可以看到com.iyang.spring.config.YangBeanScannerConfig#YangBeanScannerConfig中打印的语句了,也就是说走完这里，我们定义的bean就已经被Spring被实例化了.             </span></span><br><span class="line">            getBean(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line"><span class="comment">// 这里再对 beanNames 进行迭代,如果是 SmartInitializingSingleton 的话，就会再调用    afterSingletonsInstantiated 方法.</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">singletonInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="type">SmartInitializingSingleton</span> <span class="variable">smartSingleton</span> <span class="operator">=</span> (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">         <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">               smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以对我们定义的 bean 进行实例化，最后是调用了 getBean 方法， getBean 方法表面看上去是获取，其实如果没有的话，调用的是createBean方法, 也就是会实例化我们的bean。当然它肯定不会很简单的去调用反射就实例化完一个我们的bean,肯定是有一系列的走Spring内置的或者我们自己定义的后置处理器等操作.</p><p>getBean 方法需要后面专门领出来分析，不能简单的过，这里对 Spring 容器进行大致的flow过,所以还是比较轻描淡写的写过去.</p><h5 id="finishRefresh-方法"><a href="#finishRefresh-方法" class="headerlink" title="finishRefresh 方法"></a>finishRefresh 方法</h5><p>中文式的英语 : 结束刷新方法.</p><p>显示清除缓存,再是init了LifecycleProcessor,调用其onRefresh()方法,接近就是发送一个ContextRefreshedEvent事件出来.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the refresh of this context, invoking the LifecycleProcessor&#x27;s</span></span><br><span class="line"><span class="comment"> * onRefresh() method and publishing the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.context.event.ContextRefreshedEvent&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line"><span class="comment">//对org.springframework.core.io.DefaultResourceLoader#resourceCaches进行清除.    </span></span><br><span class="line">   clearResourceCaches();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line">   initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line"><span class="comment">//org.springframework.context.support.DefaultLifecycleProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.support.DefaultLifecycleProcessor#startBeans</span></span><br><span class="line">    </span><br><span class="line">   getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Publish the final event.</span></span><br><span class="line"><span class="comment">// 推送Event,这里的Event是 ContextRefreshedEvent.    </span></span><br><span class="line">   publishEvent(<span class="keyword">new</span> <span class="title class_">ContextRefreshedEvent</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line"><span class="comment">//org.springframework.context.support.LiveBeansView#registerApplicationContext</span></span><br><span class="line"><span class="comment">//先根据key:spring.liveBeansView.mbeanDomain获取value,这里获取出来的是null,</span></span><br><span class="line"><span class="comment">// 所以也就是没有下文了.    </span></span><br><span class="line">   LiveBeansView.registerApplicationContext(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="initLifecycleProcessor-方法"><a href="#initLifecycleProcessor-方法" class="headerlink" title="initLifecycleProcessor 方法 ()"></a>initLifecycleProcessor 方法 ()</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Initialize the LifecycleProcessor.</span><br><span class="line"> * Uses DefaultLifecycleProcessor if none defined in the context.</span><br><span class="line"> * @see org.springframework.context.support.DefaultLifecycleProcessor</span><br><span class="line"> */</span><br><span class="line">protected void initLifecycleProcessor() &#123;</span><br><span class="line">  // 获取出 beanFactory 来.  </span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">// 判断beanFactory中是否包含lifecycleProcessor    </span><br><span class="line">   if (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">// 包含的话,就会获取出来,指向this.lifecycleProcessor       </span><br><span class="line">      this.lifecycleProcessor =</span><br><span class="line">            beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor.class);</span><br><span class="line">      if (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(&quot;Using LifecycleProcessor [&quot; + this.lifecycleProcessor + &quot;]&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">   // 如果不包含的话，就自己new一个,然后注册到Spring容器中来.    </span><br><span class="line">      DefaultLifecycleProcessor defaultProcessor = new DefaultLifecycleProcessor();</span><br><span class="line">      defaultProcessor.setBeanFactory(beanFactory);</span><br><span class="line">      this.lifecycleProcessor = defaultProcessor;</span><br><span class="line">      beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, this.lifecycleProcessor);</span><br><span class="line">      if (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(&quot;No &#x27;&quot; + LIFECYCLE_PROCESSOR_BEAN_NAME + &quot;&#x27; bean, using &quot; +</span><br><span class="line">               &quot;[&quot; + this.lifecycleProcessor.getClass().getSimpleName() + &quot;]&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="publishEvent-方法"><a href="#publishEvent-方法" class="headerlink" title="publishEvent 方法"></a>publishEvent 方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Publish the given event to all listeners.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> event the event to publish (may be an &#123;<span class="doctag">@link</span> ApplicationEvent&#125;</span></span><br><span class="line"><span class="comment"> * or a payload object to be turned into a &#123;<span class="doctag">@link</span> PayloadApplicationEvent&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eventType the resolved event type, if known</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(Object event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> &#123;</span><br><span class="line">   Assert.notNull(event, <span class="string">&quot;Event must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Decorate event as an ApplicationEvent if necessary</span></span><br><span class="line">   ApplicationEvent applicationEvent;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 对传入进来的 event 进行类型的判断.    </span></span><br><span class="line">   <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line">      applicationEvent = (ApplicationEvent) event;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      applicationEvent = <span class="keyword">new</span> <span class="title class_">PayloadApplicationEvent</span>&lt;&gt;(<span class="built_in">this</span>, event);</span><br><span class="line">      <span class="keyword">if</span> (eventType == <span class="literal">null</span>) &#123;</span><br><span class="line">         eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Multicast right now if possible - or lazily once the multicaster is initialized</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.earlyApplicationEvents != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType)</span></span><br><span class="line"><span class="comment">//走到了这里来发送event的,       </span></span><br><span class="line">      getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Publish event via parent context as well...</span></span><br><span class="line"><span class="comment">// 这里的 parent是null.    </span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">         ((AbstractApplicationContext) <span class="built_in">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.parent.publishEvent(event);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是发送ContextRefreshedEvent事件出来.</p><h5 id="resetCommonCaches-方法"><a href="#resetCommonCaches-方法" class="headerlink" title="resetCommonCaches 方法()"></a>resetCommonCaches 方法()</h5><p>可以看到 finally 代码块中是疯狂的清除各种缓存.</p><p>可以大家可以点进去详细的看下，具体就不仔细描述了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reset Spring&#x27;s common reflection metadata caches, in particular the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ReflectionUtils&#125;, &#123;<span class="doctag">@link</span> AnnotationUtils&#125;, &#123;<span class="doctag">@link</span> ResolvableType&#125;</span></span><br><span class="line"><span class="comment"> * and &#123;<span class="doctag">@link</span> CachedIntrospectionResults&#125; caches.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ReflectionUtils#clearCache()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AnnotationUtils#clearCache()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ResolvableType#clearCache()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> CachedIntrospectionResults#clearClassLoader(ClassLoader)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">resetCommonCaches</span><span class="params">()</span> &#123;</span><br><span class="line">   ReflectionUtils.clearCache();</span><br><span class="line">   AnnotationUtils.clearCache();</span><br><span class="line">   ResolvableType.clearCache();</span><br><span class="line">   CachedIntrospectionResults.clearClassLoader(getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后总结下,Spring在加载 bean &amp; 处理内置的一些配置 &amp; 内部处理器的时候,是下了很多的功夫。可以看着这些方法一步一步的分析下去,理解起来，个人感觉这里还不是特别深入的跟进去了代码，只是一个简单的大概描述，更深入的知识需要更加详细的理解等了.</p><p>这里只是简单的对这个整个flow来进行描述，还不是特别有详细的那种.</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/11/04/spring/spring%E5%88%9D%E5%A7%8B%E5%8C%96-%E4%B8%89/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/04/spring/spring%E5%88%9D%E5%A7%8B%E5%8C%96-%E4%B8%89/" class="post-title-link" itemprop="url">spring初始化(三)</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-04 00:16:33" itemprop="dateCreated datePublished" datetime="2021-11-04T00:16:33+08:00">2021-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>9.9k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>9 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h4 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h4><p>前面讲到了这么多的什么BeanPostProcessor,事件什么的. 如果不写几下代码这里怕是很难弄清楚是个怎么回事. 所以只有看到代码跑,就大致可以看到其效果还是很明显的.</p><h4 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h4><p>先写一个类简单实现下 BeanDefinitionRegistryPostProcessor 这个接口 :</p><p>运行后的结果是可以很明显的看到我们的打印数据输出结果的.</p><p>程序是怎么运行到这个地方来的呢？</p><p>org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;) 走到这个方法的</p><p>beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class…..),从这个类中获取出来的postProcessorNames,就有包含我们的自己定义的一个.</p><p>由于我们自己扩展的这个类,是没有实现 PriorityOrdered&#x2F;Ordered的,所以就放到最后来处理了.</p><p>也就是在这个方法,while (reiterate) { … invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);}</p><p>走的这个方法的时候,才会去走到我们定义的类。</p><p>那是因为这个地方 Spring是有处理顺序的。 先处理 PriorityOrdered.class , 再处理 Ordered.class , 最后处理既没有PriorityOrdered,也没有Ordered的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GavinYangRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GavinYangRegistryPostProcessor</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;GavinYangRegistryPostProcessor 构造方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用到 GavinYangRegistryPostProcessor#postProcessBeanDefinitionRegistry方法&quot;</span>);</span><br><span class="line">        String[] beanDefinitionNames = registry.getBeanDefinitionNames();</span><br><span class="line">        <span class="type">String</span> <span class="variable">bdNamesString</span> <span class="operator">=</span> Arrays.toString(beanDefinitionNames);</span><br><span class="line">        System.out.println(<span class="string">&quot;GavinYangRegistryPostProcessor 类中&quot;</span> + bdNamesString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h4><p>简单实现一下 BeanFactoryPostProcessor 这个接口来看一下效果.</p><p>先写一个类 : 然后实现一下这个接口 BeanFactoryPostProcessor , 我们这里就获取下beanFactory中的所有beanDefinitionNames的数组, 然后打印出来看下效果. 打印结果也是贴在下面的. 接着我们看下其源码是一个怎么样的走向.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GavinYangBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        String[] beanDefinitionNames = beanFactory.getBeanDefinitionNames();</span><br><span class="line">        System.out.println(Arrays.toString(beanDefinitionNames));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[org.springframework.context.annotation.internalConfigurationAnnotationProcessor, org.springframework.context.annotation.internalAutowiredAnnotationProcessor, org.springframework.context.annotation.internalCommonAnnotationProcessor, org.springframework.context.event.internalEventListenerProcessor, org.springframework.context.event.internalEventListenerFactory, yangBeanOne, gavinYangBeanFactoryPostProcessor, yangBeanPostProcessor, gavinYangLifeImpl]</span></span><br></pre></td></tr></table></figure><p>直接看这个类的这个方法，我这里只截取了一部分代码,也就是和 BeanFactoryPostProcessor 有关的代码.</p><p>和它没关系的代码,这里就没有去截取了.</p><p>org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;) .</p><p>看源码看是如何调用到这个方法的,还是比较好理解。先是根据 BeanFactoryPostProcessor.class获取出beanName的集合,然后老规矩进行一些特定的排序,当然我这里什么都没做,也就是最后处理哦。</p><p>然后跟到invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);这个方法里面,可以看到它迭代这个集合的元素,当然了,我们只需要关注我们自己定义的哪个就可以了,然后就会走其postProcessBeanFactory方法,也就是走到了我们定义的类的这个方法上来了.</p><p>OK啦。大致流程就是这个样子的,还是比较好理解的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line"><span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line"><span class="comment">// 这个地方获取出来的数组里面的值,就有我们想看到的.</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.event.internalEventListenerProcessor</span></span><br><span class="line"><span class="comment">//gavinYangBeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">//当看到第三个是不是非常的熟悉.没错,这就是我们自己定义的.</span></span><br><span class="line">String[] postProcessorNames =</span><br><span class="line">      beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line"><span class="comment">// Ordered, and the rest.</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 然后先经过一轮排序,就可以看到 我们自己定义的就放入到了nonOrderedPostProcessorNames这个集合中,</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">   <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">      <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">      priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">      orderedPostProcessorNames.add(ppName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">   orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">   nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后我们直接看到处理nonOrderedPostProcessors这个集合的方法,</span></span><br><span class="line"><span class="comment">//因为这个方法也会走到我们自己定义的类中去</span></span><br><span class="line"><span class="comment">//方法里面对nonOrderedPostProcessors进行迭代,然后一次调用其postProcessBeanFactory方法,同时也传入了beanFactory到里面去.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br></pre></td></tr></table></figure><h4 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h4><p>我们先写一个 Bean. 然后可以里面写一个属性,方便标识.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YangBeanOne</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">YangBeanOne</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;YangBeanOne无参数构造函数&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们自定义一个BeanPostProcessor,其实现了BeanPostProcessor接口.</p><p>可以看到的是,我们在if中做了beanName的判断,如果是的话,那么我们就会强转,然后给name字段赋值上GavinYang的值.</p><p>我们给断点打到 if这里，然后看进来的堆栈信息,发现其是在初始化bean中,然后调用beanPostProcessor的postProcessAfterInitialization的方法才会走到这里,也就是在doCreateBean这个方法里面.</p><p>然后这个 YangBeanPostProcessor 是什么时候给添加到 beanFactory中去的呢？</p><p>org.springframework.context.support.PostProcessorRegistrationDelegate#registerBeanPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, org.springframework.context.support.AbstractApplicationContext)在这个方法打上断点,然后你会发现其get出来的postProcessorNames数组,就有我们的这个YangBeanPostProcessor，然后走registerBeanPostProcessors方法的时候,就会给添加到beanFactory中去.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YangBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;yangBeanOne&quot;</span>.equalsIgnoreCase(beanName))&#123;</span><br><span class="line">            ((YangBeanOne) bean).setName(<span class="string">&quot;GavinYang&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类 :</p><p>这就打印出来的结果就可以看到的是GavinYang,也就是说我们初始化这个bean之后,然后给其name属性赋值上了GavinYang这个值.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringStartMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(<span class="string">&quot;com.iyang.spring&quot;</span>);</span><br><span class="line">        <span class="type">YangBeanOne</span> <span class="variable">yangBeanOne</span> <span class="operator">=</span> context.getBean(YangBeanOne.class);</span><br><span class="line">        System.out.println(yangBeanOne.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lifecycle-扩展"><a href="#Lifecycle-扩展" class="headerlink" title="Lifecycle 扩展"></a>Lifecycle 扩展</h4><p>Lifecycle 扩展要比起 BeanPostProcessor要好理解得多,因为你只用去实现这个接口(SmartLifecycle),然后在org.springframework.context.support.AbstractApplicationContext#finishRefresh到这个方法的时候,就会去调用实现这个接口的对用的方法.</p><p>这里我们自己写一个类,然后实现 SmartLifecycle 接口即可。</p><p>可以看到下面的打印参数.还是很清楚的明白.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GavinYangLifeImpl</span> <span class="keyword">implements</span> <span class="title class_">SmartLifecycle</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPhase</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用到了GavinYangLifeImpl.start()方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//YangBeanOne无参数构造函数</span></span><br><span class="line"><span class="comment">//调用到了GavinYangLifeImpl.start()方法</span></span><br><span class="line"><span class="comment">//GavinYang</span></span><br></pre></td></tr></table></figure><p>然后我们再看下源码,为什么要实现 SmartLifecycle 这个接口呢？</p><p>org.springframework.context.support.DefaultLifecycleProcessor</p><p>这里我们先看到 phases ,也就是最底下的代码, 这个集合是有值的情况下先排序,然后再迭代,然后调用到 start()方法, 这个start方法是不是在我们的实现类中可以看到,是不是非常的熟悉感觉.</p><p>然后我们在看下,怎么样让这个集合能有值呢？</p><p>phases.put(phase, group); 可以看到 put方法这里, autoStartupOnly 是false 或者bean是SmartLifecycle的子类,并且其isAutoStartup方法的是true. 点到SmartLifecycle源码中去看,可以发现这个方法默认是返回的true.</p><p>接着在调用getPhase方法, 该方法也就是判断.最最关键的phases集合来了,先从里面get出数据,然后判断数据是不是null,如果是null的话,就先new一个Group出来,然后调用phases的put方法,也就是放入到这个集合中去了</p><p>所以这里就是我们为什么要实现 SmartLifecycle 这个接口,就会有启动的效果了的原因.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Internal helpers</span></span><br><span class="line"><span class="comment">// 传入进来的  autoStartupOnly 参数是true.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startBeans</span><span class="params">(<span class="type">boolean</span> autoStartupOnly)</span> &#123;</span><br><span class="line">   Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();</span><br><span class="line">   Map&lt;Integer, LifecycleGroup&gt; phases = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">   lifecycleBeans.forEach((beanName, bean) -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!autoStartupOnly || (bean <span class="keyword">instanceof</span> SmartLifecycle &amp;&amp; ((SmartLifecycle) bean).isAutoStartup())) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">phase</span> <span class="operator">=</span> getPhase(bean);</span><br><span class="line">         <span class="type">LifecycleGroup</span> <span class="variable">group</span> <span class="operator">=</span> phases.get(phase);</span><br><span class="line">         <span class="keyword">if</span> (group == <span class="literal">null</span>) &#123;</span><br><span class="line">            group = <span class="keyword">new</span> <span class="title class_">LifecycleGroup</span>(phase, <span class="built_in">this</span>.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);</span><br><span class="line">            phases.put(phase, group);</span><br><span class="line">         &#125;</span><br><span class="line">         group.add(beanName, bean);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="keyword">if</span> (!phases.isEmpty()) &#123;</span><br><span class="line">      List&lt;Integer&gt; keys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(phases.keySet());</span><br><span class="line">      Collections.sort(keys);</span><br><span class="line">      <span class="keyword">for</span> (Integer key : keys) &#123;</span><br><span class="line">         phases.get(key).start();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>可以看到我们基于接口扩展的,还是很好理解的。 跟着源码中的初始化一些类,看哪个类是怎么写的，然后我们跟着写一个。 前提是,你要弄得明白 Spring 这个执行过程的. 不然你跟着写,不是很明白的话,就可能不是很容易看明白或者看懂你这个效果的.</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/11/04/spring/spring%E5%88%9D%E5%A7%8B%E5%8C%96-%E4%BA%8C/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/04/spring/spring%E5%88%9D%E5%A7%8B%E5%8C%96-%E4%BA%8C/" class="post-title-link" itemprop="url">spring初始化(二)</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-04 00:16:29" itemprop="dateCreated datePublished" datetime="2021-11-04T00:16:29+08:00">2021-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>29k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>27 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h4 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h4><p>昨天记录了this()和 register() 这二个方法, 这二个方法都是为后面的做铺垫,也就是提前初始化了一些环境和读取class文件. refresh() 这个方法才是最重要的,其中包含的内容是非常多的. 所以这里慢慢进行更新其方法的内容.</p><h4 id="refresh-方法"><a href="#refresh-方法" class="headerlink" title="refresh 方法"></a>refresh 方法</h4><p>这里可以看到的是, refresh()该方法里面,基本都是走了很多方法的. 所以挨个看方法,有些方法是留给子类的,也就是进行扩展的. 从synchronized这个关键字来看,这里只容许一次只有一个线程来执行这个方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"></span><br><span class="line">      <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * org.springframework.beans.factory.support.DefaultListableBeanFactory</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line">         <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line">         <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">         onRefresh();</span><br><span class="line">         <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">         registerListeners();</span><br><span class="line">         <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         destroyBeans();</span><br><span class="line">         <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line">         <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="refresh-prepareRefresh-方法"><a href="#refresh-prepareRefresh-方法" class="headerlink" title="refresh.prepareRefresh() 方法"></a>refresh.prepareRefresh() 方法</h4><p>prepareRefresh() 方法: 可以看到该方法先是对closed&#x2F;active参数进行设置,然后对Enviornment进行调用检验方法,接着判断this.earlyApplicationListeners是否有值来操作this.applicationListeners. 最后初始化earlyApplicationEvents这个集合. 这里大概还是进行一些初始化操作.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prepare this context for refreshing, setting its startup date and</span></span><br><span class="line"><span class="comment"> * active flag as well as performing any initialization of property sources.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// Switch to active.</span></span><br><span class="line">   <span class="built_in">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">  <span class="comment">// closed设置为false,active设置为true.  </span></span><br><span class="line">   <span class="built_in">this</span>.closed.set(<span class="literal">false</span>);</span><br><span class="line">   <span class="built_in">this</span>.active.set(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 根据log级别来进行输出 </span></span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">&quot;Refreshing &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize any placeholder property sources in the context environment.</span></span><br><span class="line">   <span class="comment">// 目前该方法没有调用;目前没有做任何事情. 目测是应该留给子类之类的进行扩展的.</span></span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Validate that all properties marked as required are resolvable:</span></span><br><span class="line">   <span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line"><span class="comment">//先调用getEnvironment()获取this()方法中创建出来的Environment来,然后走validateRequiredProperties方法来进行一些检验,</span></span><br><span class="line"><span class="comment">//org.springframework.core.env.AbstractPropertyResolver#validateRequiredProperties</span></span><br><span class="line"><span class="comment">//最后是走到了这个方法,如果this.requiredProperties中是有值的话,那么这里就会抛出一个异常来    </span></span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line"><span class="comment">// 这里是对 earlyApplicationListeners 进行判断,如果有值的话,就先会clear掉,然后再addAll</span></span><br><span class="line"><span class="comment">//如果是没有值的话,就会new一个集合,然后赋值给this.earlyApplicationListeners参数   </span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.earlyApplicationListeners == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.earlyApplicationListeners = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="built_in">this</span>.applicationListeners);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">      <span class="built_in">this</span>.applicationListeners.clear();</span><br><span class="line">      <span class="built_in">this</span>.applicationListeners.addAll(<span class="built_in">this</span>.earlyApplicationListeners);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">   <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line"><span class="comment">// 最后初始化一下 this.earlyApplicationEvents 这个参数</span></span><br><span class="line">   <span class="built_in">this</span>.earlyApplicationEvents = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="refresh-obtainFreshBeanFactory-方法"><a href="#refresh-obtainFreshBeanFactory-方法" class="headerlink" title="refresh.obtainFreshBeanFactory()方法"></a>refresh.obtainFreshBeanFactory()方法</h4><p>这个方法是有方法一个BeanFactory回去的.</p><p>该方法对beanFactory进行SerializationId,然后获取BeanFactory,最后返回这个BeanFactory.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment"> *  告诉子类刷新内部Bean工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the fresh BeanFactory instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refreshBeanFactory()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getBeanFactory()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//this.refreshed.compareAndSet(false, true)该方法如果返回的是false的话,就会有异常给抛出来</span></span><br><span class="line"><span class="comment">//不是false的话,接着就是对beanFactory设置SerializationId    </span></span><br><span class="line">   refreshBeanFactory();</span><br><span class="line"><span class="comment">// org.springframework.context.support.GenericApplicationContext#getBeanFactory</span></span><br><span class="line"><span class="comment">//该方法直接返回DefaultListableBeanFactory    </span></span><br><span class="line">   <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//返回获取的beanFactory.    </span></span><br><span class="line">   <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="refresh-prepareBeanFactory-方法"><a href="#refresh-prepareBeanFactory-方法" class="headerlink" title="refresh.prepareBeanFactory() 方法"></a>refresh.prepareBeanFactory() 方法</h4><p>从这个方法来看,是对BeanFactory的准备.</p><p>该方法可以先是对classLoader,expressionResolver,propertyEditorRegistrar添加到beanFactory中去. 然后添加ApplicationContextAwareProcessor(BeanPostProcessor)到BeanFactory,然后忽略到一些接口的注入到beanFactory中去.</p><p>设置 BeanFactory , ResourceLoader , ApplicationEventPublisher, ApplicationContext等bean到BeanFactory中去.</p><p>最后就是一些environment,systemProperties,systemEnvironment等注入到BeanFactory中去.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Configure the factory&#x27;s standard context characteristics,</span></span><br><span class="line"><span class="comment"> * such as the context&#x27;s ClassLoader and post-processors.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the BeanFactory to configure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">   <span class="comment">// Tell the internal bean factory to use the context&#x27;s class loader etc.</span></span><br><span class="line"><span class="comment">//给beanFactory设置classLoader(加载bean) </span></span><br><span class="line">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line"><span class="comment">//这里根据classLoader来获取解析器,然后set到BeanFactory中去.(解析bean定义的表达式)</span></span><br><span class="line">   beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> <span class="title class_">StandardBeanExpressionResolver</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line"><span class="comment">//属性编辑注册器,set到BeanFactory中</span></span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> <span class="title class_">ResourceEditorRegistrar</span>(<span class="built_in">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line"><span class="comment">//添加ApplicationContextAwareProcessor到BeanFactory中.该类是有实现BeanPostProcessor的</span></span><br><span class="line"><span class="comment">//BeanPostProcessor是在bean初始化完后,调用BeanPostProcessor进行扩展.</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationContextAwareProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line"><span class="comment">//忽略掉EnvironmentAware/EmbeddedValueResolverAware....ApplicationContextAware</span></span><br><span class="line"><span class="comment">//这六个接口的注入(依赖). 因为ApplicationContextAwareProcessor中有做了这些事</span></span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">   <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line"><span class="comment">// BeanFactory,ResourceLoader,ApplicationEventPublisher,ApplicationContext这四个接口</span></span><br><span class="line"><span class="comment">//对应的bean都set到beanFactory中去.    </span></span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="built_in">this</span>);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="built_in">this</span>);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line"><span class="comment">//添加ApplicationListenerDetector(BeanPostProcessor)到beanFactory中去.</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">      <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register default environment beans.</span></span><br><span class="line"><span class="comment">//如果beanFactory中没有ENVIRONMENT_BEAN_NAME这个bean的话,就注入一个进去</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// SYSTEM_PROPERTIES_BEAN_NAME也是一样,注入到beanFactory中去</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//SYSTEM_ENVIRONMENT_BEAN_NAME同上    </span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="refresh-postProcessBeanFactory-方法"><a href="#refresh-postProcessBeanFactory-方法" class="headerlink" title="refresh.postProcessBeanFactory() 方法"></a>refresh.postProcessBeanFactory() 方法</h4><p>该方法目前在单个 Spring中是没有做任何事情的。 等到看SpringBoot源码的时候,这里就会有代码走进来,是进行根据包来扫描来获取class等信息的. 满足条件的class,就会当为bd给注册到beanFactory中去.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Modify the application context&#x27;s internal bean factory after its standard</span></span><br><span class="line"><span class="comment"> * initialization. All bean definitions will have been loaded, but no beans</span></span><br><span class="line"><span class="comment"> * will have been instantiated yet. This allows for registering special</span></span><br><span class="line"><span class="comment"> * BeanPostProcessors etc in certain ApplicationContext implementations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="refresh-invokeBeanFactoryPostProcessors-方法"><a href="#refresh-invokeBeanFactoryPostProcessors-方法" class="headerlink" title="refresh.invokeBeanFactoryPostProcessors() 方法"></a>refresh.invokeBeanFactoryPostProcessors() 方法</h4><p>可以看到这个方法,借助PostProcessorRegistrationDelegate来对PostProcessor进行处理。</p><p>先是对BeanDefinitionRegistryPostProcessor进行从beanFactory中获取出相应的名字数组,然后迭代这个数组,然后处理PriorityOrdered—&gt;Ordered—&gt; 没有,这个顺序,最后还有一个while循环迭代来检查BeanDefinitionRegistryPostProcessor是否都处理完了.</p><p>再接着就是处理BeanFactoryPostProcessor,处理方式是和BeanDefinitionRegistryPostProcessor一样的,顺序也是一样的.</p><p>最后就是调用beanFactory.clearMetadataCache()清除.</p><p>当然,这个里面有些上面 PostProcessor等待阅读SpringBoot的时候给补上来,因为到时候SpringBoot这里会有很多PostProcessor,这里目前是没有的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate and invoke all registered BeanFactoryPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before singleton instantiation.</span></span><br><span class="line"><span class="comment">BeanFactoryPostProcessor: 用来修改Spring容器中已经存在的bean定义.</span></span><br><span class="line"><span class="comment">BeanDefinitionRegistryPostProcessor: 是BeanFactoryPostProcessor的子类,作用和父类是一样的,不同的是,该使用的是BeanDefinitionRegistry对bean进行处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line"><span class="comment">//org.springframework.context.support.AbstractApplicationContext#getBeanFactoryPostProcessors,由于这里只是启动了单个Spring,返回的集合是没有值的.</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; postProcessorsList = getBeanFactoryPostProcessors();</span><br><span class="line">   <span class="comment">//System.out.println(&quot;postProcessorsList value ---&gt; &quot; + postProcessorsList);</span></span><br><span class="line">   <span class="comment">// System.out.println(&quot;beanFactory  value 111111 ---&gt; &quot; + beanFactory);</span></span><br><span class="line"><span class="comment">//借助PostProcessorRegistrationDelegate来处理PostProcessors.</span></span><br><span class="line"><span class="comment">//对传入postProcessorsList进行迭代,如果PostProcessor是BeanDefinitionRegistryPostProcessor的话,就会强转然后调用postProcessBeanDefinitionRegistry方法(传入参数是beanFacotry),添加到registryProcessors集合中.如果不是的话,就会添加到regularPostProcessors集合中.</span></span><br><span class="line"><span class="comment">//根据BeanDefinitionRegistryPostProcessor,从beanFactory中获取postProcessorNames,</span></span><br><span class="line"><span class="comment">//进行迭代,如果是有PriorityOrdered接口的子类的话,就会从beanFactory中根据bean名字,类.class来获取BeanDefinitionRegistryPostProcessor,并且添加到currentRegistryProcessors集合中,ppName(名字的值)也会添加到processedBeans该集合中</span></span><br><span class="line"><span class="comment">//对currentRegistryProcessors进行排序,全部添加到registryProcessors集合中,invokeBeanDefinitionRegistryPostProcessors()该方法是调用BeanDefinitionRegistryPostProcessors的,调用完了然后清空currentRegistryProcessors这个集合.</span></span><br><span class="line"><span class="comment">//同样方法获取postProcessorNames,processedBeans集合中不包含并且是Ordered的子类,然后添加到currentRegistryProcessors集合中,ppName也会添加到processedBeans集合中,同样的排序方式,添加到registryProcessors中,再调用invokeBeanDefinitionRegistryPostProcessors()方法,currentRegistryProcessors清空该集合.</span></span><br><span class="line"><span class="comment">// 也就是到这里,可以看出来,处理的顺序,先是处理PriorityOrdered,再处理Ordered.</span></span><br><span class="line"><span class="comment">// 然后使用一个while循环,继续获取BeanDefinitionRegistryPostProcessor对应的postProcessorNames,这个地方是为了防止有些没有调用到的,并且是processedBeans集合中不包含的,然后就会放入到currentRegistryProcessors这个集合中,排序currentRegistryProcessors集合,全部添加到registryProcessors中,调用invokeBeanDefinitionRegistryPostProcessors,也就是调用具体的PostProcessors.</span></span><br><span class="line"><span class="comment">//invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span></span><br><span class="line"><span class="comment">//invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span></span><br><span class="line"><span class="comment">// 之前的二个集合,registryProcessors和regularPostProcessors,在这里还是会继续调用.</span></span><br><span class="line"><span class="comment">//然后根据BeanFactoryPostProcessor.class获取postProcessorNames数组,与上面的也是同样的方法,</span></span><br><span class="line"><span class="comment">//对postProcessorNames进行迭代,如果是processedBeans(上面装的名字)如果包含了,就会跳过.</span></span><br><span class="line"><span class="comment">/** 如果ppName,也就是迭代的值,是有PriorityOrdered的子类的话,就会从走beanFactory.getBean(ppName, BeanFactoryPostProcessor.class)获取出BeanFactoryPostProcessor放入到priorityOrderedPostProcessors集合中.  如果是Ordered的子类,就将名字放入到orderedPostProcessorNames集合中,如果上面三种都不满足的话,就会放入到nonOrderedPostProcessorNames集合中.</span></span><br><span class="line"><span class="comment">然后先排序priorityOrderedPostProcessors,再走invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span></span><br><span class="line"><span class="comment">接着迭代orderedPostProcessorNames集合,然后从beanFactory中获取BeanFactoryPostProcessor,再就做与priorityOrderedPostProcessors一样的操作.</span></span><br><span class="line"><span class="comment">最后在做nonOrderedPostProcessors这个集合的,操作是与orderedPostProcessorNames一摸一样的.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">最后在调用一个beanFactory的clearMetadataCache方法.</span></span><br><span class="line"><span class="comment">可以看到这个方法是先对BeanDefinitionRegistryPostProcessor.class进行处理,然后根据顺序PriorityOrdered--&gt;Ordered---&gt;没有, 这样的顺序执行的.</span></span><br><span class="line"><span class="comment">然后再处理BeanFactoryPostProcessor.class,处理方式是和BeanDefinitionRegistryPostProcessor.class也是一样的,根据顺序来进行处理.</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line">   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, postProcessorsList);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">   <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line"><span class="comment">// 获取beanFactory的tempClassLoader加载,并且beanFactory是包含了loadTimeWeaver这个bean的,</span></span><br><span class="line"><span class="comment">//就会走if方法,可以看到是添加LoadTimeWeaverAwareProcessor到beanFactory的postProcessor中,</span></span><br><span class="line"><span class="comment">//然后添加一个ClassLoader到beanFactory中   </span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="literal">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="refresh-registerBeanPostProcessors-方法"><a href="#refresh-registerBeanPostProcessors-方法" class="headerlink" title="refresh.registerBeanPostProcessors() 方法"></a>refresh.registerBeanPostProcessors() 方法</h4><p>仔细看中这个方法,其实和上一个方法走的逻辑好像是有点类似的. 也是借助PostProcessorRegistrationDelegate来完成其逻辑的.</p><p>先是从BeanFactory中获取BeanPostProcessor对用的postProcessorNames数组。</p><p>然后分为 PriorityOrdered –&gt; Ordered –&gt; 既不是PriorityOrdered ,也不是Ordered –&gt; MergedBeanDefinitionPostProcessor子类, 这样的先后顺序,走registerBeanPostProcessors,这个是将PostProcessros注册到Spring的beanFactory中(Spring容器).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate and register all BeanPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before any instantiation of application beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">   PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先是根据BeanPostProcessor获取出postProcessorNames数组,这个根据和上面的方法很相似.    </span></span><br><span class="line">		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class,</span><br><span class="line">				<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line">		<span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line">		<span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line"><span class="comment">//然后从beanFactory中获取出个数 + postProcessorNames数组长度再加上一个1.     </span></span><br><span class="line">		<span class="type">int</span> <span class="variable">beanProcessorTargetCount</span> <span class="operator">=</span> beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line"><span class="comment">//添加一个BeanPostProcessorChecker到beanFactory中.从名字上来,这个PostProcessor应该是进行检查的操作.</span></span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">BeanPostProcessorChecker</span>(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">		<span class="comment">// Ordered, and the rest.</span></span><br><span class="line">		List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 对 postProcessorNames 进行遍历;同时使用不同类型的集合来存储数据</span></span><br><span class="line"><span class="comment">//主要是根据是否是PriorityOrdered的子类,是的话就会放入到priorityOrderedPostProcessors集合中,接着在判断是否是MergedBeanDefinitionPostProcessor,如果是的话,就会放入到internalPostProcessors集合中</span></span><br><span class="line"><span class="comment">//是不是orderd的子类,是的话,就会放入到orderedPostProcessorNames集合中,</span></span><br><span class="line"><span class="comment">//如果上面二者都不的话,就会放入到nonOrderedPostProcessorNames集合中  </span></span><br><span class="line">		<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">			<span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">				<span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">				priorityOrderedPostProcessors.add(pp);</span><br><span class="line">				<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">					internalPostProcessors.add(pp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">				orderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line"><span class="comment">//先处理priorityOrderedPostProcessors这个集合中的数据.先排序,然后调用registerBeanPostPtocessors方法.</span></span><br><span class="line">		sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line"><span class="comment">//在处理orderedPostProcessorNames集合中的数据,发现如果也是MergedBeanDefinitionPostProcessor或者其子类的话,也就放入到internalPostProcessors集合中,也就是这里先不处理.</span></span><br><span class="line">		List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">			<span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">			orderedPostProcessors.add(pp);</span><br><span class="line">			<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//排序,处理上面不是MergedBeanDefinitionPostProcessor的或其子类,并且是 orderedPostProcessorNames集合中的数据</span></span><br><span class="line">		sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line"><span class="comment">//最后就处理既不是PriorityOrdered,也不是Ordered的,如果也是MergedBeanDefinitionPostProcessor或者其子类的话,这里也会放入到internalPostProcessors集合中 </span></span><br><span class="line">		List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">			<span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">			nonOrderedPostProcessors.add(pp);</span><br><span class="line">			<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//这里先处理nonOrderedPostProcessorNames中的数据并且不是 MergedBeanDefinitionPostProcessor的子类.</span></span><br><span class="line">		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line"><span class="comment">//最后排序下 MergedBeanDefinitionPostProcessor子类的集合,调用registerBeanPostProcessors方法,注册到BeanFactory中去.   </span></span><br><span class="line">		sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">		<span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line"><span class="comment">//最后添加一个ApplicationListenerDetector到beanFactory中去,并且ApplicationListenerDetector是有实现MergedBeanDefinitionPostProcessor接口的.</span></span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(applicationContext));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><h4 id="refersh-initMessageSource-方法"><a href="#refersh-initMessageSource-方法" class="headerlink" title="refersh.initMessageSource() 方法"></a>refersh.initMessageSource() 方法</h4><p>这个方法主要是对 MESSAGE_SOURCE_BEAN_NAME 是否在beanFactory中进行判断.如果已经在了的话,就会判断是不是HierarchicalMessageSource类型,继续判断其ParentMessageSource是不是null,如果是null的话,就会getInternalParentMessageSource调用初始化获取一些值给赋值进去.</p><p>如果beanFactory中没有的话,就会先new一个,然后也会setParentMessageSource值进去,最后注册到beanFactory中去.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the MessageSource.</span></span><br><span class="line"><span class="comment"> * Use parent&#x27;s if none defined in this context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initMessageSource</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//先获取BeanFactory.  </span></span><br><span class="line">   <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line"><span class="comment">// beanFactory中包含MESSAGE_SOURCE_BEAN_NAME</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line"> <span class="comment">//获取出出来的bean赋值给this.messageSource      </span></span><br><span class="line">      <span class="built_in">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line">      <span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line"><span class="comment">//this.parent不是null并且bean是HierarchicalMessageSource</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">        <span class="comment">//强转  </span></span><br><span class="line">         <span class="type">HierarchicalMessageSource</span> <span class="variable">hms</span> <span class="operator">=</span> (HierarchicalMessageSource) <span class="built_in">this</span>.messageSource;</span><br><span class="line">  <span class="comment">// hms获取出来的parentMessageSource是null情况下,getInternalParentMessageSource()返回的值赋值给hms的ParentMessageSource属性  </span></span><br><span class="line">         <span class="keyword">if</span> (hms.getParentMessageSource() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line">            <span class="comment">// registered already.</span></span><br><span class="line">            hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;Using MessageSource [&quot;</span> + <span class="built_in">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// beanFactory中不包含MESSAGE_SOURCE_BEAN_NAME    </span></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line"><span class="comment">//自己new一个DelegatingMessageSource,dms    </span></span><br><span class="line">      <span class="type">DelegatingMessageSource</span> <span class="variable">dms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegatingMessageSource</span>();</span><br><span class="line"><span class="comment">//调用getInternalParentMessageSource()方法的返回值给set进去.  </span></span><br><span class="line">      dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">      <span class="built_in">this</span>.messageSource = dms;</span><br><span class="line"><span class="comment">// 注入到 beanFactroy中去       </span></span><br><span class="line">      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="built_in">this</span>.messageSource);</span><br><span class="line"><span class="comment">// 根据log的级别来打印.       </span></span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;Unable to locate MessageSource with name &#x27;&quot;</span> + MESSAGE_SOURCE_BEAN_NAME +</span><br><span class="line">               <span class="string">&quot;&#x27;: using default [&quot;</span> + <span class="built_in">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="refresh-initApplicationEventMulticaster-方法"><a href="#refresh-initApplicationEventMulticaster-方法" class="headerlink" title="refresh.initApplicationEventMulticaster() 方法"></a>refresh.initApplicationEventMulticaster() 方法</h4><p>该方法可以看到也是对APPLICATION_EVENT_MULTICASTER_BEAN_NAME是否在bean的判断，如果有的话,就会get出来,没有的话,就会new一个出来,然后注册到beanFactory中去.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the ApplicationEventMulticaster.</span></span><br><span class="line"><span class="comment"> * Uses SimpleApplicationEventMulticaster if none defined in the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.event.SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initApplicationEventMulticaster</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// 先获取beanFactory   </span></span><br><span class="line">   <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line"> <span class="comment">//判断beanFactory是不是有APPLICATION_EVENT_MULTICASTER_BEAN_NAME这个bean,</span></span><br><span class="line"> <span class="comment">//如果是有的话,就会获取出来.然后进行log的级别,判断要不要打印</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.applicationEventMulticaster =</span><br><span class="line">            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;Using ApplicationEventMulticaster [&quot;</span> + <span class="built_in">this</span>.applicationEventMulticaster + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">//如果beanFactory是不包含的话,那么久new一个SimpleApplicationEventMulticaster出来,</span></span><br><span class="line"> <span class="comment">//然后注册到beanFactory中去,最后根据log的级别来判断打印</span></span><br><span class="line">  </span><br><span class="line">      <span class="built_in">this</span>.applicationEventMulticaster = <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>(beanFactory);</span><br><span class="line">      beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="built_in">this</span>.applicationEventMulticaster);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;Unable to locate ApplicationEventMulticaster with name &#x27;&quot;</span> +</span><br><span class="line">               APPLICATION_EVENT_MULTICASTER_BEAN_NAME +</span><br><span class="line">               <span class="string">&quot;&#x27;: using default [&quot;</span> + <span class="built_in">this</span>.applicationEventMulticaster + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="refresh-onRefresh-方法"><a href="#refresh-onRefresh-方法" class="headerlink" title="refresh.onRefresh() 方法"></a>refresh.onRefresh() 方法</h4><p>该方法时留给子类的。 如果是SpringBoot启动的话,这里就会去new Tomcat,然后启动web相应的环境.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Template method which can be overridden to add context-specific refresh work.</span></span><br><span class="line"><span class="comment"> * Called on initialization of special beans, before instantiation of singletons.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation is empty.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refresh()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="refresh-registerListeners-方法"><a href="#refresh-registerListeners-方法" class="headerlink" title="refresh.registerListeners() 方法"></a>refresh.registerListeners() 方法</h4><p>该方法是先获取 ApplicationListeners,如果是有值的话,就会添加到AbstractApplicationEventMulticaster的ListenerRetriever的applicationListeners集合中去.</p><p>根据ApplicationListener.class获取对应的bean信息,然后迭代,最后会添加到AbstractApplicationEventMulticaster的ListenerRetriever的applicationListenerBeans属性中去</p><p>最后是对this.earlyApplicationEvents中的事件进行发布</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add beans that implement ApplicationListener as listeners.</span></span><br><span class="line"><span class="comment"> * Doesn&#x27;t affect other listeners, which can be added without being beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerListeners</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// Register statically specified listeners first.</span></span><br><span class="line"><span class="comment">//getApplicationListeners()获取AbstractApplicationContext中的applicationListeners</span></span><br><span class="line"><span class="comment">//getApplicationEventMulticaster()方法获取的applicationEventMulticaster,是在</span></span><br><span class="line"><span class="comment">//initApplicationEventMulticaster方法中有初始化的.    </span></span><br><span class="line"><span class="comment">//org.springframework.context.event.AbstractApplicationEventMulticaster#addApplicationListener,最后是走到了这里, </span></span><br><span class="line"><span class="comment">//this.defaultRetriever.applicationListeners.add(listener);最后listener是添加到</span></span><br><span class="line"><span class="comment">//其内部内ListenerRetriever的applicationListeners参数中去了.    </span></span><br><span class="line">   <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">      getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">   <span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line"><span class="comment">//根据ApplicationListener获取相应的beanNames数组,这里可以看到和之前获取PostProcessor是一样的</span></span><br><span class="line">   String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">//然后迭代, getApplicationListenerBean是走到了</span></span><br><span class="line"><span class="comment">//org.springframework.context.event.AbstractApplicationEventMulticaster#addApplicationListenerBean,也就是添加到了其内部类ListenerRetriever的applicationListenerBeans属性里面    </span></span><br><span class="line">   <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line"><span class="comment">//使用this.earlyApplicationEvents的集合的值,赋值给变量earlyEventsToProcess,</span></span><br><span class="line"><span class="comment">//然后给this.earlyApplicationEvents重置为null   </span></span><br><span class="line">   Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="built_in">this</span>.earlyApplicationEvents;</span><br><span class="line">   <span class="built_in">this</span>.earlyApplicationEvents = <span class="literal">null</span>;</span><br><span class="line"> <span class="comment">//集合不是null并且是有值的话,   </span></span><br><span class="line">   <span class="keyword">if</span> (earlyEventsToProcess != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">  <span class="comment">//org.springframework.context.event.SimpleApplicationEventMulticaster#invokeListener,这里是走到了这里,可以看到是对这个事件进行发布.</span></span><br><span class="line"> <span class="comment">// 然后会根据ApplicationListener去走onApplicationEvent方法         </span></span><br><span class="line">         getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="refresh-finishBeanFactoryInitialization-方法"><a href="#refresh-finishBeanFactoryInitialization-方法" class="headerlink" title="refresh.finishBeanFactoryInitialization() 方法"></a>refresh.finishBeanFactoryInitialization() 方法</h4><p>该方法从名字上来,就是结束beanFactory的初始化,也就是我们前面准备的bd,postProcessor等信息,在这里都会使用到的.</p><p>可以看到该方法就是真正的实例化bean的方法。 大致就是getBean往下走,getBean如果是没有的话,就会走createBean,也就是没有就去创建嘛，就是这个意思。然后其创建的条件,是走各种beanPostProcessors来进行扩展bean.</p><p>beanFactory.preInstantiateSingletons() 是需要去阅读很多遍的. 不是一遍或者简单的几遍就ok了的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the initialization of this context&#x27;s bean factory,</span></span><br><span class="line"><span class="comment"> * initializing all remaining singleton beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">   <span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line"><span class="comment">//如果beanFactory包含CONVERSION_SERVICE_BEAN_NAME,并且该CONVERSION_SERVICE_BEAN_NAME是</span></span><br><span class="line"><span class="comment">//ConversionService的子类的话,久满足条件,然后先从beanFactory中获取出bean,set给beanFactory中的conversionService属性    </span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">      beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">   <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">   <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line"><span class="comment">// beanFactory中没有EmbeddedValueResolver,也就是该方法返回的是false,然后就从environment中获取出来一个给add到beanFactory中去.    </span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">      beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line"><span class="comment">//根据LoadTimeWeaverAware获取出对用的names数组</span></span><br><span class="line">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class,</span><br><span class="line">         <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后迭代上面获取出来的数组,挨个调用getBean方法    </span></span><br><span class="line">   <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;      </span><br><span class="line">      getBean(weaverAwareName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line"><span class="comment">// tempClassLoader,temp的ClassLoader设置为null    </span></span><br><span class="line">   beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line"><span class="comment">//org.springframework.beans.factory.support.DefaultListableBeanFactory#freezeConfiguration,该方法时走的这里. 其中可以看到是给configurationFrozen设置为true,然后beanName的集合转化为数组,并且赋值给this.frozenBeanDefinitionNames这个数组    </span></span><br><span class="line">   beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"><span class="comment">//这里面初始化bean,简单说一下逻辑. org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String)</span></span><br><span class="line"><span class="comment">//getBean() ---&gt; doGetBean() ---&gt;   createBean() ---&gt;  doCreateBean() </span></span><br><span class="line"><span class="comment">//然后再createBean和doCreateBean()方法之中,会根据条件上面的,获取BeanPostProcessors,然后判断走哦不走其各种BeanPostProceesors提供的方法.满足条件就会走,不满足也就自然不会走了.</span></span><br><span class="line"><span class="comment">//当然了这个方法的复杂程度是比较高的，是需要好好理解的。不是这个简简单单的几句话,还需要自己去读.</span></span><br><span class="line"><span class="comment">//起大致打代码走向就是这样,然后其中会走很多调用bean扩展的BeanPostProcessors，还有实现Init...接口后提供的afterS...等方法.    </span></span><br><span class="line">   beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><a href="#" class="headerlink"></a></h4><h4 id="refresh-finishRefresh-方法"><a href="#refresh-finishRefresh-方法" class="headerlink" title="refresh.finishRefresh() 方法"></a>refresh.finishRefresh() 方法</h4><p>可以看到这个方法是清除了资源缓存, 然后 实现Lifecycle接口的子类,这里就会启动其start方法</p><p>发送一个ContextRefreshedEvent事件出去</p><p>最后将当前的 AbstractApplicationContext 添加到 LiveBeansView的applicationContexts集合中来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the refresh of this context, invoking the LifecycleProcessor&#x27;s</span></span><br><span class="line"><span class="comment"> * onRefresh() method and publishing the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.context.event.ContextRefreshedEvent&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line">  <span class="comment">//清除资源缓存  </span></span><br><span class="line">   clearResourceCaches();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line"><span class="comment">// 这个方法就会调用实现了 Lifecycle 接口的子类,并且执行其start方法    </span></span><br><span class="line">   initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line">   getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Publish the final event.</span></span><br><span class="line"> <span class="comment">//发送一个刷新上下文的Event出去   </span></span><br><span class="line">   publishEvent(<span class="keyword">new</span> <span class="title class_">ContextRefreshedEvent</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line"><span class="comment">//org.springframework.context.support.LiveBeansView#applicationContexts</span></span><br><span class="line"><span class="comment">//将AbstractApplicationContext添加到liveBean的applicationContexts集合中    </span></span><br><span class="line">   LiveBeansView.registerApplicationContext(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="refresh-resetCommonCaches"><a href="#refresh-resetCommonCaches" class="headerlink" title="refresh.resetCommonCaches()"></a>refresh.resetCommonCaches()</h4><p>可以看到这个方法才是真正的清除各种集合缓存啥的操作. 是在finally代码快中,也就是说是必须要执行的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reset Spring&#x27;s common reflection metadata caches, in particular the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ReflectionUtils&#125;, &#123;<span class="doctag">@link</span> AnnotationUtils&#125;, &#123;<span class="doctag">@link</span> ResolvableType&#125;</span></span><br><span class="line"><span class="comment"> * and &#123;<span class="doctag">@link</span> CachedIntrospectionResults&#125; caches.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ReflectionUtils#clearCache()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AnnotationUtils#clearCache()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ResolvableType#clearCache()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> CachedIntrospectionResults#clearClassLoader(ClassLoader)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">resetCommonCaches</span><span class="params">()</span> &#123;</span><br><span class="line">   ReflectionUtils.clearCache();</span><br><span class="line">   AnnotationUtils.clearCache();</span><br><span class="line">   ResolvableType.clearCache();</span><br><span class="line">   CachedIntrospectionResults.clearClassLoader(getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/11/04/spring/spring%E5%88%9D%E5%A7%8B%E5%8C%96-%E4%B8%80/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/04/spring/spring%E5%88%9D%E5%A7%8B%E5%8C%96-%E4%B8%80/" class="post-title-link" itemprop="url">spring初始化(一)</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-04 00:16:21" itemprop="dateCreated datePublished" datetime="2021-11-04T00:16:21+08:00">2021-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>11k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>10 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h4 id="阅读方法"><a href="#阅读方法" class="headerlink" title="阅读方法"></a>阅读方法</h4><p>最简单的阅读方法,就是创建一个maven项目,让引入Spring的依赖. 然后写上一个main方法,来读取包下的内容,然后写一个bean,即可. 这个bean要在你扫描的包下. 于是我们直接在new的地方打上断点跟进去即可.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">5.2</span><span class="number">.0</span>.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringStartMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(<span class="string">&quot;com.iyang.spring&quot;</span>);</span><br><span class="line">        <span class="type">YangBeanOne</span> <span class="variable">yangBeanOne</span> <span class="operator">=</span> context.getBean(YangBeanOne.class);</span><br><span class="line">        System.out.println(yangBeanOne.getClass().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种就是你去github上clone一个Spring的源码,然后倒入idea,当然你需要gradle环境来构建.然后成功的build一下, 如果成功了的话,就在源码的目录创建一个模块(x项目),然后像上面一样。这样做的好处是,你可以随便修改源码的代码, 你觉得它的哪个地方的代码写到不够好的话,也是可以去修改的.</p><h4 id="Debug阅读"><a href="#Debug阅读" class="headerlink" title="Debug阅读"></a>Debug阅读</h4><p>开始debug进行代码的阅读 :</p><p>debug就会进入到这个构造函数中, 这里我们先对 this() 和 scan(basePackages) 这二个方法进行阅读, refresh()里面涉及到内容比较多(BeanPostprocess,Aware,event等),不是一下子就能看明白的,是需要大量的时间去仔细阅读的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new AnnotationConfigApplicationContext, scanning for components</span></span><br><span class="line"><span class="comment"> * in the given packages, registering bean definitions for those components,</span></span><br><span class="line"><span class="comment"> * and automatically refreshing the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> basePackages the packages to scan for component classes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>();</span><br><span class="line">   scan(basePackages);</span><br><span class="line">   refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this () 方法</p><p>可以看到this方法,基本是在做一些对环境初始化的操作.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new AnnotationConfigApplicationContext that needs to be populated</span></span><br><span class="line"><span class="comment"> * through &#123;<span class="doctag">@link</span> #register&#125; calls and then manually &#123;<span class="doctag">@linkplain</span> #refresh refreshed&#125;.</span></span><br><span class="line"><span class="comment"> 同时还会走到 : org.springframework.context.support.GenericApplicationContext#GenericApplicationContext()这个方法里面来.  this.beanFactory = new DefaultListableBeanFactory(); 可以看到这里是new了一个beanFactory的,也就是我们后面的refresh()方法,可以看到DefaultListableBeanFactroy这个类.</span></span><br><span class="line"><span class="comment"> 再往父类走 : org.springframework.context.support.AbstractApplicationContext#AbstractApplicationContext()就会走到这个类的这个方法来, this.resourcePatternResolver = getResourcePatternResolver(); 这里可以看到是初始化了 resourcePatternResolver.当然了,肯定还有一些new的全局变量的初始化也会进行初始化的.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line"><span class="comment">//这个方法对registry,environment和resourceLoader进行赋值,然后根据filter是true,添加了三个filter过滤器.可以看到这个方法虽然带了scanner名字,但是看每个走的方法,好像是没有扫描任何东西,都是对全局参数进行赋值等操作.</span></span><br><span class="line">   <span class="built_in">this</span>.scanner = <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new &#123;<span class="doctag">@code</span> AnnotatedBeanDefinitionReader&#125; for the given registry.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;If the registry is &#123;<span class="doctag">@link</span> EnvironmentCapable&#125;, e.g. is an &#123;<span class="doctag">@code</span> ApplicationContext&#125;,</span></span><br><span class="line"><span class="comment">	 * the &#123;<span class="doctag">@link</span> Environment&#125; will be inherited, otherwise a new</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> StandardEnvironment&#125; will be created and used.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registry the &#123;<span class="doctag">@code</span> BeanFactory&#125; to load bean definitions into,</span></span><br><span class="line"><span class="comment">	 * in the form of a &#123;<span class="doctag">@code</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #AnnotatedBeanDefinitionReader(BeanDefinitionRegistry, Environment)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #setEnvironment(Environment)</span></span><br><span class="line"><span class="comment">这里可以看到传入进来的registry是 this,也就是传入了AnnotationConfigApplicationContext它自己. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以看到这个方法主要做的事情是,初始化Environment,然后new一个ConditionEvaluator对象,其保存了五个信息. 最后就分别添加五个 Processor到beanFactroy的beanDefinitionMap中来.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// getOrCreateEnvironment()方法,先对registry进行非null的判断,如果是Null的话,就会抛出对应的异常.最后是new StandardEnvironment()了一个对象返回来. registry是满足EnvironmentCapable</span></span><br><span class="line"><span class="comment">// this()方法:先对传入进来的registry和environemnt进行非null的判断.this.registry = registry; 紧着new了一个ConditionEvaluator对象,其构造函数中,初始化了registry,beanFactory,environment,resourceLoader和classLoader这五个参数,是在内部类ConditionContextImpl中. 最后往beanFactory的beanDefinitionMap中添加了五个值,分别是:</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.internalCommonAnnotationProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.event.internalEventListenerProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.event.internalEventListenerFactory  </span></span><br><span class="line"><span class="comment">//添加完,new AnnotatedBeanDefinitionReader()这个方法就走完了.        </span></span><br><span class="line">		<span class="built_in">this</span>(registry, getOrCreateEnvironment(registry));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new &#123;<span class="doctag">@code</span> ClassPathBeanDefinitionScanner&#125; for the given bean factory.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registry the &#123;<span class="doctag">@code</span> BeanFactory&#125; to load bean definitions into, in the form</span></span><br><span class="line"><span class="comment">	 * of a &#123;<span class="doctag">@code</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>(registry, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="type">boolean</span> useDefaultFilters)</span> &#123;</span><br><span class="line"><span class="comment">//这里也有getOrCreateEnvironment()方法来获取环境,在上一步已经做了,所以这步是直接获取上一步的结果即可.      </span></span><br><span class="line">		<span class="built_in">this</span>(registry, useDefaultFilters, getOrCreateEnvironment(registry));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先对传入进来的 registry 进行非null的判断,</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="type">boolean</span> useDefaultFilters,</span></span><br><span class="line"><span class="params">			Environment environment, <span class="meta">@Nullable</span> ResourceLoader resourceLoader)</span> &#123;</span><br><span class="line"></span><br><span class="line">		Assert.notNull(registry, <span class="string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.registry = registry;</span><br><span class="line">		<span class="comment">// 这里传入的是ture,也就是会走到这个if里面来.</span></span><br><span class="line">		<span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line"><span class="comment">//org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#registerDefaultFilters, 往includeFilters 集合中添加Filter,这些添加的filter,点进去看即可.            </span></span><br><span class="line">			registerDefaultFilters();</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">// this.environment赋上传入进来的environment值.        </span></span><br><span class="line">		setEnvironment(environment);</span><br><span class="line"><span class="comment">// org.springframework.core.io.support.ResourcePatternUtils#getResourcePatternResolver进行判断,这里由于是ResourcePatternResolver,所以在第一个if就返回了.</span></span><br><span class="line"><span class="comment">//接着new一个CachingMetadataReaderFactory,传入进去resourceLoader,new这个类的内部也是可以看,就是对参数进行赋值,并没有做其他的什么事情了.      </span></span><br><span class="line"><span class="comment">//this.componentsIndex = CandidateComponentsIndexLoader.loadIndex(this.resourcePatternResolver.getClassLoader());获取出来的值Null.        </span></span><br><span class="line">		setResourceLoader(resourceLoader);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>scan(basePackages) 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对传入进来的参数进行一个校验.</span></span><br><span class="line"><span class="comment">//scanner也是上面那步this.scanner = new ClassPathBeanDefinitionScanner(this)给new出来的.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">   Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line">   <span class="built_in">this</span>.scanner.scan(basePackages);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Perform a scan within the specified base packages.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> basePackages the packages to check for annotated classes</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> number of beans registered</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">scan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.DefaultListableBeanFactory#getBeanDefinitionCount 走到这步来获取个数,还记得new AnnotatedBeanDefinitionReader(this)这个方法里面添加了五个processor吗?所以这里获取出来的beanCountAtScanStart大小就是5(默认对初始化做任何改动的情况下).</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">beanCountAtScanStart</span> <span class="operator">=</span> <span class="built_in">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line"><span class="comment">//从名字上看,这个方法是真正的做扫描的.其实Spring中,scan都算不做事的,doScan才是真的做事的。到后面还有getBean不是做事的,doGetBean才是做事的,createBean也是的. </span></span><br><span class="line"><span class="comment">//doScan做的事情可以看到,读取包下的类,然后根据filter条件来过滤,满足条件的话,就会封装成ScannedGenericBeanDefinition,最后是一个集合包装的该包下全部满足条件的. 然后就是接着对 sbd进行注解的处理,比如有些打入了Lazy等注解的,都要读取出来,存入bd的信息中.最后再检查一遍db,如果没问题的话,就会根据beanName和bd,new一个BeanDefinitionHolder出来,最后注册到beanFactory中去,也就是放入BeanFactory的beanDeifitionMap中去.    </span></span><br><span class="line">	doScan(basePackages);</span><br><span class="line">	<span class="comment">// Register annotation config processors, if necessary.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line"><span class="comment">// 先获取出beanFactory,先调用beanFactory的getDependencyComparator和getAutowireCandidateResolver方法,如果满足条件的话,就会有对应的set方法.然后紧接着就是判断beanFactory中是否包含一些bd,如果是不包含的话,这里就会添加进去. 这里判断的值,再最初new reader()的时候已经有添加到BeanFactory的beanDifitionMap中去.        </span></span><br><span class="line">		AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="built_in">this</span>.registry);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 这里返回int参数,但是 this.scanner.scan(basePackages); 好像并没有使用到返回值.</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Perform a scan within the specified base packages,</span></span><br><span class="line"><span class="comment">* returning the registered bean definitions.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;This method does &lt;i&gt;not&lt;/i&gt; register an annotation config processor</span></span><br><span class="line"><span class="comment">* but rather leaves this up to the caller.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> basePackages the packages to check for annotated classes</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> set of beans registered if any for tooling registration purposes (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    <span class="comment">// 先是对传入进来的参数进行检验.</span></span><br><span class="line">	Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line">    <span class="comment">// 存BeanDefinitionHolder的集合,也是最后要返回的.</span></span><br><span class="line">	Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line"><span class="comment">//根据传入进去的包名字,读取出包名字下的所有文件,然后迭代这些文件,这些文件要有能读的权限,再走isCandidateComponent(metadataReader)这个方法,其中就有使用 excludeFilters和includeFilters,这二个filter来过滤进行一些判断操作. 返回ture,就会往下走,new一个ScannedGenericBeanDefinition,其中beanClass就是这个类的全限定名字.比如这里(com.iyang.spring.bean.YangBeanOne),我们的是这个.</span></span><br><span class="line"><span class="comment">//这就是这个方法,扫描,然后根据特定filter,如果是满足条件的话,就会new一个sbd,然后放入Set集合中,返回. </span></span><br><span class="line">		Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line"><span class="comment">//org.springframework.context.annotation.AnnotationScopeMetadataResolver#resolveScopeMetadata,走的这个方法,因AnnotationConfigUtils.attributesFor(...)方法返回的是null,所以这个里面就仅仅只是new了一个ScopeMetadata对象返回了           </span></span><br><span class="line">			<span class="type">ScopeMetadata</span> <span class="variable">scopeMetadata</span> <span class="operator">=</span> <span class="built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line"><span class="comment">//scope的值是singletone.这不就是我们熟悉的单例嘛.            </span></span><br><span class="line">			candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line"><span class="comment">//获取出这个bean的名字            </span></span><br><span class="line">			<span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> <span class="built_in">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="built_in">this</span>.registry);</span><br><span class="line"><span class="comment">// db是 AbstractBeanDefinition的话,这里肯定是,从AbstractBeanDefinition这个名字上看,是一个抽象的，也就是应该是父类.            </span></span><br><span class="line">			<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line"><span class="comment">//beanDefinition.applyDefaults(this.beanDefinitionDefaults)该方法是对一些参数进行赋值操作. </span></span><br><span class="line"><span class="comment">//                </span></span><br><span class="line">				postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">// bd是AnnotatedBeanDefinition或者其子类.            </span></span><br><span class="line">			<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line"><span class="comment">// 该方是对bd的Lazy.calss,Primary.class,DependsOn.class,Role.class,Description.class这些注解进行获取,如果有的话,就会调用bd对应的set方法给值set进去. 当然我们这里的bean没有这些属性.这里可自行加入一些注入,然后debug到这个地方进行看.</span></span><br><span class="line">                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">				&#125;</span><br><span class="line"><span class="comment">// 检查registry中是否含有这个beanName,如果没包含的话,就直接返回ture.            </span></span><br><span class="line">			<span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line"><span class="comment">// 传入bean和beanName, new一个bean的Holder出来,也就是bean的持有者的意思.其实个人觉得这里是对bean进行一层封装,Holder更抽象地理解点.                </span></span><br><span class="line">				<span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(candidate, beanName);</span><br><span class="line"><span class="comment">//scopeMetadata中获取出getScopedProxyMode,如果是No的话,就直接返回definitionHolder         </span></span><br><span class="line">				definitionHolder =</span><br><span class="line">							AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line"><span class="comment">// 添加到最外层的集合中                </span></span><br><span class="line">				beanDefinitions.add(definitionHolder);</span><br><span class="line"><span class="comment">//org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition,最后走到了这里,该方法会先对传入进来的参数进行非null的判断,如果bd是AbstractBeanDefinition的话,就会强转调用其validate()方法,进行检验. 在从this.beanDefinitionMap中获取,根据beanName,第一次肯定是获取不到的,走到else.else中在判断hasBeanCreationStarted(),这里返回的是flase,也就是走到了else的else中去了,根据beanName和bean存入到this.beanDefinitionMap中,然后beanName添加到beanDefinitionNames集合中.  这就是这步根据beanName和bean放入beanFactory的beanDefinitionMap集合中.               </span></span><br><span class="line">				registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>this() 方法 : 该方法中主要是初始化了 this.reader 和 this.scanner这个参数,当然了,其中还有一些环境等信息 的初始化. this.reader的时候,是有往beanFactroy中添加五个默认要添加的bd,也就是添加到了 BeanFactory的BeanDefitionMap中. this.scanner 也是对一些环境等信息初始化 , 然后下接来的方法就是使用 this.scanner来进扫描 class,然后满足条件的,就封装成bd,注册到beanFactory中去.</li><li>register() 方法里面调用 this.reader.register(componentClasses); 该方法就是读取包下的class信息,然后满足条件的就封装成bd,同时还会对注解@Lazy等也会读取,如果是有这些注解的话,就会调用bd对应的set方法,给赋值进去,最后将bd给注册到BeanFactory的beanDefitionMap中去即可.</li></ul><p>可以看到 this() 方法 和 register()方法,主要是对环境的初始化和根据传入进来的包名来进行扫描获取class信息,满足条件的class信息就会转化为bd,然后注册到beanFactory中去.</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/11/04/java/ThreadLocal%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/04/java/ThreadLocal%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" class="post-title-link" itemprop="url">ThreadLocal源码阅读</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-04 00:15:45" itemprop="dateCreated datePublished" datetime="2021-11-04T00:15:45+08:00">2021-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/java%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">java线程</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>2k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>2 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>ThreadLocal 是来这个公司有过使用一次的感受,所以就学习阅读下源码。 其实Thread 这个里面,就有一个 Map(这里是用ThreadLocal内部类中实现的) , 里面的key就是 ThreadLocal, value 就是存储的值,所以一个Thread是有多个 ThreadLocal。</p><hr><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>参数部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private final int threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The next hash code to be given out. Updated atomically. Starts at</span><br><span class="line"> * zero.</span><br><span class="line">   AtomicInteger 是一个线程安全的,实现原理是采用了cas.	</span><br><span class="line"> */</span><br><span class="line">private static AtomicInteger nextHashCode =</span><br><span class="line">    new AtomicInteger();</span><br></pre></td></tr></table></figure><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>set 赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*	首先获取当前线程.</span><br><span class="line">	调用 getMap 方法, 直接调用 t.trheadLocals来获取 ThreadLocalMap。(ThreadLocalMap这里是ThreadLocal内部自己实现的类)</span><br><span class="line">	如果map不是null的话,就进行set值,这里可以看到 set 的key是this,也就是ThreadLocal它自己.</span><br><span class="line">	否则就是调用createMap方法,走这个方法是可以确认 currentThread中的threadLocals的值是null,所以直接new了一个进行赋值即可.</span><br><span class="line">*/</span><br><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">        return t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">        t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Get-方法"><a href="#Get-方法" class="headerlink" title="Get 方法"></a>Get 方法</h4><p>get 方法,获取值.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	这里可以看到,获取ThreadLocalMap,如果ThreadLocalMap的是null的话,就会走setInitialValue方法。</span><br><span class="line">	如果有值的话,就会进行获取值并且返回.</span><br><span class="line">*/</span><br><span class="line">public T get() &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	如果获取出来的ThreadLocalMap 不是null的话,就会进行set,这个时候set进去的值,value就是null了.</span><br><span class="line">	如果获取出来是nulld</span><br><span class="line">*/</span><br><span class="line">private T setInitialValue() &#123;</span><br><span class="line">        T value = initialValue();</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null)</span><br><span class="line">            map.set(this, value);</span><br><span class="line">        else</span><br><span class="line">            createMap(t, value);</span><br><span class="line">        return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected T initialValue() &#123;</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove 方法"></a>remove 方法</h4><p>remove 方法就是获取map,如果map不是null的话,就调用m.remove(this)，根据当前this来删除.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    if (m != null)</span><br><span class="line">        m.remove(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>ThreadLocal里面的方法也比较少,还是比较好理解的。只要弄清楚ThreadLocal和Thread是怎么在存储的,就很好的理解了。</p><p>注意 : 使用ThreadLocal一定要进行remove,否则容易出现内存泄漏，从而导致内存溢出。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/11/04/java/ReentrantLock%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/04/java/ReentrantLock%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" class="post-title-link" itemprop="url">ReentrantLock源码阅读</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-04 00:15:30" itemprop="dateCreated datePublished" datetime="2021-11-04T00:15:30+08:00">2021-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/java%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">java线程</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>5.6k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>5 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ReetrantLock 效果是和 synchronized 是一样的,只不过 synchronized 是内置锁,ReetrantLock是语法级别的锁, 相对于而言是比synchronized灵活性高些. 不过从我目前公司写代码角度来看,都是直接使用 synchronized . 但是不妨碍我们来看 ReetrantLock 里面的代码实现.</p><p>使用代码 : 有lock方法就一定要有 unlock方法来释放锁. 一般代码中这样写即可.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLockCaseMain &#123;</span><br><span class="line"></span><br><span class="line">    private ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void lockUseCase()&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;执行业务代码逻辑&quot;);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>ReetrantLock 中是没有什么全局参数,相比于集合,就没有那么多全局参数.但是我们要看其里面的内,这里有三个类, Sync , NonfairSync , FairSync. NonfairSync和FairSync 都是有继承 Sync. 可以看到NonfairSync 是非公平锁 , FairSync是公平锁.</p><p>Sync 又集成 AQS, 使用独占锁, 重写了 tryRelease 方法.</p><ul><li><p>构造函数: 默认是使用的非公平锁,如果传入进来的是true就会使用公平锁,否则就会使用非公平锁.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * Creates an instance of &#123;@code ReentrantLock&#125;.</span><br><span class="line"> * This is equivalent to using &#123;@code ReentrantLock(false)&#125;.</span><br><span class="line"> */</span><br><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Creates an instance of &#123;@code ReentrantLock&#125; with the</span><br><span class="line"> * given fairness policy.</span><br><span class="line"> *</span><br><span class="line"> * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy</span><br><span class="line"> */</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>lock 方法: lock方法是加锁的方法</p><p>lock方法是调用的 Sync 的lock方法, 然后我们可以看到上锁的时候,走的Sync,然后根据FairSync&#x2F;NonfairSync取走各自的加锁方法,所以说公平锁和非公平锁是加锁的方式是不一样的.</p></li></ul><p>非公平锁获取锁的时候,会获取state这个状态标识,然后再去走对应的逻辑,这里多了比非公平锁多了一个从队列中获取信息和不能获取锁的线程就会被挂起进入队列中排队.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">public void lock() &#123;    sync.lock();&#125;</span><br><span class="line"></span><br><span class="line">// Sync </span><br><span class="line">abstract void lock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 公平锁</span><br><span class="line">     * Sync object for fair locks</span><br><span class="line">     */</span><br><span class="line">tatic final class FairSync extends Sync &#123;</span><br><span class="line">        private static final long serialVersionUID = -3000897897090466540L;</span><br><span class="line"></span><br><span class="line">    	/* </span><br><span class="line">    	acquire(1) 调用到AQS中,最后还是调用到下面的tryAcquire方法.</span><br><span class="line">    	那些没有获取到锁的线程,就会按照队列的方式排队,满足先进先出的效果的,也就是先来的线程先执行,</span><br><span class="line">    	果然这就很公平</span><br><span class="line">    	**/</span><br><span class="line">        final void lock() &#123;</span><br><span class="line">            acquire(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Fair version of tryAcquire.  Don&#x27;t grant access unless</span><br><span class="line">         * recursive call or no waiters or is first.</span><br><span class="line">         */</span><br><span class="line">        protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current = Thread.currentThread();</span><br><span class="line">            int c = getState();</span><br><span class="line">            if (c == 0) &#123;</span><br><span class="line">                /**</span><br><span class="line">                	hasQueuedPredecessors() 方法,先判断头结点和尾结点是不相等的,因为相等的话,就重复了,就是同一个. 然后在判断头结点的 thread是不是当前线程,如果不是当前的前程的话,那么就是在这个线程钱面还有一个等待获取锁时间更久的线程,于是就先抛弃这个线程,去执行那个等待更久的线程.</span><br><span class="line">                	</span><br><span class="line">                	compareAndSetState 就是用cas来获取锁的代码,如果获取成功的话,就会走setExclusiveOwnerThread方法,这里set进去的值是在释放锁的时候会用到.</span><br><span class="line">                	最后返回true,说明获取锁成功了.</span><br><span class="line">                */</span><br><span class="line">                if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            /**</span><br><span class="line">            	获取从setExclusiveOwnerThread里面的thread,来判断是否与当前线程相等,如果相等的话,就说明重入了.</span><br><span class="line">            */</span><br><span class="line">            else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc = c + acquires;</span><br><span class="line">                if (nextc &lt; 0)</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;之前</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">        // The correctness of this depends on head being initialized</span><br><span class="line">        // before tail and on head.next being accurate if the current</span><br><span class="line">        // thread is first in queue.</span><br><span class="line">        Node t = tail; // Read fields in reverse initialization order</span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        return h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == null || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	非公平锁:</span><br><span class="line">*/</span><br><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">        private static final long serialVersionUID = 7316153563782823691L;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Performs lock.  Try immediate barge, backing up to normal</span><br><span class="line">         * acquire on failure.</span><br><span class="line">         可以看到非公平锁是没有从队列中获取说明结点信息,而是直接获取锁的.</span><br><span class="line">         获取成功了就会走 setExclusiveOwnerThread 方法</span><br><span class="line">         */</span><br><span class="line">        final void lock() &#123;</span><br><span class="line">            if (compareAndSetState(0, 1))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            else</span><br><span class="line">                acquire(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            return nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	Sync类中</span><br><span class="line">	这段代码的逻辑也是和 公平锁后来的处理一样的了. c如果是0的话,就会走获取锁的代码,如果不是0的话,就说明重入了,所以就++</span><br><span class="line">*/</span><br><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current = Thread.currentThread();</span><br><span class="line">            int c = getState();</span><br><span class="line">            if (c == 0) &#123;</span><br><span class="line">                if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc = c + acquires;</span><br><span class="line">                if (nextc &lt; 0) // overflow</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unlock方法: unlock是释放锁的方法. 可以看到释放锁是走的 Sync的release方法,所以不管公平锁还是非公平锁起走的释放锁方法是不一样的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;    sync.release(1);&#125;  </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	Sync 中方法. </span><br><span class="line">*/</span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">        // tryRelease()方法返回true的话,就说明锁都释放完了.</span><br><span class="line">        </span><br><span class="line">        if (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            // 恢复线程</span><br><span class="line">            if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">            // 释放锁</span><br><span class="line">            int c = getState() - releases;</span><br><span class="line">            // 如果当前线程不是自己的话,就会抛出异常.这里可以理解为,独占锁,肯定是自己.</span><br><span class="line">            // 也就是说,如果不是独占锁的话,就会抛出异常.</span><br><span class="line">            if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            boolean free = false;</span><br><span class="line">            // 如果你调用了一次lock的话,那么会加一,所以这个地方要等这个lock方法全部被释放掉.</span><br><span class="line">    		// 也就是由于重入锁的原因.</span><br><span class="line">            if (c == 0) &#123;</span><br><span class="line">                free = true;</span><br><span class="line">                // 释放完了,就设置了null.  </span><br><span class="line">                // 然后AbstractOwnableSynchronizer中的thread标记也就是null,</span><br><span class="line">                // 所以下个线程判断是null的话,就可以获取到执行权,也就是获取到锁.</span><br><span class="line">                setExclusiveOwnerThread(null);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>isLocked () 方法, 判断这个线程是不是被锁了:</p><p>调用Sync中isLock方法,如果不是0的话,就说明是被锁了,如果是0的话,就说明没有被锁.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Queries if this lock is held by any thread. This method is</span></span><br><span class="line"><span class="comment">     * designed for use in monitoring of the system state,</span></span><br><span class="line"><span class="comment">     * not for synchronization control.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if any thread holds this lock and</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>hasQueuedThreads() : 是否有线程在等待队列中</p><p>hasQueuedThread(Thread thread) : 线程是否在等待队列中</p><p>getQueueLength() : 获取队列中线程个数</p><p>等这些方法都是比较好理解的,可以自行点进去仔细看下.</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> Sync  /  NonfairSync  /  FairSync  这个三个类就是 ReetrantLock中的三个类,都是围绕这这三个类在做文章.</span><br><span class="line"></span><br><span class="line">公平锁和非公平锁的获取锁方式不一样,但是释放方式是一样的. 公平锁获取锁的时候,如果有线程持有了的话</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/11/04/java/PriorityQueue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/04/java/PriorityQueue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">PriorityQueue源码阅读记录</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-04 00:15:16" itemprop="dateCreated datePublished" datetime="2021-11-04T00:15:16+08:00">2021-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/java%E9%9B%86%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">java集合</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>7.9k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>7 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>PriorityQueue : 中文是优先队列 , 队列的特点就是数据 先进先出, 但是这个优先队列的特别是什么呢？ 首先肯定是有队列的基本特点，也就是有先进先出。 如果是先进先出的话,那么就和普通的有什么区别？优先二字又是体现在什么地方呢？ 优先级队列的元素按照其自然顺序进行排序, 或者根据 构造队列时提供的 Comparator 进行排序.</p><hr><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>结构就是 PriorityQueue这个类的 全局变量参数, 因为这些参数是存储数据的, 所以只要理解了这些参数,就明白了这个 PriorityQueue这个是对数据是怎么样进行存储的, 还是比较好理解的.</p><p>这里可以看到 priorityQueue的数据结构还是很简单的, 一眼扫过去没什么需要特别的理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 存储数据的数组</span><br><span class="line">transient Object[] queue;</span><br><span class="line"></span><br><span class="line">// 记录 priorityQueue的长度</span><br><span class="line">private int size = 0;</span><br><span class="line"></span><br><span class="line">// 这个就是之前说提到的  可以根据 Comparator 进行排序</span><br><span class="line">private final Comparator&lt;? super E&gt; comparator;</span><br></pre></td></tr></table></figure><hr><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>priorityQueue的构造方法相对于其他的集合的构造方法可能是比较多的.</p><p>这里列举出来, 可以看到构造方法还是比较多的.</p><p>对构造函数的初始化赋值等操作还是很好理解的,并没有什么特别难理解的。 主要还是对数组&#x2F;长度&#x2F;或者传入进来的数组进行赋值操作.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">// 1   </span><br><span class="line">// 这里是走到 4 的构造方法去了</span><br><span class="line">public PriorityQueue() &#123;</span><br><span class="line">    this(DEFAULT_INITIAL_CAPACITY, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">// 这里是走到 4 的构造方法去了</span><br><span class="line">public PriorityQueue(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">// 这里是走到 4 的构造方法去了</span><br><span class="line">public PriorityQueue(Comparator&lt;? super E&gt; comparator) &#123;</span><br><span class="line">        this(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4 </span><br><span class="line">/**  可以看到前面的三个都是走到了这里来了,</span><br><span class="line">	 长度如果是小于1的话,就会报错.  </span><br><span class="line">     this.queue 的数组长度就是 initialCapacity</span><br><span class="line">     comparator 排序方法就是传入进来的</span><br><span class="line">*/</span><br><span class="line">public PriorityQueue(int initialCapacity,</span><br><span class="line">                         Comparator&lt;? super E&gt; comparator) &#123;</span><br><span class="line">        // Note: This restriction of at least one is not actually needed,</span><br><span class="line">        // but continues for 1.5 compatibility</span><br><span class="line">        if (initialCapacity &lt; 1)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        this.queue = new Object[initialCapacity];</span><br><span class="line">        this.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 5</span><br><span class="line">/**  对传入进来的集合进行判断. 分为   SortedSet  或者  PriorityQueue  或者其他</span><br><span class="line">     如果是 SortedSet 的话, 对 comparator 的值赋值为 传入进来集合的排序方式,然后走 initElementsFromCollection() 方法, 这里应该是对集合进行赋值操作.</span><br><span class="line">     如果是 PriorityQueue , comparator 处理方式是和 SortedSet一样,然后走 initFromPriorityQueue 方法. </span><br><span class="line">     否则就不上面的二种, comparator 复置为 null ,走 initFromCollection 方法.</span><br><span class="line">     这里总结的话,就是传入进来不同的集合,走的方法也是不一样的,这个还是很好理解的.</span><br><span class="line">	</span><br><span class="line">*/</span><br><span class="line">public PriorityQueue(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        if (c instanceof SortedSet&lt;?&gt;) &#123;</span><br><span class="line">            SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">            this.comparator = (Comparator&lt;? super E&gt;) ss.comparator();</span><br><span class="line">            initElementsFromCollection(ss);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (c instanceof PriorityQueue&lt;?&gt;) &#123;</span><br><span class="line">            PriorityQueue&lt;? extends E&gt; pq = (PriorityQueue&lt;? extends E&gt;) c;</span><br><span class="line">            this.comparator = (Comparator&lt;? super E&gt;) pq.comparator();</span><br><span class="line">            initFromPriorityQueue(pq);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            this.comparator = null;</span><br><span class="line">            initFromCollection(c);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 6  这个对应上面的, 如果是传入进来 PriorityQueue 的处理方法</span><br><span class="line">public PriorityQueue(PriorityQueue&lt;? extends E&gt; c) &#123;</span><br><span class="line">        this.comparator = (Comparator&lt;? super E&gt;) c.comparator();</span><br><span class="line">        initFromPriorityQueue(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 7  这个也是对应上面的 SortedSet 处理方法</span><br><span class="line">public PriorityQueue(SortedSet&lt;? extends E&gt; c) &#123;</span><br><span class="line">        this.comparator = (Comparator&lt;? super E&gt;) c.comparator();</span><br><span class="line">        initElementsFromCollection(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------------   华丽分割线   --------------------</span><br><span class="line">上面的if else 里面提到的走不同的方法,还是有必要取看看的. </span><br><span class="line">    </span><br><span class="line">/**</span><br><span class="line">  对传入进来是  PriorityQueue  进行处理, 先判断确认 class是PriorityQueue ,是的话,调用toArray() 将数组赋值给 queue , 并且长度也进行复置给size.</span><br><span class="line">  否则就走  initFromCollection 方法, 这个 if else 还是比较严谨的.进行多次判断处理</span><br><span class="line">*/    </span><br><span class="line">private void initFromPriorityQueue(PriorityQueue&lt;? extends E&gt; c) &#123;</span><br><span class="line">        if (c.getClass() == PriorityQueue.class) &#123;</span><br><span class="line">            this.queue = c.toArray();</span><br><span class="line">            this.size = c.size();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            initFromCollection(c);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">   这个对传入进来的集合, 将值转化为 数组a (Object []), 如果 comparator不是null的话,就会根据comparator来进行排序. 也就是对a进行排序,并且这个的值不可以为null的,如果出现了null的话,就会有空指针的异常出现.</span><br><span class="line">   然后将数组a赋值给queue,长度也是调用 a.length 复置给size</span><br><span class="line">*/</span><br><span class="line">private void initElementsFromCollection(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        // If c.toArray incorrectly doesn&#x27;t return Object[], copy it.</span><br><span class="line">        if (a.getClass() != Object[].class)</span><br><span class="line">            a = Arrays.copyOf(a, a.length, Object[].class);</span><br><span class="line">        int len = a.length;</span><br><span class="line">        if (len == 1 || this.comparator != null)</span><br><span class="line">            for (int i = 0; i &lt; len; i++)</span><br><span class="line">                if (a[i] == null)</span><br><span class="line">                    throw new NullPointerException();</span><br><span class="line">        this.queue = a;</span><br><span class="line">        this.size = a.length;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 可以看到这个方法是走了  initElementsFromCollection 这个方法, 然后再走 headify 方法</span><br><span class="line">*/</span><br><span class="line">private void initFromCollection(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        initElementsFromCollection(c);</span><br><span class="line">        heapify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>添加元素方法 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	这里可以看到,如果值是null的话,就会抛出NPE的异常.</span><br><span class="line">	如果size的大小比 queue数组的长度还大的话,就会进行扩容.</span><br><span class="line">	然后size长度+1,如何i是0的话,就说明是第一个元素,不需要任何拍寻处理,直接赋值给第一个即可.</span><br><span class="line">	如果不是第一个的话,就会走siftUp方法</span><br><span class="line">*/</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">        if (e == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        modCount++;</span><br><span class="line">        int i = size;</span><br><span class="line">        if (i &gt;= queue.length)</span><br><span class="line">            grow(i + 1);</span><br><span class="line">        size = i + 1;</span><br><span class="line">        if (i == 0)</span><br><span class="line">            queue[0] = e;</span><br><span class="line">        else</span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	如果 comparator是null的话,就走  siftUpUsingComparator 方法.</span><br><span class="line">	否则就会走 siftUpComparable 方法</span><br><span class="line">*/</span><br><span class="line">private void siftUp(int k, E x) &#123;</span><br><span class="line">        if (comparator != null)</span><br><span class="line">            siftUpUsingComparator(k, x);</span><br><span class="line">        else</span><br><span class="line">            siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	这里先判断k是大于0的,也就是不是第一个的意思.</span><br><span class="line">	然后通过 (k - 1) &gt;&gt;&gt; 1 计算出来下标位置,下标是parent的值,调用 comparator.compare(x,e)来进行比较,如果是大于0的话,就不需要做任何处理。</span><br><span class="line">	否则的话,就会 queue[k] = e ; k = parent; 来进行下标数值的替换处理.</span><br><span class="line">	最后queue[k] = x 的值</span><br><span class="line">*/</span><br><span class="line">private void siftUpUsingComparator(int k, E x) &#123;</span><br><span class="line">        while (k &gt; 0) &#123;</span><br><span class="line">            int parent = (k - 1) &gt;&gt;&gt; 1;</span><br><span class="line">            Object e = queue[parent];</span><br><span class="line">            if (comparator.compare(x, (E) e) &gt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	这个方法其实也是和上面的处理方式是类似的,通过比较值来进行处理.</span><br><span class="line">*/</span><br><span class="line">private void siftUpComparable(int k, E x) &#123;</span><br><span class="line">        Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x;</span><br><span class="line">        while (k &gt; 0) &#123;</span><br><span class="line">            int parent = (k - 1) &gt;&gt;&gt; 1;</span><br><span class="line">            Object e = queue[parent];</span><br><span class="line">            if (key.compareTo((E) e) &gt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	这里顺路看下 grow 扩容方法吧。 </span><br><span class="line">	肯定是根据 queue的长度来进行扩容,如果值太小了的话,就会进行 二倍扩容.  否则的话,就是1.5倍扩容.</span><br><span class="line">	最后调用 Arrays.copyOf() 来进行扩容数组操作</span><br><span class="line">	这个扩容还是想对比较简单的</span><br><span class="line">*/</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">        int oldCapacity = queue.length;</span><br><span class="line">        // Double size if small; else grow by 50%</span><br><span class="line">        int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ?</span><br><span class="line">                                         (oldCapacity + 2) :</span><br><span class="line">                                         (oldCapacity &gt;&gt; 1));</span><br><span class="line">        // overflow-conscious code</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>peek 方法</p><p>这里可以看清楚的看到，出队列方法的值,就是默认的第一个嘛，这么一眼看下去就是很清楚明了的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public E peek() &#123;</span><br><span class="line">    return (size == 0) ? null : (E) queue[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove 方法 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	删除元素的方法。</span><br><span class="line">	indexOf 如果返回的不是-1的话,就说明是有值得,就会走到 removeAt 方法</span><br><span class="line">*/</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    int i = indexOf(o);</span><br><span class="line">    if (i == -1)</span><br><span class="line">        return false;</span><br><span class="line">    else &#123;</span><br><span class="line">        removeAt(i);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	indexOf 这个方法就是判断在这个集合里面有没有 o 这个值, 如果有的话就会返回对应的下标,如果不存在的话,就会返回-1的值</span><br><span class="line">*/</span><br><span class="line">private int indexOf(Object o) &#123;</span><br><span class="line">        if (o != null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; size; i++)</span><br><span class="line">                if (o.equals(queue[i]))</span><br><span class="line">                    return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	removeAt 方法就会将传入进来的i的下标的值重置为null,这是满足 i == --size 的情况下.</span><br><span class="line">	然后会将要删除的下标 i 和 对应的值 moved 传入到 siftDown 这个方法中.</span><br><span class="line">	siftUp()是在前面有讲解到的.</span><br><span class="line">	这里还是很明显的看到, priorityQueue是一直在维护这排序的关系。</span><br><span class="line">*/</span><br><span class="line">private E removeAt(int i) &#123;</span><br><span class="line">        // assert i &gt;= 0 &amp;&amp; i &lt; size;</span><br><span class="line">        modCount++;</span><br><span class="line">        int s = --size;</span><br><span class="line">        if (s == i) // removed last element</span><br><span class="line">            queue[i] = null;</span><br><span class="line">        else &#123;</span><br><span class="line">            E moved = (E) queue[s];</span><br><span class="line">            queue[s] = null;</span><br><span class="line">            siftDown(i, moved);</span><br><span class="line">            if (queue[i] == moved) &#123;</span><br><span class="line">                siftUp(i, moved);</span><br><span class="line">                if (queue[i] != moved)</span><br><span class="line">                    return moved;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	根据comparator走不同的方法</span><br><span class="line">	可以看到走的二个方法，其中的区别是 comparator.compare 和 comparator.compareTo 调用的api是不一样的</span><br><span class="line">*/</span><br><span class="line">private void siftDown(int k, E x) &#123;</span><br><span class="line">        if (comparator != null)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        else</span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void siftDownUsingComparator(int k, E x) &#123;</span><br><span class="line">        int half = size &gt;&gt;&gt; 1;</span><br><span class="line">        while (k &lt; half) &#123;</span><br><span class="line">            int child = (k &lt;&lt; 1) + 1;</span><br><span class="line">            Object c = queue[child];</span><br><span class="line">            int right = child + 1;</span><br><span class="line">            if (right &lt; size &amp;&amp;</span><br><span class="line">                comparator.compare((E) c, (E) queue[right]) &gt; 0)</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            if (comparator.compare(x, (E) c) &lt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void siftDownComparable(int k, E x) &#123;</span><br><span class="line">        Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;)x;</span><br><span class="line">        int half = size &gt;&gt;&gt; 1;        // loop while a non-leaf</span><br><span class="line">        while (k &lt; half) &#123;</span><br><span class="line">            int child = (k &lt;&lt; 1) + 1; // assume left child is least</span><br><span class="line">            Object c = queue[child];</span><br><span class="line">            int right = child + 1;</span><br><span class="line">            if (right &lt; size &amp;&amp;</span><br><span class="line">                ((Comparable&lt;? super E&gt;) c).compareTo((E) queue[right]) &gt; 0)</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            if (key.compareTo((E) c) &lt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>PriorityQueue 的存储数据结构是采用一个数据来进行存储,也就是一直在操作这个数组，只是每次都对数据进行了维护排序的关系。</p><p>PriorityQueue 是线程不安全的队列，这里还是提一下吧,因为添加元素和删除元素的方法都是没有进行加锁处理，当然了,如果不使用作为全局变量的话，自然是没有任何问题的,在局部变量里面.</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/11/04/spring/spring%E5%88%9B%E5%BB%BAbean-one/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/04/spring/spring%E5%88%9B%E5%BB%BAbean-one/" class="post-title-link" itemprop="url">spring创建bean_one</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-04 00:14:45" itemprop="dateCreated datePublished" datetime="2021-11-04T00:14:45+08:00">2021-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>51k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>46 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>我们在创建 Spring Bean 的时候，是可以通过很多种方式来创建的. 但是这么多种方式,又是怎么加载的？是不是又有顺序呢？ 所以对 Spring 的 Bean 创建还是很有必要的.</p><h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><p>我们可以通过自己创建 bd , 然后调用 registerBeanDefinition 方法给注册到 Spring 中来.</p><p>那么创建bd的怎么创建的呢？可以看到下面的二种创建方式.</p><p>这是通过 bd 来的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinitionCreateAndRegister</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 : 通过 BeanDefinitionBuilder 来创建 bd</span></span><br><span class="line">        <span class="type">BeanDefinitionBuilder</span> <span class="variable">beanDefinitionBuilder</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(Person.class);</span><br><span class="line">        beanDefinitionBuilder.addPropertyValue(<span class="string">&quot;id&quot;</span>,<span class="number">9527</span>).addPropertyValue(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;GavinYang&quot;</span>);</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> beanDefinitionBuilder.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 : 通过 new GenericBeanDefinition 来创建 bd.</span></span><br><span class="line">        <span class="type">GenericBeanDefinition</span> <span class="variable">genericBeanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericBeanDefinition</span>();</span><br><span class="line">        genericBeanDefinition.setBeanClass(Person.class);</span><br><span class="line">        <span class="type">MutablePropertyValues</span> <span class="variable">mutablePropertyValues</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>();</span><br><span class="line">        mutablePropertyValues.add(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>).add(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Peterwong&quot;</span>);</span><br><span class="line">        genericBeanDefinition.setPropertyValues(mutablePropertyValues);</span><br><span class="line"></span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里是给 bd 给注册到 Spring 容器里面来.</span></span><br><span class="line">        <span class="comment">// context.registerBeanDefinition(&quot;person&quot;,beanDefinition);</span></span><br><span class="line">        context.registerBeanDefinition(<span class="string">&quot;peterwong&quot;</span>,genericBeanDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这里不调用 refresh 是会有错误的.</span></span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> context.getBean(Person.class);</span><br><span class="line">        person.say();</span><br><span class="line">        System.out.println(person.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过我们常用的注解</p><p>这里主要是 @Import&#x2F;@Bean&#x2F;@Component+@ComponentScan 方式来注入对象到 Spring 容器中来.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(ImportBeanConfigMain.ImportConfig.class)</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.iyang.bean.bd&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImportBeanConfigMain</span> &#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ImportBeanConfigMain</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ImportBeanConfigMain 无参数构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">        context.register(ImportBeanConfigMain.class);</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="type">ImportConfig</span> <span class="variable">importConfig</span> <span class="operator">=</span> context.getBean(ImportConfig.class);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> context.getBean(Person.class);</span><br><span class="line">        <span class="type">AnnotConfig</span> <span class="variable">annotConfig</span> <span class="operator">=</span> context.getBean(AnnotConfig.class);</span><br><span class="line">        <span class="type">ExternalConfig</span> <span class="variable">externalConfig</span> <span class="operator">=</span> context.getBean(ExternalConfig.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(importConfig);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        System.out.println(annotConfig);</span><br><span class="line">        System.out.println(externalConfig);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 <span class="doctag">@Import</span> 导入进来.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImportConfig</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">importMe</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是导入自己的方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ImportConfig 的 toString 方法&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ImportConfig</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ImportConfig无参数构造函数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用 <span class="doctag">@Bean</span> 注解 注入 Bean 进来.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Person <span class="title function_">importPerson</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">9527</span>,<span class="string">&quot;GavinYang&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AnnotConfig</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AnnotConfig</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;AnnotConfig无参数构造函数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;使用注解来注入bean进来.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExternalConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExternalConfig</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;externalConfig 无参构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;externalConfig 打印 toString() 方法&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------------</span><br><span class="line">ImportBeanConfigMain 无参数构造函数    </span><br><span class="line">externalConfig 无参构造函数</span><br><span class="line">AnnotConfig无参数构造函数</span><br><span class="line">ImportConfig无参数构造函数</span><br><span class="line">person 有参数构造函数</span><br><span class="line">ImportConfig 的 toString 方法</span><br><span class="line">Person&#123;id=<span class="number">9527</span>, name=<span class="string">&#x27;GavinYang&#x27;</span>&#125;</span><br><span class="line">使用注解来注入bean进来.</span><br><span class="line">externalConfig 打印 toString() 方法</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 这里可以看到new出来的对象打印顺序.</span></span><br></pre></td></tr></table></figure><p>如果是基于创建 bd 的方式的话，是说明下是可以通过这种方式来将我们自己创建的对象给注入到Spring容器中来.我们主要来分析第二种,是做了什么事情.</p><h4 id="Import-x2F-Bean-x2F-Component-ComponentScan-分析"><a href="#Import-x2F-Bean-x2F-Component-ComponentScan-分析" class="headerlink" title="@Import&#x2F;@Bean&#x2F;@Component+@ComponentScan 分析"></a>@Import&#x2F;@Bean&#x2F;@Component+@ComponentScan 分析</h4><p>在分析之前，我们看下我们的 beanClass 是怎么先注册到 Spring中来的,也就是在org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionMap和org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionNames中,可以看到一个是Map类型的,一个是集合类型的.</p><p>我们把断点打在 org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition 进来的方法上就可以看到,然后看堆栈信息,就可以看到怎么一步一步给添加进来的.</p><h5 id="注册-Spring-中来走的方法"><a href="#注册-Spring-中来走的方法" class="headerlink" title="注册 Spring 中来走的方法"></a>注册 Spring 中来走的方法</h5><p>这里只用关注我们自己自己定义的，Spring内部的就不需要管了。</p><p><strong>ImportBeanConfigMain</strong></p><p>org.springframework.context.annotation.AnnotatedBeanDefinitionReader#registerBean(java.lang.Class&lt;?&gt;) —-&gt; org.springframework.beans.factory.support.BeanDefinitionReaderUtils#registerBeanDefinition —-&gt; org.springframework.context.support.GenericApplicationContext#registerBeanDefinition</p><p><strong>externalConfig</strong></p><p>org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors —-&gt;</p><p>org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors —–&gt; org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions —-&gt; org.springframework.context.annotation.ConfigurationClassParser#parse(org.springframework.core.type.AnnotationMetadata, java.lang.String) —&gt; org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass —-&gt;</p><p>org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan —&gt; org.springframework.context.annotation.ClassPathBeanDefinitionScanner#registerBeanDefinition</p><p><strong>importBeanConfigMain.AnnotConfig</strong></p><p>org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors —-&gt;org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;) —-&gt; org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry —-&gt; org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions —&gt; org.springframework.context.annotation.ConfigurationClassParser#parse(org.springframework.core.type.AnnotationMetadata, java.lang.String) —&gt; org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass —&gt; org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan —&gt; org.springframework.context.annotation.ClassPathBeanDefinitionScanner#registerBeanDefinition</p><p><strong>com.iyang.bean.bd.ImportBeanConfigMain$ImportConfig</strong></p><p>org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors —&gt; org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors —&gt; org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry —-&gt; org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitions —&gt; org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#registerBeanDefinitionForImportedConfigurationClass</p><p><strong>importPerson</strong></p><p>org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors —&gt; org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors —&gt; org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry —&gt; org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitions —&gt; org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod</p><p>可以看到除了 ImportBeanConfigMain 在扫描的时候就被注册到 spring 容器里面来，后面的都是走的 AbstractApplicationContext#invokeBeanFactoryPostProcessors 方法给注册到 Spring 容器中来了. 是不是应该详细分析下 invokeBeanFactoryPostProcessors 方法到了做了什么或者说用了什么,将我们定义的对象给注册到 Spring 容器中来了呢？</p><h5 id="invokeBeanFactoryPostProcessors-方法解析"><a href="#invokeBeanFactoryPostProcessors-方法解析" class="headerlink" title="invokeBeanFactoryPostProcessors 方法解析"></a>invokeBeanFactoryPostProcessors 方法解析</h5><p>从上面来看，这个方法并不是我们想象中那么简单的.</p><p>org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;) 委托到这里来进行解析的,所以我们直接深度分析这个方法即可.</p><p>上面可以看到都是走的 PostProcessorRegistrationDelegate 这个类,但是我们并没有在这个方法中找到这个类.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">      ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">   Set&lt;String&gt; processedBeans = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">      <span class="type">BeanDefinitionRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">      List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">         <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">            <span class="type">BeanDefinitionRegistryPostProcessor</span> <span class="variable">registryProcessor</span> <span class="operator">=</span></span><br><span class="line">                  (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">            registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">            registryProcessors.add(registryProcessor);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            regularPostProcessors.add(postProcessor);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">      <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">      <span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line">      <span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">      List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">      String[] postProcessorNames =</span><br><span class="line">            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">         <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">            processedBeans.add(ppName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">      registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line"><span class="comment">// Note : 我们根据 debug 是可以跟进到这里的, 我们直接在这里打上断点,再来仔细看看这个方法做了什么事情.   // currentRegistryProcessors : org.springframework.context.annotation.ConfigurationClassPostProcessor      </span></span><br><span class="line"><span class="comment">// registry :  DefaultableListFactory </span></span><br><span class="line"><span class="comment">// 走完这个方法,我们的bean信息都注册到 Spring 的 DefaultLitableFactory中来了.      </span></span><br><span class="line">      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">      currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">            processedBeans.add(ppName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">      registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">      currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">reiterate</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">         reiterate = <span class="literal">false</span>;</span><br><span class="line">         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">         <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">               processedBeans.add(ppName);</span><br><span class="line">               reiterate = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">         registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">         currentRegistryProcessors.clear();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">   <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">   String[] postProcessorNames =</span><br><span class="line">         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">   <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">      <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">         <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">         orderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">   &#125;</span><br><span class="line">   sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">   &#125;</span><br><span class="line">   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">   <span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">   beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="org-springframework-context-annotation-ConfigurationClassPostProcessor-processConfigBeanDefinitions-方法"><a href="#org-springframework-context-annotation-ConfigurationClassPostProcessor-processConfigBeanDefinitions-方法" class="headerlink" title="org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions 方法"></a>org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions 方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Build and validate a configuration model based on the registry of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Configuration&#125; classes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">   List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">      <span class="type">BeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> registry.getBeanDefinition(beanName);</span><br><span class="line">      <span class="keyword">if</span> (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 对是否满足配置类进行检查, 这里我们的bean是importBeanConfigMain,满足条件的,具体可以看下面该方法的分析.然后会构建一个 bdHolder,添加到集合中来.</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">         configCandidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDef, beanName));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Return immediately if no @Configuration classes were found</span></span><br><span class="line">   <span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Sort by previously determined @Order value, if applicable</span></span><br><span class="line"><span class="comment">// 这里会根据 @Order 来进行排序下.</span></span><br><span class="line"><span class="comment">// 从 Integer.compare(i1, i2) 来分析，应该是从小到大的排序,也就是说,越小的话,优先级就约高. </span></span><br><span class="line">   configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">      <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">      <span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line">   <span class="type">SingletonBeanRegistry</span> <span class="variable">sbr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line"><span class="comment">// 满足类型条件强转下.       </span></span><br><span class="line">      sbr = (SingletonBeanRegistry) registry;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line"><span class="comment">// 这里不包含,所以返回的就是null.</span></span><br><span class="line"><span class="comment">//org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean)          </span></span><br><span class="line">         <span class="type">BeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> (BeanNameGenerator) sbr.getSingleton(</span><br><span class="line">               AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">         <span class="keyword">if</span> (generator != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">            <span class="built_in">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 确保environment不是null.</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.environment == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.environment = <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Parse each @Configuration class</span></span><br><span class="line"><span class="comment">// 创建一个解析 @Configuration 的对象.</span></span><br><span class="line"><span class="comment">// 在创建ConfigurationClassParser的这个有参构造函数里面,是可以看到又new了二个对象的,一个是ComponentScanAnnotationParser,一个是ConditionEvaluator.</span></span><br><span class="line"><span class="comment">// ComponentScanAnnotationParser 这个从名字上看,可以理解为@ComponentScan注解的解析.  </span></span><br><span class="line">   <span class="type">ConfigurationClassParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassParser</span>(</span><br><span class="line">         <span class="built_in">this</span>.metadataReaderFactory, <span class="built_in">this</span>.problemReporter, <span class="built_in">this</span>.environment,</span><br><span class="line">         <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">   Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(configCandidates);</span><br><span class="line">   Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(configCandidates.size());</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass这里走到这里,主要看这个方法中的doProcessConfigurationClass方法.       </span></span><br><span class="line">      parser.parse(candidates);</span><br><span class="line"><span class="comment">// 这里对我们上面解析出来的bean进行valiate,如果validate失败的话,那么最后是会抛出一个异常来的.	       </span></span><br><span class="line">      parser.validate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装有我们解析出来的bean信息       </span></span><br><span class="line">      Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line"><span class="comment">// 移除已经解析过了的.       </span></span><br><span class="line">      configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line"><span class="comment">//如果this.reader是null的话,就会new一个ConfigurationClassBeanDefinitionReader出来.       </span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.reader == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">ConfigurationClassBeanDefinitionReader</span>(</span><br><span class="line">               registry, <span class="built_in">this</span>.sourceExtractor, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.environment,</span><br><span class="line">               <span class="built_in">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">      &#125;</span><br><span class="line"> <span class="comment">// 这里对我们获取的 bean 再进行一个 load.      </span></span><br><span class="line">      <span class="built_in">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line"><span class="comment">// 解析过了的bean放入到 alreadyParsed 中来.       </span></span><br><span class="line">      alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">      candidates.clear();</span><br><span class="line"><span class="comment">// 扫描获取出来的bean个数大于 初始化传入进来的个数.       </span></span><br><span class="line">      <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">        <span class="comment">// 获取出新扫描的bean信息.  </span></span><br><span class="line">         String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">        <span class="comment">// 旧的bean信息  </span></span><br><span class="line">         Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">        <span class="comment">// 表示已经注册过了的  </span></span><br><span class="line">         Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       <span class="comment">// 将外面的 alreadyParsed 中的元素的 metadata的className给放入到alreadyParsedClasses集合中来.    </span></span><br><span class="line">         <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">         &#125;</span><br><span class="line"> <span class="comment">// 对new的集合中元素进行迭代         </span></span><br><span class="line">         <span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">       <span class="comment">// 老的集合中不包含      </span></span><br><span class="line">            <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">               <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> registry.getBeanDefinition(candidateName);</span><br><span class="line">                </span><br><span class="line">       <span class="comment">// alreadyParsedClasses 中不包含并且检验出需要配置的,比如有一些@Configuration等特殊注解，这个方法在之前是有提到的.         </span></span><br><span class="line">               <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="built_in">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">                     !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">           <span class="comment">// 满足上面这些条件就会放入到candidates集合中来.         </span></span><br><span class="line">                  candidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(bd, candidateName));</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         candidateNames = newCandidateNames;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// candidates 是 empty 就跳出while循环,否则就认为还有bean需要解析.    </span></span><br><span class="line">   <span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.ConfigurationClassPostProcessor.importRegistry sbr不包含importRegistry的话,就会注册一个进去.   </span></span><br><span class="line">   <span class="keyword">if</span> (sbr != <span class="literal">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">      sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">      <span class="comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span></span><br><span class="line">      <span class="comment">// for a shared cache since it&#x27;ll be cleared by the ApplicationContext.</span></span><br><span class="line"> <span class="comment">// 这里是清除缓存,也是清除一些集合.      </span></span><br><span class="line">      ((CachingMetadataReaderFactory) <span class="built_in">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>走完这个方法,如果是debug模式的话,就可以在 registry(也就是DefaultListableBeanFactory)的 beanDefintionMap和beanDefinitionNames这二个集合中是可以看到我们的bean名字已经bean对应的class信息的.</strong></p><h6 id="org-springframework-context-annotation-ConfigurationClassParser-doProcessConfigurationClass方法"><a href="#org-springframework-context-annotation-ConfigurationClassParser-doProcessConfigurationClass方法" class="headerlink" title="org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass方法"></a>org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass方法</h6><p>可以看到这个方法就是对 configuration 类进行处理的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Apply processing and build a complete &#123;<span class="doctag">@link</span> ConfigurationClass&#125; by reading the</span></span><br><span class="line"><span class="comment"> * annotations, members and methods from the source class. This method can be called</span></span><br><span class="line"><span class="comment"> * multiple times as relevant sources are discovered.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> configClass the configuration class being build</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceClass a source class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the superclass, or &#123;<span class="doctag">@code</span> null&#125; if none found or previously processed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title function_">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是不是有 @Component 注解.  </span></span><br><span class="line">   <span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class="line">      <span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">      processMemberClasses(configClass, sourceClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line"><span class="comment">// 接着再处理 @PropertySources 注解. 可以看到这个注解貌似是和 Environment 有关系.   </span></span><br><span class="line">   <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">         sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">         org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">         processPropertySource(propertySource);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         logger.info(<span class="string">&quot;Ignoring @PropertySource annotation on [&quot;</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">               <span class="string">&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process any @ComponentScan annotations</span></span><br><span class="line"><span class="comment">// 获取@ComponentScan 注解,我们这里是有的.    </span></span><br><span class="line">   Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">         sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">   <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">         !<span class="built_in">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">         <span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">          </span><br><span class="line"><span class="comment">// org.springframework.context.annotation.ComponentScanAnnotationParser#parse</span></span><br><span class="line"><span class="comment">// parse 方法内部是使用 ClassPathBeanDefinitionScanner 扫描器的,对resourcePattern/includeFilters/excludeFilters/lazyInit 是否有进行处理.</span></span><br><span class="line"><span class="comment">// 获取注解上的属性 basePackages/basePackageClasses的值,添加一个AbstractTypeHierarchyTraversingFilter,这个是ExcludeFilter</span></span><br><span class="line"><span class="comment">//最后来org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan做扫描操作.</span></span><br><span class="line"><span class="comment">//doScan做了什么事情呢? 显示通过传入进来的包,调用findCandidateComponents获取出bd的集合来,ScopeMetadata设置也是默认的,用beanNameGenerator生成bean对应的beanName</span></span><br><span class="line"><span class="comment">//如果bd是AbstractBeanDefinition,再走一下postProcessBeanDefinition方法</span></span><br><span class="line"><span class="comment">//如果bd是AnnotatedBeanDefinition,会走AnnotationConfigUtils.processCommonDefinitionAnnotations()方法,也是对一些注解的属性进行设置值操作. 走个checkCandidat检查方法,确保bd再registry中不存在的,如果存在的话,那就说明是已经注册过了的.     //如果是不存在的话,就会new一个BeanDefinitionHolder来,然后走registerBeanDefinition给注册到Spring容器中来. 最后返回扫描获取到的bdHolder集合来.     </span></span><br><span class="line">         Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">               <span class="built_in">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">         <span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">         <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">            <span class="type">BeanDefinition</span> <span class="variable">bdCand</span> <span class="operator">=</span> holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">            <span class="keyword">if</span> (bdCand == <span class="literal">null</span>) &#123;</span><br><span class="line">               bdCand = holder.getBeanDefinition();</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 可以看到这里, 我们在最初进入到processConfigBeanDefinitions来的时候,其实就已经是调用了这个方法,那么我们这里扫描获取的bean在此调用这个方法. 也就是确保,扫描获取的bean,也是有一些配置的注解并且也是需要解析的.           </span></span><br><span class="line">            <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line"><span class="comment">// org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass这里最后也是走到这里了.</span></span><br><span class="line"><span class="comment">// 最初我们是从parse.parse() 进来的,也是走的ConfigurationClassParser#processConfigurationClas,这里又走到了该方法.</span></span><br><span class="line"><span class="comment">// 也就说我们是调用这个方法,只要满足条件的话,就会一直调用这个方法,直到不满足条件为止.                </span></span><br><span class="line">               parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process any @Import annotations</span></span><br><span class="line"><span class="comment">// 这里是对 @Import 注解进行处理. 该方法是有利用 importStack 来控制,</span></span><br><span class="line"><span class="comment">// 其内部又分为 @ImportSelector/@ImportBeanDefinitionRegistrar/无注解这三种情况.</span></span><br><span class="line"><span class="comment">// 获取完 bean 信息后,就又走到了org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass方法来.</span></span><br><span class="line"><span class="comment">// 最后importStack 调用 pop 给数据给弹出来.    </span></span><br><span class="line">   processImports(configClass, sourceClass, getImports(sourceClass), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process any @ImportResource annotations</span></span><br><span class="line"><span class="comment">// 对@ImportResource是否有进行判断.    </span></span><br><span class="line">   <span class="type">AnnotationAttributes</span> <span class="variable">importResource</span> <span class="operator">=</span></span><br><span class="line">         AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">   <span class="keyword">if</span> (importResource != <span class="literal">null</span>) &#123;</span><br><span class="line">      String[] resources = importResource.getStringArray(<span class="string">&quot;locations&quot;</span>);</span><br><span class="line">      Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanDefinitionReader</span>&gt; readerClass = importResource.getClass(<span class="string">&quot;reader&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">resolvedResource</span> <span class="operator">=</span> <span class="built_in">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">         configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process individual @Bean methods</span></span><br><span class="line"><span class="comment">// @Bean 注解处理.</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.ConfigurationClassParser#retrieveBeanMethodMetadata , </span></span><br><span class="line"><span class="comment">// 这里对于主入口类进来,是没有这个配置的.    </span></span><br><span class="line">   Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">   <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">      configClass.addBeanMethod(<span class="keyword">new</span> <span class="title class_">BeanMethod</span>(methodMetadata, configClass));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process default methods on interfaces</span></span><br><span class="line"><span class="comment">// 对接口的进行处理. 这里目前也是没有的.    </span></span><br><span class="line">   processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process superclass, if any</span></span><br><span class="line"><span class="comment">// 先是判断是不是有父类.    </span></span><br><span class="line">   <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line"><span class="comment">// 获取出父类信息       </span></span><br><span class="line">      <span class="type">String</span> <span class="variable">superclass</span> <span class="operator">=</span> sourceClass.getMetadata().getSuperClassName();</span><br><span class="line"><span class="comment">// 父类不是null,不是java开头并且knownSuperclasses中不存在,就满满足条件.       </span></span><br><span class="line">      <span class="keyword">if</span> (superclass != <span class="literal">null</span> &amp;&amp; !superclass.startsWith(<span class="string">&quot;java&quot;</span>) &amp;&amp;</span><br><span class="line">            !<span class="built_in">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">         <span class="built_in">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">         <span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">         <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里可以看到 doProcessConfigurationClass方法,是传入进来主类入口进行解析, 然后没满足一个条件的bean,都会在走一遍解析的方法,直到都走到没满足条件的.</strong></p><h6 id="org-springframework-context-annotation-ConfigurationClassUtils-checkConfigurationClassCandidate方法"><a href="#org-springframework-context-annotation-ConfigurationClassUtils-checkConfigurationClassCandidate方法" class="headerlink" title="org.springframework.context.annotation.ConfigurationClassUtils#checkConfigurationClassCandidate方法"></a>org.springframework.context.annotation.ConfigurationClassUtils#checkConfigurationClassCandidate方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check whether the given bean definition is a candidate for a configuration class</span></span><br><span class="line"><span class="comment"> * (or a nested component class declared within a configuration/component class,</span></span><br><span class="line"><span class="comment"> * to be auto-registered as well), and mark it accordingly.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanDef the bean definition to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadataReaderFactory the current factory in use by the caller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether the candidate qualifies as (any kind of) configuration class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkConfigurationClassCandidate</span><span class="params">(</span></span><br><span class="line"><span class="params">      BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory)</span> &#123;</span><br><span class="line"><span class="comment">// 先获取 beanName 出来</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> beanDef.getBeanClassName();</span><br><span class="line">   <span class="keyword">if</span> (className == <span class="literal">null</span> || beanDef.getFactoryMethodName() != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   AnnotationMetadata metadata;</span><br><span class="line"><span class="comment">// 判断 bd 是不是AnnotatedBeanDefinition 并且 确认 beanName是不是与前面获取出来的classsName是一样的.    </span></span><br><span class="line">   <span class="keyword">if</span> (beanDef <span class="keyword">instanceof</span> AnnotatedBeanDefinition &amp;&amp;</span><br><span class="line">         className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) &#123;</span><br><span class="line">      <span class="comment">// Can reuse the pre-parsed metadata from the given BeanDefinition...</span></span><br><span class="line"><span class="comment">// 获取类上的注解.我们这里获取出来的是 @Import 和 @ComponentScan       </span></span><br><span class="line">      metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (beanDef <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) beanDef).hasBeanClass()) &#123;</span><br><span class="line">      <span class="comment">// Check already loaded Class if present...</span></span><br><span class="line">      <span class="comment">// since we possibly can&#x27;t even load the class file for this Class.</span></span><br><span class="line">      Class&lt;?&gt; beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();</span><br><span class="line">      <span class="keyword">if</span> (BeanFactoryPostProcessor.class.isAssignableFrom(beanClass) ||</span><br><span class="line">            BeanPostProcessor.class.isAssignableFrom(beanClass) ||</span><br><span class="line">            AopInfrastructureBean.class.isAssignableFrom(beanClass) ||</span><br><span class="line">            EventListenerFactory.class.isAssignableFrom(beanClass)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      metadata = AnnotationMetadata.introspect(beanClass);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> metadataReaderFactory.getMetadataReader(className);</span><br><span class="line">         metadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Could not find class file for introspecting configuration annotations: &quot;</span> +</span><br><span class="line">                  className, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取@Configuration,我们这里没有,所以获取出来的null.   </span></span><br><span class="line">   Map&lt;String, Object&gt; config = metadata.getAnnotationAttributes(Configuration.class.getName());</span><br><span class="line">   <span class="keyword">if</span> (config != <span class="literal">null</span> &amp;&amp; !Boolean.FALSE.equals(config.get(<span class="string">&quot;proxyBeanMethods&quot;</span>))) &#123;</span><br><span class="line">      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 注意这里的 isConfigurationCandidate方法,org.springframework.context.annotation.ConfigurationClassUtils#isConfigurationCandidate</span></span><br><span class="line"><span class="comment">// @Component/@ComponentScan/@Import/@ImportResource,只要有其中的一种的话，那么返回的就是true. </span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (config != <span class="literal">null</span> || isConfigurationCandidate(metadata)) &#123;</span><br><span class="line"><span class="comment">// CONFIGURATION_CLASS_ATTRIBUTE 对应的值是org.springframework.context.annotation.ConfigurationClassPostProcessor.configurationClass       </span></span><br><span class="line">      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// It&#x27;s a full or lite configuration candidate... Let&#x27;s determine the order value, if any.</span></span><br><span class="line"><span class="comment">// 获取 order,如果有的话,就会set进去.    </span></span><br><span class="line">   <span class="type">Integer</span> <span class="variable">order</span> <span class="operator">=</span> getOrder(metadata);</span><br><span class="line">   <span class="keyword">if</span> (order != <span class="literal">null</span>) &#123;</span><br><span class="line">      beanDef.setAttribute(ORDER_ATTRIBUTE, order);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可以看到这个方法最主的就是对一些类上是否有注解进行判断, 如果满足 @Configuration&#x2F;@Component&#x2F;@ComponentScan&#x2F;@Import&#x2F;@ImportResource,那么返回的就是会true,同时也会set一个CONFIGURATION_CLASS_ATTRIBUTE属性到bd里面来.</strong></p><h4 id="getBean方法分析"><a href="#getBean方法分析" class="headerlink" title="getBean方法分析"></a>getBean方法分析</h4><p>getBean 不仅仅是获取bean的效果,更是创建bean的，可以看到getBean最后走到了createBean方法来.</p><p>org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons : 这里我们直接定位到这个方法,来看下是怎么调用的,调用之前&#x2F;实例化bean等过程,又做了什么事情？</p><h5 id="preInstantiateSingletons-方法"><a href="#preInstantiateSingletons-方法" class="headerlink" title="preInstantiateSingletons 方法"></a>preInstantiateSingletons 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">   <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line"><span class="comment">// 从 beanDefinitionNames 中获取出 beanName的集合.</span></span><br><span class="line"><span class="comment">// 这里获取出来的 beanNameList 不仅仅有Spring内部的,还有我们自己的.    </span></span><br><span class="line">   List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      <span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="comment">// bd不是抽象的,是单列的,不是赖加载的,就进入到这里来.       </span></span><br><span class="line">      <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">    <span class="comment">// 判断是不是 FactoryBean      </span></span><br><span class="line">         <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">               <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">               <span class="type">boolean</span> isEagerInit;</span><br><span class="line">               <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                  isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                              ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                        getAccessControlContext());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                  isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                        ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                  getBean(beanName);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不是 FactroyBean的话,就直接走 getBean方法.       </span></span><br><span class="line">            getBean(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line"><span class="comment">// 根据 beanNames 来进行迭代.    </span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">   <span class="comment">// 根据 beanName 来获取对象.    </span></span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean)       </span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">singletonInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">  <span class="comment">// 满足是 SmartInitializingSingleton 接口的子类. 最后就都会调用 afterSingletonsInstantiated 方法, 这个也算是bean自身实现SmartInitializingSingleton接口来做的一种扩展.  </span></span><br><span class="line">      <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="type">SmartInitializingSingleton</span> <span class="variable">smartSingleton</span> <span class="operator">=</span> (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">         <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">               smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 preInstanitateSingletons方法，根据beanDefinitionNames中注册过的beanName集合,调用getBean方法来创建这个bean. 当创建完所有的bean后,判断是不是有实现 SmartInitializingSingleton 接口的bean,如果有的话, 就会调用这个bean 的afterSingletonsInstantiated方法.</p><h6 id="doGetBean-方法"><a href="#doGetBean-方法" class="headerlink" title="doGetBean() 方法"></a>doGetBean() 方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> requiredType the required type of the bean to retrieve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment"> * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> typeCheckOnly whether the instance is obtained for a type check,</span></span><br><span class="line"><span class="comment"> * not for actual use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="comment">// 获取beanName</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">   Object bean;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line"> <span class="comment">//   这里是判断是不是手动给添加到单例池里面去的.</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">   <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                  <span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 如果是从单例池里面获取出来的,就走这个方法.    </span></span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">      <span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">  <span class="comment">// 判断这个bean当前是不是已经在注册了,如果是的话,就会抛出异常来.  </span></span><br><span class="line"><span class="comment">//org.springframework.beans.factory.support.AbstractBeanFactory#prototypesCurrentlyInCreation,利用ThreadLocal来记录值,如果beanName是相同的话就会返回ture,否则就返回flase,这里返回的是false.       </span></span><br><span class="line">      <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line"> <span class="comment">//  org.springframework.beans.factory.support.AbstractBeanFactory#getParentBeanFactory获取父工厂,这里返回的是null,也就是说是没有的.所以下面的if条件也就不会进去.     </span></span><br><span class="line">      <span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory != <span class="literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">         <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">nameToLookup</span> <span class="operator">=</span> originalBeanName(name);</span><br><span class="line">         <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">                  nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">            <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">            <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typeCheckOnly 在此处的值是 false.</span></span><br><span class="line"><span class="comment">//org.springframework.beans.factory.support.AbstractBeanFactory#alreadyCreated,利用Set集合来标记是否创建,可以看到往alreadyCreated中添加元素进去的时候,还使用了synchronized来加锁判断并且使用了双重if,可以看到我们在接触单例模式的时候，也是有使用  synchronized + 双重if的.      </span></span><br><span class="line">      <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">         markBeanAsCreated(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 获取出 bd 来,org.springframework.beans.factory.support.AbstractBeanFactory#mergedBeanDefinitions,从这个ConcurrentHashMap中获取出来,也就是说这个mergedBeanDefinitions Map 中,key就是beanName,value就是对应的bd.          </span></span><br><span class="line">         <span class="keyword">final</span> <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">          </span><br><span class="line"><span class="comment">// 对 bd 进行检查,如果是抽象的话,就会抛出异常来.          </span></span><br><span class="line">         checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line"> <span class="comment">// 获取 @DependsOn 注解.并且对 @Depends进行处理.         </span></span><br><span class="line">         String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">         <span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">               <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               registerDependentBean(dep, beanName);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  getBean(dep);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Create bean instance.</span></span><br><span class="line"> <span class="comment">// 确保 bd 是单例的.     </span></span><br><span class="line">         <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                  <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">                  <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">                  <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">                  destroySingleton(beanName);</span><br><span class="line">                  <span class="keyword">throw</span> ex;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">             </span><br><span class="line"><span class="comment">// 获取bean实例             </span></span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">// 这里是实例化一个 多列的 bean</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">            <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               beforePrototypeCreation(beanName);</span><br><span class="line">               prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">               afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 这里操作的,不仅单列也不是多列.</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line">            <span class="keyword">if</span> (scope == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, () -&gt; &#123;</span><br><span class="line">                  beforePrototypeCreation(beanName);</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">finally</span> &#123;</span><br><span class="line">                     afterPrototypeCreation(beanName);</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName,</span><br><span class="line">                     <span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">                     ex);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line"> <span class="comment">// 不满足条件,所以没进入到这里.   </span></span><br><span class="line">   <span class="keyword">if</span> (requiredType != <span class="literal">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="type">T</span> <span class="variable">convertedBean</span> <span class="operator">=</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">         <span class="keyword">if</span> (convertedBean == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> convertedBean;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">                  ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接返回了 bean 信息.    </span></span><br><span class="line">   <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doGetBean方法 : 可以看到该方法主要是对 bean 分为三种类型来进行初始化 , 分别是 mbd.isSingleton&#x2F;mbd.isPrototype()&#x2F;非前二者 这三种情况. 在分这三种情况之前,还对@DependsOn 注解来进行分析,也就说当你初始化这个bean的时候,如果它依赖了一个宁外的bean,就会先去初始化宁外一个bean,也就是调用了 getBean 方法, 而getBean方法就是走的 doGetBean() —&gt; createBean() 也就是走到了自身这里,是一种递归调用.</p><p>然后我们这里是单例的,自然就往下走了 createBean 方法.</p><h6 id="createBean-方法"><a href="#createBean-方法" class="headerlink" title="createBean() 方法"></a>createBean() 方法</h6><p>从名字来看,还是可以很很闲的感受到,是创建bean的方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Central method of this class: creates a bean instance,</span></span><br><span class="line"><span class="comment"> * populates the bean instance, applies post-processors, etc.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doCreateBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line">   <span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line">   <span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line"><span class="comment">// 确定bean的class, 如果bd有beanClass的信息,就会直接返回.    </span></span><br><span class="line">   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"><span class="comment">//如果这里从bd获取出来的class是有值的,然后bd是没有beanCalss,获取出来的beanClassName也是null的话,那么这里就会重新来构建出一个bd,并且设置上 beanClass信息.    </span></span><br><span class="line">   <span class="keyword">if</span> (resolvedClass != <span class="literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="literal">null</span>) &#123;</span><br><span class="line">      mbdToUse = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(mbd);</span><br><span class="line">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Prepare method overrides.</span></span><br><span class="line"><span class="comment">// 准备重写的方法信息,先判断是不是有重写的方法,    </span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      mbdToUse.prepareMethodOverrides();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(),</span><br><span class="line">            beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 这是 Spring 系统默认的后置处理器,是有六个的.       </span></span><br><span class="line"><span class="comment">// ApplicationContextAwareProcessor ,  ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor , PostProcessorRegistrationDelegate$BeanPostProcessorCheck , CommonAnnotationBeanPostProcessor ,  AutowiredAnnotationBeanPostProcessor ,  ApplicationListenerDetector ,        </span></span><br><span class="line">       </span><br><span class="line">      <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line"><span class="comment">// Apply before-instantiation post-processors, resolving whether there is a before-instantiation shortcut for the specified bean. 可以看到这里有个应用实例化前的处理器,</span></span><br><span class="line"><span class="comment">//org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation,可以看到这个方法里面,满足条件的话,会调用applyBeanPostProcessorsBeforeInstantiation() / applyBeanPostProcessorsAfterInitialization() 这二个方法的.</span></span><br><span class="line"><span class="comment">// 走完 applyBeanPostProcessorsBeforeInstantiation 方法,如果前置处理器能够返回bean回来并且不是null的话,就会继续走applyBeanPostProcessorsAfterInitialization方法.</span></span><br><span class="line"><span class="comment">// 我们这里返回的 bean 是null,如果不是null的话,就会直接返回的.       </span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> bean;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的前置处理器applyBeanPostProcessorsBeforeInstantiation返回的bean是null的话,就会接着这个下面继续往下走.  于是就有了走 doCreateBean 方法.   </span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"> <span class="comment">// 返回 bean 对象回去.      </span></span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">      <span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">      <span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">            mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createBean 方法 : 可以看到createBean在创建之前走了前置处理器,如果前置处理器返回的bean不是null,那么也就没有下面的doCreateBean什么事情了. 如果返回的bean是null的话,那么就会走到下面的doCreateBean方法,可以理解为这个方法才是真正调用反射去获取 bean 对象实例的方法 , 并且其返回值 beanInstance 是直接返回返回去了,也没有做什么其他的处理.</p><h6 id="doCreateBean-方法"><a href="#doCreateBean-方法" class="headerlink" title="doCreateBean() 方法"></a>doCreateBean() 方法</h6><p>可以感觉到 doCreateBean 就是真正实例化bean的方法, 是不是Spring 加上了 do 开头的方法,才是真正干活的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Actually create the specified bean. Pre-creation processing has already happened</span></span><br><span class="line"><span class="comment"> * at this point, e.g. checking &#123;<span class="doctag">@code</span> postProcessBeforeInstantiation&#125; callbacks.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Differentiates between default bean instantiation, use of a</span></span><br><span class="line"><span class="comment"> * factory method, and autowiring a constructor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the merged bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args explicit arguments to use for constructor or factory method invocation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanCreationException if the bean could not be created</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateUsingFactoryMethod</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #autowireConstructor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate the bean.</span></span><br><span class="line">   <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 确定是单例,    </span></span><br><span class="line">   <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line"><span class="comment">// 从org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#factoryBeanInstanceCache缓存中remove掉.       </span></span><br><span class="line">      instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line"> <span class="comment">// 创建 bean 的实例对象.</span></span><br><span class="line"> <span class="comment">// 先根据 bd 获取出 beanClass,根据beanClass获取出如果是null并且不是public并且无参数构造函数不是public的话,就会抛出一个BeanCreationException异常来. </span></span><br><span class="line"><span class="comment">// 从bd获取出实例提供者信息,这里获取出来的是Null,所以也就不会往下走.</span></span><br><span class="line"><span class="comment">// 获取 mbd.getFactoryMethodName() 操作</span></span><br><span class="line"><span class="comment">// 用变量resolved/autowireNecessary布尔类型的来控制一些流程,  用传入进来的args参数来决定是走无参构造函数还是在有参构造函数,如果args是null的话,就走无参数构造函数.</span></span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#determineConstructorsFromBeanPostProcessors, 该方法是获取出全部的 后置处理器,如果后置处理器是继承了SmartInstantiationAwareBeanPostProcessor的话,就会走到后置处理器的determineCandidateConstructors方法来,  根据 Constructor&lt;?&gt;[] ctors = ibp.determineCandidateConstructors(beanClass, beanName) 可以看到,最后返回的是一个构造方法,可以看到org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#determineCandidateConstructors这个地方来. 这里目测是对@Autowired注解注入的对象进行操作.</span></span><br><span class="line"><span class="comment">//最后,看到这个方法:org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#instantiateBean   ----&gt;   org.springframework.beans.factory.support.SimpleInstantiationStrategy#instantiate(org.springframework.beans.factory.support.RootBeanDefinition, java.lang.String, org.springframework.beans.factory.BeanFactory) 走到这里, 先判断没有重写的方法,接着判断如果是接口的话,就会抛出异常来,用constructorToUse = clazz.getDeclaredConstructor();获取出构造方法,最后用BeanUtils.instantiateClass(constructorToUse)来实例化对象,可以看到这行代码走完,我们在无参构造函数中的输出语句就可以打印出来了.  将我们实例化出来的对象beanInstance用BeanWrapperImpl包装下,所以这里最后返回的就是   BeanWrapperImpl , 是对我们的目标对象进行一层包装过了的.     </span></span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 从包装了beanInstance的BeanWrapperImpl中获取出来bean和beanType来,    </span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">   Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 赋值beanType给mbd.resolvedTargetType    </span></span><br><span class="line">   <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">      mbd.resolvedTargetType = beanType;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">   <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// 这里后走了一个调用后置处理器的方法,是MergedBeanDefinitionPostProcessor接口的子类,就会调用到后置处理器的postProcessMergedBeanDefinition方法.从名字上看,是对bd进行合并的处理操作.	            </span></span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">   <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line"><span class="comment">//  bd是单例的并且是循环引用的并且单例是创建的,就满足这个条件,这里是处理循环依赖问题?还是用于实现BeanFactoryAware这种来避免循环依赖?    </span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">         isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">   <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">               <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//  添加到 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#registeredSingletons 中来.       </span></span><br><span class="line">      addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 构建bean,这里走了 InstantiationAwareBeanPostProcessor 接口的实现类的后置处理器,如果满足条件就会走处理器的postProcessAfterInstantiation方法,该方法会返回一个布尔类型的值,如果是false的话,就会跳出循环来的.</span></span><br><span class="line"><span class="comment">// 下面还会走一个InstantiationAwareBeanPostProcessor接口的子类的后置处理器,满足条件就会走后置处理器的postProcessProperties方法,如果获取出来的PropertyValues pvsToUse是null的话,会继续走后置处理器的postProcessPropertyValues方法.       </span></span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">//  这里调用每个后置处理器的 postProcessBeforeInitialization 方法,</span></span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#invokeInitMethods 该方法可以看到(InitializingBean) bean).afterPropertiesSet();对于afterPropertiesSet方法还是有点熟悉的.</span></span><br><span class="line"><span class="comment">//  接着就是调用每个后置处理器的postProcessAfterInitialization方法,       </span></span><br><span class="line">      exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">       </span><br><span class="line"><span class="comment">// 可以看到这二个方法都是在调用后置处理器来进行扩展.       </span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//  earlySingletonExposure is true.  </span></span><br><span class="line">   <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="comment">// 从单例池中根据 beanName 来获取对象.       </span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">       </span><br><span class="line"><span class="comment">// 获取出来的对象不是null的话,就会进入到这里来.       </span></span><br><span class="line">      <span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">            exposedObject = earlySingletonReference;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">            String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">            Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);</span><br><span class="line">            <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                  actualDependentBeans.add(dependentBean);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line">                     <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                     <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register bean as disposable.</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// 如果有必要的话,注册任意bean信息.      </span></span><br><span class="line">      registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doCreateBean() 方法 : 该方法才是正在去走反射来实例化bean的. 并且在实例化这个bean之前和之后,都是有调用许多后置处理器的,也就是这个bean进行一些增强或者其他的处理. 从现在来看,都是Spring内置的处理器.我们后面可以跟着Spring里面的写法,来做相同的扩展处理.</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>其实可以看到,我们通过这种方式给我们定义的 bean 给注入到 Spring 容器中, 先是通过我们定义的 @ComponentScan(basePackages &#x3D; “com.iyang.bean.bd”) 来扫描，然后将扫描得到的信息给添加到Spring的信息池里面,也就是添加到集合中来了. 最后在getBean 方法中, 通过扫描获取到的beanNames集合进行迭代，然后挨个调用getBean()方法来实例化bean, getBean() 方法中又走了 doGetBean () —-&gt; createBean() —&gt; doCreateBean() 方法， 然后每个方法有各自要做的事情，并且也会走相应的后置处理器.</p><p>最后，这是一个比较详细的getBean分析，但是还有更深入的 , 比如 : @Autowired &#x2F; @DependsOn &#x2F; 循环依赖等注入，需要扩展来讲.</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/11/04/java/LinkedList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/04/java/LinkedList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">LinkedList源码阅读记录</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-04 00:14:26" itemprop="dateCreated datePublished" datetime="2021-11-04T00:14:26+08:00">2021-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/java%E9%9B%86%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">java集合</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>6.2k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>6 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>虽然一般都是使用ArrayList集合比使用LinkedList集合要多,但是这并不妨碍我们对LinkedList的源码研究和学习</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>LinkedList 是一个双向链表的结构,这点可以直接看其内部内就可以非常明显的看出来. 静态私有的内部类,只提供一个构造函数.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item = element;</span><br><span class="line">        this.next = next;</span><br><span class="line">        this.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们看 LinkedList 自身的变量. size 肯定是记录这个链表的长度,不然到时候node.next.next….获取长度就很得不偿失了. 然后记录了一个头节点和尾节点，个人认为这是方便遍历。从头开始遍历就从first节点获取,从尾部开始遍历的话,就从last开始获取.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">transient int size = 0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Pointer to first node.</span><br><span class="line"> * Invariant: (first == null &amp;&amp; last == null) ||</span><br><span class="line"> *            (first.prev == null &amp;&amp; first.item != null)</span><br><span class="line"> */</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Pointer to last node.</span><br><span class="line"> * Invariant: (first == null &amp;&amp; last == null) ||</span><br><span class="line"> *            (last.next == null &amp;&amp; last.item != null)</span><br><span class="line"> */</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><hr><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>add 方法</p><p>add方法调用一个linkLast方法,然后就返回true了. 也就是说add(E e)就是默认从尾部开始插入元素进去.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Links e as last element.</span><br><span class="line">       翻译 : 链接e作为最后一个元素。</span><br><span class="line">       先对last赋值给 Node&lt;E&gt; l , 然后调用new Node&lt;&gt;(l,e,null);传入进去的上个节点,也就是l,上次保存的尾部节点,也就是从倒数第一变为了倒数二,这样理解。然后此时的newNode就是尾节点了,然后赋值给last,因为last每次记录的都是尾节点.</span><br><span class="line">       if else 中是对之前的尾节点进行判断,如果是null的话,说明此时就是添加的第一个元素,first也赋值给newNode,否则的话,l.next 和 尾节点进行关联。</span><br><span class="line">       size 长度加一</span><br><span class="line">     */</span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">        final Node&lt;E&gt; l = last;</span><br><span class="line">        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">        last = newNode;</span><br><span class="line">        if (l == null)</span><br><span class="line">            first = newNode;</span><br><span class="line">        else</span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>根据下标添加 add(int index,E element)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	1: 检查传入进来的下标是否越界了,如果下标越界的话,就会抛出 下标越界的异常</span><br><span class="line">	2: 根据传入进来的下标值,判断是否和 size 相等,如果是相等的话,就说明是尾部插入,就不需要挨个迭代去获取对应的下标值对应的节点.满足条件,就会调用上面说到的 linkLast方法</span><br><span class="line">	3: 不满足条件2的话,就会走lineBefore()方法,其中也调用到了.传入下标调用node方法.node会返回对应下标的值,根据返回的节点和当前的值调用lienkBefore方法.</span><br><span class="line">*/</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    if (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    else</span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void checkPositionIndex(int index) &#123;</span><br><span class="line">        if (!isPositionIndex(index))</span><br><span class="line">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> private boolean isPositionIndex(int index) &#123;</span><br><span class="line">        return index &gt;= 0 &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	size &gt;&gt; 1 ; 是对 size 进行去半, 比如 6 &gt;&gt; 1 是 3， 5 &gt;&gt; 1 是2</span><br><span class="line">	如果小于一半的话,就会从first节点开始遍历,也就是从头节点开始遍历,否则就是从尾节点开始遍历.</span><br><span class="line">	这个方法可以看到,从头开始遍历的话,就是调用的next,如果尾部遍历的话,调用的就是prev。找到对应下标的节点并且返回回去.</span><br><span class="line">*/</span><br><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">        // assert isElementIndex(index);</span><br><span class="line"></span><br><span class="line">        if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            for (int i = 0; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            return x;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	获取节点的上个节点赋值给pred，其实类似于pred这种,都是用于变量替换创建出来的.</span><br><span class="line">	上一个节点,当前值e,succ节点来new一个新的节点出来.</span><br><span class="line">	succ.prev 指向当前new出来的节点</span><br><span class="line">	对pred判断是否是null,如果是null的话,就说明是第一个值,否则就是赋值上pred个节点的next</span><br><span class="line">	,size ++ 就是对长度 ++ </span><br><span class="line">*/</span><br><span class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">        // assert succ != null;</span><br><span class="line">        final Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        if (pred == null)</span><br><span class="line">            first = newNode;</span><br><span class="line">        else</span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>头插入 和 尾插入</p><p>头插入，将值插入到头部</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void addFirst(E e) &#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	先将first 赋值给 f ,  根据传入进来的值e 和 下一个节点f(前一个头节点),new一个新的newNode节点出来,first指向newNode.如果f是null的话就说明是初始化,如果不是null的话,f的上一个节点指向newNode,刚刚程序newNode出来的.就完成了头节点的插入</span><br><span class="line">*/</span><br><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">        final Node&lt;E&gt; f = first;</span><br><span class="line">        final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);</span><br><span class="line">        first = newNode;</span><br><span class="line">        if (f == null)</span><br><span class="line">            last = newNode;</span><br><span class="line">        else</span><br><span class="line">            f.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>尾节点插入;与头节点相似，也是利用变量last来实现尾部插入.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void addLast(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">        final Node&lt;E&gt; l = last;</span><br><span class="line">        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">        last = newNode;</span><br><span class="line">        if (l == null)</span><br><span class="line">            first = newNode;</span><br><span class="line">        else</span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>get 方法,获取值方法</p><p>根据下标来获取出值 ,然后调用node方法获取出节点,node.item就是我们需要的值,然后对其进行返回即可.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果输入index是小于0和大于size的话,就会爆出下标越界的错误.</span><br><span class="line">private void checkElementIndex(int index) &#123;</span><br><span class="line">        if (!isElementIndex(index))</span><br><span class="line">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>getFirst &#x2F; getLast 可以看到first和 last都是直接从定义的变量中获取出对应的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public E getFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f = first;</span><br><span class="line">    if (f == null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    public E getLast() &#123;</span><br><span class="line">        final Node&lt;E&gt; l = last;</span><br><span class="line">        if (l == null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return l.item;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>peek 方法;使用first节点,如果是null的话就会返回null，否则就是f.item. 这里是没有删除first元素,poll是弹出元素并且删除.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E peek() &#123;</span><br><span class="line">    final Node&lt;E&gt; f = first;</span><br><span class="line">    return (f == null) ? null : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>poll 方法 : 这里主要看unlinkFirst方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   取出 f 的item,节点对应的值和 f的next个节点,如果下个节点是null的话,就说明是没有值的,如果不为null的话，说将next的上一个节点prev指向null,因为头节点的prev和尾节点的next都是null来进行区分。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> &#123;</span><br><span class="line">        <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> f.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">        f.item = <span class="literal">null</span>;</span><br><span class="line">        f.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        first = next;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">            last = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next.prev = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>offer 等方法都是内部调用了add &#x2F; addFirst &#x2F; addLast等方法.</p><ul><li><p>remove 方法</p><p>根据下标进来remove方法, node(index) 也是在上面进行讲到的,就是根据下标获取对应的node节点信息.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	这里获取出节点的 next 和 prev方法.</span></span><br><span class="line"><span class="comment">	该节点的上一个节点(prev)的next需要指向指向该节点的下个节点(next),该节点的下一个节点和prev的操作是相反的,因为这样的话,就删除了该节点,并且上一个节点和下一个节点关联起来了.	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>remove(Object o) 根据值来进行删除.这个可以看出来，如果有二个相同节点的值,调用一次这个方法是只可以删除一个,而不是二个.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好啦,今天的知识内容就更新到这里,虽然文字描述到很难理解,但是主要去理解 Node 节点的 双向指向,并且每次添加节点和删除添加，都是靠Node的prev和next来进行指向. 所以说LinkedList是删除快，查询慢的原因。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://ruy9527.github.io/2021/11/04/java/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/touxiang.jpg"><meta itemprop="name" content="YangBao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="YangBao"><meta itemprop="description" content="知识笔记"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | YangBao"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/04/java/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">HashMap源码阅读记录</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-04 00:14:11" itemprop="dateCreated datePublished" datetime="2021-11-04T00:14:11+08:00">2021-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-11-04 21:46:13" itemprop="dateModified" datetime="2022-11-04T21:46:13+08:00">2022-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/java%E9%9B%86%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">java集合</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>9k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>8 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>HashMap 这种Key,Value 的存储结构,是我们在写代码中经常使用到的.可以说使用是非常频繁的,不过现在使用JSONObject也是非常多的,二者都是实现了Map接口。</p><p>所以看下HashMap源码是非常有必要的.</p><hr><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>这里我们要看下 HashMap的内部类.</p><p>这里的 Node 节点就是 HashMap存放数据的结构. hash 计算出来的哈希值,key就是HashMap中的key,value就是key对应的value的值. 这个 next 就是 key 不一样,计算出来的hash却是一样的,这样就有了hash冲突,所以就将节点存放在next里面了,从尾部插入进去. java8 后,如果next的长度是大于8的话,就会转化了红黑树来存储,那样获取值的速度变快了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeNode 这个内部类就是表示红黑树的. TODO 后续进行更新.</p><p>参数, 可以看到 HashMap 是使用了一个数组来进行存储 Node节点.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><hr><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> 	当使用无参构造函数的时候,只是对 loadFactor 进行了赋值操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递一个int类型的参数时候,就会计息往下调用构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	对值进行判断,怕你可能传入进来一个负数来测试玩玩哈哈哈。</span></span><br><span class="line"><span class="comment">	最后调用到了tableSizeFor方法,可以看到这个方法是对传入进来的参数,进行一连串的位运算.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入 Map 的实现类的话,就是往下继续调用 putMapEntries方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	传入 m.size()的长度,长度大于0就会走逻辑代码.最后可以看到 迭代了m,然后调用putVal来将值放入Map中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">                <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">                <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                    threshold = tableSizeFor(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">                resize();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">                putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put 添加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据传入进来的key来计算对应的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	putVal 就是 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义一些变量</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    	<span class="comment">// table 赋值给 tab 并判断是否等于null 或者 tab的长度是否等于0,如果是的话，就会调用resize来进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	扩容方法</span></span><br><span class="line"><span class="comment">	table使用 oldTab来进行存储,拿出oldTab的长度(如果oldTab是null的话,对应的长度就是为0).</span></span><br><span class="line"><span class="comment">	oldThr 是 记录 threshold 之前的值, newCap / newThr就是需要扩容使用到的变量命名.</span></span><br><span class="line"><span class="comment">	这里分为 </span></span><br><span class="line"><span class="comment">	1 : oldCap 是大于0的。 如果比 MAXIMUM_CAPACITY 还是要大的话,就说明里面存储的元素是太多了,就直接返回oldTab.  还有一种就是 newCap等于oldCap的1.5倍并且小于MAXIMUM_CAPACITY和oldCap是大于默认16的,就会进行1.5倍的扩容</span></span><br><span class="line"><span class="comment">	2 : oldThr 大于 0, newCap(扩容新长度) 就是等于 oldThe的值.</span></span><br><span class="line"><span class="comment">	3 : 否则就是都使用默认的值大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    	使用扩容后的newCap来创建一个数组,oldTab不是null,然后就需要将老的值赋值到新的newTab里面来.</span></span><br><span class="line"><span class="comment">        使用下标来进行迭代,获取每个下标的Node节点的值,然oldTab[j]赋值给e后,然后将oldTab[j]重置为null.</span></span><br><span class="line"><span class="comment">        这里面的进行Node复制是有分为下面几种, Node的next节点是没有值得,next下面是由值,e节点转化为了红黑树.</span></span><br><span class="line"><span class="comment">        1 : 如果e.next是null,也就是没有值,newTab[e.hash &amp; (newCap - 1)] = e来赋值.</span></span><br><span class="line"><span class="comment">        2 : 如果e是TreeNode的话,就会调用((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap)方法.</span></span><br><span class="line"><span class="comment">        3 : 然后可以看到 do while 循环里面, while 里面的条件是 e.next != null 才会进去,也就是next是由值得情况下才会进入到这里面来.然后可以看到一些系取节点啊,赋值给变量啊,然后赋值给新创建的Node数组下标然后将之前的node节点重置为null。 这里就需要读者对这些代码来慢慢消化了.仔细想看,就是对node节点的取值,赋值,重置等操作.</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get 方法,是通过key来获取出对应的value.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入key来计算出哈希值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	如果 table不是Null,并且长度是大于0的,能够根据 (n-1) &amp; hash 得出来的下标是在tab里面能获取到值得,才会进入逻辑代码,否则就是返回null.</span></span><br><span class="line"><span class="comment">	如果first的hash是于传入进来的hash相同,斌且给key的值也是相同的话,就会返回first节点.</span></span><br><span class="line"><span class="comment">	拿node的next节点,如果是TreeNode的类,就会走TreeNode对应的getTreeNode方法(链表的长度大于8就会转化为红黑树). 否则的话就就迭代这个Node,退出的条件就是 e.next == null,就说说明下面没有对应的节点了。</span></span><br><span class="line"><span class="comment">	这里拿值得逻辑,还是比较容易理解得。 先根据计算出来得hash值,去数组中是否可以获取到对应得值,如果有就先会对first进行判断,是否满足条件.如果不满足的话,就说明这个key的hash是由冲突的,也就是由二个不同的值,计算出来相同的hash值,这个时候就会用链表(Node)来进行存储,如果长度是大于8的话,就会转化为TreeNode的红黑树.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isEmpty 方法,这里就直接使用 size &#x3D;&#x3D; 0 来进行判断,如果你的map是null的话,直接调用这个方法就会出现空指针.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这里只是选用了 put 和 get方法来进行讲解,因为这二个是经常调用的,所以得明白是一个怎么样得大体流程走向才行.</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a></nav></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">YangBao</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>Symbols count total: </span><span title="Symbols count total">307k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>Reading time total &asymp;</span> <span title="Reading time total">4:39</span></span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a></div></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script></body></html>